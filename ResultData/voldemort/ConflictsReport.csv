==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_979c1_09650/rev_979c1-09650.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_602ec_567c1/rev_602ec-567c1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_69716_cc042/rev_69716-cc042.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_69716_18435/rev_69716-18435.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_69716_e0214/rev_69716-e0214.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3e8ce_37fa5/rev_3e8ce-37fa5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_18435_21928/rev_18435-21928.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_1eebb_b510f/rev_1eebb-b510f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_1eebb_73bf0/rev_1eebb-73bf0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2672d_88da7/rev_2672d-88da7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_641b1_901c5/rev_641b1-901c5.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415500416533/fstmerge_var1_5974897368560047194
private void handleUpdateStoresMetadataRequest(String storeKey,
                                                   DataInputStream inputStream,
                                                   DataOutputStream outputStream)
            throws IOException {
        // get current Store Info
        List<Versioned<byte[]>> storesInfo = metadataStore.get(ByteUtils.getBytes(storeKey, "UTF-8"));
        if(storesInfo.size() > 1) {
            throw new UnableUpdateMetadataException("Inconistent Stores Metdata found on Server:"
                                                    + metadata.getIdentityNode().getId());
        }

        // update version
        VectorClock updatedVersion = ((VectorClock) storesInfo.get(0).getVersion());
        updatedVersion.incrementVersion(metadata.getIdentityNode().getId(),
                                        System.currentTimeMillis());

        try {
            String storesString = inputStream.readUTF();

            List<StoreDefinition> storeDefs = new StoreDefinitionsMapper().readStoreList(new StringReader(storesString));

            // update cluster details in metaDataStore
            metadataStore.put(new ByteArray(ByteUtils.getBytes(MetadataStore.STORES_KEY, "UTF-8")),
                              new Versioned<byte[]>(ByteUtils.getBytes(new StoreDefinitionsMapper().writeStoreList(storeDefs),
                                                                       "UTF-8"),
                                                    updatedVersion));
            metadata.setStoreDefs(storeDefs);
            // if successfull update state in Voldemort Metadata
            metadata.setStoreDefMap(storeDefs);
            metadata.reinitRoutingStrategies();
            outputStream.writeShort(0);
        } catch(VoldemortException e) {
            e.printStackTrace();
            writeException(outputStream, e);
            return;
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415500416533/fstmerge_base_5706782705959781155
private void handleUpdateStoresMetadataRequest(String storeKey,
                                                   DataInputStream inputStream,
                                                   DataOutputStream outputStream)
            throws IOException {
        // get current Store Info
        List<Versioned<byte[]>> storesInfo = metadataStore.get(ByteUtils.getBytes(storeKey, "UTF-8"));
        if(storesInfo.size() > 1) {
            throw new UnableUpdateMetadataException("Inconistent Stores Metdata found on Server:"
                                                    + metadata.getIdentityNode().getId());
        }

        // update version
        VectorClock updatedVersion = ((VectorClock) storesInfo.get(0).getVersion());
        updatedVersion.incrementVersion(metadata.getIdentityNode().getId(),
                                        System.currentTimeMillis());

        try {
            String storesString = inputStream.readUTF();

            List<StoreDefinition> storeDefs = new StoreDefinitionsMapper().readStoreList(new StringReader(new String(storesString)));

            // update cluster details in metaDataStore
            metadataStore.put(new ByteArray(ByteUtils.getBytes(MetadataStore.STORES_KEY, "UTF-8")),
                              new Versioned<byte[]>(ByteUtils.getBytes(new StoreDefinitionsMapper().writeStoreList(storeDefs),
                                                                       "UTF-8"),
                                                    updatedVersion));
            metadata.setStoreDefs(storeDefs);
            // if successfull update state in Voldemort Metadata
            metadata.setStoreDefMap(storeDefs);
            metadata.reinitRoutingStrategies();
            outputStream.writeShort(0);
        } catch(VoldemortException e) {
            e.printStackTrace();
            writeException(outputStream, e);
            return;
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415500416533/fstmerge_var2_7452952763443823448

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_641b1_901c5/rev_641b1-901c5/src/java/voldemort/server/socket/AdminServiceRequestHandler.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_641b1_c7ad3/rev_641b1-c7ad3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_68a3d_ea91e/rev_68a3d-ea91e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_9e08c_cb49d/rev_9e08c-cb49d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_4e49f_bdb9e/rev_4e49f-bdb9e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_4e49f_78e50/rev_4e49f-78e50.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_474bb_285ac/rev_474bb-285ac.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_679e1_e9fc3/rev_679e1-e9fc3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_679e1_796d6/rev_679e1-796d6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2efb5_b1267/rev_2efb5-b1267.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_62f62_5e523/rev_62f62-5e523.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f2dcd_02bc2/rev_f2dcd-02bc2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f2dcd_2b1af/rev_f2dcd-2b1af.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b07c0_f1f3e/rev_b07c0-f1f3e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a63a5_3f736/rev_a63a5-3f736.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d6afc_7033e/rev_d6afc-7033e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_18819_65ac0/rev_18819-65ac0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3fb68_69ee6/rev_3fb68-69ee6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f4b3d_66900/rev_f4b3d-66900.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bbd88_f946d/rev_bbd88-f946d.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public static void main(String[] args) throws Exception {
        if(args.length != 2)
            Utils.croak("USAGE: java " + RemoteStoreComparisonTest.class.getName()
                        + " numRequests numThreads");

        int numRequests = Integer.parseInt(args[0]);
        int numThreads = Integer.parseInt(args[1]);

        /*** In memory test ***/
        final Store<byte[], byte[]> memStore = new InMemoryStorageEngine<byte[], byte[]>("test");
        PerformanceTest memWriteTest = new PerformanceTest() {

            @Override
            public void doOperation(int i) {
                byte[] key = String.valueOf(i).getBytes();
                memStore.put(key, new Versioned<byte[]>(key));
            }
        };
        System.out.println("###########################################");
        System.out.println("Performing memory write test.");
        memWriteTest.run(numRequests, numThreads);
        memWriteTest.printStats();
        System.out.println();

        PerformanceTest memReadTest = new PerformanceTest() {

            @Override
            public void doOperation(int i) {
                try {
                    memStore.get(String.valueOf(i).getBytes());
                } catch(Exception e) {
                    System.out.println("Failure on i = " + i);
                    e.printStackTrace();
                }
            }
        };
        System.out.println("Performing memory read test.");
        memReadTest.run(numRequests, numThreads);
        memReadTest.printStats();
        System.out.println();
        System.out.println();

        /*** Do Socket tests ***/
        String storeName = "test";
        StoreRepository repository = new StoreRepository();
        repository.addLocalStore(new InMemoryStorageEngine<ByteArray, byte[]>(storeName));
        SocketPool socketPool = new SocketPool(10, 10, 1000, 1000, 32 * 1024);
        final SocketStore socketStore = new SocketStore(storeName,
                                                        new SocketDestination("localhost",
                                                                              6666,
                                                                              RequestFormatType.VOLDEMORT_V1),
                                                        socketPool,
                                                        false);
        RequestHandlerFactory factory = new RequestHandlerFactory(repository, null, null);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502079356/fstmerge_var1_9101163616591202571
        SocketServer socketServer = new SocketServer(6666, 50, 50, 1000, factory);
        socketServer.start();
        socketServer.awaitStartupCompletion();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502079356/fstmerge_base_5090917795342302805
        SocketServer socketServer = new SocketServer("Socket-Server",
                                                     6666,
                                                     50,
                                                     50,
                                                     1000,
                                                     factory.getRequestHandler(RequestFormatType.VOLDEMORT));
        socketServer.start();
        socketServer.awaitStartupCompletion();
=======
        AbstractSocketService socketService = ServerTestUtils.getSocketService(factory.getRequestHandler(RequestFormatType.VOLDEMORT),
                                                                               6666,
                                                                               50,
                                                                               50,
                                                                               1000);
        socketService.start();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502079356/fstmerge_var2_2341343833994228273

        PerformanceTest socketWriteTest = new PerformanceTest() {

            @Override
            public void doOperation(int i) {
                byte[] bytes = String.valueOf(i).getBytes();
                ByteArray key = new ByteArray(bytes);
                socketStore.put(key, new Versioned<byte[]>(bytes));
            }
        };
        System.out.println("###########################################");
        System.out.println("Performing socket write test.");
        socketWriteTest.run(numRequests, numThreads);
        socketWriteTest.printStats();
        System.out.println();

        PerformanceTest socketReadTest = new PerformanceTest() {

            @Override
            public void doOperation(int i) {
                try {
                    socketStore.get(TestUtils.toByteArray(String.valueOf(i)));
                } catch(Exception e) {
                    System.out.println("Failure on i = " + i);
                    e.printStackTrace();
                }
            }
        };
        System.out.println("Performing socket read test.");
        socketReadTest.run(numRequests, 1);
        socketReadTest.printStats();
        System.out.println();
        System.out.println();

        socketStore.close();
        socketPool.close();
        socketService.stop();

        /*** Do HTTP tests ***/
        repository.addLocalStore(new InMemoryStorageEngine<ByteArray, byte[]>(storeName));
        HttpService httpService = new HttpService(null,
                                                  repository,
                                                  RequestFormatType.VOLDEMORT_V0,
                                                  numThreads,
                                                  8080);
        httpService.start();
        HttpClient httpClient = new HttpClient(new MultiThreadedHttpConnectionManager());
        HttpClientParams clientParams = httpClient.getParams();
        clientParams.setParameter(HttpMethodParams.RETRY_HANDLER,
                                  new DefaultHttpMethodRetryHandler(0, false));
        clientParams.setCookiePolicy(CookiePolicy.IGNORE_COOKIES);
        clientParams.setParameter("http.useragent", "test-agent");
        HostConfiguration hostConfig = new HostConfiguration();
        hostConfig.getParams().setParameter("http.protocol.version", HttpVersion.HTTP_1_1);
        httpClient.setHostConfiguration(hostConfig);
        HttpConnectionManagerParams managerParams = httpClient.getHttpConnectionManager()
                                                              .getParams();
        managerParams.setConnectionTimeout(10000);
        managerParams.setMaxTotalConnections(numThreads);
        managerParams.setStaleCheckingEnabled(false);
        managerParams.setMaxConnectionsPerHost(httpClient.getHostConfiguration(), numThreads);
        final HttpStore httpStore = new HttpStore("test",
                                                  "localhost",
                                                  8080,
                                                  httpClient,
                                                  new RequestFormatFactory().getRequestFormat(RequestFormatType.VOLDEMORT_V0),
                                                  false);
        Thread.sleep(400);

        PerformanceTest httpWriteTest = new PerformanceTest() {

            @Override
            public void doOperation(int i) {
                byte[] key = String.valueOf(i).getBytes();
                httpStore.put(new ByteArray(key), new Versioned<byte[]>(key));
            }
        };
        System.out.println("###########################################");
        System.out.println("Performing HTTP write test.");
        httpWriteTest.run(numRequests, numThreads);
        httpWriteTest.printStats();
        System.out.println();

        PerformanceTest httpReadTest = new PerformanceTest() {

            @Override
            public void doOperation(int i) {
                httpStore.get(new ByteArray(String.valueOf(i).getBytes()));
            }
        };
        System.out.println("Performing HTTP read test.");
        httpReadTest.run(numRequests, numThreads);
        httpReadTest.printStats();

        httpService.stop();
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bbd88_f946d/rev_bbd88-f946d/test/integration/voldemort/performance/RemoteStoreComparisonTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public void setUp() throws Exception {
        super.setUp();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502080059/fstmerge_var1_996772444204819953
        server = ServerTestUtils.getSocketServer(getClusterXml(),
                                                 getStoreDefXml(),
                                                 getValidStoreName(),
                                                 getLocalNode().getSocketPort());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502080059/fstmerge_base_1890836047619418718
        server = ServerTestUtils.getSocketServer(getClusterXml(),
                                                 getStoreDefXml(),
                                                 getValidStoreName(),
                                                 getLocalNode().getSocketPort(),
                                                 RequestFormatType.VOLDEMORT);
=======
        socketService = ServerTestUtils.getSocketService(getClusterXml(),
                                                         getStoreDefXml(),
                                                         getValidStoreName(),
                                                         getLocalNode().getSocketPort(),
                                                         RequestFormatType.VOLDEMORT);
        socketService.start();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502080059/fstmerge_var2_1332756253029455185
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bbd88_f946d/rev_bbd88-f946d/test/unit/voldemort/client/SocketStoreClientFactoryTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public void setUp() {
        this.port = ServerTestUtils.findFreePort();
        this.pool = new SocketPool(maxConnectionsPerNode,
                                   maxTotalConnections,
                                   1000,
                                   1000,
                                   32 * 1024);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502080361/fstmerge_var1_4458946087881084055
        this.dest1 = new SocketDestination("localhost", port, RequestFormatType.VOLDEMORT_V1);
        RequestHandlerFactory handlerFactory = new RequestHandlerFactory(new StoreRepository(),
                                                                         null,
                                                                         null);
        this.server = new SocketServer(port,
                                       maxTotalConnections,
                                       maxTotalConnections + 3,
                                       10000,
                                       handlerFactory);
        this.server.start();
        this.server.awaitStartupCompletion();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502080361/fstmerge_base_2588295657238078122
        this.dest1 = new SocketDestination("localhost", port);
        VoldemortNativeRequestHandler requestHandler = new VoldemortNativeRequestHandler(new ErrorCodeMapper(),
                                                                                         new StoreRepository());
        this.server = new SocketServer("test-socket",
                                       port,
                                       maxTotalConnections,
                                       maxTotalConnections + 3,
                                       10000,
                                       requestHandler);
        this.server.start();
        this.server.awaitStartupCompletion();
=======
        this.dest1 = new SocketDestination("localhost", port);
        VoldemortNativeRequestHandler requestHandler = new VoldemortNativeRequestHandler(new ErrorCodeMapper(),
                                                                                         new StoreRepository());
        this.socketService = ServerTestUtils.getSocketService(requestHandler,
                                                              port,
                                                              maxTotalConnections,
                                                              maxTotalConnections + 3,
                                                              10000);
        this.socketService.start();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502080361/fstmerge_var2_1443568652904101612
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bbd88_f946d/rev_bbd88-f946d/test/unit/voldemort/server/socket/SocketPoolTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    protected void setUp() throws Exception {
        super.setUp();
        this.socketPort = ServerTestUtils.findFreePort();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502080925/fstmerge_var1_3054151968758174682
        socketServer = ServerTestUtils.getSocketServer(VoldemortTestConstants.getOneNodeClusterXml(),
                                                       VoldemortTestConstants.getSimpleStoreDefinitionsXml(),
                                                       "test",
                                                       socketPort);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502080925/fstmerge_base_7010837268221881008
        socketServer = ServerTestUtils.getSocketServer(VoldemortTestConstants.getOneNodeClusterXml(),
                                                       VoldemortTestConstants.getSimpleStoreDefinitionsXml(),
                                                       "test",
                                                       socketPort,
                                                       requestFormatType);
=======
        socketService = ServerTestUtils.getSocketService(VoldemortTestConstants.getOneNodeClusterXml(),
                                                         VoldemortTestConstants.getSimpleStoreDefinitionsXml(),
                                                         "test",
                                                         socketPort,
                                                         requestFormatType);
        socketService.start();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502080925/fstmerge_var2_250517935403076786
        socketStore = ServerTestUtils.getSocketStore("test", socketPort, requestFormatType);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bbd88_f946d/rev_bbd88-f946d/test/unit/voldemort/store/socket/AbstractSocketStoreTest.java
Conflict type: LineBasedMCFd
Conflict body: 
private List<VoldemortService> createServices() {
        RequestHandlerFactory requestHandlerFactory = new RequestHandlerFactory(this.storeRepository,
                                                                                this.metadata,
                                                                                voldemortConfig);

        /* Services are given in the order they must be started */
        List<VoldemortService> services = new ArrayList<VoldemortService>();
        SchedulerService scheduler = new SchedulerService(voldemortConfig.getSchedulerThreads(),
                                                          SystemTime.INSTANCE);
        services.add(new StorageService(storeRepository, metadata, scheduler, voldemortConfig));
        services.add(scheduler);
        if(voldemortConfig.isHttpServerEnabled())
            services.add(new HttpService(this,
                                         storeRepository,
                                         RequestFormatType.VOLDEMORT_V1,
                                         voldemortConfig.getMaxThreads(),
                                         identityNode.getHttpPort()));
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502086216/fstmerge_var1_1407696236678120703
        if(voldemortConfig.isSocketServerEnabled())
            services.add(new SocketService(requestHandlerFactory,
                                           identityNode.getSocketPort(),
                                           voldemortConfig.getCoreThreads(),
                                           voldemortConfig.getMaxThreads(),
                                           voldemortConfig.getSocketBufferSize(),
                                           "socket-server",
                                           voldemortConfig.isJmxEnabled()));
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502086216/fstmerge_base_6941860129879179481
        if(voldemortConfig.isSocketServerEnabled())
            services.add(new SocketService(requestHandlerFactory.getRequestHandler(voldemortConfig.getRequestFormatType()),
                                           identityNode.getSocketPort(),
                                           voldemortConfig.getCoreThreads(),
                                           voldemortConfig.getMaxThreads(),
                                           voldemortConfig.getSocketBufferSize(),
                                           "client-request-service"));
        if(voldemortConfig.isAdminServerEnabled())
            services.add(new SocketService(requestHandlerFactory.getRequestHandler(RequestFormatType.ADMIN_HANDLER),
                                           identityNode.getAdminPort(),
                                           voldemortConfig.getAdminCoreThreads(),
                                           voldemortConfig.getAdminMaxThreads(),
                                           voldemortConfig.getAdminSocketBufferSize(),
                                           "admin-service"));
=======
        if(voldemortConfig.isSocketServerEnabled()) {
            if(voldemortConfig.getUseNioConnector()) {
                logger.info("Using NIO Connector.");
                services.add(new NioSocketService(requestHandlerFactory.getRequestHandler(voldemortConfig.getRequestFormatType()),
                                                  identityNode.getSocketPort(),
                                                  voldemortConfig.getSocketBufferSize(),
                                                  voldemortConfig.getNioConnectorSelectors()));
            } else {
                logger.info("Using BIO Connector.");
                services.add(new SocketService(requestHandlerFactory.getRequestHandler(voldemortConfig.getRequestFormatType()),
                                               identityNode.getSocketPort(),
                                               voldemortConfig.getCoreThreads(),
                                               voldemortConfig.getMaxThreads(),
                                               voldemortConfig.getSocketBufferSize(),
                                               "client-request-service"));
            }
        }
        if(voldemortConfig.isAdminServerEnabled())
            services.add(new SocketService(requestHandlerFactory.getRequestHandler(RequestFormatType.ADMIN_HANDLER),
                                           identityNode.getAdminPort(),
                                           voldemortConfig.getAdminCoreThreads(),
                                           voldemortConfig.getAdminMaxThreads(),
                                           voldemortConfig.getAdminSocketBufferSize(),
                                           "admin-service"));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502086216/fstmerge_var2_3757678456797522722

        if(voldemortConfig.isJmxEnabled())
            services.add(new JmxService(this,
                                        this.metadata.getCurrentCluster(),
                                        storeRepository,
                                        services));

        return ImmutableList.copyOf(services);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bbd88_f946d/rev_bbd88-f946d/src/java/voldemort/server/VoldemortServer.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bbd88_a4914/rev_bbd88-a4914.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3d1c2_3f7d2/rev_3d1c2-3f7d2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3d1c2_4d3a1/rev_3d1c2-4d3a1.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public static void main(String[] args) throws Exception {

        OptionParser parser = new OptionParser();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502347484/fstmerge_var1_4210333113958525280
        parser.accepts("r", "execute read operations");
        parser.accepts("w", "execute write operations");
        parser.accepts("d", "execute delete operations");
        parser.accepts("request-file", "execute specific requests in order").withRequiredArg();
        parser.accepts("start-key-index", "starting point when using int keys. Default = 0")
              .withRequiredArg()
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502347484/fstmerge_base_953298680745664251
        parser.accepts("r", "execute read operations").withOptionalArg();
        parser.accepts("w", "execute write operations").withOptionalArg();
        parser.accepts("d", "execute delete operations").withOptionalArg();
        parser.accepts("randomize", "randomize operations via keys").withOptionalArg();
        parser.accepts("request-file", "execute specific requests in order").withOptionalArg();
        parser.accepts("start-key-index", "starting point when using int keys")
              .withOptionalArg()
=======
        parser.accepts("r", "execute read operations");
        parser.accepts("w", "execute write operations");
        parser.accepts("d", "execute delete operations");
        parser.accepts("request-file", "execute specific requests in order").withRequiredArg();
        parser.accepts("start-key-index", "starting point when using int keys")
              .withRequiredArg()
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502347484/fstmerge_var2_3588667160429290243
              .ofType(Integer.class);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502347484/fstmerge_var1_4210333113958525280
        parser.accepts("value-size", "size in bytes for random value.  Default = 1024")
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("iterations", "number of times to repeat the test  Default = 1")
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("threads", "max number concurrent worker threads  Default = " + MAX_WORKERS)
              .withRequiredArg()
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502347484/fstmerge_base_953298680745664251
        parser.accepts("value-size", "size in bytes for random value")
              .withOptionalArg()
=======
        parser.accepts("value-size", "size in bytes for random value")
              .withRequiredArg()
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502347484/fstmerge_var2_3588667160429290243
              .ofType(Integer.class);

        OptionSet options = parser.parse(args);

        List<String> nonOptions = options.nonOptionArguments();
        if(nonOptions.size() != 3) {
            printUsage(System.err, parser);
        }

        String url = nonOptions.get(0);
        String storeName = nonOptions.get(1);
        int numRequests = Integer.parseInt(nonOptions.get(2));
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502347484/fstmerge_base_953298680745664251
        int startNum = 0;
        int valueSize = 1024;
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502347484/fstmerge_var2_3588667160429290243
        String ops = "";
        List<String> keys = null;

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502347484/fstmerge_var1_4210333113958525280
        Integer startNum = CmdUtils.valueOf(options, "start-key-index", 0);
        Integer valueSize = CmdUtils.valueOf(options, "value-size", 1024);
        Integer numIterations = CmdUtils.valueOf(options, "iterations", 1);
        Integer numThreads = CmdUtils.valueOf(options, "threads", MAX_WORKERS);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502347484/fstmerge_base_953298680745664251
        if(options.has("start-key-index")) {
            startNum = (Integer) options.valueOf("start-key-index");
        }

        if(options.has("value-size")) {
            startNum = (Integer) options.valueOf("value-size");
        }
=======
        Integer startNum = CmdUtils.valueOf(options, "start-key-index", 0);
        Integer valueSize = CmdUtils.valueOf(options, "value-size", 1024);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502347484/fstmerge_var2_3588667160429290243

        if(options.has("request-file")) {
            keys = loadKeys((String) options.valueOf("request-file"));
        }

        if(options.has("r")) {
            ops += "r";
        }
        if(options.has("w")) {
            ops += "w";
        }
        if(options.has("d")) {
            ops += "d";
        }

        if(ops.length() == 0) {
            ops = "rwd";
        }

        System.out.println("operations : " + ops);
        System.out.println("value size : " + valueSize);
        System.out.println("start index : " + startNum);
        System.out.println("iterations : " + numIterations);
        System.out.println("threads : " + numThreads);

        System.out.println("Bootstraping cluster data.");
        StoreClientFactory factory = new SocketStoreClientFactory(new ClientConfig().setMaxThreads(20)
                                                                                    .setMaxConnectionsPerNode(numThreads)
                                                                                    .setBootstrapUrls(url));
        final StoreClient<String, String> store = factory.getStoreClient(storeName);

        final String value = TestUtils.randomLetters(valueSize);
        ExecutorService service = Executors.newFixedThreadPool(numThreads);

        /*
         *   send the store a value and then delete it - useful for the NOOP store which will then use that value for
         *   other queries
         */

        String key = new KeyProvider(startNum, keys).next();        
        store.put(key, new Versioned<String>(value));
        store.delete(key);

         for (int loopCount=0; loopCount < numIterations; loopCount++) {

             System.out.println("======================= iteration = " + loopCount + " ======================================");
     
            if(ops.contains("d")) {
                System.out.println("Beginning delete test.");
                final AtomicInteger successes = new AtomicInteger(0);
                final KeyProvider keyProvider0 = new KeyProvider(startNum, keys);
                final CountDownLatch latch0 = new CountDownLatch(numRequests);
                long start = System.currentTimeMillis();
                for(int i = 0; i < numRequests; i++) {
                    service.execute(new Runnable() {

                        public void run() {
                            try {
                                store.delete(keyProvider0.next());
                                successes.getAndIncrement();
                            } catch(Exception e) {
                                e.printStackTrace();
                            } finally {
                                latch0.countDown();
                            }
                        }
                    });
                }
                latch0.await();
                long deleteTime = System.currentTimeMillis() - start;
                System.out.println("Throughput: " + (numRequests / (float) deleteTime * 1000)
                                   + " deletes/sec.");
                System.out.println(successes.get() + " things deleted.");
            }

            if(ops.contains("w")) {
                System.out.println("Beginning write test.");
                final KeyProvider keyProvider1 = new KeyProvider(startNum, keys);
                final CountDownLatch latch1 = new CountDownLatch(numRequests);
                long start = System.currentTimeMillis();
                for(int i = 0; i < numRequests; i++) {
                    service.execute(new Runnable() {

                        public void run() {
                            try {
                                store.put(keyProvider1.next(), new Versioned<String>(value));
                            } catch(Exception e) {
                                e.printStackTrace();
                            } finally {
                                latch1.countDown();
                            }
                        }
                    });
                }
                latch1.await();
                long writeTime = System.currentTimeMillis() - start;
                System.out.println("Throughput: " + (numRequests / (float) writeTime * 1000)
                                   + " writes/sec.");
            }

            if(ops.contains("r")) {
                System.out.println("Beginning read test.");
                final KeyProvider keyProvider2 = new KeyProvider(startNum, keys);
                final CountDownLatch latch2 = new CountDownLatch(numRequests);
                long start = System.currentTimeMillis();
                for(int i = 0; i < numRequests; i++) {
                    service.execute(new Runnable() {

                        public void run() {
                            try {
                                Versioned<String> v = store.get(keyProvider2.next());
                                
                                if (v == null) {
                                    throw new Exception("value returned is null");
                                }

                                if (!value.equals(v.getValue())) {
                                    throw new Exception("value returned isn't same as set value.  My val size = "
                                            + value.length() + " ret size = " + v.getValue().length());
                                }
                                
                            } catch(Exception e) {
                                e.printStackTrace();
                            } finally {
                                latch2.countDown();
                            }
                        }
                    });
                }
                latch2.await();
                long readTime = System.currentTimeMillis() - start;
                System.out.println("Throughput: " + (numRequests / (float) readTime * 1000.0)
                                   + " reads/sec.");
            }
        }

        System.exit(0);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3d1c2_4d3a1/rev_3d1c2-4d3a1/test/integration/voldemort/performance/RemoteTest.java
Conflict type: LineBasedMCFd
Conflict body: 
public void testFetchAndUpdate() throws IOException {
        Store<ByteArray, byte[]> store = server.getStoreRepository().getStorageEngine(storeName);
        assertNotSame("Store '" + storeName + "' should not be null", null, store);

        // assert server2 is missing all keys
        for(int i = 100; i <= 1000; i++) {
            ByteArray key = new ByteArray(ByteUtils.getBytes("" + i, "UTF-8"));
            assertEquals("Store should return empty result List for all before inserting",
                         0,
                         store.get(key).size());
        }

        // enter keys into server1 (keys 100 -- 1000)
        for(int i = 100; i <= 1000; i++) {
            ByteArray key = new ByteArray(ByteUtils.getBytes("" + i, "UTF-8"));
            byte[] value = ByteUtils.getBytes("value-" + i, "UTF-8");

            store.put(key,
                      new Versioned<byte[]>(value,
                                            new VectorClock().incremented(0,
                                                                          System.currentTimeMillis())));
        }

        // lets make a new server
        VoldemortConfig config2 = ServerTestUtils.createServerConfig(1,
                                                                     TestUtils.createTempDir()
                                                                              .getAbsolutePath(),
                                                                     null,
                                                                     storesXmlfile);
        VoldemortServer server2 = new VoldemortServer(config2, cluster);
        server2.start();

        // assert server2 is missing all keys
        for(int i = 100; i <= 1000; i++) {
            ByteArray key = new ByteArray(ByteUtils.getBytes("" + i, "UTF-8"));
            assertEquals("Server2 should return empty result List for all",
                         0,
                         server2.getStoreRepository().getStorageEngine(storeName).get(key).size());
        }

        // use pipeGetAndPutStream to add values to server2
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502348176/fstmerge_var1_9076186185085742042
        AdminClient client = getAdminClient();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502348176/fstmerge_base_8612290384067374843
        AdminClient client = new AdminClient(server2.getIdentityNode(),
                                             server2.getVoldemortMetadata(),
                                             new SocketPool(100, 100, 2000, 1000, 10000));

=======
        AdminClient client = new AdminClient(server2.getIdentityNode(),
                                             server2.getVoldemortMetadata(),
                                             new SocketPool(100, 100, 20000, 10000, 10000));

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502348176/fstmerge_var2_2558580303307513468
        List<Integer> stealList = new ArrayList<Integer>();
        stealList.add(0);
        stealList.add(1);

        client.fetchAndUpdateStreams(0, 1, storeName, stealList);

        // assert all partition 0, 1 keys present in server 2
        Store<ByteArray, byte[]> store2 = server2.getStoreRepository().getStorageEngine(storeName);
        assertNotSame("Store '" + storeName + "' should not be null", null, store2);

        StoreDefinition storeDef = server.getVoldemortMetadata().getStoreDef(storeName);
        assertNotSame("StoreDefinition for 'users' should not be nul ", null, storeDef);
        RoutingStrategy routingStrategy = new RoutingStrategyFactory(server.getVoldemortMetadata()
                                                                           .getCurrentCluster()).getRoutingStrategy(storeDef);

        int checked = 0;
        int matched = 0;
        for(int i = 100; i <= 1000; i++) {
            ByteArray key = new ByteArray(ByteUtils.getBytes("" + i, "UTF-8"));
            byte[] value = ByteUtils.getBytes("value-" + i, "UTF-8");

            if(routingStrategy.getPartitionList(key.get()).get(0) == 0
               || routingStrategy.getPartitionList(key.get()).get(0) == 1) {
                checked++;
                if(store2.get(key).size() > 0
                   && new String(value).equals(new String(store2.get(key).get(0).getValue()))) {
                    matched++;
                }
            }
        }

        server2.stop();
        assertEquals("All Values should have matched", checked, matched);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3d1c2_4d3a1/rev_3d1c2-4d3a1/test/unit/voldemort/client/AdminServiceTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502349028/fstmerge_var1_860976192518542027
@Override
    public void setUp() throws IOException {
        // start 2 node cluster with free ports
        int[] ports = ServerTestUtils.findFreePorts(2);
        Node node0 = new Node(0, "localhost", ports[0], ports[1], Arrays.asList(new Integer[] { 0,
                1 }));

        ports = ServerTestUtils.findFreePorts(2);
        Node node1 = new Node(1, "localhost", ports[0], ports[1], Arrays.asList(new Integer[] { 2,
                3 }));

        cluster = new Cluster("admin-service-test", Arrays.asList(new Node[] { node0, node1 }));

        server0 = new VoldemortServer(ServerTestUtils.createServerConfig(0,
                                                                         TestUtils.createTempDir()
                                                                                  .getAbsolutePath(),
                                                                         null,
                                                                         storesXmlfile),
                                      cluster);
        server0.start();

        server1 = new VoldemortServer(ServerTestUtils.createServerConfig(1,
                                                                         TestUtils.createTempDir()
                                                                                  .getAbsolutePath(),
                                                                         null,
                                                                         storesXmlfile),
                                      cluster);
        server1.start();

    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502349028/fstmerge_base_3782780988814256601
@Override
    public void setUp() throws IOException {
        // start 2 node cluster with free ports
        int[] ports = ServerTestUtils.findFreePorts(3);
        Node node0 = new Node(0,
                              "localhost",
                              ports[0],
                              ports[1],
                              ports[2],
                              Arrays.asList(new Integer[] { 0, 1 }));

        ports = ServerTestUtils.findFreePorts(3);
        Node node1 = new Node(1,
                              "localhost",
                              ports[0],
                              ports[1],
                              ports[2],
                              Arrays.asList(new Integer[] { 2, 3 }));

        cluster = new Cluster("admin-service-test", Arrays.asList(new Node[] { node0, node1 }));

        server0 = new VoldemortServer(ServerTestUtils.createServerConfig(0,
                                                                         TestUtils.createTempDir()
                                                                                  .getAbsolutePath(),
                                                                         null,
                                                                         storesXmlfile),
                                      cluster);
        server0.start();

        server1 = new VoldemortServer(ServerTestUtils.createServerConfig(1,
                                                                         TestUtils.createTempDir()
                                                                                  .getAbsolutePath(),
                                                                         null,
                                                                         storesXmlfile),
                                      cluster);
        server1.start();

    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502349028/fstmerge_var2_1548065747937980357

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3d1c2_4d3a1/rev_3d1c2-4d3a1/test/unit/voldemort/store/rebalancing/RebalancingStoreTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502349038/fstmerge_var1_6620958610830380597
public void testProxyGet() {
        // enter bunch of data into server1
        for(int i = 100; i <= 1000; i++) {
            ByteArray key = new ByteArray(ByteUtils.getBytes("" + i, "UTF-8"));
            byte[] value = ByteUtils.getBytes("value-" + i, "UTF-8");

            Store<ByteArray, byte[]> store = server1.getStoreRepository().getLocalStore(storeName);
            store.put(key,
                      Versioned.value(value,
                                      new VectorClock().incremented(0, System.currentTimeMillis())));
        }

        VoldemortMetadata metadata = server0.getVoldemortMetadata();

        // change donorNode/stealPartitionList here.
        metadata.setDonorNode(server0.getVoldemortMetadata().getCurrentCluster().getNodeById(1));
        metadata.setCurrentPartitionStealList(Arrays.asList(new Integer[] { 2, 3 }));

        RebalancingStore rebalancingStore = getRebalancingStore(metadata);

        // for Normal server state no values are expected
        for(int i = 100; i <= 1000; i++) {
            ByteArray key = new ByteArray(ByteUtils.getBytes("" + i, "UTF-8"));

            if(metadata.getRoutingStrategy(storeName)
                       .getPartitionList(key.get())
                       .contains(new Integer(2))
               || metadata.getRoutingStrategy(storeName)
                          .getPartitionList(key.get())
                          .contains(new Integer(3))) {
                assertEquals("proxyGet should return emptys list", 0, rebalancingStore.get(key)
                                                                                      .size());
            }
        }

        metadata.setServerState(VoldemortMetadata.ServerState.REBALANCING_STEALER_STATE);
        for(int i = 100; i <= 1000; i++) {
            ByteArray key = new ByteArray(ByteUtils.getBytes("" + i, "UTF-8"));

            if(metadata.getRoutingStrategy(storeName)
                       .getPartitionList(key.get())
                       .contains(new Integer(2))
               || metadata.getRoutingStrategy(storeName)
                          .getPartitionList(key.get())
                          .contains(new Integer(3))) {
                assertEquals("proxyGet should return actual value",
                             "value-" + i,
                             new String(rebalancingStore.get(key).get(0).getValue()));
            }
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502349038/fstmerge_base_223537467772397808
public void testProxyGet() {
        // enter bunch of data into server1
        for(int i = 100; i <= 1000; i++) {
            ByteArray key = new ByteArray(ByteUtils.getBytes("" + i, "UTF-8"));
            byte[] value = ByteUtils.getBytes("value-" + i, "UTF-8");

            Store<ByteArray, byte[]> store = server1.getStoreRepository().getLocalStore(storeName);
            store.put(key,
                      Versioned.value(value,
                                      new VectorClock().incremented(0, System.currentTimeMillis())));
        }

        VoldemortMetadata metadata = server0.getVoldemortMetadata();

        // change donorNode/stealPartitionList here.
        metadata.setDonorNode(server0.getVoldemortMetadata().getCurrentCluster().getNodeById(1));
        metadata.setCurrentPartitionStealList(Arrays.asList(new Integer[] { 2, 3 }));

        RebalancingStore rebalancingStore = new RebalancingStore(0,
                                                                 server0.getStoreRepository()
                                                                        .getLocalStore(storeName),
                                                                 metadata,
                                                                 new SocketPool(100,
                                                                                100,
                                                                                2000,
                                                                                1000,
                                                                                10000));

        // for Normal server state no values are expected
        for(int i = 100; i <= 1000; i++) {
            ByteArray key = new ByteArray(ByteUtils.getBytes("" + i, "UTF-8"));

            if(metadata.getRoutingStrategy(storeName)
                       .getPartitionList(key.get())
                       .contains(new Integer(2))
               || metadata.getRoutingStrategy(storeName)
                          .getPartitionList(key.get())
                          .contains(new Integer(3))) {
                assertEquals("proxyGet should return emptys list", 0, rebalancingStore.get(key)
                                                                                      .size());
            }
        }

        metadata.setServerState(VoldemortMetadata.ServerState.REBALANCING_STEALER_STATE);
        for(int i = 100; i <= 1000; i++) {
            ByteArray key = new ByteArray(ByteUtils.getBytes("" + i, "UTF-8"));

            if(metadata.getRoutingStrategy(storeName)
                       .getPartitionList(key.get())
                       .contains(new Integer(2))
               || metadata.getRoutingStrategy(storeName)
                          .getPartitionList(key.get())
                          .contains(new Integer(3))) {
                assertEquals("proxyGet should return actual value",
                             "value-" + i,
                             new String(rebalancingStore.get(key).get(0).getValue()));
            }
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502349038/fstmerge_var2_5744961552384516060

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3d1c2_4d3a1/rev_3d1c2-4d3a1/test/unit/voldemort/store/rebalancing/RebalancingStoreTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502349044/fstmerge_var1_2528898072040972060
public void testProxyPut() {
        // enter bunch of data into server1
        for(int i = 100; i <= 1000; i++) {
            ByteArray key = new ByteArray(ByteUtils.getBytes("" + i, "UTF-8"));
            byte[] value = ByteUtils.getBytes("value-" + i, "UTF-8");

            Store<ByteArray, byte[]> store = server1.getStoreRepository().getLocalStore(storeName);
            store.put(key,
                      Versioned.value(value,
                                      new VectorClock().incremented(0, System.currentTimeMillis())));

            // 
            try {
                store.put(key, store.get(key).get(0));
                fail("put should throw ObsoleteVersionException before hitting this");
            } catch(ObsoleteVersionException e) {
                // ignore
            }
        }

        VoldemortMetadata metadata = server0.getVoldemortMetadata();

        // change donorNode/stealPartitionList here.
        metadata.setDonorNode(server0.getVoldemortMetadata().getCurrentCluster().getNodeById(1));
        metadata.setCurrentPartitionStealList(Arrays.asList(new Integer[] { 2, 3 }));

        RebalancingStore rebalancingStore = getRebalancingStore(metadata);

        // we should see obsolete version exception if try to insert with same
        // version

        metadata.setServerState(VoldemortMetadata.ServerState.REBALANCING_STEALER_STATE);
        for(int i = 100; i <= 1000; i++) {
            ByteArray key = new ByteArray(ByteUtils.getBytes("" + i, "UTF-8"));
            if(metadata.getRoutingStrategy(storeName)
                       .getPartitionList(key.get())
                       .contains(new Integer(2))
               || metadata.getRoutingStrategy(storeName)
                          .getPartitionList(key.get())
                          .contains(new Integer(3))) {
                try {
                    rebalancingStore.put(key, rebalancingStore.get(key).get(0));
                    fail("put should throw ObsoleteVersionException before hitting this");
                } catch(ObsoleteVersionException e) {
                    // ignore
                }
            }
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502349044/fstmerge_base_5503181543702458841
public void testProxyPut() {
        // enter bunch of data into server1
        for(int i = 100; i <= 1000; i++) {
            ByteArray key = new ByteArray(ByteUtils.getBytes("" + i, "UTF-8"));
            byte[] value = ByteUtils.getBytes("value-" + i, "UTF-8");

            Store<ByteArray, byte[]> store = server1.getStoreRepository().getLocalStore(storeName);
            store.put(key,
                      Versioned.value(value,
                                      new VectorClock().incremented(0, System.currentTimeMillis())));

            // 
            try {
                store.put(key, store.get(key).get(0));
                fail("put should throw ObsoleteVersionException before hitting this");
            } catch(ObsoleteVersionException e) {
                // ignore
            }
        }

        VoldemortMetadata metadata = server0.getVoldemortMetadata();

        // change donorNode/stealPartitionList here.
        metadata.setDonorNode(server0.getVoldemortMetadata().getCurrentCluster().getNodeById(1));
        metadata.setCurrentPartitionStealList(Arrays.asList(new Integer[] { 2, 3 }));

        RebalancingStore rebalancingStore = new RebalancingStore(0,
                                                                 server0.getStoreRepository()
                                                                        .getLocalStore(storeName),
                                                                 metadata,
                                                                 new SocketPool(100,
                                                                                100,
                                                                                2000,
                                                                                1000,
                                                                                10000));

        // we should see obsolete version exception if try to insert with same
        // version

        metadata.setServerState(VoldemortMetadata.ServerState.REBALANCING_STEALER_STATE);
        for(int i = 100; i <= 1000; i++) {
            ByteArray key = new ByteArray(ByteUtils.getBytes("" + i, "UTF-8"));
            if(metadata.getRoutingStrategy(storeName)
                       .getPartitionList(key.get())
                       .contains(new Integer(2))
               || metadata.getRoutingStrategy(storeName)
                          .getPartitionList(key.get())
                          .contains(new Integer(3))) {
                try {
                    rebalancingStore.put(key, rebalancingStore.get(key).get(0));
                    fail("put should throw ObsoleteVersionException before hitting this");
                } catch(ObsoleteVersionException e) {
                    // ignore
                }
            }
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502349044/fstmerge_var2_3366951324117226145

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3d1c2_4d3a1/rev_3d1c2-4d3a1/test/unit/voldemort/store/rebalancing/RebalancingStoreTest.java
Conflict type: LineBasedMCFd
Conflict body: 
public void registerEngine(StorageEngine<ByteArray, byte[]> engine) {
        Cluster cluster = this.metadata.getCurrentCluster();
        storeRepository.addStorageEngine(engine);

        /* Now add any store wrappers that are enabled */
        Store<ByteArray, byte[]> store = engine;
        if(voldemortConfig.isVerboseLoggingEnabled())
            store = new LoggingStore<ByteArray, byte[]>(store,
                                                        cluster.getName(),
                                                        SystemTime.INSTANCE);
        if(voldemortConfig.isMetadataCheckingEnabled())
            store = new InvalidMetadataCheckingStore(metadata.getIdentityNode().getId(),
                                                     store,
                                                     metadata);

        if(voldemortConfig.isRedirectRoutingEnabled())
            store = new RedirectingStore(metadata.getIdentityNode().getId(),
                                         store,
                                         metadata,
                                         socketPool);

        if(voldemortConfig.isStatTrackingEnabled()) {
            store = new StatTrackingStore<ByteArray, byte[]>(store);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502355300/fstmerge_var1_2729563496192917195
            if(voldemortConfig.isJmxEnabled())
                JmxUtils.registerMbean(store.getName(), store);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502355300/fstmerge_base_7302202747264724927

            if (voldemortConfig.isJmxEnabled()) {

                MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
                ObjectName name = JmxUtils.createObjectName(JmxUtils.getPackageName(store.getClass()), store.getName());

                if(mbeanServer.isRegistered(name))
                    JmxUtils.unregisterMbean(mbeanServer, name);
                JmxUtils.registerMbean(mbeanServer, JmxUtils.createModelMBean(store), name);
            }
=======

            if(voldemortConfig.isJmxEnabled()) {

                MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
                ObjectName name = JmxUtils.createObjectName(JmxUtils.getPackageName(store.getClass()),
                                                            store.getName());

                if(mbeanServer.isRegistered(name))
                    JmxUtils.unregisterMbean(mbeanServer, name);
                JmxUtils.registerMbean(mbeanServer, JmxUtils.createModelMBean(store), name);
            }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502355300/fstmerge_var2_8976624979422486384
        }
        storeRepository.addLocalStore(store);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3d1c2_4d3a1/rev_3d1c2-4d3a1/src/java/voldemort/server/storage/StorageService.java
Conflict type: LineBasedMCFd
Conflict body: 
public static void main(String[] args) throws Exception {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502357654/fstmerge_var1_6308806952509687322
        OptionParser parser = new OptionParser();
        parser.accepts("help", "print usage information");
        parser.accepts("cluster", "[REQUIRED] the voldemort cluster.xml file ")
              .withRequiredArg()
              .describedAs("cluster.xml");
        parser.accepts("name", "[REQUIRED] the name of the store to swap")
              .withRequiredArg()
              .describedAs("store-name");
        parser.accepts("servlet-path", "the path for the read-only management servlet")
              .withRequiredArg()
              .describedAs("path");
        parser.accepts("file", "[REQUIRED] uri of a directory containing the new store files")
              .withRequiredArg()
              .describedAs("uri");
        parser.accepts("timeout", "http timeout for the fetch in ms")
              .withRequiredArg()
              .describedAs("timeout ms")
              .ofType(Integer.class);

        OptionSet options = parser.parse(args);
        if(options.has("help")) {
            parser.printHelpOn(System.out);
            System.exit(0);
        }

        Set<String> missing = CmdUtils.missing(options, "cluster", "name", "file");
        if(missing.size() > 0) {
            System.err.println("Missing required arguments: " + Joiner.on(", ").join(missing));
            parser.printHelpOn(System.err);
            System.exit(1);
        }

        String clusterXml = (String) options.valueOf("cluster");
        String storeName = (String) options.valueOf("name");
        String mgmtPath = CmdUtils.valueOf(options, "servlet-path", "read-only/mgmt");
        String filePath = (String) options.valueOf("file");
        int timeoutMs = CmdUtils.valueOf(options,
                                         "timeout",
                                         (int) (3 * Time.SECONDS_PER_HOUR * Time.MS_PER_SECOND));
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502357654/fstmerge_base_362686475207170886
        if(args.length != 4)
            Utils.croak("USAGE: cluster.xml store_name mgmtpath store_file_path");
        String clusterXml = args[0];
        String storeName = args[1];
        String mgmtPath = args[2];
        String filePath = args[3];
=======
        OptionParser parser = new OptionParser();
        parser.accepts("help", "print usage information");
        parser.accepts("cluster", "[REQUIRED] the voldemort cluster.xml file ")
              .withRequiredArg()
              .describedAs("cluster.xml");
        parser.accepts("name", "[REQUIRED] the name of the store to swap")
              .withRequiredArg()
              .describedAs("store-name");
        parser.accepts("servlet-path", "the path for the read-only management servlet")
              .withRequiredArg()
              .describedAs("path");
        parser.accepts("file", "[REQUIRED] uri of a directory containing the new store files")
              .withRequiredArg()
              .describedAs("uri");
        parser.accepts("timeout", "http timeout for the fetch in ms")
              .withRequiredArg()
              .describedAs("timeout ms")
              .ofType(Integer.class);

        OptionSet options = parser.parse(args);
        if(options.has("help")) {
            parser.printHelpOn(System.out);
            System.exit(0);
        }

        Set<String> missing = CmdUtils.missing(options, "cluster", "name", "file");
        if(missing.size() > 0) {
            System.err.println("Missing required arguments: " + Join.join(", ", missing));
            parser.printHelpOn(System.err);
            System.exit(1);
        }

        String clusterXml = (String) options.valueOf("cluster");
        String storeName = (String) options.valueOf("name");
        String mgmtPath = CmdUtils.valueOf(options, "servlet-path", "read-only/mgmt");
        String filePath = (String) options.valueOf("file");
        int timeoutMs = CmdUtils.valueOf(options,
                                         "timeout",
                                         (int) (3 * Time.SECONDS_PER_HOUR * Time.MS_PER_SECOND));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502357654/fstmerge_var2_6695531043324281830

        String clusterStr = FileUtils.readFileToString(new File(clusterXml));
        Cluster cluster = new ClusterMapper().readCluster(new StringReader(clusterStr));
        ExecutorService executor = Executors.newFixedThreadPool(10);
        HttpConnectionManager manager = new MultiThreadedHttpConnectionManager();

        int numConnections = cluster.getNumberOfNodes() + 3;
        manager.getParams().setMaxTotalConnections(numConnections);
        manager.getParams().setMaxConnectionsPerHost(HostConfiguration.ANY_HOST_CONFIGURATION,
                                                     numConnections);
        HttpClient client = new HttpClient(manager);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502357654/fstmerge_base_362686475207170886
        client.getParams().setParameter("http.socket.timeout", 3 * 60 * 60 * 1000);
=======
        client.getParams().setParameter("http.socket.timeout", timeoutMs);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502357654/fstmerge_var2_6695531043324281830

        StoreSwapper swapper = new StoreSwapper(cluster, executor, client, mgmtPath);
        long start = System.currentTimeMillis();
        swapper.swapStoreData(storeName, filePath);
        long end = System.currentTimeMillis();
        logger.info("Swap succeeded on all nodes in " + ((end - start) / Time.MS_PER_SECOND)
                    + " seconds.");
        executor.shutdownNow();
        executor.awaitTermination(1, TimeUnit.SECONDS);
        System.exit(0);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3d1c2_4d3a1/rev_3d1c2-4d3a1/src/java/voldemort/store/readonly/StoreSwapper.java
Conflict type: LineBasedMCFd
Conflict body: 
public static void main(String[] args) throws IOException {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502357946/fstmerge_var1_5399325851505986098
        OptionParser parser = new OptionParser();
        parser.accepts("help", "print usage information");
        parser.accepts("cluster", "[REQUIRED] path to cluster xml config file")
              .withRequiredArg()
              .describedAs("cluster.xml");
        parser.accepts("stores", "[REQUIRED] path to stores xml config file")
              .withRequiredArg()
              .describedAs("stores.xml");
        parser.accepts("name", "[REQUIRED] store name").withRequiredArg().describedAs("store name");
        parser.accepts("buffer", "[REQUIRED] number of key/value pairs to buffer in memory")
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("input", "[REQUIRED] input file to read from")
              .withRequiredArg()
              .describedAs("input-file");
        parser.accepts("output", "[REQUIRED] directory to output stores to")
              .withRequiredArg()
              .describedAs("output directory");
        parser.accepts("threads", "number of threads").withRequiredArg().ofType(Integer.class);
        parser.accepts("chunks", "number of store chunks per store")
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("io-buffer-size", "size of i/o buffers in bytes")
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("temp-dir", "temporary directory for sorted file pieces")
              .withRequiredArg()
              .describedAs("temp dir");
        OptionSet options = parser.parse(args);

        if(options.has("help")) {
            parser.printHelpOn(System.out);
            System.exit(0);
        }

        Set<String> missing = CmdUtils.missing(options,
                                               "cluster",
                                               "stores",
                                               "name",
                                               "buffer",
                                               "input",
                                               "output");
        if(missing.size() > 0) {
            System.err.println("Missing required arguments: " + Joiner.on(", ").join(missing));
            parser.printHelpOn(System.err);
            System.exit(1);
        }

        String clusterFile = (String) options.valueOf("cluster");
        String storeDefFile = (String) options.valueOf("stores");
        String storeName = (String) options.valueOf("name");
        int sortBufferSize = (Integer) options.valueOf("buffer");
        String inputFile = (String) options.valueOf("input");
        File outputDir = new File((String) options.valueOf("output"));
        int numThreads = CmdUtils.valueOf(options, "threads", 2);
        int numChunks = CmdUtils.valueOf(options, "chunks", 2);
        int ioBufferSize = CmdUtils.valueOf(options, "io-buffer-size", 1000000);
        File tempDir = new File(CmdUtils.valueOf(options,
                                                 "temp-dir",
                                                 System.getProperty("java.io.tmpdir")));
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502357946/fstmerge_base_7903500532816796561
        if(args.length != 8)
            Utils.croak("USAGE: java "
                        + JsonStoreBuilder.class.getName()
                        + " cluster.xml store_definitions.xml store_name sort_obj_buffer_size input_data output_dir num_threads num_chunks");
        String clusterFile = args[0];
        String storeDefFile = args[1];
        String storeName = args[2];
        int sortBufferSize = Integer.parseInt(args[3]);
        String inputFile = args[4];
        File outputDir = new File(args[5]);
        int numThreads = Integer.parseInt(args[6]);
        int numChunks = Integer.parseInt(args[7]);
=======
        OptionParser parser = new OptionParser();
        parser.accepts("help", "print usage information");
        parser.accepts("cluster", "[REQUIRED] path to cluster xml config file")
              .withRequiredArg()
              .describedAs("cluster.xml");
        parser.accepts("stores", "[REQUIRED] path to stores xml config file")
              .withRequiredArg()
              .describedAs("stores.xml");
        parser.accepts("name", "[REQUIRED] store name").withRequiredArg().describedAs("store name");
        parser.accepts("buffer", "[REQUIRED] number of key/value pairs to buffer in memory")
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("input", "[REQUIRED] input file to read from")
              .withRequiredArg()
              .describedAs("input-file");
        parser.accepts("output", "[REQUIRED] directory to output stores to")
              .withRequiredArg()
              .describedAs("output directory");
        parser.accepts("threads", "number of threads").withRequiredArg().ofType(Integer.class);
        parser.accepts("chunks", "number of store chunks per store")
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("io-buffer-size", "size of i/o buffers in bytes")
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("temp-dir", "temporary directory for sorted file pieces")
              .withRequiredArg()
              .describedAs("temp dir");
        OptionSet options = parser.parse(args);

        if(options.has("help")) {
            parser.printHelpOn(System.out);
            System.exit(0);
        }

        Set<String> missing = CmdUtils.missing(options,
                                               "cluster",
                                               "stores",
                                               "name",
                                               "buffer",
                                               "input",
                                               "output");
        if(missing.size() > 0) {
            System.err.println("Missing required arguments: " + Join.join(", ", missing));
            parser.printHelpOn(System.err);
            System.exit(1);
        }

        String clusterFile = (String) options.valueOf("cluster");
        String storeDefFile = (String) options.valueOf("stores");
        String storeName = (String) options.valueOf("name");
        int sortBufferSize = (Integer) options.valueOf("buffer");
        String inputFile = (String) options.valueOf("input");
        File outputDir = new File((String) options.valueOf("output"));
        int numThreads = CmdUtils.valueOf(options, "threads", 2);
        int numChunks = CmdUtils.valueOf(options, "chunks", 2);
        int ioBufferSize = CmdUtils.valueOf(options, "io-buffer-size", 1000000);
        File tempDir = new File(CmdUtils.valueOf(options,
                                                 "temp-dir",
                                                 System.getProperty("java.io.tmpdir")));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502357946/fstmerge_var2_8401765263482793968

        try {
            JsonReader reader = new JsonReader(new BufferedReader(new FileReader(inputFile),
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502357946/fstmerge_base_7903500532816796561
                                                                  1000000));
=======
                                                                  ioBufferSize));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502357946/fstmerge_var2_8401765263482793968
            Cluster cluster = new ClusterMapper().readCluster(new BufferedReader(new FileReader(clusterFile)));
            StoreDefinition storeDef = null;
            List<StoreDefinition> stores = new StoreDefinitionsMapper().readStoreList(new BufferedReader(new FileReader(storeDefFile)));
            for(StoreDefinition def: stores) {
                if(def.getName().equals(storeName))
                    storeDef = def;
            }

            if(storeDef == null)
                Utils.croak("No store found with name \"" + storeName + "\"");

            if(!outputDir.exists())
                Utils.croak("Directory \"" + outputDir.getAbsolutePath() + " does not exist.");

            RoutingStrategy routingStrategy = new RoutingStrategyFactory(cluster).getRoutingStrategy(storeDef);

            new JsonStoreBuilder(reader,
                                 cluster,
                                 storeDef,
                                 routingStrategy,
                                 outputDir,
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502357946/fstmerge_base_7903500532816796561
=======
                                 tempDir,
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502357946/fstmerge_var2_8401765263482793968
                                 sortBufferSize,
                                 numThreads,
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502357946/fstmerge_base_7903500532816796561
                                 numChunks).build();
=======
                                 numChunks,
                                 ioBufferSize).build();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502357946/fstmerge_var2_8401765263482793968
        } catch(FileNotFoundException e) {
            Utils.croak(e.getMessage());
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3d1c2_4d3a1/rev_3d1c2-4d3a1/src/java/voldemort/store/readonly/JsonStoreBuilder.java
Conflict type: LineBasedMCFd
Conflict body: 
public JsonTypeDefinition(Object type) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502359516/fstmerge_var1_2787560614752273933
        this.type = createValidType(type);

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502359516/fstmerge_base_8853061993647967723
        this.type = type;
        validate(type);
=======
        this.type = validate(type);

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502359516/fstmerge_var2_2181289450383759430
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3d1c2_4d3a1/rev_3d1c2-4d3a1/src/java/voldemort/serialization/json/JsonTypeDefinition.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502359557/fstmerge_var1_6861375542892522802
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502359557/fstmerge_base_4870195105802227243
private void validate(Object type) {
        if(type == null) {
            throw new IllegalArgumentException("Type or subtype cannot be null.");
        } else if(type instanceof List<?>) {
            List<?> l = (List<?>) type;
            if(l.size() != 1)
                throw new IllegalArgumentException("Lists in type definition must have length exactly one.");
            validate(l.get(0));
        } else if(type instanceof Map<?, ?>) {
            Map<?, ?> m = (Map<?, ?>) type;
            for(Map.Entry<?, ?> entry: m.entrySet())
                validate(entry.getValue());
        } else if(type instanceof JsonTypes) {
            // this is good
        } else {
            throw new IllegalArgumentException("Unknown type in json type definition: " + type
                                               + " of class " + type.getClass().getName());
        }
    }
=======
private Object validate(Object type) {
        if(type == null) {
            throw new IllegalArgumentException("Type or subtype cannot be null.");
        } else if(type instanceof List<?>) {
            List<?> l = (List<?>) type;
            if(l.size() != 1)
                throw new IllegalArgumentException("Lists in type definition must have length exactly one.");
            return validate(l.get(0));
        } else if(type instanceof Map<?, ?>) {
            Map<String, ?> m = (Map<String, ?>) type;

            // bbansal: sort keys here for consistent with fromJson()
            Map<String, Object> newM = new LinkedHashMap<String, Object>(m.size());
            List<String> keys = new ArrayList<String>((m.keySet()));
            Collections.sort(keys);
            for(String key: keys)
                newM.put(key, validate(m.get(key)));
            return newM;
        } else if(type instanceof JsonTypes) {
            // this is good
            return type;
        } else {
            throw new IllegalArgumentException("Unknown type in json type definition: " + type
                                               + " of class " + type.getClass().getName());
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415502359557/fstmerge_var2_1618316648683781741

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3d1c2_4d3a1/rev_3d1c2-4d3a1/src/java/voldemort/serialization/json/JsonTypeDefinition.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_218f0_210c5/rev_218f0-210c5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_07e1a_aae01/rev_07e1a-aae01.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_29eaf_1679e/rev_29eaf-1679e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d9554_f8bc8/rev_d9554-f8bc8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6cf30_abe83/rev_6cf30-abe83.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_38918_b6891/rev_38918-b6891.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6c51b_c50ba/rev_6c51b-c50ba.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a9309_472b3/rev_a9309-472b3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_99fa7_a755b/rev_99fa7-a755b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2c3c9_92737/rev_2c3c9-92737.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public void setUp() {
        this.port = ServerTestUtils.findFreePort();
        this.pool = new SocketPool(maxConnectionsPerNode, 1000, 1000, 32 * 1024);
        this.dest1 = new SocketDestination("localhost", port, RequestFormatType.VOLDEMORT_V1);
        RequestHandlerFactory handlerFactory = new RequestHandlerFactory(new StoreRepository(),
                                                                         null,
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503243643/fstmerge_var1_3728473784613278261
                                                                         null);
        this.server = new SocketServer(port, 10, 10 + 3, 10000, handlerFactory);
        this.server.start();
        this.server.awaitStartupCompletion();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503243643/fstmerge_base_8537900642860029549
                                                                         null);
        this.server = new SocketServer(port,
                                       maxTotalConnections,
                                       maxTotalConnections + 3,
                                       10000,
                                       handlerFactory);
        this.server.start();
        this.server.awaitStartupCompletion();
=======
                                                                         ServerTestUtils.getVoldemortConfig());
        this.socketService = ServerTestUtils.getSocketService(handlerFactory,
                                                              port,
                                                              maxTotalConnections,
                                                              maxTotalConnections + 3,
                                                              10000);
        this.socketService.start();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503243643/fstmerge_var2_2258161297963569433
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2c3c9_92737/rev_2c3c9-92737/test/unit/voldemort/server/socket/SocketPoolTest.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_5a003_3f9cb/rev_5a003-3f9cb.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_54ea5_8a9d4/rev_54ea5-8a9d4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_8a1a0_df55c/rev_8a1a0-df55c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_03f1e_8a1a0/rev_03f1e-8a1a0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bb606_adeef/rev_bb606-adeef.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503707875/fstmerge_var1_2267671877008466145
private RebalancingStore getRebalancingStore(VoldemortMetadata metadata) {
        return new RebalancingStore(0,
                                    server0.getStoreRepository().getLocalStore(storeName),
                                    metadata,
                                    new SocketPool(100, 2000, 1000, 10000));
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503707875/fstmerge_base_2656570629768329652
private RebalancingStore getRebalancingStore(VoldemortMetadata metadata) {
        return new RebalancingStore(0,
                                    server0.getStoreRepository().getLocalStore(storeName),
                                    metadata,
                                    new SocketPool(100, 100, 2000, 1000, 10000));
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503707875/fstmerge_var2_4445544036107175837

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bb606_adeef/rev_bb606-adeef/test/unit/voldemort/store/rebalancing/RebalancingStoreTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503713937/fstmerge_var1_323583034735328163
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503713937/fstmerge_base_4439984028622560006
public void handleRequest(DataInputStream inputStream, DataOutputStream outputStream)
            throws IOException {
        byte opCode = inputStream.readByte();
        StorageEngine<ByteArray, byte[]> engine;
        switch(opCode) {
            case VoldemortOpCode.GET_PARTITION_AS_STREAM_OP_CODE:
                engine = readStorageEngine(inputStream, outputStream);
                if(engine != null)
                    handleGetPartitionsAsStream(engine, inputStream, outputStream);
                break;
            case VoldemortOpCode.PUT_ENTRIES_AS_STREAM_OP_CODE:
                engine = readStorageEngine(inputStream, outputStream);
                if(engine != null)
                    handleUpdateEntries(engine, inputStream, outputStream);
                break;
            case VoldemortOpCode.UPDATE_METADATA_OP_CODE:
                String keyString = inputStream.readUTF();
                handleUpdateMetadataRequest(keyString, inputStream, outputStream);
                break;

            case VoldemortOpCode.SERVER_STATE_CHANGE_OP_CODE:
                handleServerStateChangeRequest(inputStream, outputStream);
                break;
            case VoldemortOpCode.REDIRECT_GET_OP_CODE:
                engine = readStorageEngine(inputStream, outputStream);
                byte[] key = readKey(inputStream);
                handleRedirectGetRequest(engine, key, outputStream);
                break;
            default:
                throw new IOException("Unknown op code : " + opCode + " at Node:"
                                      + metadata.getIdentityNode().getId());
        }

        outputStream.flush();
    }
=======
public void handleRequest(DataInputStream inputStream, DataOutputStream outputStream)
            throws IOException {
        byte opCode = inputStream.readByte();
        StorageEngine<ByteArray, byte[]> engine;
        switch(opCode) {
            case VoldemortOpCode.GET_PARTITION_AS_STREAM_OP_CODE:
                engine = readStorageEngine(inputStream, outputStream);
                if(engine != null)
                    handleGetPartitionsAsStream(engine, inputStream, outputStream);
                break;
            case VoldemortOpCode.PUT_ENTRIES_AS_STREAM_OP_CODE:
                engine = readStorageEngine(inputStream, outputStream);
                if(engine != null)
                    handleUpdateEntries(engine, inputStream, outputStream);
                break;
            case VoldemortOpCode.UPDATE_METADATA_OP_CODE:
                String keyString = inputStream.readUTF();
                handleUpdateMetadataRequest(keyString, inputStream, outputStream);
                break;

            case VoldemortOpCode.SERVER_STATE_CHANGE_OP_CODE:
                handleServerStateChangeRequest(inputStream, outputStream);
                break;

            case VoldemortOpCode.SET_STEAL_INFO_OP_CODE:
                handleSetStealInfoRequest(inputStream, outputStream);
                break;

            case VoldemortOpCode.REDIRECT_GET_OP_CODE:
                engine = readStorageEngine(inputStream, outputStream);
                byte[] key = readKey(inputStream);
                handleRedirectGetRequest(engine, key, outputStream);
                break;
            default:
                throw new IOException("Unknown op code : " + opCode + " at Node:"
                                      + metadata.getIdentityNode().getId());
        }

        outputStream.flush();
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503713937/fstmerge_var2_6200858926631002682

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bb606_adeef/rev_bb606-adeef/src/java/voldemort/server/socket/AdminServiceRequestHandler.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503713952/fstmerge_var1_3225965456767164105
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503713952/fstmerge_base_391219236880713696
private void handleUpdateEntries(StorageEngine<ByteArray, byte[]> engine,
                                     DataInputStream inputStream,
                                     DataOutputStream outputStream) throws IOException {
        IoThrottler throttler = new IoThrottler(streamMaxBytesWritesPerSec);

        try {
            int keySize = inputStream.readInt();
            while(keySize != -1) {
                byte[] key = new byte[keySize];
                ByteUtils.read(inputStream, key);

                int valueSize = inputStream.readInt();
                byte[] value = new byte[valueSize];
                ByteUtils.read(inputStream, value);

                VectorClock clock = new VectorClock(value);
                Versioned<byte[]> versionedValue = new Versioned<byte[]>(ByteUtils.copy(value,
                                                                                        clock.sizeInBytes(),
                                                                                        value.length),
                                                                         clock);

                engine.put(new ByteArray(key), versionedValue);

                if(throttler != null) {
                    throttler.maybeThrottle(key.length + clock.sizeInBytes() + value.length);
                }

                keySize = inputStream.readInt(); // read next KeySize
            }
            // all puts are handled.
            outputStream.writeShort(0);
        } catch(VoldemortException e) {
            writeException(outputStream, e);
        }
    }
=======
private void handleUpdateEntries(StorageEngine<ByteArray, byte[]> engine,
                                     DataInputStream inputStream,
                                     DataOutputStream outputStream) throws IOException {
        IoThrottler throttler = new IoThrottler(streamMaxBytesWritesPerSec);

        try {
            int keySize = inputStream.readInt();
            while(keySize != -1) {
                byte[] key = new byte[keySize];
                ByteUtils.read(inputStream, key);

                int valueSize = inputStream.readInt();
                byte[] value = new byte[valueSize];
                ByteUtils.read(inputStream, value);

                VectorClock clock = new VectorClock(value);
                Versioned<byte[]> versionedValue = new Versioned<byte[]>(ByteUtils.copy(value,
                                                                                        clock.sizeInBytes(),
                                                                                        value.length),
                                                                         clock);

                engine.put(new ByteArray(key), versionedValue);

                outputStream.writeShort(0); // send no Exception
                outputStream.flush();

                if(throttler != null) {
                    throttler.maybeThrottle(key.length + clock.sizeInBytes() + value.length + 1);
                }

                keySize = inputStream.readInt(); // read next KeySize
            }
            // all puts are handled.
            outputStream.writeShort(0);
            outputStream.flush();
        } catch(VoldemortException e) {
            writeException(outputStream, e);
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503713952/fstmerge_var2_1558927790780362741

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bb606_adeef/rev_bb606-adeef/src/java/voldemort/server/socket/AdminServiceRequestHandler.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503713968/fstmerge_var1_735566393406782142
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503713968/fstmerge_base_8497688065297898084
private void handleUpdateClusterMetadataRequest(String cluster_key,
                                                    DataInputStream inputStream,
                                                    DataOutputStream outputStream)
            throws IOException {
        // get current ClusterInfo
        List<Versioned<byte[]>> clusterInfo = metadataStore.get(ByteUtils.getBytes(cluster_key,
                                                                                   "UTF-8"));
        if(clusterInfo.size() > 1) {
            throw new UnableUpdateMetadataException("Inconistent Cluster Metdata found on Server:"
                                                    + metadata.getIdentityNode().getId()
                                                    + " for Key:" + cluster_key);
        }
        logger.debug("Cluster metadata  update called " + cluster_key);
        // update version
        VectorClock updatedVersion = new VectorClock();
        if(clusterInfo.size() > 0) {
            updatedVersion = ((VectorClock) clusterInfo.get(0).getVersion());
        }

        updatedVersion.incrementVersion(metadata.getIdentityNode().getId(),
                                        System.currentTimeMillis());

        try {
            String clusterString = inputStream.readUTF();

            Cluster updatedCluster = new ClusterMapper().readCluster(new StringReader(clusterString));

            // update cluster details in metaDataStore
            metadataStore.put(new ByteArray(ByteUtils.getBytes(cluster_key, "UTF-8")),
                              new Versioned<byte[]>(ByteUtils.getBytes(new ClusterMapper().writeCluster(updatedCluster),
                                                                       "UTF-8"),
                                                    updatedVersion));
            // if successfull update state in Voldemort Metadata
            if(MetadataStore.CLUSTER_KEY.equalsIgnoreCase(cluster_key)) {
                metadata.setCurrentCluster(updatedCluster);
                metadata.reinitRoutingStrategies();
            } else if(MetadataStore.ROLLBACK_CLUSTER_KEY.equalsIgnoreCase(cluster_key)) {
                metadata.setRollbackCluster(updatedCluster);
            }
            outputStream.writeShort(0);
        } catch(VoldemortException e) {
            e.printStackTrace();
            writeException(outputStream, e);
            return;
        }
    }
=======
private void handleUpdateClusterMetadataRequest(String cluster_key,
                                                    DataInputStream inputStream,
                                                    DataOutputStream outputStream)
            throws IOException {
        // get current ClusterInfo
        List<Versioned<byte[]>> clusterInfo = metadataStore.get(ByteUtils.getBytes(cluster_key,
                                                                                   "UTF-8"));
        if(clusterInfo.size() > 1) {
            throw new UnableUpdateMetadataException("Inconistent Cluster Metdata found on Server:"
                                                    + metadata.getIdentityNode().getId()
                                                    + " for Key:" + cluster_key);
        }
        logger.debug("Cluster metadata  update called " + cluster_key);
        // update version
        VectorClock updatedVersion = new VectorClock();
        if(clusterInfo.size() > 0) {
            updatedVersion = ((VectorClock) clusterInfo.get(0).getVersion());
        }

        updatedVersion.incrementVersion(metadata.getIdentityNode().getId(),
                                        System.currentTimeMillis());

        try {
            String clusterString = inputStream.readUTF();

            Cluster updatedCluster = new ClusterMapper().readCluster(new StringReader(clusterString));

            // update cluster details in metaDataStore
            metadataStore.put(new ByteArray(ByteUtils.getBytes(cluster_key, "UTF-8")),
                              new Versioned<byte[]>(ByteUtils.getBytes(new ClusterMapper().writeCluster(updatedCluster),
                                                                       "UTF-8"),
                                                    updatedVersion));
            // if successfull update state in Voldemort Metadata
            if(MetadataStore.CLUSTER_KEY.equalsIgnoreCase(cluster_key)) {
                metadata.setCurrentCluster(updatedCluster);
                metadata.reinitRoutingStrategies();
            } else if(MetadataStore.ROLLBACK_CLUSTER_KEY.equalsIgnoreCase(cluster_key)) {
                metadata.setRollbackCluster(updatedCluster);
            }
            outputStream.writeShort(0);
            outputStream.flush();
        } catch(VoldemortException e) {
            e.printStackTrace();
            writeException(outputStream, e);
            return;
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503713968/fstmerge_var2_2681169434148080317

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bb606_adeef/rev_bb606-adeef/src/java/voldemort/server/socket/AdminServiceRequestHandler.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503713972/fstmerge_var1_5037854628711346599
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503713972/fstmerge_base_5691177862808646530
private void handleUpdateStoresMetadataRequest(String storeKey,
                                                   DataInputStream inputStream,
                                                   DataOutputStream outputStream)
            throws IOException {
        // get current Store Info
        List<Versioned<byte[]>> storesInfo = metadataStore.get(ByteUtils.getBytes(storeKey, "UTF-8"));
        if(storesInfo.size() > 1) {
            throw new UnableUpdateMetadataException("Inconistent Stores Metdata found on Server:"
                                                    + metadata.getIdentityNode().getId());
        }

        // update version
        VectorClock updatedVersion = ((VectorClock) storesInfo.get(0).getVersion());
        updatedVersion.incrementVersion(metadata.getIdentityNode().getId(),
                                        System.currentTimeMillis());

        try {
            String storesString = inputStream.readUTF();

            List<StoreDefinition> storeDefs = new StoreDefinitionsMapper().readStoreList(new StringReader(storesString));

            // update cluster details in metaDataStore
            metadataStore.put(new ByteArray(ByteUtils.getBytes(MetadataStore.STORES_KEY, "UTF-8")),
                              new Versioned<byte[]>(ByteUtils.getBytes(new StoreDefinitionsMapper().writeStoreList(storeDefs),
                                                                       "UTF-8"),
                                                    updatedVersion));
            metadata.setStoreDefs(storeDefs);
            // if successfull update state in Voldemort Metadata
            metadata.setStoreDefMap(storeDefs);
            metadata.reinitRoutingStrategies();
            outputStream.writeShort(0);
        } catch(VoldemortException e) {
            e.printStackTrace();
            writeException(outputStream, e);
            return;
        }
    }
=======
private void handleUpdateStoresMetadataRequest(String storeKey,
                                                   DataInputStream inputStream,
                                                   DataOutputStream outputStream)
            throws IOException {
        // get current Store Info
        List<Versioned<byte[]>> storesInfo = metadataStore.get(ByteUtils.getBytes(storeKey, "UTF-8"));
        if(storesInfo.size() > 1) {
            throw new UnableUpdateMetadataException("Inconistent Stores Metdata found on Server:"
                                                    + metadata.getIdentityNode().getId());
        }

        // update version
        VectorClock updatedVersion = ((VectorClock) storesInfo.get(0).getVersion());
        updatedVersion.incrementVersion(metadata.getIdentityNode().getId(),
                                        System.currentTimeMillis());

        try {
            String storesString = inputStream.readUTF();

            List<StoreDefinition> storeDefs = new StoreDefinitionsMapper().readStoreList(new StringReader(storesString));

            // update cluster details in metaDataStore
            metadataStore.put(new ByteArray(ByteUtils.getBytes(MetadataStore.STORES_KEY, "UTF-8")),
                              new Versioned<byte[]>(ByteUtils.getBytes(new StoreDefinitionsMapper().writeStoreList(storeDefs),
                                                                       "UTF-8"),
                                                    updatedVersion));
            metadata.setStoreDefs(storeDefs);
            // if successfull update state in Voldemort Metadata
            metadata.setStoreDefMap(storeDefs);
            metadata.reinitRoutingStrategies();
            outputStream.writeShort(0);
            outputStream.flush();
        } catch(VoldemortException e) {
            e.printStackTrace();
            writeException(outputStream, e);
            return;
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503713972/fstmerge_var2_1337733561765191759

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bb606_adeef/rev_bb606-adeef/src/java/voldemort/server/socket/AdminServiceRequestHandler.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503713977/fstmerge_var1_6792811386296064965
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503713977/fstmerge_base_2481356763473064906
private void handleServerStateChangeRequest(DataInputStream inputStream,
                                                DataOutputStream outputStream) throws IOException {
        try {
            VoldemortMetadata.ServerState newState = VoldemortMetadata.ServerState.valueOf(inputStream.readUTF());
            metadata.setServerState(newState);

            outputStream.writeShort(0);
        } catch(VoldemortException e) {
            e.printStackTrace();
            writeException(outputStream, e);
            return;
        }

    }
=======
private void handleServerStateChangeRequest(DataInputStream inputStream,
                                                DataOutputStream outputStream) throws IOException {
        try {
            VoldemortMetadata.ServerState newState = VoldemortMetadata.ServerState.valueOf(inputStream.readUTF());
            metadata.setServerState(newState);

            outputStream.writeShort(0);
            outputStream.flush();
        } catch(VoldemortException e) {
            e.printStackTrace();
            writeException(outputStream, e);
            return;
        }

    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503713977/fstmerge_var2_1574915035084792190

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bb606_adeef/rev_bb606-adeef/src/java/voldemort/server/socket/AdminServiceRequestHandler.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503713981/fstmerge_var1_8838338473394551447
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503713981/fstmerge_base_338582904762373515
private void handleRedirectGetRequest(StorageEngine<ByteArray, byte[]> engine,
                                          byte[] key,
                                          DataOutputStream outputStream) throws IOException {
        List<Versioned<byte[]>> results = null;
        try {
            results = engine.get(new ByteArray(key));
            outputStream.writeShort(0);
        } catch(VoldemortException e) {
            e.printStackTrace();
            writeException(outputStream, e);
            return;
        }
        outputStream.writeInt(results.size());
        for(Versioned<byte[]> v: results) {
            byte[] clock = ((VectorClock) v.getVersion()).toBytes();
            byte[] value = v.getValue();
            outputStream.writeInt(clock.length + value.length);
            outputStream.write(clock);
            outputStream.write(value);
        }
    }
=======
private void handleRedirectGetRequest(StorageEngine<ByteArray, byte[]> engine,
                                          byte[] key,
                                          DataOutputStream outputStream) throws IOException {
        List<Versioned<byte[]>> results = null;
        try {
            results = engine.get(new ByteArray(key));
            outputStream.writeShort(0);
        } catch(VoldemortException e) {
            e.printStackTrace();
            writeException(outputStream, e);
            return;
        }
        outputStream.writeInt(results.size());
        for(Versioned<byte[]> v: results) {
            byte[] clock = ((VectorClock) v.getVersion()).toBytes();
            byte[] value = v.getValue();
            outputStream.writeInt(clock.length + value.length);
            outputStream.write(clock);
            outputStream.write(value);
        }
        outputStream.flush();
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503713981/fstmerge_var2_4925584725332557490

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bb606_adeef/rev_bb606-adeef/src/java/voldemort/server/socket/AdminServiceRequestHandler.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503713986/fstmerge_var1_6609381582314362453
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503713986/fstmerge_base_3336298275487559444
private void writeException(DataOutputStream stream, VoldemortException e) throws IOException {
        short code = errorMapper.getCode(e);
        stream.writeShort(code);
        stream.writeUTF(e.getMessage());
    }
=======
private void writeException(DataOutputStream stream, VoldemortException e) throws IOException {
        short code = errorMapper.getCode(e);
        stream.writeShort(code);
        stream.writeUTF(e.getMessage());
        stream.flush();
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415503713986/fstmerge_var2_8889623974354580670

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bb606_adeef/rev_bb606-adeef/src/java/voldemort/server/socket/AdminServiceRequestHandler.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_414bb_81260/rev_414bb-81260.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f318a_efcdd/rev_f318a-efcdd.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_79f45_1fc80/rev_79f45-1fc80.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_79f45_1fc80/rev_79f45-1fc80.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bfd86_58df0/rev_bfd86-58df0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_48f27_35f75/rev_48f27-35f75.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public VoldemortConfig(Props props) {
        try {
            this.nodeId = props.getInt("node.id");
        } catch(UndefinedPropertyException e) {
            this.nodeId = getIntEnvVariable(VOLDEMORT_NODE_ID_VAR_NAME);
        }
        this.voldemortHome = props.getString("voldemort.home");
        this.dataDirectory = props.getString("data.directory", this.voldemortHome + File.separator
                                                               + "data");
        this.metadataDirectory = props.getString("metadata.directory", voldemortHome
                                                                       + File.separator + "config");

        this.bdbCacheSize = props.getBytes("bdb.cache.size", 200 * 1024 * 1024);
        this.bdbWriteTransactions = props.getBoolean("bdb.write.transactions", false);
        this.bdbFlushTransactions = props.getBoolean("bdb.flush.transactions", false);
        this.bdbDataDirectory = props.getString("bdb.data.directory", this.dataDirectory
                                                                      + File.separator + "bdb");
        this.bdbMaxLogFileSize = props.getBytes("bdb.max.logfile.size", 1024 * 1024 * 1024);
        this.bdbBtreeFanout = props.getInt("bdb.btree.fanout", 512);
        this.bdbCheckpointBytes = props.getLong("bdb.checkpoint.interval.bytes", 20 * 1024 * 1024);
        this.bdbCheckpointMs = props.getLong("bdb.checkpoint.interval.ms", 30 * Time.MS_PER_SECOND);
        this.bdbSortedDuplicates = props.getBoolean("bdb.enable.sorted.duplicates", true);
        this.bdbOneEnvPerStore = props.getBoolean("bdb.one.env.per.store", false);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504210430/fstmerge_var1_8321777984909973589
        setBdbCleanerMinFileUtilization(props.getInt("bdb.cleaner.minFileUtilization", 5));
        setBdbCleanerMinUtilization(props.getInt("bdb.cleaner.minUtilization", 50));
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504210430/fstmerge_base_5414258242975941440
=======
        this.bdbCleanerMinFileUtilization = props.getInt("bdb.cleaner.min.file.utilization", 5);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504210430/fstmerge_var2_6320563659782527495

        this.readOnlyFileWaitTimeoutMs = props.getLong("readonly.file.wait.timeout.ms", 4000L);
        this.readOnlyBackups = props.getInt("readonly.backups", 1);
        this.readOnlyFileHandles = props.getInt("readonly.file.handles", 5);
        this.readOnlyStorageDir = props.getString("readonly.data.directory", this.dataDirectory
                                                                             + File.separator
                                                                             + "read-only");

        this.slopStoreType = props.getString("slop.store.engine", BdbStorageConfiguration.TYPE_NAME);

        this.mysqlUsername = props.getString("mysql.user", "root");
        this.mysqlPassword = props.getString("mysql.password", "");
        this.mysqlHost = props.getString("mysql.host", "localhost");
        this.mysqlPort = props.getInt("mysql.port", 3306);
        this.mysqlDatabaseName = props.getString("mysql.database", "voldemort");

        this.maxThreads = props.getInt("max.threads", 100);
        this.coreThreads = props.getInt("core.threads", Math.max(1, maxThreads / 2));

        this.adminMaxThreads = props.getInt("admin.max.threads", 10);
        this.adminCoreThreads = props.getInt("admin.core.threads", Math.max(1, adminMaxThreads / 2));
        this.adminStreamBufferSize = (int) props.getBytes("admin.streams.buffer.size",
                                                          10 * 1000 * 1000);

        this.streamMaxReadBytesPerSec = props.getInt("stream.read.byte.per.sec", 1 * 1000 * 1000);
        this.streamMaxWriteBytesPerSec = props.getInt("stream.write.byte.per.sec", 1 * 1000 * 1000);

        this.socketTimeoutMs = props.getInt("socket.timeout.ms", 4000);
        this.socketBufferSize = (int) props.getBytes("socket.buffer.size", 32 * 1024);

        this.useNioConnector = props.getBoolean("enable.nio.connector", false);
        this.nioConnectorSelectors = props.getInt("nio.connector.selectors",
                                                  Runtime.getRuntime().availableProcessors());

        this.clientMaxConnectionsPerNode = props.getInt("client.max.connections.per.node", 5);
        this.clientConnectionTimeoutMs = props.getInt("client.connection.timeout.ms", 400);
        this.clientRoutingTimeoutMs = props.getInt("client.routing.timeout.ms", 5000);
        this.clientNodeBannageMs = props.getInt("client.node.bannage.ms", 10000);
        this.clientMaxThreads = props.getInt("client.max.threads", 100);
        this.clientThreadIdleMs = props.getInt("client.thread.idle.ms", 5000);
        this.clientMaxQueuedRequests = props.getInt("client.max.queued.requests", 1000);

        this.enableHttpServer = props.getBoolean("http.enable", true);
        this.enableSocketServer = props.getBoolean("socket.enable", true);
        this.enableAdminServer = props.getBoolean("admin.enable", true);
        this.enableJmx = props.getBoolean("jmx.enable", true);
        this.enableSlop = props.getBoolean("slop.enable", true);
        this.enableVerboseLogging = props.getBoolean("enable.verbose.logging", true);
        this.enableStatTracking = props.getBoolean("enable.stat.tracking", true);
        this.enableServerRouting = props.getBoolean("enable.server.routing", true);
        this.enableMetadataChecking = props.getBoolean("enable.metadata.checking", true);
        this.enableRedirectRouting = props.getBoolean("enable.redirect.routing", true);

        this.pusherPollMs = props.getInt("pusher.poll.ms", 2 * 60 * 1000);

        this.schedulerThreads = props.getInt("scheduler.threads", 3);

        this.numCleanupPermits = props.getInt("num.cleanup.permits", 1);

        this.storageConfigurations = props.getList("storage.configs",
                                                   ImmutableList.of(BdbStorageConfiguration.class.getName(),
                                                                    MysqlStorageConfiguration.class.getName(),
                                                                    InMemoryStorageConfiguration.class.getName(),
                                                                    CacheStorageConfiguration.class.getName(),
                                                                    ReadOnlyStorageConfiguration.class.getName()));

        // save props for access from plugins
        this.allProps = props;

        String requestFormatName = props.getString("request.format",
                                                   RequestFormatType.VOLDEMORT_V1.getCode());
        this.requestFormatType = RequestFormatType.fromCode(requestFormatName);

        validateParams();
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_48f27_35f75/rev_48f27-35f75/src/java/voldemort/server/VoldemortConfig.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e09f9_79f45/rev_e09f9-79f45.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b20e9_943cf/rev_b20e9-943cf.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public GetResult call() throws Exception {
            List<Versioned<byte[]>> fetched = Collections.emptyList();
            List<NodeValue<ByteArray, byte[]>> nodeValues = Lists.newArrayList();
            Throwable exception = null;
            try {
                if(logger.isTraceEnabled())
                    logger.trace("Attempting get operation on node " + node.getId() + " for key '"
                                 + ByteUtils.toHexString(key.get()) + "'.");
                fetched = innerStores.get(node.getId()).get(key);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504458755/fstmerge_var1_7078076455874537334
                fillRepairReadsValues(nodeValues, key, node, fetched);
                node.getStatus().setAvailable();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504458755/fstmerge_base_8340591890434178086
                if(repairReads) {
                    for(Versioned<byte[]> f: fetched)
                        nodeValues.add(new NodeValue<ByteArray, byte[]>(node.getId(), key, f));
                }
                node.getStatus().setAvailable();
=======
                if(repairReads) {
                    for(Versioned<byte[]> f: fetched)
                        nodeValues.add(new NodeValue<ByteArray, byte[]>(node.getId(), key, f));
                }
                failureDetector.recordSuccess(node);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504458755/fstmerge_var2_6747260632179096384
            } catch(UnreachableStoreException e) {
                exception = e;
                failureDetector.recordException(node, e);
            } catch(Throwable e) {
                if(e instanceof Error)
                    throw (Error) e;
                logger.warn("Error in GET on node " + node.getId() + "(" + node.getHost() + ")", e);
                exception = e;
            }
            return new GetResult(fetched, nodeValues, exception);
        }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b20e9_943cf/rev_b20e9-943cf/src/java/voldemort/store/routed/RoutedStore.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_cbe82_29cae/rev_cbe82-29cae.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504567109/fstmerge_var1_7211148821296145470
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504567109/fstmerge_base_8740129303956976309
@Override
    public void doUpdateRemoteMetadata(int remoteNodeId, ByteArray key, Versioned<byte[]> value) {
        Node node = this.getMetadata().getCluster().getNodeById(remoteNodeId);
        SocketDestination destination = new SocketDestination(node.getHost(),
                node.getSocketPort(),
                RequestFormatType.ADMIN_PROTOCOL_BUFFERS);
        SocketAndStreams sands = pool.checkout(destination);
        try {
            StoreUtils.assertValidKey(key);
            DataOutputStream outputStream = sands.getOutputStream();
            DataInputStream inputStream = sands.getInputStream();
            ProtoUtils.writeMessage(outputStream,
                    VAdminProto.VoldemortAdminRequest.newBuilder()
                    .setType(VAdminProto.AdminRequestType.UPDATE_METADATA)
                    .setUpdateMetadata(VAdminProto.UpdateMetadataRequest.newBuilder()
                            .setKey(ByteString.copyFrom(key.get()))
                            .setVersioned(ProtoUtils.encodeVersioned(value)))
                    .build());
            outputStream.flush();
            VAdminProto.UpdateMetadataResponse.Builder response = ProtoUtils.readToBuilder(
                    inputStream, VAdminProto.UpdateMetadataResponse.newBuilder());
            if (response.hasError())
                throwException(response.getError());
        } catch (IOException e) {
            close(sands.getSocket());
            throw new VoldemortException(e);
        } finally {
            pool.checkin(destination, sands);
        }
    }
=======
@Override
    public void doUpdateRemoteMetadata(int remoteNodeId, ByteArray key, Versioned<byte[]> value) {
        Node node = this.getMetadata().getCluster().getNodeById(remoteNodeId);
        SocketDestination destination = new SocketDestination(node.getHost(),
                                                              node.getAdminPort(),
                                                              RequestFormatType.ADMIN_PROTOCOL_BUFFERS);
        SocketAndStreams sands = pool.checkout(destination);
        try {
            StoreUtils.assertValidKey(key);
            DataOutputStream outputStream = sands.getOutputStream();
            DataInputStream inputStream = sands.getInputStream();
            ProtoUtils.writeMessage(outputStream,
                                    VAdminProto.VoldemortAdminRequest.newBuilder()
                                                                     .setType(VAdminProto.AdminRequestType.UPDATE_METADATA)
                                                                     .setUpdateMetadata(VAdminProto.UpdateMetadataRequest.newBuilder()
                                                                                                                         .setKey(ByteString.copyFrom(key.get()))
                                                                                                                         .setVersioned(ProtoUtils.encodeVersioned(value)))
                                                                     .build());
            outputStream.flush();
            VAdminProto.UpdateMetadataResponse.Builder response = ProtoUtils.readToBuilder(inputStream,
                                                                                           VAdminProto.UpdateMetadataResponse.newBuilder());
            if(response.hasError())
                throwException(response.getError());
        } catch(IOException e) {
            close(sands.getSocket());
            throw new VoldemortException(e);
        } finally {
            pool.checkin(destination, sands);
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504567109/fstmerge_var2_4721168652579730024

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_cbe82_29cae/rev_cbe82-29cae/src/java/voldemort/client/protocol/pb/ProtoBuffAdminClientRequestFormat.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504567114/fstmerge_var1_2020424420912783089
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504567114/fstmerge_base_661190361875106301
@Override
    public Versioned<byte[]> doGetRemoteMetadata(int remoteNodeId, ByteArray key) {
        Node node = this.getMetadata().getCluster().getNodeById(remoteNodeId);

        SocketDestination destination = new SocketDestination(node.getHost(),
                node.getSocketPort(),
                RequestFormatType.ADMIN_PROTOCOL_BUFFERS);
        SocketAndStreams sands = pool.checkout(destination);
        try {
            DataOutputStream outputStream = sands.getOutputStream();
            DataInputStream inputStream = sands.getInputStream();
            ProtoUtils.writeMessage(outputStream,
                    VAdminProto.VoldemortAdminRequest.newBuilder()
                    .setType(VAdminProto.AdminRequestType.GET_METADATA)
                    .setGetMetadata(VAdminProto.GetMetadataRequest.newBuilder()
                            .setKey(ByteString.copyFrom(key.get())))
                    .build());
            outputStream.flush();
            VAdminProto.GetMetadataResponse.Builder response = ProtoUtils.readToBuilder(
                    inputStream, VAdminProto.GetMetadataResponse.newBuilder());
            if (response.hasError())
                throwException(response.getError());
            return ProtoUtils.decodeVersioned(response.getVersion());
        } catch (IOException e) {
            close(sands.getSocket());
            throw new VoldemortException(e);
        } finally {
            pool.checkin(destination, sands);
        }
    }
=======
@Override
    public Versioned<byte[]> doGetRemoteMetadata(int remoteNodeId, ByteArray key) {
        Node node = this.getMetadata().getCluster().getNodeById(remoteNodeId);

        SocketDestination destination = new SocketDestination(node.getHost(),
                                                              node.getAdminPort(),
                                                              RequestFormatType.ADMIN_PROTOCOL_BUFFERS);
        SocketAndStreams sands = pool.checkout(destination);
        try {
            DataOutputStream outputStream = sands.getOutputStream();
            DataInputStream inputStream = sands.getInputStream();
            ProtoUtils.writeMessage(outputStream,
                                    VAdminProto.VoldemortAdminRequest.newBuilder()
                                                                     .setType(VAdminProto.AdminRequestType.GET_METADATA)
                                                                     .setGetMetadata(VAdminProto.GetMetadataRequest.newBuilder()
                                                                                                                   .setKey(ByteString.copyFrom(key.get())))
                                                                     .build());
            outputStream.flush();
            VAdminProto.GetMetadataResponse.Builder response = ProtoUtils.readToBuilder(inputStream,
                                                                                        VAdminProto.GetMetadataResponse.newBuilder());
            if(response.hasError())
                throwException(response.getError());
            return ProtoUtils.decodeVersioned(response.getVersion());
        } catch(IOException e) {
            close(sands.getSocket());
            throw new VoldemortException(e);
        } finally {
            pool.checkin(destination, sands);
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504567114/fstmerge_var2_7959044319426260950

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_cbe82_29cae/rev_cbe82-29cae/src/java/voldemort/client/protocol/pb/ProtoBuffAdminClientRequestFormat.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504567120/fstmerge_var1_3592724413424068855
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504567120/fstmerge_base_5042985818134950246
@Override
    public List<Versioned<byte[]>> doRedirectGet(int proxyDestNodeId, String storeName, ByteArray key) {
        Node proxyDestNode = this.getMetadata().getCluster().getNodeById(proxyDestNodeId);
        SocketDestination destination = new SocketDestination(proxyDestNode.getHost(),
                proxyDestNode.getSocketPort(),
                RequestFormatType.ADMIN_PROTOCOL_BUFFERS
                );
        SocketAndStreams sands = pool.checkout(destination);
        try {
            DataOutputStream outputStream = sands.getOutputStream();
            DataInputStream inputStream = sands.getInputStream();
            VAdminProto.VoldemortAdminRequest request =
                    VAdminProto.VoldemortAdminRequest.newBuilder()
                            .setType(VAdminProto.AdminRequestType.REDIRECT_GET)
                            .setRedirectGet(VAdminProto.RedirectGetRequest.newBuilder()
                                    .setKey(ProtoUtils.encodeBytes(key))
                                    .setStoreName(storeName)).build();
            ProtoUtils.writeMessage(outputStream, request);
            outputStream.flush();
            VAdminProto.RedirectGetResponse.Builder response =
                    ProtoUtils.readToBuilder(inputStream, VAdminProto.RedirectGetResponse.newBuilder());
            if (response.hasError())
                throwException(response.getError());
            return ProtoUtils.decodeVersions(response.getVersionedList());
        } catch (IOException e) {
            close(sands.getSocket());
            throw new VoldemortException(e);
        } finally {
            pool.checkin(destination, sands);
        }

    }
=======
@Override
    public List<Versioned<byte[]>> doRedirectGet(int proxyDestNodeId,
                                                 String storeName,
                                                 ByteArray key) {
        Node proxyDestNode = this.getMetadata().getCluster().getNodeById(proxyDestNodeId);
        SocketDestination destination = new SocketDestination(proxyDestNode.getHost(),
                                                              proxyDestNode.getAdminPort(),
                                                              RequestFormatType.ADMIN_PROTOCOL_BUFFERS);
        SocketAndStreams sands = pool.checkout(destination);
        try {
            DataOutputStream outputStream = sands.getOutputStream();
            DataInputStream inputStream = sands.getInputStream();
            VAdminProto.VoldemortAdminRequest request = VAdminProto.VoldemortAdminRequest.newBuilder()
                                                                                         .setType(VAdminProto.AdminRequestType.REDIRECT_GET)
                                                                                         .setRedirectGet(VAdminProto.RedirectGetRequest.newBuilder()
                                                                                                                                       .setKey(ProtoUtils.encodeBytes(key))
                                                                                                                                       .setStoreName(storeName))
                                                                                         .build();
            ProtoUtils.writeMessage(outputStream, request);
            outputStream.flush();
            VAdminProto.RedirectGetResponse.Builder response = ProtoUtils.readToBuilder(inputStream,
                                                                                        VAdminProto.RedirectGetResponse.newBuilder());
            if(response.hasError())
                throwException(response.getError());
            return ProtoUtils.decodeVersions(response.getVersionedList());
        } catch(IOException e) {
            close(sands.getSocket());
            throw new VoldemortException(e);
        } finally {
            pool.checkin(destination, sands);
        }

    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504567120/fstmerge_var2_4680249439065723827

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_cbe82_29cae/rev_cbe82-29cae/src/java/voldemort/client/protocol/pb/ProtoBuffAdminClientRequestFormat.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504567124/fstmerge_var1_6179390685717488558
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504567124/fstmerge_base_1497126585775963038
@Override
    public void doUpdatePartitionEntries(int nodeId, String storeName, Iterator<Pair<ByteArray, Versioned<byte[]>>> entryIterator, VoldemortFilter filter) {
        Node node = this.getMetadata().getCluster().getNodeById(nodeId);
        SocketDestination destination = new SocketDestination(node.getHost(),
                node.getSocketPort(),
                RequestFormatType.ADMIN_PROTOCOL_BUFFERS);
        SocketAndStreams sands = pool.checkout(destination);
        DataOutputStream outputStream = sands.getOutputStream();
        DataInputStream inputStream = sands.getInputStream();
        boolean firstMessage=true;
        try {
            while (entryIterator.hasNext()) {
                Pair<ByteArray, Versioned<byte[]>> entry = entryIterator.next();
                VAdminProto.PartitionEntry partitionEntry =
                        VAdminProto.PartitionEntry.newBuilder()
                        .setKey(ProtoUtils.encodeBytes(entry.getFirst()))
                        .setVersioned(ProtoUtils.encodeVersioned(entry.getSecond()))
                        .build();
                VAdminProto.UpdatePartitionEntriesRequest updateRequest =
                        VAdminProto.UpdatePartitionEntriesRequest.newBuilder()
                        .setStore(storeName)
                        .setPartitionEntry(partitionEntry)
                        .build();
                if (firstMessage) {
                    ProtoUtils.writeMessage(outputStream,
                            VAdminProto.VoldemortAdminRequest.newBuilder()
                            .setType(VAdminProto.AdminRequestType.UPDATE_PARTITION_ENTRIES)
                            .setUpdatePartitionEntries(updateRequest).build());
                    outputStream.flush();
                    firstMessage = false;
                } else {
                    ProtoUtils.writeMessage(outputStream, updateRequest);
                }
            }
            outputStream.writeInt(-1);
            outputStream.flush();
            VAdminProto.UpdatePartitionEntriesResponse.Builder updateResponse =
                    ProtoUtils.readToBuilder(inputStream,
                            VAdminProto.UpdatePartitionEntriesResponse.newBuilder());
            if (updateResponse.hasError()) {
                throwException(updateResponse.getError());
            }
        } catch (IOException e) {
            close(sands.getSocket());
            throw new VoldemortException(e);
        }  finally {
            pool.checkin(destination, sands);
        }
    }
=======
@Override
    public void doUpdatePartitionEntries(int nodeId,
                                         String storeName,
                                         Iterator<Pair<ByteArray, Versioned<byte[]>>> entryIterator,
                                         VoldemortFilter filter) {
        Node node = this.getMetadata().getCluster().getNodeById(nodeId);
        SocketDestination destination = new SocketDestination(node.getHost(),
                                                              node.getAdminPort(),
                                                              RequestFormatType.ADMIN_PROTOCOL_BUFFERS);
        SocketAndStreams sands = pool.checkout(destination);
        DataOutputStream outputStream = sands.getOutputStream();
        DataInputStream inputStream = sands.getInputStream();
        boolean firstMessage = true;
        try {
            while(entryIterator.hasNext()) {
                Pair<ByteArray, Versioned<byte[]>> entry = entryIterator.next();
                VAdminProto.PartitionEntry partitionEntry = VAdminProto.PartitionEntry.newBuilder()
                                                                                      .setKey(ProtoUtils.encodeBytes(entry.getFirst()))
                                                                                      .setVersioned(ProtoUtils.encodeVersioned(entry.getSecond()))
                                                                                      .build();
                VAdminProto.UpdatePartitionEntriesRequest updateRequest = VAdminProto.UpdatePartitionEntriesRequest.newBuilder()
                                                                                                                   .setStore(storeName)
                                                                                                                   .setPartitionEntry(partitionEntry)
                                                                                                                   .build();
                if(firstMessage) {
                    ProtoUtils.writeMessage(outputStream,
                                            VAdminProto.VoldemortAdminRequest.newBuilder()
                                                                             .setType(VAdminProto.AdminRequestType.UPDATE_PARTITION_ENTRIES)
                                                                             .setUpdatePartitionEntries(updateRequest)
                                                                             .build());
                    outputStream.flush();
                    firstMessage = false;
                } else {
                    ProtoUtils.writeMessage(outputStream, updateRequest);
                }
            }
            outputStream.writeInt(-1);
            outputStream.flush();
            VAdminProto.UpdatePartitionEntriesResponse.Builder updateResponse = ProtoUtils.readToBuilder(inputStream,
                                                                                                         VAdminProto.UpdatePartitionEntriesResponse.newBuilder());
            if(updateResponse.hasError()) {
                throwException(updateResponse.getError());
            }
        } catch(IOException e) {
            close(sands.getSocket());
            throw new VoldemortException(e);
        } finally {
            pool.checkin(destination, sands);
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504567124/fstmerge_var2_2044245075797784408

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_cbe82_29cae/rev_cbe82-29cae/src/java/voldemort/client/protocol/pb/ProtoBuffAdminClientRequestFormat.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504567129/fstmerge_var1_6908369663464047157
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504567129/fstmerge_base_4060923757405934264
@Override
    public Iterator<Pair<ByteArray, Versioned<byte[]>>>
    doFetchPartitionEntries(int nodeId, String storeName, List<Integer> partitionList, VoldemortFilter filter) {
        Node node = this.getMetadata().getCluster().getNodeById(nodeId);
        final SocketDestination destination = new SocketDestination(node.getHost(),
                node.getSocketPort(),
                RequestFormatType.ADMIN_PROTOCOL_BUFFERS);
        final SocketAndStreams sands = pool.checkout(destination);
        DataOutputStream outputStream = sands.getOutputStream();
        final DataInputStream inputStream = sands.getInputStream();
        try {
            VAdminProto.FetchPartitionEntriesRequest.Builder fetchRequest =
                    VAdminProto.FetchPartitionEntriesRequest.newBuilder()
                    .addAllPartitions(partitionList)
                    .setStore(storeName);
            if (filter != null) {
                Class cl = filter.getClass();
                byte[] classBytes = networkClassLoader.dumpClass(cl);
                VAdminProto.VoldemortFilter encodedFilter = VAdminProto.VoldemortFilter.newBuilder()
                        .setName(cl.getName())
                        .setData(ProtoUtils.encodeBytes(new ByteArray(classBytes)))
                        .build();
                fetchRequest.setFilter(encodedFilter);
            }
            VAdminProto.VoldemortAdminRequest request = VAdminProto.VoldemortAdminRequest.newBuilder()
                    .setType(VAdminProto.AdminRequestType.FETCH_PARTITION_ENTRIES)
                    .setFetchPartitionEntries(fetchRequest)
                    .build();
            ProtoUtils.writeMessage(outputStream, request);
            outputStream.flush();
        } catch (IOException e) {
            close (sands.getSocket());
            pool.checkin(destination, sands);
            throw new VoldemortException(e);
        }

        return new AbstractIterator<Pair<ByteArray, Versioned<byte[]>>>() {
            @Override
            public Pair<ByteArray, Versioned<byte[]>> computeNext() {
                try {
                    int size = inputStream.readInt();
                    if (size <= 0) {
                        pool.checkin(destination, sands);
                        return endOfData();
                    }

                    // There is a bug in CodedInputStream
                    // Work around suggested by ijuma
                    byte[] input = new byte[size];
                    ByteUtils.read(inputStream, input);
                    VAdminProto.FetchPartitionEntriesResponse.Builder response =
                            VAdminProto.FetchPartitionEntriesResponse.newBuilder();
                    response.mergeFrom(input);
                    if (response.hasError()) {
                        pool.checkin(destination, sands);
                        throwException(response.getError());
                    }
                    VAdminProto.PartitionEntry partitionEntry = response.getPartitionEntry();
                    return Pair.create(ProtoUtils.decodeBytes(partitionEntry.getKey()),
                            ProtoUtils.decodeVersioned(partitionEntry.getVersioned()));
                } catch (IOException e) {
                    close(sands.getSocket());
                    pool.checkin(destination, sands);
                    throw new VoldemortException(e);
                }
            }
        };



    }
=======
@Override
    public Iterator<Pair<ByteArray, Versioned<byte[]>>> doFetchPartitionEntries(int nodeId,
                                                                                String storeName,
                                                                                List<Integer> partitionList,
                                                                                VoldemortFilter filter) {
        Node node = this.getMetadata().getCluster().getNodeById(nodeId);
        final SocketDestination destination = new SocketDestination(node.getHost(),
                                                                    node.getAdminPort(),
                                                                    RequestFormatType.ADMIN_PROTOCOL_BUFFERS);
        final SocketAndStreams sands = pool.checkout(destination);
        DataOutputStream outputStream = sands.getOutputStream();
        final DataInputStream inputStream = sands.getInputStream();
        try {
            VAdminProto.FetchPartitionEntriesRequest.Builder fetchRequest = VAdminProto.FetchPartitionEntriesRequest.newBuilder()
                                                                                                                    .addAllPartitions(partitionList)
                                                                                                                    .setStore(storeName);
            if(filter != null) {
                Class cl = filter.getClass();
                byte[] classBytes = networkClassLoader.dumpClass(cl);
                VAdminProto.VoldemortFilter encodedFilter = VAdminProto.VoldemortFilter.newBuilder()
                                                                                       .setName(cl.getName())
                                                                                       .setData(ProtoUtils.encodeBytes(new ByteArray(classBytes)))
                                                                                       .build();
                fetchRequest.setFilter(encodedFilter);
            }
            VAdminProto.VoldemortAdminRequest request = VAdminProto.VoldemortAdminRequest.newBuilder()
                                                                                         .setType(VAdminProto.AdminRequestType.FETCH_PARTITION_ENTRIES)
                                                                                         .setFetchPartitionEntries(fetchRequest)
                                                                                         .build();
            ProtoUtils.writeMessage(outputStream, request);
            outputStream.flush();
        } catch(IOException e) {
            close(sands.getSocket());
            pool.checkin(destination, sands);
            throw new VoldemortException(e);
        }

        return new AbstractIterator<Pair<ByteArray, Versioned<byte[]>>>() {

            @Override
            public Pair<ByteArray, Versioned<byte[]>> computeNext() {
                try {
                    int size = inputStream.readInt();
                    if(size <= 0) {
                        pool.checkin(destination, sands);
                        return endOfData();
                    }

                    // There is a bug in CodedInputStream
                    // Work around suggested by ijuma
                    byte[] input = new byte[size];
                    ByteUtils.read(inputStream, input);
                    VAdminProto.FetchPartitionEntriesResponse.Builder response = VAdminProto.FetchPartitionEntriesResponse.newBuilder();
                    response.mergeFrom(input);
                    if(response.hasError()) {
                        pool.checkin(destination, sands);
                        throwException(response.getError());
                    }
                    VAdminProto.PartitionEntry partitionEntry = response.getPartitionEntry();
                    return Pair.create(ProtoUtils.decodeBytes(partitionEntry.getKey()),
                                       ProtoUtils.decodeVersioned(partitionEntry.getVersioned()));
                } catch(IOException e) {
                    close(sands.getSocket());
                    pool.checkin(destination, sands);
                    throw new VoldemortException(e);
                }
            }
        };

    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504567129/fstmerge_var2_6761353552160192659

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_cbe82_29cae/rev_cbe82-29cae/src/java/voldemort/client/protocol/pb/ProtoBuffAdminClientRequestFormat.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504567135/fstmerge_var1_8390592632735927176
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504567135/fstmerge_base_2778309532744181627
@Override
    public int doDeletePartitionEntries(int nodeId, String storeName, List<Integer> partitionList, VoldemortFilter filter) {
        Node node = this.getMetadata().getCluster().getNodeById(nodeId);

        SocketDestination destination = new SocketDestination(node.getHost(),
                node.getSocketPort(),
                RequestFormatType.ADMIN_PROTOCOL_BUFFERS);
        SocketAndStreams sands = pool.checkout(destination);

        try {
            Class cl = filter == null ? DefaultVoldemortFilter.class : filter.getClass();
            byte[] classBytes = networkClassLoader.dumpClass(cl);
            DataOutputStream outputStream = sands.getOutputStream();
            DataInputStream inputStream = sands.getInputStream();

            VAdminProto.VoldemortAdminRequest.Builder request = VAdminProto.VoldemortAdminRequest.newBuilder()
                    .setType(VAdminProto.AdminRequestType.DELETE_PARTITION_ENTRIES)
                    .setDeletePartitionEntries(VAdminProto.DeletePartitionEntriesRequest.newBuilder()
                            .addAllPartitions(partitionList)
                            .setFilter(VAdminProto.VoldemortFilter.newBuilder()
                                    .setName(cl.getName())
                                    .setData(ProtoUtils.encodeBytes(new ByteArray(classBytes))))
                            .setStore(storeName));
            ProtoUtils.writeMessage(outputStream, request.build());
            outputStream.flush();

            VAdminProto.DeletePartitionEntriesResponse.Builder response = ProtoUtils.readToBuilder(inputStream,
                    VAdminProto.DeletePartitionEntriesResponse.newBuilder());
            if (response.hasError())
                throwException(response.getError());

            return response.getCount();
        } catch (IOException e) {
            close(sands.getSocket());
            throw new VoldemortException(e);
        } finally {
            pool.checkin(destination, sands);
        }
    }
=======
@Override
    public int doDeletePartitionEntries(int nodeId,
                                        String storeName,
                                        List<Integer> partitionList,
                                        VoldemortFilter filter) {
        Node node = this.getMetadata().getCluster().getNodeById(nodeId);

        SocketDestination destination = new SocketDestination(node.getHost(),
                                                              node.getAdminPort(),
                                                              RequestFormatType.ADMIN_PROTOCOL_BUFFERS);
        SocketAndStreams sands = pool.checkout(destination);

        try {
            Class cl = filter == null ? DefaultVoldemortFilter.class : filter.getClass();
            byte[] classBytes = networkClassLoader.dumpClass(cl);
            DataOutputStream outputStream = sands.getOutputStream();
            DataInputStream inputStream = sands.getInputStream();

            VAdminProto.VoldemortAdminRequest.Builder request = VAdminProto.VoldemortAdminRequest.newBuilder()
                                                                                                 .setType(VAdminProto.AdminRequestType.DELETE_PARTITION_ENTRIES)
                                                                                                 .setDeletePartitionEntries(VAdminProto.DeletePartitionEntriesRequest.newBuilder()
                                                                                                                                                                     .addAllPartitions(partitionList)
                                                                                                                                                                     .setFilter(VAdminProto.VoldemortFilter.newBuilder()
                                                                                                                                                                                                           .setName(cl.getName())
                                                                                                                                                                                                           .setData(ProtoUtils.encodeBytes(new ByteArray(classBytes))))
                                                                                                                                                                     .setStore(storeName));
            ProtoUtils.writeMessage(outputStream, request.build());
            outputStream.flush();

            VAdminProto.DeletePartitionEntriesResponse.Builder response = ProtoUtils.readToBuilder(inputStream,
                                                                                                   VAdminProto.DeletePartitionEntriesResponse.newBuilder());
            if(response.hasError())
                throwException(response.getError());

            return response.getCount();
        } catch(IOException e) {
            close(sands.getSocket());
            throw new VoldemortException(e);
        } finally {
            pool.checkin(destination, sands);
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504567135/fstmerge_var2_7517185730816486836

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_cbe82_29cae/rev_cbe82-29cae/src/java/voldemort/client/protocol/pb/ProtoBuffAdminClientRequestFormat.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504567140/fstmerge_var1_227570735781286776
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504567140/fstmerge_base_7428341071035967166
public void throwException(VProto.Error error) {
            throw errorMapper.getError((short) error.getErrorCode(), error.getErrorMessage());
    }
=======
public void throwException(VProto.Error error) {
        throw errorMapper.getError((short) error.getErrorCode(), error.getErrorMessage());
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504567140/fstmerge_var2_8677863527929626851

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_cbe82_29cae/rev_cbe82-29cae/src/java/voldemort/client/protocol/pb/ProtoBuffAdminClientRequestFormat.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5e1e_0c0ad/rev_c5e1e-0c0ad.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_864d6_12716/rev_864d6-12716.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public List<Versioned<byte[]>> get(ByteArray key) {
        Function<List<GetResult<Versioned<byte[]>>>, Void> readRepairFunction = new Function<List<GetResult<Versioned<byte[]>>>, Void>() {

            public Void apply(List<GetResult<Versioned<byte[]>>> nodeResults) {
                List<NodeValue<ByteArray, byte[]>> nodeValues = Lists.newArrayListWithExpectedSize(nodeResults.size());
                for(GetResult<Versioned<byte[]>> getResult: nodeResults)
                    fillRepairReadsValues(nodeValues,
                                          getResult.key,
                                          getResult.node,
                                          getResult.retrieved);
                repairReads(nodeValues);
                return null;
            }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504876234/fstmerge_var1_5545854341397043238
        };
        return get(key, VERSIONED_OP, readRepairFunction);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504876234/fstmerge_base_3831976366632866786
        }

        // Now if we had any failures we will be short a few reads. Do serial
        // reads to make up for these.
        while(successes < this.storeDef.getPreferredReads() && nodeIndex < nodes.size()) {
            Node node = nodes.get(nodeIndex);
            try {
                List<Versioned<byte[]>> fetched = innerStores.get(node.getId()).get(key);
                retrieved.addAll(fetched);
                fillRepairReadsValues(nodeValues, key, node, fetched);
                ++successes;
                node.getStatus().setAvailable();
            } catch(UnreachableStoreException e) {
                failures.add(e);
                markUnavailable(node, e);
            } catch(Exception e) {
                logger.warn("Error in GET on node " + node.getId() + "(" + node.getHost() + ")", e);
                failures.add(e);
            }
            nodeIndex++;
        }

        if(logger.isTraceEnabled())
            logger.trace("GET retrieved the following node values: " + formatNodeValues(nodeValues));

        repairReads(nodeValues);

        if(successes >= this.storeDef.getRequiredReads())
            return retrieved;
        else
            throw new InsufficientOperationalNodesException(this.storeDef.getRequiredReads()
                                                            + " reads required, but " + successes
                                                            + " succeeded.", failures);
=======
        }

        // Now if we had any failures we will be short a few reads. Do serial
        // reads to make up for these.
        while(successes < this.storeDef.getPreferredReads() && nodeIndex < nodes.size()) {
            Node node = nodes.get(nodeIndex);
            try {
                List<Versioned<byte[]>> fetched = innerStores.get(node.getId()).get(key);
                retrieved.addAll(fetched);
                fillRepairReadsValues(nodeValues, key, node, fetched);
                ++successes;
                failureDetector.recordSuccess(node);
            } catch(UnreachableStoreException e) {
                failures.add(e);
                failureDetector.recordException(node, e);
            } catch(Exception e) {
                logger.warn("Error in GET on node " + node.getId() + "(" + node.getHost() + ")", e);
                failures.add(e);
            }
            nodeIndex++;
        }

        if(logger.isTraceEnabled())
            logger.trace("GET retrieved the following node values: " + formatNodeValues(nodeValues));

        repairReads(nodeValues);

        if(successes >= this.storeDef.getRequiredReads())
            return retrieved;
        else
            throw new InsufficientOperationalNodesException(this.storeDef.getRequiredReads()
                                                            + " reads required, but " + successes
                                                            + " succeeded.", failures);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504876234/fstmerge_var2_1767066966057812934
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_864d6_12716/rev_864d6-12716/src/java/voldemort/store/routed/RoutedStore.java
Conflict type: LineBasedMCFd
Conflict body: 
public GetResult<R> call() throws Exception {
            List<R> fetched = Collections.emptyList();
            Throwable exception = null;
            try {
                if(logger.isTraceEnabled())
                    logger.trace("Attempting get operation on node " + node.getId() + " for key '"
                                 + ByteUtils.toHexString(key.get()) + "'.");
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504876307/fstmerge_var1_8025432622953000028
                fetched = fetcher.execute(innerStores.get(node.getId()), key);
                node.getStatus().setAvailable();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504876307/fstmerge_base_2555262912624995063
                fetched = innerStores.get(node.getId()).get(key);
                fillRepairReadsValues(nodeValues, key, node, fetched);
                node.getStatus().setAvailable();
=======
                fetched = innerStores.get(node.getId()).get(key);
                fillRepairReadsValues(nodeValues, key, node, fetched);
                failureDetector.recordSuccess(node);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415504876307/fstmerge_var2_310969520831584821
            } catch(UnreachableStoreException e) {
                exception = e;
                failureDetector.recordException(node, e);
            } catch(Throwable e) {
                if(e instanceof Error)
                    throw (Error) e;
                logger.warn("Error in GET on node " + node.getId() + "(" + node.getHost() + ")", e);
                exception = e;
            }
            return new GetResult<R>(node, key, fetched, exception);
        }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_864d6_12716/rev_864d6-12716/src/java/voldemort/store/routed/RoutedStore.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_95b86_c6508/rev_95b86-c6508.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d6a50_15b5c/rev_d6a50-15b5c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bf682_5e36e/rev_bf682-5e36e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_adc97_0e8dc/rev_adc97-0e8dc.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_1c83b_64694/rev_1c83b-64694.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_ebfba_47ff4/rev_ebfba-47ff4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b2daa_5f315/rev_b2daa-5f315.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd3_ea4b3/rev_6efd3-ea4b3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b2daa_4aab0/rev_b2daa-4aab0.revisions
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415505970988/fstmerge_var1_4751457087250982186
public void testSocketPoolLimitSomeTimeout() throws Exception {
        // start a dummy server
        SocketServer server = new SocketServer(7666, 50, 50, 1000, new RequestHandlerFactory(null,
                                                                                             null,
                                                                                             null));
        server.start();

        final ResourcePoolConfig config = new ResourcePoolConfig().setTimeout(50,
                                                                              TimeUnit.MILLISECONDS)
                                                                  .setMaxPoolSize(20);

        ResourceFactory<SocketDestination, SocketAndStreams> factory = ResourcePoolTestUtils.getSocketPoolFactory();
        final AbstractSocketPoolTest<SocketDestination, SocketAndStreams> test = new AbstractSocketPoolTest<SocketDestination, SocketAndStreams>() {

            @Override
            protected void doSomethingWithResource(SocketDestination key, SocketAndStreams resource)
                    throws Exception {
                Thread.sleep(100);
                int random = (int) (Math.random() * 10);
                if(random >= 5)
                    resource.getSocket().close();
            }

            @Override
            protected SocketDestination getRequestKey() throws Exception {
                return new SocketDestination("localhost", 7666, RequestFormatType.VOLDEMORT_V1);
            }

        };

        // borrow timeout >> doSomething() no timeout expected
        TestStats testStats = test.startTest(factory, config, 50, 200);
        assertEquals("We should see some timeoutRequests", true, testStats.timeoutRequests > 0);
        server.shutdown();
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415505970988/fstmerge_base_7657509507858783223
=======
public void testSocketPoolLimitSomeTimeout() throws Exception {
        // start a dummy server
        SocketServer server = new SocketServer(7666, 50, 50, 1000, new SocketRequestHandlerFactory(null), "test");
        server.start();

        final ResourcePoolConfig config = new ResourcePoolConfig().setTimeout(50,
                                                                              TimeUnit.MILLISECONDS)
                                                                  .setMaxPoolSize(20);

        ResourceFactory<SocketDestination, SocketAndStreams> factory = ResourcePoolTestUtils.getSocketPoolFactory();
        final AbstractSocketPoolTest<SocketDestination, SocketAndStreams> test = new AbstractSocketPoolTest<SocketDestination, SocketAndStreams>() {

            @Override
            protected void doSomethingWithResource(SocketDestination key, SocketAndStreams resource)
                    throws Exception {
                Thread.sleep(100);
                int random = (int) (Math.random() * 10);
                if(random >= 5)
                    resource.getSocket().close();
            }

            @Override
            protected SocketDestination getRequestKey() throws Exception {
                return new SocketDestination("localhost", 7666, RequestFormatType.VOLDEMORT_V1);
            }

        };

        // borrow timeout >> doSomething() no timeout expected
        TestStats testStats = test.startTest(factory, config, 50, 200);
        assertEquals("We should see some timeoutRequests", true, testStats.timeoutRequests > 0);
        server.shutdown();
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415505970988/fstmerge_var2_5662504323617244392

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b2daa_4aab0/rev_b2daa-4aab0/test/integration/voldemort/socketpool/SimpleSocketPoolTest.java
Conflict type: SameIdFd
Conflict body: 
~~FSTMerge~~ private volatile int maxBootstrapRetries = 1; ##FSTMerge## ##FSTMerge## private volatile int maxBootstrapRetries = 3;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b2daa_4aab0/rev_b2daa-4aab0/src/java/voldemort/client/ClientConfig.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415505974041/fstmerge_var1_6360041670219546573
public void setMaxBootstrapRetries(int maxBootstrapRetries) {
        if(maxBootstrapRetries < 1)
            throw new IllegalArgumentException("maxBootstrapRetries should be >= 1");

        this.maxBootstrapRetries = maxBootstrapRetries;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415505974041/fstmerge_base_94389659952782716
=======
public void setMaxBootstrapRetries(int maxBootstrapRetries) {
        this.maxBootstrapRetries = maxBootstrapRetries;
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415505974041/fstmerge_var2_5164520799783176138

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b2daa_4aab0/rev_b2daa-4aab0/src/java/voldemort/client/ClientConfig.java
Conflict type: LineBasedMCFd
Conflict body: 
public static RequestType valueOf(int value) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415505974352/fstmerge_var1_4417038860177871344
            switch(value) {
                case 0:
                    return GET;
                case 1:
                    return GET_ALL;
                case 2:
                    return PUT;
                case 3:
                    return DELETE;
                case 4:
                    return GET_VERSION;
                default:
                    return null;
            }
        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415505974352/fstmerge_base_5375917052522547218
            switch(value) {
                case 0:
                    return GET;
                case 1:
                    return GET_ALL;
                case 2:
                    return PUT;
                case 3:
                    return DELETE;
                default:
                    return null;
            }
        }
=======
      switch (value) {
        case 0: return GET;
        case 1: return GET_ALL;
        case 2: return PUT;
        case 3: return DELETE;
        default: return null;
      }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415505974352/fstmerge_var2_7505318236444745427

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b2daa_4aab0/rev_b2daa-4aab0/src/java/voldemort/client/protocol/pb/VProto.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ private static final RequestType[] VALUES = { GET, GET_ALL, PUT, DELETE, GET_VERSION, }; ##FSTMerge## private static final RequestType[] VALUES = { GET, GET_ALL, PUT, DELETE, }; ##FSTMerge## private static final RequestType[] VALUES = {
      GET, GET_ALL, PUT, DELETE, 
    };
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b2daa_4aab0/rev_b2daa-4aab0/src/java/voldemort/client/protocol/pb/VProto.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415505979854/fstmerge_var1_8947046887371691765
private void handleGetPartitionsAsStream(StorageEngine<ByteArray, byte[]> engine,
                                             DataInputStream inputStream,
                                             DataOutputStream outputStream) throws IOException {
        // read partition List
        int partitionSize = inputStream.readInt();
        int[] partitionList = new int[partitionSize];
        for(int i = 0; i < partitionSize; i++) {
            partitionList[i] = inputStream.readInt();
        }

        RoutingStrategy routingStrategy = new RoutingStrategyFactory(metadata.getCurrentCluster()).getRoutingStrategy(metadata.getStoreDef(engine.getName()));
        EventThrottler throttler = new EventThrottler(streamMaxBytesReadPerSec);
        try {
            /**
             * TODO HIGH: This way to iterate over all keys is not optimal
             * stores should be made routing aware to fix this problem
             */
            ClosableIterator<Pair<ByteArray, Versioned<byte[]>>> iterator = engine.entries();

            while(iterator.hasNext()) {
                Pair<ByteArray, Versioned<byte[]>> entry = iterator.next();

                if(validPartition(entry.getFirst().get(), partitionList, routingStrategy)) {
                    outputStream.writeShort(0);

                    // write key
                    byte[] key = entry.getFirst().get();
                    outputStream.writeInt(key.length);
                    outputStream.write(key);

                    // write value
                    byte[] clock = ((VectorClock) entry.getSecond().getVersion()).toBytes();
                    byte[] value = entry.getSecond().getValue();
                    outputStream.writeInt(clock.length + value.length);
                    outputStream.write(clock);
                    outputStream.write(value);

                    if(throttler != null) {
                        throttler.maybeThrottle(key.length + clock.length + value.length);
                    }
                }
            }
            // close the iterator here
            iterator.close();
            // client reads exception before every key length
            outputStream.writeShort(0);
            // indicate that all keys are done
            outputStream.writeInt(-1);
            outputStream.flush();

        } catch(VoldemortException e) {
            writeException(outputStream, e);
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415505979854/fstmerge_base_5484409413675079124
private void handleGetPartitionsAsStream(StorageEngine<ByteArray, byte[]> engine,
                                             DataInputStream inputStream,
                                             DataOutputStream outputStream) throws IOException {
        // read partition List
        int partitionSize = inputStream.readInt();
        int[] partitionList = new int[partitionSize];
        for(int i = 0; i < partitionSize; i++) {
            partitionList[i] = inputStream.readInt();
        }

        RoutingStrategy routingStrategy = new RoutingStrategyFactory(metadata.getCurrentCluster()).getRoutingStrategy(metadata.getStoreDef(engine.getName()));
        IoThrottler throttler = new IoThrottler(streamMaxBytesReadPerSec);
        try {
            /**
             * TODO HIGH: This way to iterate over all keys is not optimal
             * stores should be made routing aware to fix this problem
             */
            ClosableIterator<Pair<ByteArray, Versioned<byte[]>>> iterator = engine.entries();

            while(iterator.hasNext()) {
                Pair<ByteArray, Versioned<byte[]>> entry = iterator.next();

                if(validPartition(entry.getFirst().get(), partitionList, routingStrategy)) {
                    outputStream.writeShort(0);

                    // write key
                    byte[] key = entry.getFirst().get();
                    outputStream.writeInt(key.length);
                    outputStream.write(key);

                    // write value
                    byte[] clock = ((VectorClock) entry.getSecond().getVersion()).toBytes();
                    byte[] value = entry.getSecond().getValue();
                    outputStream.writeInt(clock.length + value.length);
                    outputStream.write(clock);
                    outputStream.write(value);

                    if(throttler != null) {
                        throttler.maybeThrottle(key.length + clock.length + value.length);
                    }
                }
            }
            // close the iterator here
            iterator.close();
            // client reads exception before every key length
            outputStream.writeShort(0);
            // indicate that all keys are done
            outputStream.writeInt(-1);
            outputStream.flush();

        } catch(VoldemortException e) {
            writeException(outputStream, e);
        }
    }
=======
protected abstract void handleGetPartitionsAsStream(StorageEngine<ByteArray, byte[]> engine,
                                                        DataInputStream inputStream,
                                                        DataOutputStream outputStream)
            throws IOException;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415505979854/fstmerge_var2_3521848642019453201

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b2daa_4aab0/rev_b2daa-4aab0/src/java/voldemort/server/protocol/admin/AdminServiceRequestHandler.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415505979878/fstmerge_var1_8606086363644149148
private void handleUpdateEntries(StorageEngine<ByteArray, byte[]> engine,
                                     DataInputStream inputStream,
                                     DataOutputStream outputStream) throws IOException {
        EventThrottler throttler = new EventThrottler(streamMaxBytesWritesPerSec);

        try {
            int keySize = inputStream.readInt();
            while(keySize != -1) {
                byte[] key = new byte[keySize];
                ByteUtils.read(inputStream, key);

                int valueSize = inputStream.readInt();
                byte[] value = new byte[valueSize];
                ByteUtils.read(inputStream, value);

                VectorClock clock = new VectorClock(value);
                Versioned<byte[]> versionedValue = new Versioned<byte[]>(ByteUtils.copy(value,
                                                                                        clock.sizeInBytes(),
                                                                                        value.length),
                                                                         clock);

                engine.put(new ByteArray(key), versionedValue);

                if(throttler != null) {
                    throttler.maybeThrottle(key.length + clock.sizeInBytes() + value.length);
                }

                keySize = inputStream.readInt(); // read next KeySize
            }
            // all puts are handled.
            outputStream.writeShort(0);
        } catch(VoldemortException e) {
            writeException(outputStream, e);
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415505979878/fstmerge_base_8679480576244131031
private void handleUpdateEntries(StorageEngine<ByteArray, byte[]> engine,
                                     DataInputStream inputStream,
                                     DataOutputStream outputStream) throws IOException {
        IoThrottler throttler = new IoThrottler(streamMaxBytesWritesPerSec);

        try {
            int keySize = inputStream.readInt();
            while(keySize != -1) {
                byte[] key = new byte[keySize];
                ByteUtils.read(inputStream, key);

                int valueSize = inputStream.readInt();
                byte[] value = new byte[valueSize];
                ByteUtils.read(inputStream, value);

                VectorClock clock = new VectorClock(value);
                Versioned<byte[]> versionedValue = new Versioned<byte[]>(ByteUtils.copy(value,
                                                                                        clock.sizeInBytes(),
                                                                                        value.length),
                                                                         clock);

                engine.put(new ByteArray(key), versionedValue);

                if(throttler != null) {
                    throttler.maybeThrottle(key.length + clock.sizeInBytes() + value.length);
                }

                keySize = inputStream.readInt(); // read next KeySize
            }
            // all puts are handled.
            outputStream.writeShort(0);
        } catch(VoldemortException e) {
            writeException(outputStream, e);
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415505979878/fstmerge_var2_9080761335473697900

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b2daa_4aab0/rev_b2daa-4aab0/src/java/voldemort/server/protocol/admin/AdminServiceRequestHandler.java
Conflict type: LineBasedMCFd
Conflict body: 
public BdbStorageEngine(String name, Environment environment, Database database) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415505983843/fstmerge_var1_8181285171003731006
        this.name = Utils.notNull(name);
        this.bdbDatabase = Utils.notNull(database);
        this.environment = Utils.notNull(environment);
        this.versionedSerializer = new VersionedSerializer<byte[]>(new IdentitySerializer());
        this.versionSerializer = new Serializer<Version>() {

            public byte[] toBytes(Version object) {
                return ((VectorClock) object).toBytes();
            }

            public Version toObject(byte[] bytes) {
                return versionedSerializer.getVersion(bytes);
            }
        };
        this.isOpen = new AtomicBoolean(true);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415505983843/fstmerge_base_3426215373912685941
        this.name = Utils.notNull(name);
        this.bdbDatabase = Utils.notNull(database);
        this.environment = Utils.notNull(environment);
        this.serializer = new VersionedSerializer<byte[]>(new IdentitySerializer());
        this.isOpen = new AtomicBoolean(true);
=======
        this(name, environment, database, false);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415505983843/fstmerge_var2_871743848356681048
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b2daa_4aab0/rev_b2daa-4aab0/src/java/voldemort/store/bdb/BdbStorageEngine.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415505983919/fstmerge_var1_5035797141206201554
@JmxOperation(description = "A variety of stats about the BDB for this store.")
    public String getBdbStats() {
        String stats = getStats(false).toString();
        logger.debug("Bdb store" + getName() + " stats:\n" + stats + "\n");
        return stats;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415505983919/fstmerge_base_6057183001446663347
=======
@JmxOperation(description = "A variety of stats about the BDB for this store.")
    public String getBdbStats() {
        String stats = getStats(false).toString();
        logger.info("Bdb store" + getName() + " stats:\n" + stats + "\n");
        return stats;
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415505983919/fstmerge_var2_417895676292515814

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b2daa_4aab0/rev_b2daa-4aab0/src/java/voldemort/store/bdb/BdbStorageEngine.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b9a57_ff63c/rev_b9a57-ff63c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f0e35_0ea66/rev_f0e35-0ea66.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_393f6_9b156/rev_393f6-9b156.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d93b8_becb4/rev_d93b8-becb4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_935e7_b4673/rev_935e7-b4673.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public Iterator<Pair<ByteArray, Versioned<byte[]>>> fetchPartitionEntries(int nodeId,
                                                                              String storeName,
                                                                              List<Integer> partitionList,
                                                                              VoldemortFilter filter) {
        Node node = this.getMetadata().getCluster().getNodeById(nodeId);
        final SocketDestination destination = new SocketDestination(node.getHost(),
                                                                    node.getAdminPort(),
                                                                    RequestFormatType.ADMIN_PROTOCOL_BUFFERS);
        final SocketAndStreams sands = pool.checkout(destination);
        DataOutputStream outputStream = sands.getOutputStream();
        final DataInputStream inputStream = sands.getInputStream();

        try {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415506828528/fstmerge_var1_8102212186836721663
            VAdminProto.FetchPartitionEntriesRequest.Builder fetchRequest = VAdminProto.FetchPartitionEntriesRequest.newBuilder()
                                                                                                                    .addAllPartitions(partitionList)
                                                                                                                    .setStore(storeName);

            if(filter != null) {
                fetchRequest.setFilter(encodeFilter(filter));
            }

            VAdminProto.VoldemortAdminRequest request = VAdminProto.VoldemortAdminRequest.newBuilder()
                                                                                         .setType(VAdminProto.AdminRequestType.FETCH_PARTITION_ENTRIES)
                                                                                         .setFetchPartitionEntries(fetchRequest)
                                                                                         .build();

            ProtoUtils.writeMessage(outputStream, request);
            outputStream.flush();
        } catch(IOException e) {
            close(sands.getSocket());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415506828528/fstmerge_base_1136264901692470380
            VAdminProto.FetchPartitionEntriesRequest.Builder fetchRequest =
                    VAdminProto.FetchPartitionEntriesRequest.newBuilder()
                    .addAllPartitions(partitionList)
                    .setStore(storeName);

            if (filter != null) {
                fetchRequest.setFilter(encodeFilter(filter));
            }

            VAdminProto.VoldemortAdminRequest request = VAdminProto.VoldemortAdminRequest
                .newBuilder()
                .setType(VAdminProto.AdminRequestType.FETCH_PARTITION_ENTRIES)
                .setFetchPartitionEntries(fetchRequest)
                .build();

            ProtoUtils.writeMessage(outputStream, request);
            outputStream.flush();
        } catch (IOException e) {
            close (sands.getSocket());
=======
            initiateFetchRequest(outputStream, storeName, partitionList, filter, true);
        } catch (IOException e) {
            close (sands.getSocket());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415506828528/fstmerge_var2_7207976155238151882
            pool.checkin(destination, sands);
            throw new VoldemortException(e);
        }

        return new AbstractIterator<Pair<ByteArray, Versioned<byte[]>>>() {

            @Override
            public Pair<ByteArray, Versioned<byte[]>> computeNext() {
                try {
                    int size = inputStream.readInt();
                    if(size <= 0) {
                        pool.checkin(destination, sands);
                        return endOfData();
                    }

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415506828528/fstmerge_var1_8102212186836721663
                    // There is a bug in CodedInputStream
                    // Work around suggested by ijuma
                    byte[] input = new byte[size];
                    ByteUtils.read(inputStream, input);
                    VAdminProto.FetchPartitionEntriesResponse.Builder response = VAdminProto.FetchPartitionEntriesResponse.newBuilder();
                    response.mergeFrom(input);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415506828528/fstmerge_base_1136264901692470380
                    // There is a bug in CodedInputStream
                    // Work around suggested by ijuma
                    byte[] input = new byte[size];
                    ByteUtils.read(inputStream, input);
                    VAdminProto.FetchPartitionEntriesResponse.Builder response =
                            VAdminProto.FetchPartitionEntriesResponse.newBuilder();
                    response.mergeFrom(input);
=======
                    VAdminProto.FetchPartitionEntriesResponse response =
                            responseFromStream(inputStream, size);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415506828528/fstmerge_var2_7207976155238151882

                    if(response.hasError()) {
                        pool.checkin(destination, sands);
                        throwException(response.getError());
                    }

                    VAdminProto.PartitionEntry partitionEntry = response.getPartitionEntry();

                    return Pair.create(ProtoUtils.decodeBytes(partitionEntry.getKey()),
                                       ProtoUtils.decodeVersioned(partitionEntry.getVersioned()));
                } catch(IOException e) {
                    close(sands.getSocket());
                    pool.checkin(destination, sands);
                    throw new VoldemortException(e);
                }
            }
        };

    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_935e7_b4673/rev_935e7-b4673/src/java/voldemort/client/protocol/admin/ProtoBuffAdminClientRequestFormat.java
Conflict type: LineBasedMCFd
Conflict body: 
public Iterator<ByteArray> fetchPartitionKeys(int nodeId,
                                                  String storeName,
                                                  List<Integer> partitionList,
                                                  VoldemortFilter filter) {
        Node node = this.getMetadata().getCluster().getNodeById(nodeId);
        final SocketDestination destination = new SocketDestination(node.getHost(),
                                                                    node.getAdminPort(),
                                                                    RequestFormatType.ADMIN_PROTOCOL_BUFFERS);
        final SocketAndStreams sands = pool.checkout(destination);
        DataOutputStream outputStream = sands.getOutputStream();
        final DataInputStream inputStream = sands.getInputStream();

        try {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415506828535/fstmerge_var1_7991095652398242755
            VAdminProto.FetchPartitionKeysRequest.Builder fetchRequest = VAdminProto.FetchPartitionKeysRequest.newBuilder()
                                                                                                              .addAllPartitions(partitionList)
                                                                                                              .setStore(storeName);

            if(filter != null) {
                fetchRequest.setFilter(encodeFilter(filter));
            }

            VAdminProto.VoldemortAdminRequest request = VAdminProto.VoldemortAdminRequest.newBuilder()
                                                                                         .setFetchPartitionKeys(fetchRequest)
                                                                                         .setType(VAdminProto.AdminRequestType.FETCH_KEYS)
                                                                                         .build();
            ProtoUtils.writeMessage(outputStream, request);
            outputStream.flush();
        } catch(IOException e) {
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415506828535/fstmerge_base_3048446006168617579
            VAdminProto.FetchPartitionKeysRequest.Builder fetchRequest =
                VAdminProto.FetchPartitionKeysRequest.newBuilder()
                    .addAllPartitions(partitionList)
                    .setStore(storeName);

            if (filter != null) {
                fetchRequest.setFilter(encodeFilter(filter));
            }

            VAdminProto.VoldemortAdminRequest request =
                VAdminProto.VoldemortAdminRequest.newBuilder()
                .setFetchPartitionKeys(fetchRequest)
                .setType(VAdminProto.AdminRequestType.FETCH_KEYS)
                .build();
            ProtoUtils.writeMessage(outputStream, request);
            outputStream.flush();
        } catch (IOException e) {
=======
            initiateFetchRequest(outputStream, storeName, partitionList, filter, false);
        } catch (IOException e) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415506828535/fstmerge_var2_7759174354537288877
            close(sands.getSocket());
            pool.checkin(destination, sands);
            throw new VoldemortException(e);
        }

        return new AbstractIterator<ByteArray>() {

            @Override
            public ByteArray computeNext() {
                try {
                    int size = inputStream.readInt();
                    if(size <= 0) {
                        pool.checkin(destination, sands);
                        return endOfData();
                    }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415506828535/fstmerge_var1_7991095652398242755

                    byte[] input = new byte[size];
                    ByteUtils.read(inputStream, input);
                    VAdminProto.FetchPartitionKeysResponse.Builder response = VAdminProto.FetchPartitionKeysResponse.newBuilder();
                    response.mergeFrom(input);

                    if(response.hasError()) {
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415506828535/fstmerge_base_3048446006168617579

                    byte[] input = new byte[size];
                    ByteUtils.read(inputStream, input);
                    VAdminProto.FetchPartitionKeysResponse.Builder response =
                        VAdminProto.FetchPartitionKeysResponse.newBuilder();
                    response.mergeFrom(input);

                    if (response.hasError()) {
=======
                    
                    VAdminProto.FetchPartitionEntriesResponse response =
                            responseFromStream(inputStream, size);
                    
                    if (response.hasError()) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415506828535/fstmerge_var2_7759174354537288877
                        pool.checkin(destination, sands);
                        throwException(response.getError());
                    }

                    return ProtoUtils.decodeBytes(response.getKey());
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415506828535/fstmerge_var1_7991095652398242755

                } catch(IOException e) {
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415506828535/fstmerge_base_3048446006168617579

                } catch (IOException e) {
=======
                } catch (IOException e) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415506828535/fstmerge_var2_7759174354537288877
                    close(sands.getSocket());
                    pool.checkin(destination, sands);
                    throw new VoldemortException(e);
                }

            }
        };
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_935e7_b4673/rev_935e7-b4673/src/java/voldemort/client/protocol/admin/ProtoBuffAdminClientRequestFormat.java
Conflict type: LineBasedMCFd
Conflict body: 
public void handleFetchPartitionEntries(VAdminProto.FetchPartitionEntriesRequest request,
                                            DataOutputStream outputStream) throws IOException {
        try {
            String storeName = request.getStore();
            StorageEngine<ByteArray, byte[]> storageEngine = storeRepository.getStorageEngine(storeName);

            if(storageEngine == null) {
                throw new VoldemortException("No store named '" + storeName + "'.");
            }
            RoutingStrategy routingStrategy = metadataStore.getRoutingStrategy(storageEngine.getName());
            EventThrottler throttler = new EventThrottler(streamMaxBytesReadPerSec);
            List<Integer> partitionList = request.getPartitionsList();
            boolean fetchValues = request.hasFetchValues() && request.getFetchValues();
            VoldemortFilter filter;

            if(request.hasFilter()) {
                filter = getFilterFromRequest(request.getFilter());
            } else {
                filter = new DefaultVoldemortFilter();
            }

            ClosableIterator<Pair<ByteArray, Versioned<byte[]>>> iterator = storageEngine.entries();
            while(iterator.hasNext()) {
                Pair<ByteArray, Versioned<byte[]>> entry = iterator.next();

                if(validPartition(entry.getFirst().get(), partitionList, routingStrategy)
                   && filter.accept(entry.getFirst(), entry.getSecond())) {

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415506830075/fstmerge_var1_3338758195049589120
                    VAdminProto.PartitionEntry partitionEntry = VAdminProto.PartitionEntry.newBuilder()
                                                                                          .setKey(ProtoUtils.encodeBytes(entry.getFirst()))
                                                                                          .setVersioned(ProtoUtils.encodeVersioned(entry.getSecond()))
                                                                                          .build();
                    VAdminProto.FetchPartitionEntriesResponse.Builder response = VAdminProto.FetchPartitionEntriesResponse.newBuilder();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415506830075/fstmerge_base_3763672372452423644
                    VAdminProto.PartitionEntry partitionEntry =
                            VAdminProto.PartitionEntry.newBuilder()
                                    .setKey(ProtoUtils.encodeBytes(entry.getFirst()))
                                    .setVersioned(ProtoUtils.encodeVersioned(entry.getSecond()))
                                    .build();
                    VAdminProto.FetchPartitionEntriesResponse.Builder response =
                            VAdminProto.FetchPartitionEntriesResponse.newBuilder();
=======
                    VAdminProto.FetchPartitionEntriesResponse.Builder response =
                                                VAdminProto.FetchPartitionEntriesResponse.newBuilder();

                    if (fetchValues) {
                        VAdminProto.PartitionEntry partitionEntry =
                                VAdminProto.PartitionEntry.newBuilder()
                                        .setKey(ProtoUtils.encodeBytes(entry.getFirst()))
                                        .setVersioned(ProtoUtils.encodeVersioned(entry.getSecond()))
                                        .build();
                        response.setPartitionEntry(partitionEntry);
                    } else {
                        response.setKey(ProtoUtils.encodeBytes(entry.getFirst()));
                    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415506830075/fstmerge_var2_2829777730331493010

                    Message message = response.build();
                    ProtoUtils.writeMessage(outputStream, message);

                    if(throttler != null) {
                        throttler.maybeThrottle(entrySize(entry));
                    }
                }
            }

            iterator.close();
            ProtoUtils.writeEndOfStream(outputStream);
        } catch(VoldemortException e) {
            VAdminProto.FetchPartitionEntriesResponse response = VAdminProto.FetchPartitionEntriesResponse.newBuilder()
                                                                                                          .setError(ProtoUtils.encodeError(errorCodeMapper,
                                                                                                                                           e))
                                                                                                          .build();

            ProtoUtils.writeMessage(outputStream, response);
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_935e7_b4673/rev_935e7-b4673/src/java/voldemort/server/protocol/admin/ProtoBuffAdminServiceRequestHandler.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415506830109/fstmerge_var1_8541598691520816741
public void handleFetchPartitionKeys(VAdminProto.FetchPartitionKeysRequest request,
                                         DataOutputStream outputStream) throws IOException {
        try {
            String storeName = request.getStore();
            StorageEngine<ByteArray, byte[]> storageEngine = storeRepository.getStorageEngine(storeName);

            if(storageEngine == null) {
                throw new VoldemortException("No store named '" + storeName + "'.");
            }
            RoutingStrategy routingStrategy = metadataStore.getRoutingStrategy(storageEngine.getName());
            EventThrottler throttler = new EventThrottler(streamMaxBytesReadPerSec);
            List<Integer> partitionList = request.getPartitionsList();
            VoldemortFilter filter;

            if(request.hasFilter()) {
                filter = getFilterFromRequest(request.getFilter());
            } else {
                filter = new DefaultVoldemortFilter();
            }

            ClosableIterator<Pair<ByteArray, Versioned<byte[]>>> iterator = storageEngine.entries();
            while(iterator.hasNext()) {
                Pair<ByteArray, Versioned<byte[]>> entry = iterator.next();

                if(validPartition(entry.getFirst().get(), partitionList, routingStrategy)
                   && filter.accept(entry.getFirst(), entry.getSecond())) {
                    VAdminProto.FetchPartitionKeysResponse response = VAdminProto.FetchPartitionKeysResponse.newBuilder()
                                                                                                            .setKey(ProtoUtils.encodeBytes(entry.getFirst()))
                                                                                                            .build();
                    ProtoUtils.writeMessage(outputStream, response);

                    if(throttler != null) {
                        throttler.maybeThrottle(entry.getFirst().length());
                    }
                }
            }
            iterator.close();
            ProtoUtils.writeEndOfStream(outputStream);
        } catch(VoldemortException e) {
            VAdminProto.FetchPartitionKeysResponse response = VAdminProto.FetchPartitionKeysResponse.newBuilder()
                                                                                                    .setError(ProtoUtils.encodeError(errorCodeMapper,
                                                                                                                                     e))
                                                                                                    .build();
            ProtoUtils.writeMessage(outputStream, response);
        }

    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415506830109/fstmerge_base_861817682625886740
public void handleFetchPartitionKeys(VAdminProto.FetchPartitionKeysRequest request,
                                DataOutputStream outputStream) throws IOException {
        try {
            String storeName = request.getStore();
            StorageEngine<ByteArray, byte[]> storageEngine = storeRepository.getStorageEngine(storeName);

            if (storageEngine == null) {
                throw new VoldemortException("No store named '" + storeName + "'.");
            }
            RoutingStrategy routingStrategy =
                metadataStore.getRoutingStrategy(storageEngine.getName());
            EventThrottler throttler = new EventThrottler(streamMaxBytesReadPerSec);
            List<Integer> partitionList = request.getPartitionsList();
            VoldemortFilter filter;

            if (request.hasFilter()) {
                filter = getFilterFromRequest(request.getFilter());
            } else {
                filter = new DefaultVoldemortFilter();
            }

            ClosableIterator<Pair<ByteArray, Versioned<byte[]>>> iterator = storageEngine.entries();
            while (iterator.hasNext()) {
                Pair<ByteArray, Versioned<byte[]>> entry = iterator.next();

                if (validPartition(entry.getFirst().get(), partitionList, routingStrategy)
                    && filter.filter(entry.getFirst(), entry.getSecond())) {
                    VAdminProto.FetchPartitionKeysResponse response = VAdminProto.FetchPartitionKeysResponse
                        .newBuilder()
                        .setKey(ProtoUtils.encodeBytes(entry.getFirst()))
                        .build();
                    ProtoUtils.writeMessage(outputStream, response);

                    if (throttler != null) {
                        throttler.maybeThrottle(entry.getFirst().length());
                    }
                }
            }
            iterator.close();
            ProtoUtils.writeEndOfStream(outputStream);
        } catch (VoldemortException e) {
            VAdminProto.FetchPartitionKeysResponse response = VAdminProto.FetchPartitionKeysResponse.newBuilder()
                .setError(ProtoUtils.encodeError(errorCodeMapper, e))
                .build();
            ProtoUtils.writeMessage(outputStream, response);
        }

    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415506830109/fstmerge_var2_6099075321543704391

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_935e7_b4673/rev_935e7-b4673/src/java/voldemort/server/protocol/admin/ProtoBuffAdminServiceRequestHandler.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_afae7_02829/rev_afae7-02829.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c79f0_eb466/rev_c79f0-eb466.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_27e1f_efc6f/rev_27e1f-efc6f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_04f52_ea592/rev_04f52-ea592.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_09098_bbafb/rev_09098-bbafb.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_1f412_320c4/rev_1f412-320c4.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@Override
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507837168/fstmerge_var1_6653955243660019168
    public int fetchAndUpdateStreams(int donorNodeId, int stealerNodeId, String storeName, List<Integer> stealList, VoldemortFilter filter) {
        VAdminProto.InitiateFetchAndUpdateRequest.Builder initiateFetchAndUpdateRequest =
                VAdminProto.InitiateFetchAndUpdateRequest.newBuilder()
                .setNodeId(donorNodeId)
                .addAllPartitions(stealList)
                .setStore(storeName);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507837168/fstmerge_base_8877494008382272938
    public void fetchAndUpdateStreams(int donorNodeId, int stealerNodeId, String storeName, List<Integer> stealList, VoldemortFilter filter) {
        VAdminProto.InitiateFetchAndUpdateRequest.Builder initiateFetchAndUpdateRequest =
                VAdminProto.InitiateFetchAndUpdateRequest.newBuilder()
                .setNodeId(donorNodeId)
                .addAllPartitions(stealList)
                .setStore(storeName);
=======
    public void fetchAndUpdateStreams(int donorNodeId,
                                      int stealerNodeId,
                                      String storeName,
                                      List<Integer> stealList,
                                      VoldemortFilter filter) {
        VAdminProto.InitiateFetchAndUpdateRequest.Builder initiateFetchAndUpdateRequest = VAdminProto.InitiateFetchAndUpdateRequest.newBuilder()
                                                                                                                                   .setNodeId(donorNodeId)
                                                                                                                                   .addAllPartitions(stealList)
                                                                                                                                   .setStore(storeName);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507837168/fstmerge_var2_6439641495171628988
        try {
            if(filter != null) {
                initiateFetchAndUpdateRequest.setFilter(encodeFilter(filter));
            }
        } catch(IOException e) {
            throw new VoldemortException(e);
        }

        VAdminProto.VoldemortAdminRequest adminRequest = VAdminProto.VoldemortAdminRequest.newBuilder()
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507837168/fstmerge_var1_6653955243660019168
                .setInitiateFetchAndUpdate(initiateFetchAndUpdateRequest)
                .setType(VAdminProto.AdminRequestType.INITIATE_FETCH_AND_UPDATE)
                .build();
        VAdminProto.AsyncOperationStatusResponse.Builder response = sendAndReceive(stealerNodeId, adminRequest,
                VAdminProto.AsyncOperationStatusResponse.newBuilder());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507837168/fstmerge_base_8877494008382272938
                .setInitiateFetchAndUpdate(initiateFetchAndUpdateRequest)
                .setType(VAdminProto.AdminRequestType.INITIATE_FETCH_AND_UPDATE)
                .build();
        VAdminProto.InitiateFetchAndUpdateResponse.Builder response = sendAndReceive(stealerNodeId, adminRequest,
                VAdminProto.InitiateFetchAndUpdateResponse.newBuilder());
=======
                                                                                          .setInitiateFetchAndUpdate(initiateFetchAndUpdateRequest)
                                                                                          .setType(VAdminProto.AdminRequestType.INITIATE_FETCH_AND_UPDATE)
                                                                                          .build();
        VAdminProto.InitiateFetchAndUpdateResponse.Builder response = sendAndReceive(stealerNodeId,
                                                                                     adminRequest,
                                                                                     VAdminProto.InitiateFetchAndUpdateResponse.newBuilder());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507837168/fstmerge_var2_6439641495171628988

        if(response.hasError()) {
            throwException(response.getError());
        }

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507837168/fstmerge_var1_6653955243660019168
        return response.getRequestId();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507837168/fstmerge_base_8877494008382272938
        /**
         * This uses exponential back off to wait for the request to finish on the stealer node
         * TODO: make waiting optional, add configurable delay parameters, use DelayQueue
         */
        long delay = 250;
        long maxDelay = 1000*60;
        String requestId = response.getRequestId();
        while (true) {
            Pair<String,Boolean> status = getAsyncRequestStatus(stealerNodeId, requestId);
            if (status.getSecond())
                break;
            if (delay < maxDelay)
                delay *= 2;
            try {
                Thread.sleep(delay);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
=======
        /**
         * This uses exponential back off to wait for the request to finish on
         * the stealer node TODO: make waiting optional, add configurable delay
         * parameters, use DelayQueue
         */
        long delay = 250;
        long maxDelay = 1000 * 60;
        String requestId = response.getRequestId();
        while(true) {
            Pair<String, Boolean> status = getAsyncRequestStatus(stealerNodeId, requestId);
            if(status.getSecond())
                break;
            if(delay < maxDelay)
                delay *= 2;
            try {
                Thread.sleep(delay);
            } catch(InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507837168/fstmerge_var2_6439641495171628988
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_1f412_320c4/rev_1f412-320c4/src/java/voldemort/client/protocol/admin/ProtoBuffAdminClientRequestFormat.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507837173/fstmerge_var1_2728139177441665221
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507837173/fstmerge_base_6198475206785764637
@Override
    public Pair<String, Boolean> getAsyncRequestStatus(int nodeId, String requestId) {
        VAdminProto.AsyncStatusRequest asyncRequest = VAdminProto.AsyncStatusRequest.newBuilder()
                .setRequestId(requestId)
                .build();
        VAdminProto.VoldemortAdminRequest adminRequest = VAdminProto.VoldemortAdminRequest.newBuilder()
                .setType(VAdminProto.AdminRequestType.ASYNC_STATUS)
                .setAsyncStatus(asyncRequest)
                .build();
        VAdminProto.AsyncStatusResponse.Builder response = sendAndReceive(nodeId, adminRequest,
                VAdminProto.AsyncStatusResponse.newBuilder());

        if (response.hasError())
            throwException(response.getError());

        return new Pair<String,Boolean>(response.getStatus(), response.getIsComplete());
    }
=======
@Override
    public Pair<String, Boolean> getAsyncRequestStatus(int nodeId, String requestId) {
        VAdminProto.AsyncStatusRequest asyncRequest = VAdminProto.AsyncStatusRequest.newBuilder()
                                                                                    .setRequestId(requestId)
                                                                                    .build();
        VAdminProto.VoldemortAdminRequest adminRequest = VAdminProto.VoldemortAdminRequest.newBuilder()
                                                                                          .setType(VAdminProto.AdminRequestType.ASYNC_STATUS)
                                                                                          .setAsyncStatus(asyncRequest)
                                                                                          .build();
        VAdminProto.AsyncStatusResponse.Builder response = sendAndReceive(nodeId,
                                                                          adminRequest,
                                                                          VAdminProto.AsyncStatusResponse.newBuilder());

        if(response.hasError())
            throwException(response.getError());

        return new Pair<String, Boolean>(response.getStatus(), response.getIsComplete());
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507837173/fstmerge_var2_4397541077428165570

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_1f412_320c4/rev_1f412-320c4/src/java/voldemort/client/protocol/admin/ProtoBuffAdminClientRequestFormat.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507837223/fstmerge_var1_6040531107686551729
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507837223/fstmerge_base_5444594844013506501
public abstract Pair<String,Boolean> getAsyncRequestStatus(int nodeId, String requestId);
=======
public abstract Pair<String, Boolean> getAsyncRequestStatus(int nodeId, String requestId);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507837223/fstmerge_var2_4856873060568621371

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_1f412_320c4/rev_1f412-320c4/src/java/voldemort/client/protocol/admin/AdminClient.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507838630/fstmerge_var1_7344386384016263203
public VAdminProto.AsyncOperationStatusResponse
    handleFetchAndUpdate(VAdminProto.InitiateFetchAndUpdateRequest request) {
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507838630/fstmerge_base_6341169597995093476
public VAdminProto.InitiateFetchAndUpdateResponse
    handleFetchAndUpdate(VAdminProto.InitiateFetchAndUpdateRequest request) {
=======
public VAdminProto.InitiateFetchAndUpdateResponse handleFetchAndUpdate(VAdminProto.InitiateFetchAndUpdateRequest request) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507838630/fstmerge_var2_7971843167388582160
        final int nodeId = request.getNodeId();
        Cluster cluster = metadataStore.getCluster();
        Node remoteNode = cluster.getNodeById(nodeId);
        String adminUrl = remoteNode.getSocketUrl().toString();

        final List<Integer> partitions = request.getPartitionsList();

        final VoldemortFilter filter = request.hasFilter() ? getFilterFromRequest(request.getFilter())
                                                          : new DefaultVoldemortFilter();
        final String storeName = request.getStore();

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507838630/fstmerge_var1_7344386384016263203
        int requestId = lastOperationId.getAndIncrement();
        VAdminProto.AsyncOperationStatusResponse.Builder response = VAdminProto.AsyncOperationStatusResponse.newBuilder()
                .setRequestId(requestId)
                .setComplete(false)
                .setDescription("Fetch and update")
                .setStatus("started");
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507838630/fstmerge_base_6341169597995093476
        String requestId = "fetchAndUpdate" + requestToId(storeName, nodeId, partitions);
        VAdminProto.InitiateFetchAndUpdateResponse.Builder response = VAdminProto.InitiateFetchAndUpdateResponse.newBuilder()
                .setRequestId(requestId);
=======
        String requestId = "fetchAndUpdate" + requestToId(storeName, nodeId, partitions);
        VAdminProto.InitiateFetchAndUpdateResponse.Builder response = VAdminProto.InitiateFetchAndUpdateResponse.newBuilder()
                                                                                                                .setRequestId(requestId);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507838630/fstmerge_var2_7971843167388582160

        try {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507838630/fstmerge_var1_7344386384016263203
            asyncRunner.startRequest(requestId, new AsyncOperation(requestId, "Fetch and Update") {
                public void apply() {
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507838630/fstmerge_base_6341169597995093476
            asyncRunner.startRequest(requestId, new AsyncOperation() {
                public void run() {
                    setStatus("Started");
=======
            asyncRunner.startRequest(requestId, new AsyncOperation() {

                public void run() {
                    setStatus("Started");
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507838630/fstmerge_var2_7971843167388582160
                    StorageEngine<ByteArray, byte[]> storageEngine = getStorageEngine(storeName);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507838630/fstmerge_var1_7344386384016263203
                    AdminClient adminClient = adminClientFactory.getAdminClient();
                    Iterator<Pair<ByteArray, Versioned<byte[]>>> entriesIterator =
                            adminClient.fetchPartitionEntries(nodeId, storeName, partitions, filter);
                    updateStatus("Initated fetchPartitionEntries");
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507838630/fstmerge_base_6341169597995093476
                    AdminClient adminClient = adminClientFactory.getAdminClient();
                    Iterator<Pair<ByteArray, Versioned<byte[]>>> entriesIterator =
                            adminClient.fetchPartitionEntries(nodeId, storeName, partitions, filter);
                    setStatus("Initated fetchPartitionEntries");
=======

                    // TODO bbansal : fix me this should be shared.
                    AdminClient adminClient = null;

                    Iterator<Pair<ByteArray, Versioned<byte[]>>> entriesIterator = adminClient.fetchPartitionEntries(nodeId,
                                                                                                                     storeName,
                                                                                                                     partitions,
                                                                                                                     filter);
                    setStatus("Initated fetchPartitionEntries");
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507838630/fstmerge_var2_7971843167388582160
                    EventThrottler throttler = new EventThrottler(streamMaxBytesWritesPerSec);
                    for(long i = 0; entriesIterator.hasNext(); i++) {
                        Pair<ByteArray, Versioned<byte[]>> entry = entriesIterator.next();
                        storageEngine.put(entry.getFirst(), entry.getSecond());

                        throttler.maybeThrottle(entrySize(entry));

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507838630/fstmerge_var1_7344386384016263203
                        if ((i % 1000) == 0) {
                            updateStatus(i + " entries processed");
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507838630/fstmerge_base_6341169597995093476
                        if ((i % 1000) == 0) {
                            setStatus(i + " entries processed");
=======
                        if((i % 1000) == 0) {
                            setStatus(i + " entries processed");
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507838630/fstmerge_var2_7971843167388582160
                        }
                    }
                }
            });

        } catch(VoldemortException e) {
            response.setError(ProtoUtils.encodeError(errorCodeMapper, e));
        }

        return response.build();
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_1f412_320c4/rev_1f412-320c4/src/java/voldemort/server/protocol/admin/ProtoBuffAdminServiceRequestHandler.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507838636/fstmerge_var1_160885913282928994
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507838636/fstmerge_base_1983563847933606409
public VAdminProto.AsyncStatusResponse handleAsyncStatus(VAdminProto.AsyncStatusRequest request) {
        VAdminProto.AsyncStatusResponse.Builder response = VAdminProto.AsyncStatusResponse.newBuilder();
        try {
            String requestId = request.getRequestId();
            String requestStatus = asyncRunner.getRequestStatus(requestId);
            boolean requestComplete = asyncRunner.isComplete(requestId);

            response.setIsComplete(requestComplete);
            response.setStatus(requestStatus);
        } catch (VoldemortException e) {
            response.setError(ProtoUtils.encodeError(errorCodeMapper, e));
        }

        return response.build();
    }
=======
public VAdminProto.AsyncStatusResponse handleAsyncStatus(VAdminProto.AsyncStatusRequest request) {
        VAdminProto.AsyncStatusResponse.Builder response = VAdminProto.AsyncStatusResponse.newBuilder();
        try {
            String requestId = request.getRequestId();
            String requestStatus = asyncRunner.getRequestStatus(requestId);
            boolean requestComplete = asyncRunner.isComplete(requestId);

            response.setIsComplete(requestComplete);
            response.setStatus(requestStatus);
        } catch(VoldemortException e) {
            response.setError(ProtoUtils.encodeError(errorCodeMapper, e));
        }

        return response.build();
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415507838636/fstmerge_var2_3824636695071660913

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_1f412_320c4/rev_1f412-320c4/src/java/voldemort/server/protocol/admin/ProtoBuffAdminServiceRequestHandler.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_46ab6_cffd8/rev_46ab6-cffd8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_4d200_7d732/rev_4d200-7d732.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_4d200_4a918/rev_4d200-4a918.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_ce3d2_31d2a/rev_ce3d2-31d2a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c2bdf_31d2a/rev_c2bdf-31d2a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e420d_1b4c5/rev_e420d-1b4c5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6dd69_70e06/rev_6dd69-70e06.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f15e2_7893d/rev_f15e2-7893d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f15e2_f6780/rev_f15e2-f6780.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3b74b_48b2b/rev_3b74b-48b2b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2ae78_3b74b/rev_2ae78-3b74b.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509353410/fstmerge_var1_8336556900710000726
public void waitForCompletion(int nodeId, int requestId, long maxWait, TimeUnit timeUnit) {
        long delay = INITIAL_DELAY;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509353410/fstmerge_base_7688569846503115905
public boolean waitForCompletion(int nodeId, int requestId, long maxWait, TimeUnit timeUnit) {
        long delay = 250;
        // don't do exponential back off past a certain limit
        long maxDelay = 1000 * 60;

=======
public void waitForCompletion(int nodeId, int requestId, long maxWait, TimeUnit timeUnit) {
        long delay = 250;
        // don't do exponential back off past a certain limit
        long maxDelay = 1000 * 60;

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509353410/fstmerge_var2_8488386956504364204
        long waitUntil = System.currentTimeMillis() + timeUnit.toMillis(maxWait);

        while(System.currentTimeMillis() < waitUntil) {
            AsyncOperationStatus status = getAsyncRequestStatus(nodeId, requestId);
            if(status.isComplete())
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509353410/fstmerge_var1_8336556900710000726
                return;
            if(delay < MAX_DELAY)
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509353410/fstmerge_base_7688569846503115905
                return true;
            if(delay < maxDelay)
=======
                return;
            if(delay < maxDelay)
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509353410/fstmerge_var2_8488386956504364204
                // keep doubling the wait period until we rach maxDelay
                delay <<= 2;
            try {
                Thread.sleep(delay);
            } catch(InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509353410/fstmerge_var1_8336556900710000726
        throw new VoldemortException("Failed to finish task requestId:" + requestId + " in maxWait"
                                     + maxWait + " " + timeUnit.toString());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509353410/fstmerge_base_7688569846503115905

        return false;
=======
        throw new VoldemortException("Task requestId:" + requestId + " failed to complete in " + maxWait + " " + timeUnit.toString()) ;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509353410/fstmerge_var2_8488386956504364204
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2ae78_3b74b/rev_2ae78-3b74b/src/java/voldemort/client/protocol/admin/AdminClient.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_caed9_6cf1e/rev_caed9-6cf1e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_caed9_33d01/rev_caed9-33d01.revisions
Conflict type: LineBasedMCFd
Conflict body: 
private Node node(int id, int... tags) {
        List<Integer> list = new ArrayList<Integer>(tags.length);
        for(int tag: tags)
            list.add(tag);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509703449/fstmerge_var1_5602932424639157077
        return new Node(id, "localhost", 8080, 6666, 6667, list, new NodeStatus(time));
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509703449/fstmerge_base_783180898850689193
        return new Node(id, "localhost", 8080, 6666, list, new NodeStatus(time));
=======
        return new Node(id, "localhost", 8080, 6666, list);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509703449/fstmerge_var2_4966411811287862456
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_caed9_33d01/rev_caed9-33d01/test/unit/voldemort/routing/ConsistentRoutingStrategyTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509703526/fstmerge_var1_3100456092601791082
    public void setUp() {
        this.nodes = ImmutableList.of(new Node(1,
                                               "test1",
                                               1,
                                               1,
                                               1,
                                               ImmutableList.of(1, 2, 3),
                                               new NodeStatus(time)),
                                      new Node(2,
                                               "test1",
                                               2,
                                               2,
                                               2,
                                               ImmutableList.of(3, 5, 6),
                                               new NodeStatus(time)),
                                      new Node(3,
                                               "test1",
                                               3,
                                               3,
                                               3,
                                               ImmutableList.of(7, 8, 9),
                                               new NodeStatus(time)),
                                      new Node(4,
                                               "test1",
                                               4,
                                               4,
                                               4,
                                               ImmutableList.of(10, 11, 12),
                                               new NodeStatus(time)));
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509703526/fstmerge_base_7030061289332581820
    public void setUp() {
        this.nodes = ImmutableList.of(new Node(1,
                                               "test1",
                                               1,
                                               1,
                                               ImmutableList.of(1, 2, 3),
                                               new NodeStatus(time)),
                                      new Node(2,
                                               "test1",
                                               2,
                                               2,
                                               ImmutableList.of(3, 5, 6),
                                               new NodeStatus(time)),
                                      new Node(3,
                                               "test1",
                                               3,
                                               3,
                                               ImmutableList.of(7, 8, 9),
                                               new NodeStatus(time)),
                                      new Node(4,
                                               "test1",
                                               4,
                                               4,
                                               ImmutableList.of(10, 11, 12),
                                               new NodeStatus(time)));
=======
    @Before
    public void setUp() throws Exception {
        this.nodes = ImmutableList.of(new Node(1, "test1", 1, 1, ImmutableList.of(1, 2, 3)),
                                      new Node(2, "test1", 2, 2, ImmutableList.of(3, 5, 6)),
                                      new Node(3, "test1", 3, 3, ImmutableList.of(7, 8, 9)),
                                      new Node(4, "test1", 4, 4, ImmutableList.of(10, 11, 12)));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509703526/fstmerge_var2_1457201085070829117
        this.cluster = new Cluster(clusterName, nodes);
        this.time = SystemTime.INSTANCE;

        Map<Integer, Store<ByteArray, byte[]>> stores = new HashMap<Integer, Store<ByteArray, byte[]>>();

        for(Node node: nodes) {
            stores.put(node.getId(), new Store<ByteArray, byte[]>() {

                public void close() throws VoldemortException {}

                public boolean delete(ByteArray key, Version version) throws VoldemortException {
                    return false;
                }

                public List<Versioned<byte[]>> get(ByteArray key) throws VoldemortException {
                    return null;
                }

                public Map<ByteArray, List<Versioned<byte[]>>> getAll(Iterable<ByteArray> keys)
                        throws VoldemortException {
                    return null;
                }

                public Object getCapability(StoreCapabilityType capability) {
                    return null;
                }

                public String getName() {
                    return null;
                }

                public void put(ByteArray key, Versioned<byte[]> value) throws VoldemortException {}

            });
        }

        FailureDetectorConfig config = new BasicFailureDetectorConfig(failureDetectorClass.getName(),
                                                                      BANNAGE_TIME,
                                                                      stores,
                                                                      time);
        failureDetector = FailureDetectorUtils.create(config);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_caed9_33d01/rev_caed9-33d01/test/unit/voldemort/cluster/TestCluster.java
Conflict type: LineBasedMCFd
Conflict body: 
public static void main(String[] args) throws Exception {
        if(args.length < 2 || args.length > 3)
            Utils.croak("USAGE: java VoldemortClientShell store_name bootstrap_url [command_file]");

        String storeName = args[0];
        String bootstrapUrl = args[1];
        String commandsFileName = "";
        BufferedReader fileReader = null;
        BufferedReader inputReader = null;
        try {
            if(args.length == 3) {
                commandsFileName = args[2];
                fileReader = new BufferedReader(new FileReader(commandsFileName));
            }

            inputReader = new BufferedReader(new InputStreamReader(System.in));
        } catch(IOException e) {
            Utils.croak("Failure to open input stream: " + e.getMessage());
        }

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509705225/fstmerge_var1_1703440356113814788
        StoreClientFactory factory = new SocketStoreClientFactory(new ClientConfig().setBootstrapUrls(bootstrapUrl));
        client = null;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509705225/fstmerge_base_2304276915183478245
        StoreClientFactory factory = new SocketStoreClientFactory(new ClientConfig().setBootstrapUrls(bootstrapUrl));
        DefaultStoreClient<Object, Object> client = null;
=======
        ClientConfig clientConfig = new ClientConfig().setBootstrapUrls(bootstrapUrl);
        StoreClientFactory factory = new SocketStoreClientFactory(clientConfig);

        DefaultStoreClient<Object, Object> client = null;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509705225/fstmerge_var2_2317354094397881615
        try {
            client = (DefaultStoreClient<Object, Object>) factory.getStoreClient(storeName);
        } catch(Exception e) {
            Utils.croak("Could not connect to server: " + e.getMessage());
        }

        System.out.println("Established connection to " + storeName + " via " + bootstrapUrl);
        System.out.print(PROMPT);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509705225/fstmerge_var1_1703440356113814788
        if(fileReader != null) {
            processCommands(fileReader, true);
            fileReader.close();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509705225/fstmerge_base_2304276915183478245
        for(String line = reader.readLine(); line != null; line = reader.readLine()) {
            if(line.trim().equals(""))
                continue;
            try {
                if(line.toLowerCase().startsWith("put")) {
                    JsonReader jsonReader = new JsonReader(new StringReader(line.substring("put".length())));
                    client.put(tightenNumericTypes(jsonReader.read()),
                               tightenNumericTypes(jsonReader.read()));
                } else if(line.toLowerCase().startsWith("getall")) {
                    JsonReader jsonReader = new JsonReader(new StringReader(line.substring("getall".length())));
                    List<Object> keys = new ArrayList<Object>();
                    try {
                        while(true)
                            keys.add(jsonReader.read());
                    } catch(EndOfFileException e) {
                        // this is okay, just means we are done reading
                    }
                    Map<Object, Versioned<Object>> vals = client.getAll(keys);
                    for(Map.Entry<Object, Versioned<Object>> entry: vals.entrySet()) {
                        System.out.print(entry.getKey());
                        System.out.print(" => ");
                        printVersioned(entry.getValue());
                    }
                } else if(line.toLowerCase().startsWith("get")) {
                    JsonReader jsonReader = new JsonReader(new StringReader(line.substring("get".length())));
                    printVersioned(client.get(tightenNumericTypes(jsonReader.read())));
                } else if(line.toLowerCase().startsWith("delete")) {
                    JsonReader jsonReader = new JsonReader(new StringReader(line.substring("delete".length())));
                    client.delete(tightenNumericTypes(jsonReader.read()));
                } else if(line.startsWith("locate")) {
                    JsonReader jsonReader = new JsonReader(new StringReader(line.substring("locate".length())));
                    Object key = tightenNumericTypes(jsonReader.read());
                    printNodeList(client.getResponsibleNodes(key));
                } else if(line.startsWith("help")) {
                    System.out.println("Commands:");
                    System.out.println("put key value -- Associate the given value with the key.");
                    System.out.println("get key -- Retrieve the value associated with the key.");
                    System.out.println("delete key -- Remove all values associated with the key.");
                    System.out.println("locate key -- Determine which servers host the give key.");
                    System.out.println("help -- Print this message.");
                    System.out.println("exit -- Exit from this shell.");
                    System.out.println();
                } else if(line.startsWith("quit") || line.startsWith("exit")) {
                    System.out.println("k k thx bye.");
                    System.exit(0);
                } else {
                    System.err.println("Invalid command.");
                }
            } catch(EndOfFileException e) {
                System.err.println("Expected additional token.");
            } catch(SerializationException e) {
                System.err.print("Error serializing values: ");
                e.printStackTrace();
            } catch(VoldemortException e) {
                System.err.println("Exception thrown during operation.");
                e.printStackTrace(System.err);
            } catch(ArrayIndexOutOfBoundsException e) {
                System.err.println("Invalid command.");
            } catch(Exception e) {
                System.err.println("Unexpected error:");
                e.printStackTrace(System.err);
            }
            System.out.print(PROMPT);
=======
        for(String line = reader.readLine(); line != null; line = reader.readLine()) {
            if(line.trim().equals(""))
                continue;
            try {
                if(line.toLowerCase().startsWith("put")) {
                    JsonReader jsonReader = new JsonReader(new StringReader(line.substring("put".length())));
                    client.put(tightenNumericTypes(jsonReader.read()),
                               tightenNumericTypes(jsonReader.read()));
                } else if(line.toLowerCase().startsWith("getall")) {
                    JsonReader jsonReader = new JsonReader(new StringReader(line.substring("getall".length())));
                    List<Object> keys = new ArrayList<Object>();
                    try {
                        while(true)
                            keys.add(jsonReader.read());
                    } catch(EndOfFileException e) {
                        // this is okay, just means we are done reading
                    }
                    Map<Object, Versioned<Object>> vals = client.getAll(keys);
                    for(Map.Entry<Object, Versioned<Object>> entry: vals.entrySet()) {
                        System.out.print(entry.getKey());
                        System.out.print(" => ");
                        printVersioned(entry.getValue());
                    }
                } else if(line.toLowerCase().startsWith("get")) {
                    JsonReader jsonReader = new JsonReader(new StringReader(line.substring("get".length())));
                    printVersioned(client.get(tightenNumericTypes(jsonReader.read())));
                } else if(line.toLowerCase().startsWith("delete")) {
                    JsonReader jsonReader = new JsonReader(new StringReader(line.substring("delete".length())));
                    client.delete(tightenNumericTypes(jsonReader.read()));
                } else if(line.startsWith("locate")) {
                    JsonReader jsonReader = new JsonReader(new StringReader(line.substring("locate".length())));
                    Object key = tightenNumericTypes(jsonReader.read());
                    printNodeList(client.getResponsibleNodes(key),
                                  factory.getFailureDetector());
                } else if(line.startsWith("help")) {
                    System.out.println("Commands:");
                    System.out.println("put key value -- Associate the given value with the key.");
                    System.out.println("get key -- Retrieve the value associated with the key.");
                    System.out.println("delete key -- Remove all values associated with the key.");
                    System.out.println("locate key -- Determine which servers host the give key.");
                    System.out.println("help -- Print this message.");
                    System.out.println("exit -- Exit from this shell.");
                    System.out.println();
                } else if(line.startsWith("quit") || line.startsWith("exit")) {
                    System.out.println("k k thx bye.");
                    System.exit(0);
                } else {
                    System.err.println("Invalid command.");
                }
            } catch(EndOfFileException e) {
                System.err.println("Expected additional token.");
            } catch(SerializationException e) {
                System.err.print("Error serializing values: ");
                e.printStackTrace();
            } catch(VoldemortException e) {
                System.err.println("Exception thrown during operation.");
                e.printStackTrace(System.err);
            } catch(ArrayIndexOutOfBoundsException e) {
                System.err.println("Invalid command.");
            } catch(Exception e) {
                System.err.println("Unexpected error:");
                e.printStackTrace(System.err);
            }
            System.out.print(PROMPT);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509705225/fstmerge_var2_2317354094397881615
        }
        processCommands(inputReader, false);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_caed9_33d01/rev_caed9-33d01/src/java/voldemort/VoldemortClientShell.java
Conflict type: LineBasedMCFd
Conflict body: 
public ClientConfig(Properties properties) {
        Props props = new Props(properties);
        if(props.containsKey(MAX_CONNECTIONS_PER_NODE_PROPERTY))
            this.setMaxConnectionsPerNode(props.getInt(MAX_CONNECTIONS_PER_NODE_PROPERTY));

        if(props.containsKey(MAX_TOTAL_CONNECTIONS_PROPERTY))
            this.setMaxTotalConnections(props.getInt(MAX_TOTAL_CONNECTIONS_PROPERTY));

        if(props.containsKey(MAX_THREADS_PROPERTY))
            this.setMaxThreads(props.getInt(MAX_THREADS_PROPERTY));

        if(props.containsKey(MAX_QUEUED_REQUESTS_PROPERTY))
            this.setMaxQueuedRequests(props.getInt(MAX_QUEUED_REQUESTS_PROPERTY));

        if(props.containsKey(THREAD_IDLE_MS_PROPERTY))
            this.setThreadIdleTime(props.getLong(THREAD_IDLE_MS_PROPERTY), TimeUnit.MILLISECONDS);

        if(props.containsKey(CONNECTION_TIMEOUT_MS_PROPERTY))
            this.setConnectionTimeout(props.getInt(CONNECTION_TIMEOUT_MS_PROPERTY),
                                      TimeUnit.MILLISECONDS);

        if(props.containsKey(SOCKET_TIMEOUT_MS_PROPERTY))
            this.setSocketTimeout(props.getInt(SOCKET_TIMEOUT_MS_PROPERTY), TimeUnit.MILLISECONDS);

        if(props.containsKey(ROUTING_TIMEOUT_MS_PROPERTY))
            this.setRoutingTimeout(props.getInt(ROUTING_TIMEOUT_MS_PROPERTY), TimeUnit.MILLISECONDS);

        if(props.containsKey(NODE_BANNAGE_MS_PROPERTY))
            this.setNodeBannagePeriod(props.getInt(NODE_BANNAGE_MS_PROPERTY), TimeUnit.MILLISECONDS);

        if(props.containsKey(SOCKET_BUFFER_SIZE_PROPERTY))
            this.setSocketBufferSize(props.getInt(SOCKET_BUFFER_SIZE_PROPERTY));

        if(props.containsKey(SERIALIZER_FACTORY_CLASS_PROPERTY)) {
            Class<?> factoryClass = ReflectUtils.loadClass(props.getString(SERIALIZER_FACTORY_CLASS_PROPERTY));
            SerializerFactory factory = (SerializerFactory) ReflectUtils.callConstructor(factoryClass,
                                                                                         new Object[] {});
            this.setSerializerFactory(factory);
        }

        if(props.containsKey(BOOTSTRAP_URLS_PROPERTY))
            this.setBootstrapUrls(props.getList(BOOTSTRAP_URLS_PROPERTY));

        if(props.containsKey(REQUEST_FORMAT_PROPERTY))
            this.setRequestFormatType(RequestFormatType.fromCode(props.getString(REQUEST_FORMAT_PROPERTY)));

        if(props.containsKey(ENABLE_JMX_PROPERTY))
            this.setEnableJmx(props.getBoolean(ENABLE_JMX_PROPERTY));

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509705491/fstmerge_var1_7266704789932625818
        if(props.containsKey(MAX_BOOTSTRAP_RETRIES))
            this.setMaxBootstrapRetries(props.getInt(MAX_BOOTSTRAP_RETRIES));

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509705491/fstmerge_base_7462625116528977582
=======
        if(props.containsKey(NODE_AVAILABILITY_DETECTOR_PROPERTY))
            this.setFailureDetector(props.getString(NODE_AVAILABILITY_DETECTOR_PROPERTY));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509705491/fstmerge_var2_8365476901145335364
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_caed9_33d01/rev_caed9-33d01/src/java/voldemort/client/ClientConfig.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509711846/fstmerge_var1_5462937861199140707
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509711846/fstmerge_base_45374869507858626
public StorageService(StoreRepository storeRepository,
                          VoldemortMetadata metadata,
                          SchedulerService scheduler,
                          VoldemortConfig config) {
        super(ServiceType.STORAGE);
        this.voldemortConfig = config;
        this.scheduler = scheduler;
        this.storeRepository = storeRepository;
        this.metadata = metadata;
        this.cleanupPermits = new Semaphore(1);
        this.storageConfigs = new ConcurrentHashMap<String, StorageConfiguration>();
        this.clientThreadPool = new ClientThreadPool(config.getClientMaxThreads(),
                                                     config.getClientThreadIdleMs(),
                                                     config.getClientMaxQueuedRequests());
        this.socketPool = new SocketPool(config.getClientMaxConnectionsPerNode(),
                                         config.getClientConnectionTimeoutMs(),
                                         config.getSocketTimeoutMs(),
                                         config.getSocketBufferSize());
    }
=======
public StorageService(StoreRepository storeRepository,
                          VoldemortMetadata metadata,
                          SchedulerService scheduler,
                          VoldemortConfig config) {
        super(ServiceType.STORAGE);
        this.voldemortConfig = config;
        this.scheduler = scheduler;
        this.storeRepository = storeRepository;
        this.metadata = metadata;
        this.cleanupPermits = new Semaphore(1);
        this.storageConfigs = new ConcurrentHashMap<String, StorageConfiguration>();
        this.clientThreadPool = new ClientThreadPool(config.getClientMaxThreads(),
                                                     config.getClientThreadIdleMs(),
                                                     config.getClientMaxQueuedRequests());
        this.socketPool = new SocketPool(config.getClientMaxConnectionsPerNode(),
                                         config.getClientConnectionTimeoutMs(),
                                         config.getSocketTimeoutMs(),
                                         config.getSocketBufferSize());

        FailureDetectorConfig failureDetectorConfig = new ServerFailureDetectorConfig(voldemortConfig,
                                                                                      storeRepository);
        failureDetector = FailureDetectorUtils.create(failureDetectorConfig);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509711846/fstmerge_var2_4375221972715474834

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_caed9_33d01/rev_caed9-33d01/src/java/voldemort/server/storage/StorageService.java
Conflict type: LineBasedMCFd
Conflict body: 
public Node(int id, String host, int httpPort, int socketPort, List<Integer> partitions) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509712270/fstmerge_var1_6243987065765291986
        this(id, host, httpPort, socketPort, -1, partitions, new NodeStatus());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509712270/fstmerge_base_8584545135266891267
        this(id, host, httpPort, socketPort, partitions, new NodeStatus());
=======
        this.id = id;
        this.host = Utils.notNull(host);
        this.httpPort = httpPort;
        this.socketPort = socketPort;
        this.partitions = ImmutableList.copyOf(partitions);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509712270/fstmerge_var2_8714231768241626203
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_caed9_33d01/rev_caed9-33d01/src/java/voldemort/cluster/Node.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509715508/fstmerge_var1_5201629647484182074
public RoutedStore(String name,
                       Map<Integer, Store<ByteArray, byte[]>> innerStores,
                       Cluster cluster,
                       StoreDefinition storeDef,
                       boolean repairReads,
                       ExecutorService threadPool,
                       long timeoutMs,
                       long nodeBannageMs,
                       Time time) {
        if(storeDef.getRequiredReads() < 1)
            throw new IllegalArgumentException("Cannot have a storeDef.getRequiredReads() number less than 1.");
        if(storeDef.getRequiredWrites() < 1)
            throw new IllegalArgumentException("Cannot have a storeDef.getRequiredWrites() number less than 1.");
        if(storeDef.getPreferredReads() < storeDef.getRequiredReads())
            throw new IllegalArgumentException("storeDef.getPreferredReads() must be greater or equal to storeDef.getRequiredReads().");
        if(storeDef.getPreferredWrites() < storeDef.getRequiredWrites())
            throw new IllegalArgumentException("storeDef.getPreferredWrites() must be greater or equal to storeDef.getRequiredWrites().");
        if(storeDef.getPreferredReads() > innerStores.size())
            throw new IllegalArgumentException("storeDef.getPreferredReads() is larger than the total number of nodes!");
        if(storeDef.getPreferredWrites() > innerStores.size())
            throw new IllegalArgumentException("storeDef.getPreferredWrites() is larger than the total number of nodes!");

        this.name = name;
        this.innerStores = new ConcurrentHashMap<Integer, Store<ByteArray, byte[]>>(innerStores);
        this.repairReads = repairReads;
        this.executor = threadPool;
        this.readRepairer = new ReadRepairer<ByteArray, byte[]>();
        this.timeoutMs = timeoutMs;
        this.nodeBannageMs = nodeBannageMs;
        this.time = Utils.notNull(time);
        this.cluster = cluster;
        this.storeDef = storeDef;

        this.routingStrategy = new RoutingStrategyFactory().updateRoutingStrategy(storeDef, cluster);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509715508/fstmerge_base_5391323983727225646
public RoutedStore(String name,
                       Map<Integer, Store<ByteArray, byte[]>> innerStores,
                       Cluster cluster,
                       StoreDefinition storeDef,
                       boolean repairReads,
                       ExecutorService threadPool,
                       long timeoutMs,
                       long nodeBannageMs,
                       Time time) {
        if(storeDef.getRequiredReads() < 1)
            throw new IllegalArgumentException("Cannot have a storeDef.getRequiredReads() number less than 1.");
        if(storeDef.getRequiredWrites() < 1)
            throw new IllegalArgumentException("Cannot have a storeDef.getRequiredWrites() number less than 1.");
        if(storeDef.getPreferredReads() < storeDef.getRequiredReads())
            throw new IllegalArgumentException("storeDef.getPreferredReads() must be greater or equal to storeDef.getRequiredReads().");
        if(storeDef.getPreferredWrites() < storeDef.getRequiredWrites())
            throw new IllegalArgumentException("storeDef.getPreferredWrites() must be greater or equal to storeDef.getRequiredWrites().");
        if(storeDef.getPreferredReads() > innerStores.size())
            throw new IllegalArgumentException("storeDef.getPreferredReads() is larger than the total number of nodes!");
        if(storeDef.getPreferredWrites() > innerStores.size())
            throw new IllegalArgumentException("storeDef.getPreferredWrites() is larger than the total number of nodes!");

        this.name = name;
        this.innerStores = new ConcurrentHashMap<Integer, Store<ByteArray, byte[]>>(innerStores);
        this.repairReads = repairReads;
        this.executor = threadPool;
        this.readRepairer = new ReadRepairer<ByteArray, byte[]>();
        this.timeoutMs = timeoutMs;
        this.nodeBannageMs = nodeBannageMs;
        this.time = Utils.notNull(time);
        this.cluster = cluster;
        this.storeDef = storeDef;

        this.routingStrategy = new RoutingStrategyFactory(this.cluster).getRoutingStrategy(storeDef);
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415509715508/fstmerge_var2_4285459258374314381

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_caed9_33d01/rev_caed9-33d01/src/java/voldemort/store/routed/RoutedStore.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_caed9_450f1/rev_caed9-450f1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_86ea8_d2b16/rev_86ea8-d2b16.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f4122_c1885/rev_f4122-c1885.revisions
Conflict type: LineBasedMCFd
Conflict body: 
private static Properties getEc2Properties() throws Exception {
        String propertiesFileName = System.getProperty("ec2PropertiesFile");

        String[] requireds = { "ec2AccessId", "ec2SecretKey", "ec2Ami", "ec2KeyPairId",
                "ec2HostUserId", "ec2VoldemortRootDirectory", "ec2VoldemortHomeDirectory",
                "ec2SourceDirectory", "ec2ParentDirectory", "ec2ClusterXmlFile",
                "ec2InstanceCount", "ec2RampTime", "ec2Iterations", "ec2NumRequests" };

        if(propertiesFileName == null)
            throw new Exception("ec2PropertiesFile system property must be defined that "
                                + "provides the path to file containing the following "
                                + "required Ec2SmokeTest properties: "
                                + StringUtils.join(requireds, ", "));

        Properties properties = new Properties();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415510208536/fstmerge_var1_5900730191254238927
        InputStream r = null;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415510208536/fstmerge_base_1910145303300687411
        Reader r = null;
=======
        InputStream in = null;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415510208536/fstmerge_var2_5079258462575353672

        try {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415510208536/fstmerge_var1_5900730191254238927
            r = new FileInputStream(propertiesFileName);
            properties.load(r);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415510208536/fstmerge_base_1910145303300687411
            r = new FileReader(propertiesFileName);
            properties.load(r);
=======
            in = new FileInputStream(propertiesFileName);
            properties.load(in);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415510208536/fstmerge_var2_5079258462575353672
        } finally {
            IOUtils.closeQuietly(in);
        }

        for(String required: requireds) {
            // Allow system properties to override
            if(System.getProperties().containsKey(required))
                properties.put(required, System.getProperty(required));

            if(!properties.containsKey(required))
                throw new Exception("Required properties for Ec2SmokeTest: "
                                    + StringUtils.join(requireds, ", ") + "; missing " + required);
        }

        return properties;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f4122_c1885/rev_f4122-c1885/contrib/ec2-testing/test/voldemort/utils/Ec2SmokeTest.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7bbd8_a4ba2/rev_7bbd8-a4ba2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_cf770_429ee/rev_cf770-429ee.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f4122_ed5b6/rev_f4122-ed5b6.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public static String createReadOnlyIndex(Cluster cluster,
                                             Map<String, String> data,
                                             String baseDir) throws Exception {
        // write data to file
        File dataFile = File.createTempFile("test", ".txt");
        dataFile.deleteOnExit();
        BufferedWriter writer = new BufferedWriter(new FileWriter(dataFile));
        for(Map.Entry<String, String> entry: data.entrySet())
            writer.write("\"" + entry.getKey() + "\"\t\"" + entry.getValue() + "\"\n");
        writer.close();
        BufferedReader reader = new BufferedReader(new FileReader(dataFile));
        JsonReader jsonReader = new JsonReader(reader);

        SerializerDefinition serDef = new SerializerDefinition("json", "'string'");
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415510737418/fstmerge_var1_5477896712084549699
        StoreDefinition storeDef = new StoreDefinition("test",
                                                       ReadOnlyStorageConfiguration.TYPE_NAME,
                                                       serDef,
                                                       serDef,
                                                       RoutingTier.CLIENT,
                                                       RoutingStrategyType.CONSISTENT_STRATEGY,
                                                       1,
                                                       1,
                                                       1,
                                                       1,
                                                       1,
                                                       1,
                                                       1);
        RoutingStrategy router = new RoutingStrategyFactory().updateRoutingStrategy(storeDef,
                                                                                    cluster);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415510737418/fstmerge_base_850415918484926766
        StoreDefinition storeDef = new StoreDefinition("test",
                                                       ReadOnlyStorageConfiguration.TYPE_NAME,
                                                       serDef,
                                                       serDef,
                                                       RoutingTier.CLIENT,
                                                       RoutingStrategyType.CONSISTENT_STRATEGY,
                                                       1,
                                                       1,
                                                       1,
                                                       1,
                                                       1,
                                                       1,
                                                       1);
        RoutingStrategy router = new RoutingStrategyFactory(cluster).getRoutingStrategy(storeDef);
=======
        StoreDefinition storeDef = new StoreDefinitionBuilder().setName("test")
                                                               .setType(ReadOnlyStorageConfiguration.TYPE_NAME)
                                                               .setKeySerializer(serDef)
                                                               .setValueSerializer(serDef)
                                                               .setRoutingPolicy(RoutingTier.CLIENT)
                                                               .setRoutingStrategyType(RoutingStrategyType.CONSISTENT_STRATEGY)
                                                               .setReplicationFactor(1)
                                                               .setPreferredReads(1)
                                                               .setRequiredReads(1)
                                                               .setPreferredWrites(1)
                                                               .setRequiredWrites(1)
                                                               .build();
        RoutingStrategy router = new RoutingStrategyFactory(cluster).getRoutingStrategy(storeDef);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415510737418/fstmerge_var2_8683074204677148711

        // make a temp dir
        File dataDir = new File(baseDir + File.separatorChar + "read-only-temp-index-"
                                + new Integer((int) (Math.random() * 1000)));
        // build and open store
        JsonStoreBuilder storeBuilder = new JsonStoreBuilder(jsonReader,
                                                             cluster,
                                                             storeDef,
                                                             router,
                                                             dataDir,
                                                             null,
                                                             100,
                                                             1,
                                                             2,
                                                             10000);
        storeBuilder.build();

        return dataDir.getAbsolutePath();
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f4122_ed5b6/rev_f4122-ed5b6/test/common/voldemort/TestUtils.java
Conflict type: LineBasedMCFd
Conflict body: 
public static ReadOnlyStorageEngineTestInstance create(File baseDir,
                                                           int testSize,
                                                           int numNodes,
                                                           int repFactor) throws Exception {
        // create some test data
        Map<String, String> data = createTestData(testSize);
        JsonReader reader = makeTestDataReader(data, baseDir);

        // set up definitions for cluster and store
        List<Node> nodes = new ArrayList<Node>();
        for(int i = 0; i < numNodes; i++) {
            nodes.add(new Node(i, "localhost", 8080 + i, 6666 + i, Arrays.asList(4 * i,
                                                                                 4 * i + 1,
                                                                                 4 * i + 2,
                                                                                 4 * i + 3)));
        }
        Cluster cluster = new Cluster("test", nodes);
        SerializerDefinition serDef = new SerializerDefinition("json", "'string'");
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415510738832/fstmerge_var1_1923228462353817681
        StoreDefinition storeDef = new StoreDefinition("test",
                                                       ReadOnlyStorageConfiguration.TYPE_NAME,
                                                       serDef,
                                                       serDef,
                                                       RoutingTier.CLIENT,
                                                       RoutingStrategyType.CONSISTENT_STRATEGY,
                                                       repFactor,
                                                       1,
                                                       1,
                                                       1,
                                                       1,
                                                       1,
                                                       1);
        RoutingStrategy router = new RoutingStrategyFactory().updateRoutingStrategy(storeDef,
                                                                                    cluster);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415510738832/fstmerge_base_429058379373591196
        StoreDefinition storeDef = new StoreDefinition("test",
                                                       ReadOnlyStorageConfiguration.TYPE_NAME,
                                                       serDef,
                                                       serDef,
                                                       RoutingTier.CLIENT,
                                                       RoutingStrategyType.CONSISTENT_STRATEGY,
                                                       repFactor,
                                                       1,
                                                       1,
                                                       1,
                                                       1,
                                                       1,
                                                       1);
        RoutingStrategy router = new RoutingStrategyFactory(cluster).getRoutingStrategy(storeDef);
=======
        StoreDefinition storeDef = new StoreDefinitionBuilder().setName("test")
                                                               .setType(ReadOnlyStorageConfiguration.TYPE_NAME)
                                                               .setKeySerializer(serDef)
                                                               .setValueSerializer(serDef)
                                                               .setRoutingPolicy(RoutingTier.CLIENT)
                                                               .setRoutingStrategyType(RoutingStrategyType.CONSISTENT_STRATEGY)
                                                               .setReplicationFactor(repFactor)
                                                               .setPreferredReads(1)
                                                               .setRequiredReads(1)
                                                               .setPreferredWrites(1)
                                                               .setRequiredWrites(1)
                                                               .build();

        RoutingStrategy router = new RoutingStrategyFactory(cluster).getRoutingStrategy(storeDef);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415510738832/fstmerge_var2_777829667094764654

        // build store files in outputDir
        File outputDir = TestUtils.createTempDir(baseDir);
        JsonStoreBuilder storeBuilder = new JsonStoreBuilder(reader,
                                                             cluster,
                                                             storeDef,
                                                             router,
                                                             outputDir,
                                                             null,
                                                             testSize / 5,
                                                             1,
                                                             2,
                                                             10000);
        storeBuilder.build();

        File nodeDir = TestUtils.createTempDir(baseDir);
        @SuppressWarnings("unchecked")
        Serializer<String> serializer = (Serializer<String>) new DefaultSerializerFactory().getSerializer(serDef);
        Map<Integer, Store<String, String>> nodeStores = Maps.newHashMap();
        for(int i = 0; i < numNodes; i++) {
            File currNode = new File(nodeDir, Integer.toString(i));
            currNode.mkdirs();
            currNode.deleteOnExit();
            Utils.move(new File(outputDir, "node-" + Integer.toString(i)), new File(currNode,
                                                                                    "version-0"));
            nodeStores.put(i, SerializingStore.wrap(new ReadOnlyStorageEngine("test", currNode, 1),
                                                    serializer,
                                                    serializer));
        }

        return new ReadOnlyStorageEngineTestInstance(data, baseDir, nodeStores, router, serializer);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f4122_ed5b6/rev_f4122-ed5b6/test/unit/voldemort/store/readonly/ReadOnlyStorageEngineTestInstance.java
Conflict type: LineBasedMCFd
Conflict body: 
public String bootstrapMetadataWithRetries(String key, URI[] urls) {
        int nTries = 0;
        while(nTries++ < this.maxBootstrapRetries) {
            try {
                return bootstrapMetadata(key, urls);
            } catch(BootstrapFailureException e) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415510739797/fstmerge_var1_194645859700819299
                if(nTries < this.maxBootstrapRetries) {
                    int backOffTime = 5 * nTries;
                    logger.warn("Failed to bootstrap will try again after " + backOffTime + "s.");
                    try {
                        Thread.sleep(backOffTime * 1000);
                    } catch(InterruptedException e1) {
                        throw new RuntimeException(e1);
                    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415510739797/fstmerge_base_6120667117134434914
                int backOffTime = 5 * nTries;
                logger.warn("Failed to bootstrap will try again after" + backOffTime);
                try {
                    Thread.sleep(backOffTime * 1000);
                } catch(InterruptedException e1) {
                    throw new RuntimeException(e1);
=======
                int backOffTime = 5 * nTries;
                logger.warn("Failed to bootstrap will try again after " + backOffTime);
                try {
                    Thread.sleep(backOffTime * 1000);
                } catch(InterruptedException e1) {
                    throw new RuntimeException(e1);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415510739797/fstmerge_var2_131772028696944178
                }
            }
        }

        throw new BootstrapFailureException("No available boostrap servers found!");
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f4122_ed5b6/rev_f4122-ed5b6/src/java/voldemort/client/AbstractStoreClientFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415510750535/fstmerge_var1_2478728452163130226
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415510750535/fstmerge_base_6619892727982327173
public static MetadataStore readFromDirectory(File dir) {
        if(!Utils.isReadableDir(dir))
            throw new IllegalArgumentException("Metadata directory " + dir.getAbsolutePath()
                                               + " does not exist or can not be read.");
        if(dir.listFiles() == null)
            throw new IllegalArgumentException("No configuration found in " + dir.getAbsolutePath()
                                               + ".");
        Store<String, String> innerStore = new FilesystemStorageEngine(MetadataStore.METADATA_STORE_NAME,
                                                                       dir.getAbsolutePath());
        return new MetadataStore(innerStore);
    }
=======
public static MetadataStore readFromDirectory(File dir) {
        if(!Utils.isReadableDir(dir))
            throw new IllegalArgumentException("Metadata directory " + dir.getAbsolutePath()
                                               + " does not exist or can not be read.");
        if(dir.listFiles() == null)
            throw new IllegalArgumentException("No configuration found in " + dir.getAbsolutePath()
                                               + ".");
        Store<String, String> innerStore = new TextFileStorageEngine(MetadataStore.METADATA_STORE_NAME,
                                                                     dir.getAbsolutePath());
        return new MetadataStore(innerStore);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415510750535/fstmerge_var2_8660887820309047461

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f4122_ed5b6/rev_f4122-ed5b6/src/java/voldemort/store/metadata/MetadataStore.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bd9a3_34d0c/rev_bd9a3-34d0c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_dd363_61293/rev_dd363-61293.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_883c0_6c955/rev_883c0-6c955.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_1f704_38280/rev_1f704-38280.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_fa9f7_e8b1c/rev_fa9f7-e8b1c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_23194_6d30c/rev_23194-6d30c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f085f_8f699/rev_f085f-8f699.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_29a6e_7e263/rev_29a6e-7e263.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_29a6e_c9095/rev_29a6e-c9095.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415512445256/fstmerge_var1_1042212561203171306
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415512445256/fstmerge_base_5857191764278461563
public ProtoBuffAdminServiceRequestHandler(ErrorCodeMapper errorCodeMapper,
                                               StoreRepository storeRepository,
                                               MetadataStore metadataStore,
                                               VoldemortConfig voldemortConfig,
                                               AsyncOperationRunner asyncRunner) {
        this.errorCodeMapper = errorCodeMapper;
        this.metadataStore = metadataStore;
        this.storeRepository = storeRepository;
        this.voldemortConfig = voldemortConfig;
        this.networkClassLoader = new NetworkClassLoader(Thread.currentThread()
                                                               .getContextClassLoader());
        this.asyncRunner = asyncRunner;
        this.adminClient = RebalanceUtils.createTempAdminClient(voldemortConfig,
                                                                metadataStore.getCluster());
    }
=======
public ProtoBuffAdminServiceRequestHandler(ErrorCodeMapper errorCodeMapper,
                                               StoreRepository storeRepository,
                                               MetadataStore metadataStore,
                                               VoldemortConfig voldemortConfig,
                                               AsyncOperationRunner asyncRunner) {
        this.errorCodeMapper = errorCodeMapper;
        this.metadataStore = metadataStore;
        this.storeRepository = storeRepository;
        this.voldemortConfig = voldemortConfig;
        this.networkClassLoader = null;
        this.asyncRunner = asyncRunner;
        this.adminClient = RebalanceUtils.createTempAdminClient(voldemortConfig,
                                                                metadataStore.getCluster());
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415512445256/fstmerge_var2_2509825325494036067

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_29a6e_c9095/rev_29a6e-c9095/src/java/voldemort/server/protocol/admin/ProtoBuffAdminServiceRequestHandler.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415512445568/fstmerge_var1_515176059208497182
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415512445568/fstmerge_base_7626075755572761240
public int rebalanceLocalNode(final MetadataStore metadataStore,
                                  final VoldemortConfig config,
                                  final String storeName,
                                  final RebalanceStealInfo stealInfo,
                                  final AsyncOperationRunner asyncRunner) {
        int requestId = asyncRunner.getUniqueRequestId();

        asyncRunner.submitOperation(requestId, new AsyncOperation(requestId, stealInfo.toString()) {

            private int fetchAndUpdateAsyncId = -1;

            @Override
            public void operate() throws Exception {
                synchronized(metadataStore) {
                    checkCurrentState(metadataStore, stealInfo);
                    setRebalancingState(metadataStore, stealInfo);
                }

                AdminClient adminClient = RebalanceUtils.createTempAdminClient(config,
                                                                               metadataStore.getCluster());

                try {
                    fetchAndUpdateAsyncId = adminClient.fetchAndUpdateStreams(stealInfo.getDonorId(),
                                                                              metadataStore.getNodeId(),
                                                                              storeName,
                                                                              stealInfo.getPartitionList(),
                                                                              null);
                    logger.info("rebalance internal async Id:" + fetchAndUpdateAsyncId);
                    adminClient.waitForCompletion(metadataStore.getNodeId(),
                                                  fetchAndUpdateAsyncId,
                                                  24 * 60 * 60,
                                                  TimeUnit.SECONDS);

                } finally {
                    adminClient.stop();
                }

                // clean state only if successfull.
                metadataStore.cleanAllRebalancingState();
            }

            @Override
            @JmxGetter(name = "asyncTaskStatus")
            public AsyncOperationStatus getStatus() {
                if(-1 != fetchAndUpdateAsyncId && !asyncRunner.isComplete(fetchAndUpdateAsyncId))
                    updateStatus(asyncRunner.getStatus(fetchAndUpdateAsyncId));

                return super.getStatus();
            }
        });

        logger.info("rebalance node request_id:" + requestId);
        return requestId;
    }
=======
public int rebalanceLocalNode(final MetadataStore metadataStore,
                                  final VoldemortConfig config,
                                  final String storeName,
                                  final RebalanceStealInfo stealInfo,
                                  final AsyncOperationRunner asyncRunner) {
        int requestId = asyncRunner.getUniqueRequestId();

        asyncRunner.submitOperation(requestId, new AsyncOperation(requestId, stealInfo.toString()) {

            private int fetchAndUpdateAsyncId = -1;

            @Override
            public void operate() throws Exception {
                synchronized(metadataStore) {
                    checkCurrentState(metadataStore, stealInfo);
                    setRebalancingState(metadataStore, stealInfo);
                }

                AdminClient adminClient = RebalanceUtils.createTempAdminClient(config,
                                                                               metadataStore.getCluster());

                try {
                    fetchAndUpdateAsyncId = adminClient.fetchAndUpdateStreams(stealInfo.getDonorId(),
                                                                              metadataStore.getNodeId(),
                                                                              storeName,
                                                                              stealInfo.getPartitionList(),
                                                                              null);
                    logger.debug("rebalance internal async Id:" + fetchAndUpdateAsyncId);
                    adminClient.waitForCompletion(metadataStore.getNodeId(),
                                                  fetchAndUpdateAsyncId,
                                                  24 * 60 * 60,
                                                  TimeUnit.SECONDS);
                    logger.info("rebalance " + stealInfo + " completed successfully.");

                } finally {
                    adminClient.stop();
                }

                // clean state only if successfull.
                metadataStore.cleanAllRebalancingState();
            }

            @Override
            @JmxGetter(name = "asyncTaskStatus")
            public AsyncOperationStatus getStatus() {
                if(-1 != fetchAndUpdateAsyncId && !asyncRunner.isComplete(fetchAndUpdateAsyncId))
                    updateStatus(asyncRunner.getStatus(fetchAndUpdateAsyncId));

                return super.getStatus();
            }
        });

        logger.debug("rebalance node request_id:" + requestId);
        return requestId;
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415512445568/fstmerge_var2_726456430177105588

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_29a6e_c9095/rev_29a6e-c9095/src/java/voldemort/server/rebalance/Rebalancer.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_233e2_421e3/rev_233e2-421e3.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415512628536/fstmerge_var1_7346140862015535127
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415512628536/fstmerge_base_8088777392271661323
public static ReadOnlyStorageEngineTestInstance create(File baseDir,
                                                           int testSize,
                                                           int numNodes,
                                                           int repFactor) throws Exception {
        // create some test data
        Map<String, String> data = createTestData(testSize);
        JsonReader reader = makeTestDataReader(data, baseDir);

        // set up definitions for cluster and store
        List<Node> nodes = new ArrayList<Node>();
        for(int i = 0; i < numNodes; i++) {
            nodes.add(new Node(i, "localhost", 8080 + i, 6666 + i, Arrays.asList(4 * i,
                                                                                 4 * i + 1,
                                                                                 4 * i + 2,
                                                                                 4 * i + 3)));
        }
        Cluster cluster = new Cluster("test", nodes);
        SerializerDefinition serDef = new SerializerDefinition("json", "'string'");
        StoreDefinition storeDef = new StoreDefinition("test",
                                                       ReadOnlyStorageConfiguration.TYPE_NAME,
                                                       serDef,
                                                       serDef,
                                                       RoutingTier.CLIENT,
                                                       RoutingStrategyType.CONSISTENT_STRATEGY,
                                                       repFactor,
                                                       1,
                                                       1,
                                                       1,
                                                       1,
                                                       1,
                                                       1);
        RoutingStrategy router = new RoutingStrategyFactory().updateRoutingStrategy(storeDef,
                                                                                    cluster);

        // build store files in outputDir
        File outputDir = TestUtils.createTempDir(baseDir);
        JsonStoreBuilder storeBuilder = new JsonStoreBuilder(reader,
                                                             cluster,
                                                             storeDef,
                                                             router,
                                                             outputDir,
                                                             null,
                                                             testSize / 5,
                                                             1,
                                                             2,
                                                             10000);
        storeBuilder.build();

        File nodeDir = TestUtils.createTempDir(baseDir);
        @SuppressWarnings("unchecked")
        Serializer<String> serializer = (Serializer<String>) new DefaultSerializerFactory().getSerializer(serDef);
        Map<Integer, Store<String, String>> nodeStores = Maps.newHashMap();
        for(int i = 0; i < numNodes; i++) {
            File currNode = new File(nodeDir, Integer.toString(i));
            currNode.mkdirs();
            currNode.deleteOnExit();
            Utils.move(new File(outputDir, "node-" + Integer.toString(i)), new File(currNode,
                                                                                    "version-0"));
            nodeStores.put(i,
                           new SerializingStore<String, String>(new ReadOnlyStorageEngine("test",
                                                                                          currNode,
                                                                                          1,
                                                                                          3,
                                                                                          1000),
                                                                serializer,
                                                                serializer));
        }

        return new ReadOnlyStorageEngineTestInstance(data, baseDir, nodeStores, router, serializer);
    }
=======
public static ReadOnlyStorageEngineTestInstance create(File baseDir,
                                                           int testSize,
                                                           int numNodes,
                                                           int repFactor) throws Exception {
        // create some test data
        Map<String, String> data = createTestData(testSize);
        JsonReader reader = makeTestDataReader(data, baseDir);

        // set up definitions for cluster and store
        List<Node> nodes = new ArrayList<Node>();
        for(int i = 0; i < numNodes; i++) {
            nodes.add(new Node(i,
                               "localhost",
                               8080 + i,
                               6666 + i,
                               7000 + i,
                               Arrays.asList(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3)));
        }
        Cluster cluster = new Cluster("test", nodes);
        SerializerDefinition serDef = new SerializerDefinition("json", "'string'");
        StoreDefinition storeDef = new StoreDefinition("test",
                                                       ReadOnlyStorageConfiguration.TYPE_NAME,
                                                       serDef,
                                                       serDef,
                                                       RoutingTier.CLIENT,
                                                       RoutingStrategyType.CONSISTENT_STRATEGY,
                                                       repFactor,
                                                       1,
                                                       1,
                                                       1,
                                                       1,
                                                       1,
                                                       1);
        RoutingStrategy router = new RoutingStrategyFactory().updateRoutingStrategy(storeDef,
                                                                                    cluster);

        // build store files in outputDir
        File outputDir = TestUtils.createTempDir(baseDir);
        JsonStoreBuilder storeBuilder = new JsonStoreBuilder(reader,
                                                             cluster,
                                                             storeDef,
                                                             router,
                                                             outputDir,
                                                             null,
                                                             testSize / 5,
                                                             1,
                                                             2,
                                                             10000);
        storeBuilder.build();

        File nodeDir = TestUtils.createTempDir(baseDir);
        @SuppressWarnings("unchecked")
        Serializer<String> serializer = (Serializer<String>) new DefaultSerializerFactory().getSerializer(serDef);
        Map<Integer, Store<String, String>> nodeStores = Maps.newHashMap();
        for(int i = 0; i < numNodes; i++) {
            File currNode = new File(nodeDir, Integer.toString(i));
            currNode.mkdirs();
            currNode.deleteOnExit();
            Utils.move(new File(outputDir, "node-" + Integer.toString(i)), new File(currNode,
                                                                                    "version-0"));
            nodeStores.put(i,
                           new SerializingStore<String, String>(new ReadOnlyStorageEngine("test",
                                                                                          currNode,
                                                                                          1,
                                                                                          3,
                                                                                          1000),
                                                                serializer,
                                                                serializer));
        }

        return new ReadOnlyStorageEngineTestInstance(data, baseDir, nodeStores, router, serializer);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415512628536/fstmerge_var2_3936739311114319078

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_233e2_421e3/rev_233e2-421e3/test/unit/voldemort/store/readonly/ReadOnlyStorageEngineTestInstance.java
Conflict type: LineBasedMCFd
Conflict body: 
public VoldemortConfig(Props props) {
        try {
            this.nodeId = props.getInt("node.id");
        } catch(UndefinedPropertyException e) {
            this.nodeId = getIntEnvVariable(VOLDEMORT_NODE_ID_VAR_NAME);
        }
        this.voldemortHome = props.getString("voldemort.home");
        this.dataDirectory = props.getString("data.directory", this.voldemortHome + File.separator
                                                               + "data");
        this.metadataDirectory = props.getString("metadata.directory", voldemortHome
                                                                       + File.separator + "config");

        this.bdbCacheSize = props.getBytes("bdb.cache.size", 200 * 1024 * 1024);
        this.bdbWriteTransactions = props.getBoolean("bdb.write.transactions", false);
        this.bdbFlushTransactions = props.getBoolean("bdb.flush.transactions", false);
        this.bdbDataDirectory = props.getString("bdb.data.directory", this.dataDirectory
                                                                      + File.separator + "bdb");
        this.bdbMaxLogFileSize = props.getBytes("bdb.max.logfile.size", 60 * 1024 * 1024);
        this.bdbBtreeFanout = props.getInt("bdb.btree.fanout", 512);
        this.bdbCheckpointBytes = props.getLong("bdb.checkpoint.interval.bytes", 20 * 1024 * 1024);
        this.bdbCheckpointMs = props.getLong("bdb.checkpoint.interval.ms", 30 * Time.MS_PER_SECOND);
        this.bdbSortedDuplicates = props.getBoolean("bdb.enable.sorted.duplicates", true);
        this.bdbOneEnvPerStore = props.getBoolean("bdb.one.env.per.store", false);
        this.bdbCleanerMinFileUtilization = props.getInt("bdb.cleaner.min.file.utilization", 5);
        this.bdbCleanerMinUtilization = props.getInt("bdb.cleaner.minUtilization", 50);

        // enabling preload make cursor slow for insufficient bdb cache size.
        this.bdbCursorPreload = props.getBoolean("bdb.cursor.preload", false);

        this.readOnlyBackups = props.getInt("readonly.backups", 1);
        this.readOnlySearchStrategy = props.getString("readonly.search.strategy",
                                                      BinarySearchStrategy.class.getName());
        this.readOnlyStorageDir = props.getString("readonly.data.directory", this.dataDirectory
                                                                             + File.separator
                                                                             + "read-only");

        this.slopStoreType = props.getString("slop.store.engine", BdbStorageConfiguration.TYPE_NAME);

        this.mysqlUsername = props.getString("mysql.user", "root");
        this.mysqlPassword = props.getString("mysql.password", "");
        this.mysqlHost = props.getString("mysql.host", "localhost");
        this.mysqlPort = props.getInt("mysql.port", 3306);
        this.mysqlDatabaseName = props.getString("mysql.database", "voldemort");

        this.maxThreads = props.getInt("max.threads", 100);
        this.coreThreads = props.getInt("core.threads", Math.max(1, maxThreads / 2));

        // Admin client should have less threads but very high buffer size.
        this.adminMaxThreads = props.getInt("admin.max.threads", 10);
        this.adminCoreThreads = props.getInt("admin.core.threads", Math.max(1, adminMaxThreads / 2));
        this.adminStreamBufferSize = (int) props.getBytes("admin.streams.buffer.size",
                                                          10 * 1000 * 1000);
        this.adminConnectionTimeout = props.getInt("admin.client.socket.timeout.ms", 5 * 60 * 1000);
        this.adminSocketTimeout = props.getInt("admin.client.socket.timeout.ms", 10000);

        this.streamMaxReadBytesPerSec = props.getInt("stream.read.byte.per.sec", 1 * 1000 * 1000);
        this.streamMaxWriteBytesPerSec = props.getInt("stream.write.byte.per.sec", 1 * 1000 * 1000);

        this.socketTimeoutMs = props.getInt("socket.timeout.ms", 4000);
        this.socketBufferSize = (int) props.getBytes("socket.buffer.size", 32 * 1024);

        this.useNioConnector = props.getBoolean("enable.nio.connector", false);
        this.nioConnectorSelectors = props.getInt("nio.connector.selectors",
                                                  Runtime.getRuntime().availableProcessors());

        this.clientMaxConnectionsPerNode = props.getInt("client.max.connections.per.node", 5);
        this.clientConnectionTimeoutMs = props.getInt("client.connection.timeout.ms", 400);
        this.clientRoutingTimeoutMs = props.getInt("client.routing.timeout.ms", 5000);
        this.clientNodeBannageMs = props.getInt("client.node.bannage.ms", 10000);
        this.clientMaxThreads = props.getInt("client.max.threads", 100);
        this.clientThreadIdleMs = props.getInt("client.thread.idle.ms", 5000);
        this.clientMaxQueuedRequests = props.getInt("client.max.queued.requests", 1000);

        this.enableHttpServer = props.getBoolean("http.enable", true);
        this.enableSocketServer = props.getBoolean("socket.enable", true);
        this.enableAdminServer = props.getBoolean("admin.enable", true);
        this.enableJmx = props.getBoolean("jmx.enable", true);
        this.enableSlop = props.getBoolean("slop.enable", true);
        this.enableVerboseLogging = props.getBoolean("enable.verbose.logging", true);
        this.enableStatTracking = props.getBoolean("enable.stat.tracking", true);
        this.enableServerRouting = props.getBoolean("enable.server.routing", true);
        this.enableMetadataChecking = props.getBoolean("enable.metadata.checking", true);
        this.enableRedirectRouting = props.getBoolean("enable.redirect.routing", true);

        this.pusherPollMs = props.getInt("pusher.poll.ms", 2 * 60 * 1000);

        this.schedulerThreads = props.getInt("scheduler.threads", 3);

        this.numCleanupPermits = props.getInt("num.cleanup.permits", 1);

        this.storageConfigurations = props.getList("storage.configs",
                                                   ImmutableList.of(BdbStorageConfiguration.class.getName(),
                                                                    MysqlStorageConfiguration.class.getName(),
                                                                    InMemoryStorageConfiguration.class.getName(),
                                                                    CacheStorageConfiguration.class.getName(),
                                                                    ReadOnlyStorageConfiguration.class.getName()));

        // start at midnight (0-23)
        this.retentionCleanupFirstStartTimeInHour = props.getInt("retention.cleanup.first.start.hour",
                                                                 0);
        // repeat every 24 hours
        this.retentionCleanupScheduledPeriodInHour = props.getInt("retention.cleanup.period.hours",
                                                                  24);

        // save props for access from plugins
        this.allProps = props;

        String requestFormatName = props.getString("request.format",
                                                   RequestFormatType.VOLDEMORT_V1.getCode());
        this.requestFormatType = RequestFormatType.fromCode(requestFormatName);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415512638991/fstmerge_var1_5419603317142734
        // network class loader disable by default.
        this.enableNetworkClassLoader = props.getBoolean("enable.network.classloader", false);

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415512638991/fstmerge_base_3812068629367512978
=======
        this.failureDetector = props.getString("failure.detector",
                                               BannagePeriodFailureDetector.class.getName());

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415512638991/fstmerge_var2_8314195062366090421
        validateParams();
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_233e2_421e3/rev_233e2-421e3/src/java/voldemort/server/VoldemortConfig.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_db4c0_5d8be/rev_db4c0-5d8be.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a8ed5_39c00/rev_a8ed5-39c00.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_ba08d_f1cae/rev_ba08d-f1cae.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_56c56_0843f/rev_56c56-0843f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_9af5a_89ebf/rev_9af5a-89ebf.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_37e2b_0d3e5/rev_37e2b-0d3e5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_249d3_40081/rev_249d3-40081.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_15566_2e97c/rev_15566-2e97c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_cfb8b_bd364/rev_cfb8b-bd364.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6293a_15566/rev_6293a-15566.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_66a2a_fe561/rev_66a2a-fe561.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_47cd1_22cc1/rev_47cd1-22cc1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public void setUp() throws IOException {
        cluster = ServerTestUtils.getLocalCluster(2);
        VoldemortConfig config = ServerTestUtils.createServerConfig(0,
                                                                    TestUtils.createTempDir()
                                                                             .getAbsolutePath(),
                                                                    null,
                                                                    storesXmlfile);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515121168/fstmerge_var1_5443019323969826726
        config.setEnableNetworkClassLoader(true);

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515121168/fstmerge_base_7123392497899719795
=======
        // TODO: network class loader is disabled.
        // config.setEnableNetworkClassLoader(true);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515121168/fstmerge_var2_4901989634121729118
        server = new VoldemortServer(config, cluster);
        server.start();

        adminClient = ServerTestUtils.getAdminClient(cluster);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/test/unit/voldemort/client/AdminServiceFilterTest.java
Conflict type: LineBasedMCFd
Conflict body: 
public static RequestType valueOf(int value) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515123830/fstmerge_var1_7836859365854595224
            switch(value) {
                case 0:
                    return GET;
                case 1:
                    return GET_ALL;
                case 2:
                    return PUT;
                case 3:
                    return DELETE;
                case 4:
                    return GET_VERSION;
                default:
                    return null;
            }
        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515123830/fstmerge_base_1105700879630809219
      switch (value) {
        case 0: return GET;
        case 1: return GET_ALL;
        case 2: return PUT;
        case 3: return DELETE;
        case 4: return GET_VERSION;
        default: return null;
      }
    }
=======
      switch (value) {
        case 0: return GET;
        case 1: return GET_ALL;
        case 2: return PUT;
        case 3: return DELETE;
        case 4: return GET_VERSION;
        case 5: return GET_UNCHECKED;
        default: return null;
      }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515123830/fstmerge_var2_5315815695864077347

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/src/java/voldemort/client/protocol/pb/VProto.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ private static final RequestType[] VALUES = { GET, GET_ALL, PUT, DELETE, GET_VERSION, }; ##FSTMerge## private static final RequestType[] VALUES = {
      GET, GET_ALL, PUT, DELETE, GET_VERSION, 
    }; ##FSTMerge## private static final RequestType[] VALUES = {
      GET, GET_ALL, PUT, DELETE, GET_VERSION, GET_UNCHECKED, 
    };
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/src/java/voldemort/client/protocol/pb/VProto.java
Conflict type: LineBasedMCFd
Conflict body: 
public static AdminRequestType valueOf(int value) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515127649/fstmerge_var1_7325628358831151466
            switch(value) {
                case 0:
                    return GET_METADATA;
                case 1:
                    return UPDATE_METADATA;
                case 2:
                    return UPDATE_PARTITION_ENTRIES;
                case 3:
                    return FETCH_PARTITION_ENTRIES;
                case 4:
                    return DELETE_PARTITION_ENTRIES;
                case 5:
                    return INITIATE_FETCH_AND_UPDATE;
                case 6:
                    return ASYNC_OPERATION_STATUS;
                default:
                    return null;
            }
        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515127649/fstmerge_base_8463527786713724733
      switch (value) {
        case 0: return GET_METADATA;
        case 1: return UPDATE_METADATA;
        case 2: return UPDATE_PARTITION_ENTRIES;
        case 3: return FETCH_PARTITION_ENTRIES;
        case 4: return DELETE_PARTITION_ENTRIES;
        case 5: return INITIATE_FETCH_AND_UPDATE;
        case 6: return ASYNC_OPERATION_STATUS;
        default: return null;
      }
    }
=======
      switch (value) {
        case 0: return GET_METADATA;
        case 1: return UPDATE_METADATA;
        case 2: return UPDATE_PARTITION_ENTRIES;
        case 3: return FETCH_PARTITION_ENTRIES;
        case 4: return DELETE_PARTITION_ENTRIES;
        case 5: return INITIATE_FETCH_AND_UPDATE;
        case 6: return ASYNC_OPERATION_STATUS;
        case 7: return INITIATE_REBALANCE_NODE;
        default: return null;
      }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515127649/fstmerge_var2_515086853712153191

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ private static final AdminRequestType[] VALUES = { GET_METADATA, UPDATE_METADATA,
                UPDATE_PARTITION_ENTRIES, FETCH_PARTITION_ENTRIES, DELETE_PARTITION_ENTRIES,
                INITIATE_FETCH_AND_UPDATE, ASYNC_OPERATION_STATUS, }; ##FSTMerge## private static final AdminRequestType[] VALUES = {
      GET_METADATA, UPDATE_METADATA, UPDATE_PARTITION_ENTRIES, FETCH_PARTITION_ENTRIES, DELETE_PARTITION_ENTRIES, INITIATE_FETCH_AND_UPDATE, ASYNC_OPERATION_STATUS, 
    }; ##FSTMerge## private static final AdminRequestType[] VALUES = {
      GET_METADATA, UPDATE_METADATA, UPDATE_PARTITION_ENTRIES, FETCH_PARTITION_ENTRIES, DELETE_PARTITION_ENTRIES, INITIATE_FETCH_AND_UPDATE, ASYNC_OPERATION_STATUS, INITIATE_REBALANCE_NODE, 
    };
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515131664/fstmerge_var1_2887457886786541055
@Override
        public final boolean isInitialized() {
            if(!hasType)
                return false;
            if(hasGetMetadata()) {
                if(!getGetMetadata().isInitialized())
                    return false;
            }
            if(hasUpdateMetadata()) {
                if(!getUpdateMetadata().isInitialized())
                    return false;
            }
            if(hasUpdatePartitionEntries()) {
                if(!getUpdatePartitionEntries().isInitialized())
                    return false;
            }
            if(hasFetchPartitionEntries()) {
                if(!getFetchPartitionEntries().isInitialized())
                    return false;
            }
            if(hasDeletePartitionEntries()) {
                if(!getDeletePartitionEntries().isInitialized())
                    return false;
            }
            if(hasInitiateFetchAndUpdate()) {
                if(!getInitiateFetchAndUpdate().isInitialized())
                    return false;
            }
            if(hasAsyncOperationStatus()) {
                if(!getAsyncOperationStatus().isInitialized())
                    return false;
            }
            return true;
        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515131664/fstmerge_base_6105419850361452778
public final boolean isInitialized() {
      if (!hasType) return false;
      if (hasGetMetadata()) {
        if (!getGetMetadata().isInitialized()) return false;
      }
      if (hasUpdateMetadata()) {
        if (!getUpdateMetadata().isInitialized()) return false;
      }
      if (hasUpdatePartitionEntries()) {
        if (!getUpdatePartitionEntries().isInitialized()) return false;
      }
      if (hasFetchPartitionEntries()) {
        if (!getFetchPartitionEntries().isInitialized()) return false;
      }
      if (hasDeletePartitionEntries()) {
        if (!getDeletePartitionEntries().isInitialized()) return false;
      }
      if (hasInitiateFetchAndUpdate()) {
        if (!getInitiateFetchAndUpdate().isInitialized()) return false;
      }
      if (hasAsyncOperationStatus()) {
        if (!getAsyncOperationStatus().isInitialized()) return false;
      }
      return true;
    }
=======
public final boolean isInitialized() {
      if (!hasType) return false;
      if (hasGetMetadata()) {
        if (!getGetMetadata().isInitialized()) return false;
      }
      if (hasUpdateMetadata()) {
        if (!getUpdateMetadata().isInitialized()) return false;
      }
      if (hasUpdatePartitionEntries()) {
        if (!getUpdatePartitionEntries().isInitialized()) return false;
      }
      if (hasFetchPartitionEntries()) {
        if (!getFetchPartitionEntries().isInitialized()) return false;
      }
      if (hasDeletePartitionEntries()) {
        if (!getDeletePartitionEntries().isInitialized()) return false;
      }
      if (hasInitiateFetchAndUpdate()) {
        if (!getInitiateFetchAndUpdate().isInitialized()) return false;
      }
      if (hasAsyncOperationStatus()) {
        if (!getAsyncOperationStatus().isInitialized()) return false;
      }
      if (hasInitiateRebalanceNode()) {
        if (!getInitiateRebalanceNode().isInitialized()) return false;
      }
      return true;
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515131664/fstmerge_var2_3902162184851157549

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515131669/fstmerge_var1_486198240880643821
@Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
            if(hasType()) {
                output.writeEnum(1, getType().getNumber());
            }
            if(hasGetMetadata()) {
                output.writeMessage(2, getGetMetadata());
            }
            if(hasUpdateMetadata()) {
                output.writeMessage(3, getUpdateMetadata());
            }
            if(hasUpdatePartitionEntries()) {
                output.writeMessage(4, getUpdatePartitionEntries());
            }
            if(hasFetchPartitionEntries()) {
                output.writeMessage(5, getFetchPartitionEntries());
            }
            if(hasDeletePartitionEntries()) {
                output.writeMessage(6, getDeletePartitionEntries());
            }
            if(hasInitiateFetchAndUpdate()) {
                output.writeMessage(7, getInitiateFetchAndUpdate());
            }
            if(hasAsyncOperationStatus()) {
                output.writeMessage(8, getAsyncOperationStatus());
            }
            getUnknownFields().writeTo(output);
        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515131669/fstmerge_base_25375120285051298
public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (hasType()) {
        output.writeEnum(1, getType().getNumber());
      }
      if (hasGetMetadata()) {
        output.writeMessage(2, getGetMetadata());
      }
      if (hasUpdateMetadata()) {
        output.writeMessage(3, getUpdateMetadata());
      }
      if (hasUpdatePartitionEntries()) {
        output.writeMessage(4, getUpdatePartitionEntries());
      }
      if (hasFetchPartitionEntries()) {
        output.writeMessage(5, getFetchPartitionEntries());
      }
      if (hasDeletePartitionEntries()) {
        output.writeMessage(6, getDeletePartitionEntries());
      }
      if (hasInitiateFetchAndUpdate()) {
        output.writeMessage(7, getInitiateFetchAndUpdate());
      }
      if (hasAsyncOperationStatus()) {
        output.writeMessage(8, getAsyncOperationStatus());
      }
      getUnknownFields().writeTo(output);
    }
=======
public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (hasType()) {
        output.writeEnum(1, getType().getNumber());
      }
      if (hasGetMetadata()) {
        output.writeMessage(2, getGetMetadata());
      }
      if (hasUpdateMetadata()) {
        output.writeMessage(3, getUpdateMetadata());
      }
      if (hasUpdatePartitionEntries()) {
        output.writeMessage(4, getUpdatePartitionEntries());
      }
      if (hasFetchPartitionEntries()) {
        output.writeMessage(5, getFetchPartitionEntries());
      }
      if (hasDeletePartitionEntries()) {
        output.writeMessage(6, getDeletePartitionEntries());
      }
      if (hasInitiateFetchAndUpdate()) {
        output.writeMessage(7, getInitiateFetchAndUpdate());
      }
      if (hasAsyncOperationStatus()) {
        output.writeMessage(8, getAsyncOperationStatus());
      }
      if (hasInitiateRebalanceNode()) {
        output.writeMessage(9, getInitiateRebalanceNode());
      }
      getUnknownFields().writeTo(output);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515131669/fstmerge_var2_5644272103051846431

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515131673/fstmerge_var1_4520464954997927293
@Override
        public int getSerializedSize() {
            int size = memoizedSerializedSize;
            if(size != -1)
                return size;

            size = 0;
            if(hasType()) {
                size += com.google.protobuf.CodedOutputStream.computeEnumSize(1,
                                                                              getType().getNumber());
            }
            if(hasGetMetadata()) {
                size += com.google.protobuf.CodedOutputStream.computeMessageSize(2,
                                                                                 getGetMetadata());
            }
            if(hasUpdateMetadata()) {
                size += com.google.protobuf.CodedOutputStream.computeMessageSize(3,
                                                                                 getUpdateMetadata());
            }
            if(hasUpdatePartitionEntries()) {
                size += com.google.protobuf.CodedOutputStream.computeMessageSize(4,
                                                                                 getUpdatePartitionEntries());
            }
            if(hasFetchPartitionEntries()) {
                size += com.google.protobuf.CodedOutputStream.computeMessageSize(5,
                                                                                 getFetchPartitionEntries());
            }
            if(hasDeletePartitionEntries()) {
                size += com.google.protobuf.CodedOutputStream.computeMessageSize(6,
                                                                                 getDeletePartitionEntries());
            }
            if(hasInitiateFetchAndUpdate()) {
                size += com.google.protobuf.CodedOutputStream.computeMessageSize(7,
                                                                                 getInitiateFetchAndUpdate());
            }
            if(hasAsyncOperationStatus()) {
                size += com.google.protobuf.CodedOutputStream.computeMessageSize(8,
                                                                                 getAsyncOperationStatus());
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSerializedSize = size;
            return size;
        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515131673/fstmerge_base_7262414695681657444
public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
    
      size = 0;
      if (hasType()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, getType().getNumber());
      }
      if (hasGetMetadata()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getGetMetadata());
      }
      if (hasUpdateMetadata()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getUpdateMetadata());
      }
      if (hasUpdatePartitionEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getUpdatePartitionEntries());
      }
      if (hasFetchPartitionEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getFetchPartitionEntries());
      }
      if (hasDeletePartitionEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getDeletePartitionEntries());
      }
      if (hasInitiateFetchAndUpdate()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getInitiateFetchAndUpdate());
      }
      if (hasAsyncOperationStatus()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getAsyncOperationStatus());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }
=======
public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
    
      size = 0;
      if (hasType()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, getType().getNumber());
      }
      if (hasGetMetadata()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getGetMetadata());
      }
      if (hasUpdateMetadata()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getUpdateMetadata());
      }
      if (hasUpdatePartitionEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getUpdatePartitionEntries());
      }
      if (hasFetchPartitionEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getFetchPartitionEntries());
      }
      if (hasDeletePartitionEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getDeletePartitionEntries());
      }
      if (hasInitiateFetchAndUpdate()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getInitiateFetchAndUpdate());
      }
      if (hasAsyncOperationStatus()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getAsyncOperationStatus());
      }
      if (hasInitiateRebalanceNode()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, getInitiateRebalanceNode());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515131673/fstmerge_var2_2957678189194800561

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
public Builder mergeFrom(voldemort.client.protocol.pb.VAdminProto.VoldemortAdminRequest other) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515131802/fstmerge_var1_6778326524955076882
                if(other == voldemort.client.protocol.pb.VAdminProto.VoldemortAdminRequest.getDefaultInstance())
                    return this;
                if(other.hasType()) {
                    setType(other.getType());
                }
                if(other.hasGetMetadata()) {
                    mergeGetMetadata(other.getGetMetadata());
                }
                if(other.hasUpdateMetadata()) {
                    mergeUpdateMetadata(other.getUpdateMetadata());
                }
                if(other.hasUpdatePartitionEntries()) {
                    mergeUpdatePartitionEntries(other.getUpdatePartitionEntries());
                }
                if(other.hasFetchPartitionEntries()) {
                    mergeFetchPartitionEntries(other.getFetchPartitionEntries());
                }
                if(other.hasDeletePartitionEntries()) {
                    mergeDeletePartitionEntries(other.getDeletePartitionEntries());
                }
                if(other.hasInitiateFetchAndUpdate()) {
                    mergeInitiateFetchAndUpdate(other.getInitiateFetchAndUpdate());
                }
                if(other.hasAsyncOperationStatus()) {
                    mergeAsyncOperationStatus(other.getAsyncOperationStatus());
                }
                this.mergeUnknownFields(other.getUnknownFields());
                return this;
            }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515131802/fstmerge_base_6196317521149108809
        if (other == voldemort.client.protocol.pb.VAdminProto.VoldemortAdminRequest.getDefaultInstance()) return this;
        if (other.hasType()) {
          setType(other.getType());
        }
        if (other.hasGetMetadata()) {
          mergeGetMetadata(other.getGetMetadata());
        }
        if (other.hasUpdateMetadata()) {
          mergeUpdateMetadata(other.getUpdateMetadata());
        }
        if (other.hasUpdatePartitionEntries()) {
          mergeUpdatePartitionEntries(other.getUpdatePartitionEntries());
        }
        if (other.hasFetchPartitionEntries()) {
          mergeFetchPartitionEntries(other.getFetchPartitionEntries());
        }
        if (other.hasDeletePartitionEntries()) {
          mergeDeletePartitionEntries(other.getDeletePartitionEntries());
        }
        if (other.hasInitiateFetchAndUpdate()) {
          mergeInitiateFetchAndUpdate(other.getInitiateFetchAndUpdate());
        }
        if (other.hasAsyncOperationStatus()) {
          mergeAsyncOperationStatus(other.getAsyncOperationStatus());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }
=======
        if (other == voldemort.client.protocol.pb.VAdminProto.VoldemortAdminRequest.getDefaultInstance()) return this;
        if (other.hasType()) {
          setType(other.getType());
        }
        if (other.hasGetMetadata()) {
          mergeGetMetadata(other.getGetMetadata());
        }
        if (other.hasUpdateMetadata()) {
          mergeUpdateMetadata(other.getUpdateMetadata());
        }
        if (other.hasUpdatePartitionEntries()) {
          mergeUpdatePartitionEntries(other.getUpdatePartitionEntries());
        }
        if (other.hasFetchPartitionEntries()) {
          mergeFetchPartitionEntries(other.getFetchPartitionEntries());
        }
        if (other.hasDeletePartitionEntries()) {
          mergeDeletePartitionEntries(other.getDeletePartitionEntries());
        }
        if (other.hasInitiateFetchAndUpdate()) {
          mergeInitiateFetchAndUpdate(other.getInitiateFetchAndUpdate());
        }
        if (other.hasAsyncOperationStatus()) {
          mergeAsyncOperationStatus(other.getAsyncOperationStatus());
        }
        if (other.hasInitiateRebalanceNode()) {
          mergeInitiateRebalanceNode(other.getInitiateRebalanceNode());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515131802/fstmerge_var2_8927758472859055024

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
            public Builder mergeFrom(com.google.protobuf.CodedInputStream input,
                                     com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                com.google.protobuf.UnknownFieldSet.Builder unknownFields = com.google.protobuf.UnknownFieldSet.newBuilder(this.getUnknownFields());
                while(true) {
                    int tag = input.readTag();
                    switch(tag) {
                        case 0:
                            this.setUnknownFields(unknownFields.build());
                            return this;
                        default: {
                            if(!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                                this.setUnknownFields(unknownFields.build());
                                return this;
                            }
                            break;
                        }
                        case 8: {
                            int rawValue = input.readEnum();
                            voldemort.client.protocol.pb.VAdminProto.AdminRequestType value = voldemort.client.protocol.pb.VAdminProto.AdminRequestType.valueOf(rawValue);
                            if(value == null) {
                                unknownFields.mergeVarintField(1, rawValue);
                            } else {
                                setType(value);
                            }
                            break;
                        }
                        case 18: {
                            voldemort.client.protocol.pb.VAdminProto.GetMetadataRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.GetMetadataRequest.newBuilder();
                            if(hasGetMetadata()) {
                                subBuilder.mergeFrom(getGetMetadata());
                            }
                            input.readMessage(subBuilder, extensionRegistry);
                            setGetMetadata(subBuilder.buildPartial());
                            break;
                        }
                        case 26: {
                            voldemort.client.protocol.pb.VAdminProto.UpdateMetadataRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.UpdateMetadataRequest.newBuilder();
                            if(hasUpdateMetadata()) {
                                subBuilder.mergeFrom(getUpdateMetadata());
                            }
                            input.readMessage(subBuilder, extensionRegistry);
                            setUpdateMetadata(subBuilder.buildPartial());
                            break;
                        }
                        case 34: {
                            voldemort.client.protocol.pb.VAdminProto.UpdatePartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.UpdatePartitionEntriesRequest.newBuilder();
                            if(hasUpdatePartitionEntries()) {
                                subBuilder.mergeFrom(getUpdatePartitionEntries());
                            }
                            input.readMessage(subBuilder, extensionRegistry);
                            setUpdatePartitionEntries(subBuilder.buildPartial());
                            break;
                        }
                        case 42: {
                            voldemort.client.protocol.pb.VAdminProto.FetchPartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.FetchPartitionEntriesRequest.newBuilder();
                            if(hasFetchPartitionEntries()) {
                                subBuilder.mergeFrom(getFetchPartitionEntries());
                            }
                            input.readMessage(subBuilder, extensionRegistry);
                            setFetchPartitionEntries(subBuilder.buildPartial());
                            break;
                        }
                        case 50: {
                            voldemort.client.protocol.pb.VAdminProto.DeletePartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.DeletePartitionEntriesRequest.newBuilder();
                            if(hasDeletePartitionEntries()) {
                                subBuilder.mergeFrom(getDeletePartitionEntries());
                            }
                            input.readMessage(subBuilder, extensionRegistry);
                            setDeletePartitionEntries(subBuilder.buildPartial());
                            break;
                        }
                        case 58: {
                            voldemort.client.protocol.pb.VAdminProto.InitiateFetchAndUpdateRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.InitiateFetchAndUpdateRequest.newBuilder();
                            if(hasInitiateFetchAndUpdate()) {
                                subBuilder.mergeFrom(getInitiateFetchAndUpdate());
                            }
                            input.readMessage(subBuilder, extensionRegistry);
                            setInitiateFetchAndUpdate(subBuilder.buildPartial());
                            break;
                        }
                        case 66: {
                            voldemort.client.protocol.pb.VAdminProto.AsyncOperationStatusRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.AsyncOperationStatusRequest.newBuilder();
                            if(hasAsyncOperationStatus()) {
                                subBuilder.mergeFrom(getAsyncOperationStatus());
                            }
                            input.readMessage(subBuilder, extensionRegistry);
                            setAsyncOperationStatus(subBuilder.buildPartial());
                            break;
                        }
                    }
                }
            }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515131808/fstmerge_var1_6366784360358914621
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515131808/fstmerge_base_3021799049879976736
            case 8: {
              int rawValue = input.readEnum();
              voldemort.client.protocol.pb.VAdminProto.AdminRequestType value = voldemort.client.protocol.pb.VAdminProto.AdminRequestType.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(1, rawValue);
              } else {
                setType(value);
              }
              break;
            }
            case 18: {
              voldemort.client.protocol.pb.VAdminProto.GetMetadataRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.GetMetadataRequest.newBuilder();
              if (hasGetMetadata()) {
                subBuilder.mergeFrom(getGetMetadata());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setGetMetadata(subBuilder.buildPartial());
              break;
            }
            case 26: {
              voldemort.client.protocol.pb.VAdminProto.UpdateMetadataRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.UpdateMetadataRequest.newBuilder();
              if (hasUpdateMetadata()) {
                subBuilder.mergeFrom(getUpdateMetadata());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setUpdateMetadata(subBuilder.buildPartial());
              break;
            }
            case 34: {
              voldemort.client.protocol.pb.VAdminProto.UpdatePartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.UpdatePartitionEntriesRequest.newBuilder();
              if (hasUpdatePartitionEntries()) {
                subBuilder.mergeFrom(getUpdatePartitionEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setUpdatePartitionEntries(subBuilder.buildPartial());
              break;
            }
            case 42: {
              voldemort.client.protocol.pb.VAdminProto.FetchPartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.FetchPartitionEntriesRequest.newBuilder();
              if (hasFetchPartitionEntries()) {
                subBuilder.mergeFrom(getFetchPartitionEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setFetchPartitionEntries(subBuilder.buildPartial());
              break;
            }
            case 50: {
              voldemort.client.protocol.pb.VAdminProto.DeletePartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.DeletePartitionEntriesRequest.newBuilder();
              if (hasDeletePartitionEntries()) {
                subBuilder.mergeFrom(getDeletePartitionEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setDeletePartitionEntries(subBuilder.buildPartial());
              break;
            }
            case 58: {
              voldemort.client.protocol.pb.VAdminProto.InitiateFetchAndUpdateRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.InitiateFetchAndUpdateRequest.newBuilder();
              if (hasInitiateFetchAndUpdate()) {
                subBuilder.mergeFrom(getInitiateFetchAndUpdate());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setInitiateFetchAndUpdate(subBuilder.buildPartial());
              break;
            }
            case 66: {
              voldemort.client.protocol.pb.VAdminProto.AsyncOperationStatusRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.AsyncOperationStatusRequest.newBuilder();
              if (hasAsyncOperationStatus()) {
                subBuilder.mergeFrom(getAsyncOperationStatus());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setAsyncOperationStatus(subBuilder.buildPartial());
              break;
            }
          }
        }
      }
=======
            case 8: {
              int rawValue = input.readEnum();
              voldemort.client.protocol.pb.VAdminProto.AdminRequestType value = voldemort.client.protocol.pb.VAdminProto.AdminRequestType.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(1, rawValue);
              } else {
                setType(value);
              }
              break;
            }
            case 18: {
              voldemort.client.protocol.pb.VAdminProto.GetMetadataRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.GetMetadataRequest.newBuilder();
              if (hasGetMetadata()) {
                subBuilder.mergeFrom(getGetMetadata());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setGetMetadata(subBuilder.buildPartial());
              break;
            }
            case 26: {
              voldemort.client.protocol.pb.VAdminProto.UpdateMetadataRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.UpdateMetadataRequest.newBuilder();
              if (hasUpdateMetadata()) {
                subBuilder.mergeFrom(getUpdateMetadata());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setUpdateMetadata(subBuilder.buildPartial());
              break;
            }
            case 34: {
              voldemort.client.protocol.pb.VAdminProto.UpdatePartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.UpdatePartitionEntriesRequest.newBuilder();
              if (hasUpdatePartitionEntries()) {
                subBuilder.mergeFrom(getUpdatePartitionEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setUpdatePartitionEntries(subBuilder.buildPartial());
              break;
            }
            case 42: {
              voldemort.client.protocol.pb.VAdminProto.FetchPartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.FetchPartitionEntriesRequest.newBuilder();
              if (hasFetchPartitionEntries()) {
                subBuilder.mergeFrom(getFetchPartitionEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setFetchPartitionEntries(subBuilder.buildPartial());
              break;
            }
            case 50: {
              voldemort.client.protocol.pb.VAdminProto.DeletePartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.DeletePartitionEntriesRequest.newBuilder();
              if (hasDeletePartitionEntries()) {
                subBuilder.mergeFrom(getDeletePartitionEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setDeletePartitionEntries(subBuilder.buildPartial());
              break;
            }
            case 58: {
              voldemort.client.protocol.pb.VAdminProto.InitiateFetchAndUpdateRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.InitiateFetchAndUpdateRequest.newBuilder();
              if (hasInitiateFetchAndUpdate()) {
                subBuilder.mergeFrom(getInitiateFetchAndUpdate());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setInitiateFetchAndUpdate(subBuilder.buildPartial());
              break;
            }
            case 66: {
              voldemort.client.protocol.pb.VAdminProto.AsyncOperationStatusRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.AsyncOperationStatusRequest.newBuilder();
              if (hasAsyncOperationStatus()) {
                subBuilder.mergeFrom(getAsyncOperationStatus());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setAsyncOperationStatus(subBuilder.buildPartial());
              break;
            }
            case 74: {
              voldemort.client.protocol.pb.VAdminProto.InitiateRebalanceNodeRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.InitiateRebalanceNodeRequest.newBuilder();
              if (hasInitiateRebalanceNode()) {
                subBuilder.mergeFrom(getInitiateRebalanceNode());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setInitiateRebalanceNode(subBuilder.buildPartial());
              break;
            }
          }
        }
      }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515131808/fstmerge_var2_1516480576580737004

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515132161/fstmerge_var1_4364538999573090278
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515132161/fstmerge_base_6292770115004646912
public ProtoBuffAdminClientRequestFormat(String bootstrapURL, ClientConfig config) {
        super(bootstrapURL);
        this.errorMapper = new ErrorCodeMapper();
        this.pool = createSocketPool(config);
        this.networkClassLoader = new NetworkClassLoader(Thread.currentThread()
                                                               .getContextClassLoader());
    }
=======
public ProtoBuffAdminClientRequestFormat(String bootstrapURL, ClientConfig config) {
        super(bootstrapURL);
        this.errorMapper = new ErrorCodeMapper();
        this.pool = createSocketPool(config);

        this.networkClassLoader = new NetworkClassLoader(Thread.currentThread()
                                                               .getContextClassLoader());

    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515132161/fstmerge_var2_8014349197185607176

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/src/java/voldemort/client/protocol/admin/ProtoBuffAdminClientRequestFormat.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515132166/fstmerge_var1_7531142455820398575
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515132166/fstmerge_base_8083370205592325297
public ProtoBuffAdminClientRequestFormat(Cluster cluster, ClientConfig config) {
        super(cluster);
        this.errorMapper = new ErrorCodeMapper();
        this.pool = createSocketPool(config);
        this.networkClassLoader = new NetworkClassLoader(Thread.currentThread()
                                                               .getContextClassLoader());
    }
=======
public ProtoBuffAdminClientRequestFormat(Cluster cluster, ClientConfig config) {
        super(cluster);
        this.errorMapper = new ErrorCodeMapper();
        this.pool = createSocketPool(config);

        this.networkClassLoader = new NetworkClassLoader(Thread.currentThread()
                                                               .getContextClassLoader());

    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515132166/fstmerge_var2_2914190904989072490

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/src/java/voldemort/client/protocol/admin/ProtoBuffAdminClientRequestFormat.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515132221/fstmerge_var1_4199942705841167742
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515132221/fstmerge_base_1313473528154023172
private VAdminProto.VoldemortFilter encodeFilter(VoldemortFilter filter) throws IOException {
        Class<?> cl = filter.getClass();
        byte[] classBytes = networkClassLoader.dumpClass(cl);
        return VAdminProto.VoldemortFilter.newBuilder()
                                          .setName(cl.getName())
                                          .setData(ProtoUtils.encodeBytes(new ByteArray(classBytes)))
                                          .build();
    }
=======
private VAdminProto.VoldemortFilter encodeFilter(VoldemortFilter filter) throws IOException {

        Class<?> cl = filter.getClass();
        byte[] classBytes = networkClassLoader.dumpClass(cl);
        return VAdminProto.VoldemortFilter.newBuilder()
                                          .setName(cl.getName())
                                          .setData(ProtoUtils.encodeBytes(new ByteArray(classBytes)))
                                          .build();
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515132221/fstmerge_var2_5204826727138475345

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/src/java/voldemort/client/protocol/admin/ProtoBuffAdminClientRequestFormat.java
Conflict type: SameIdFd
Conflict body: 
~~FSTMerge~~ private final static Logger logger = Logger.getLogger(AdminClient.class); ##FSTMerge## ##FSTMerge## private static final Logger logger = Logger.getLogger(AdminClient.class);
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/src/java/voldemort/client/protocol/admin/AdminClient.java
Conflict type: LineBasedMCFd
Conflict body: 
public void waitForCompletion(int nodeId, int requestId, long maxWait, TimeUnit timeUnit) {
        long delay = INITIAL_DELAY;
        long waitUntil = System.currentTimeMillis() + timeUnit.toMillis(maxWait);

        while(System.currentTimeMillis() < waitUntil) {
            AsyncOperationStatus status = getAsyncRequestStatus(nodeId, requestId);
            logger.debug("Status for async task " + requestId + " at node " + nodeId + " is "
                         + status);
            if(status.isComplete())
                return;
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515132299/fstmerge_var1_7554246289877930172
            if(delay < MAX_DELAY) {
                // keep doubling the wait period until we reach maxDelay
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515132299/fstmerge_base_2514820764155281917
            if(delay < MAX_DELAY)
                // keep doubling the wait period until we rach maxDelay
=======
            if(status.hasException())
                throw new VoldemortException(status.getException());

            logger.info("Waiting for AsyncTask to finish taskId:" + requestId + " description("
                        + status.getDescription() + ")  currentStatus:" + status.getStatus());
            if(delay < MAX_DELAY)
                // keep doubling the wait period until we reach maxDelay
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515132299/fstmerge_var2_5796737339691704958
                delay <<= 2;
            }
            try {
                Thread.sleep(delay);
            } catch(InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        throw new VoldemortException("Failed to finish task requestId:" + requestId + " in maxWait"
                                     + maxWait + " " + timeUnit.toString());
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/src/java/voldemort/client/protocol/admin/AdminClient.java
Conflict type: LineBasedMCFd
Conflict body: 
public VoldemortConfig(Props props) {
        try {
            this.nodeId = props.getInt("node.id");
        } catch(UndefinedPropertyException e) {
            this.nodeId = getIntEnvVariable(VOLDEMORT_NODE_ID_VAR_NAME);
        }
        this.voldemortHome = props.getString("voldemort.home");
        this.dataDirectory = props.getString("data.directory", this.voldemortHome + File.separator
                                                               + "data");
        this.metadataDirectory = props.getString("metadata.directory", voldemortHome
                                                                       + File.separator + "config");

        this.bdbCacheSize = props.getBytes("bdb.cache.size", 200 * 1024 * 1024);
        this.bdbWriteTransactions = props.getBoolean("bdb.write.transactions", false);
        this.bdbFlushTransactions = props.getBoolean("bdb.flush.transactions", false);
        this.bdbDataDirectory = props.getString("bdb.data.directory", this.dataDirectory
                                                                      + File.separator + "bdb");
        this.bdbMaxLogFileSize = props.getBytes("bdb.max.logfile.size", 60 * 1024 * 1024);
        this.bdbBtreeFanout = props.getInt("bdb.btree.fanout", 512);
        this.bdbCheckpointBytes = props.getLong("bdb.checkpoint.interval.bytes", 20 * 1024 * 1024);
        this.bdbCheckpointMs = props.getLong("bdb.checkpoint.interval.ms", 30 * Time.MS_PER_SECOND);
        this.bdbSortedDuplicates = props.getBoolean("bdb.enable.sorted.duplicates", true);
        this.bdbOneEnvPerStore = props.getBoolean("bdb.one.env.per.store", false);
        this.bdbCleanerMinFileUtilization = props.getInt("bdb.cleaner.min.file.utilization", 5);
        this.bdbCleanerMinUtilization = props.getInt("bdb.cleaner.minUtilization", 50);

        // enabling preload make cursor slow for insufficient bdb cache size.
        this.bdbCursorPreload = props.getBoolean("bdb.cursor.preload", false);

        this.readOnlyBackups = props.getInt("readonly.backups", 1);
        this.readOnlySearchStrategy = props.getString("readonly.search.strategy",
                                                      BinarySearchStrategy.class.getName());
        this.readOnlyStorageDir = props.getString("readonly.data.directory", this.dataDirectory
                                                                             + File.separator
                                                                             + "read-only");

        this.slopStoreType = props.getString("slop.store.engine", BdbStorageConfiguration.TYPE_NAME);

        this.mysqlUsername = props.getString("mysql.user", "root");
        this.mysqlPassword = props.getString("mysql.password", "");
        this.mysqlHost = props.getString("mysql.host", "localhost");
        this.mysqlPort = props.getInt("mysql.port", 3306);
        this.mysqlDatabaseName = props.getString("mysql.database", "voldemort");

        this.maxThreads = props.getInt("max.threads", 100);
        this.coreThreads = props.getInt("core.threads", Math.max(1, maxThreads / 2));

        // Admin client should have less threads but very high buffer size.
        this.adminMaxThreads = props.getInt("admin.max.threads", 10);
        this.adminCoreThreads = props.getInt("admin.core.threads", Math.max(1, adminMaxThreads / 2));
        this.adminStreamBufferSize = (int) props.getBytes("admin.streams.buffer.size",
                                                          10 * 1000 * 1000);
        this.adminConnectionTimeout = props.getInt("admin.client.socket.timeout.ms", 5 * 60 * 1000);
        this.adminSocketTimeout = props.getInt("admin.client.socket.timeout.ms", 10000);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515132641/fstmerge_var1_923528154171507696
        this.streamMaxReadBytesPerSec = props.getInt("stream.read.byte.per.sec", 10 * 1000 * 1000);
        this.streamMaxWriteBytesPerSec = props.getInt("stream.write.byte.per.sec", 10 * 1000 * 1000);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515132641/fstmerge_base_1115685777082443526
        this.streamMaxReadBytesPerSec = props.getInt("stream.read.byte.per.sec", 1 * 1000 * 1000);
        this.streamMaxWriteBytesPerSec = props.getInt("stream.write.byte.per.sec", 1 * 1000 * 1000);
=======
        this.streamMaxReadBytesPerSec = props.getInt("stream.read.byte.per.sec",
                                                     10 * 8 * 1024 * 1024);
        this.streamMaxWriteBytesPerSec = props.getInt("stream.write.byte.per.sec",
                                                      10 * 8 * 1024 * 1024);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515132641/fstmerge_var2_3998126381642946827

        this.socketTimeoutMs = props.getInt("socket.timeout.ms", 4000);
        this.socketBufferSize = (int) props.getBytes("socket.buffer.size", 32 * 1024);

        this.useNioConnector = props.getBoolean("enable.nio.connector", false);
        this.nioConnectorSelectors = props.getInt("nio.connector.selectors",
                                                  Runtime.getRuntime().availableProcessors());

        this.clientMaxConnectionsPerNode = props.getInt("client.max.connections.per.node", 5);
        this.clientConnectionTimeoutMs = props.getInt("client.connection.timeout.ms", 400);
        this.clientRoutingTimeoutMs = props.getInt("client.routing.timeout.ms", 5000);
        this.clientNodeBannageMs = props.getInt("client.node.bannage.ms", 10000);
        this.clientMaxThreads = props.getInt("client.max.threads", 100);
        this.clientThreadIdleMs = props.getInt("client.thread.idle.ms", 5000);
        this.clientMaxQueuedRequests = props.getInt("client.max.queued.requests", 1000);

        this.enableHttpServer = props.getBoolean("http.enable", true);
        this.enableSocketServer = props.getBoolean("socket.enable", true);
        this.enableAdminServer = props.getBoolean("admin.enable", true);
        this.enableJmx = props.getBoolean("jmx.enable", true);
        this.enableSlop = props.getBoolean("slop.enable", true);
        this.enableVerboseLogging = props.getBoolean("enable.verbose.logging", true);
        this.enableStatTracking = props.getBoolean("enable.stat.tracking", true);
        this.enableServerRouting = props.getBoolean("enable.server.routing", true);
        this.enableMetadataChecking = props.getBoolean("enable.metadata.checking", true);
        this.enableRedirectRouting = props.getBoolean("enable.redirect.routing", true);
        this.enableGossip = props.getBoolean("enable.gossip", false);
        this.enableRebalanceService = props.getBoolean("enable.rebalancing", true);

        this.gossipInterval = props.getInt("gossip.interval.ms", 30 * 1000);
        this.pusherPollMs = props.getInt("pusher.poll.ms", 2 * 60 * 1000);

        this.schedulerThreads = props.getInt("scheduler.threads", 3);

        this.numCleanupPermits = props.getInt("num.cleanup.permits", 1);

        this.storageConfigurations = props.getList("storage.configs",
                                                   ImmutableList.of(BdbStorageConfiguration.class.getName(),
                                                                    MysqlStorageConfiguration.class.getName(),
                                                                    InMemoryStorageConfiguration.class.getName(),
                                                                    CacheStorageConfiguration.class.getName(),
                                                                    ReadOnlyStorageConfiguration.class.getName()));

        // start at midnight (0-23)
        this.retentionCleanupFirstStartTimeInHour = props.getInt("retention.cleanup.first.start.hour",
                                                                 0);
        // repeat every 24 hours
        this.retentionCleanupScheduledPeriodInHour = props.getInt("retention.cleanup.period.hours",
                                                                  24);

        // save props for access from plugins
        this.allProps = props;

        String requestFormatName = props.getString("request.format",
                                                   RequestFormatType.VOLDEMORT_V1.getCode());
        this.requestFormatType = RequestFormatType.fromCode(requestFormatName);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515132641/fstmerge_var1_923528154171507696
        // network class loader disable by default.
        this.enableNetworkClassLoader = props.getBoolean("enable.network.classloader", false);

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515132641/fstmerge_base_1115685777082443526
=======
        // rebalancing parameters
        this.maxRebalancingAttempt = props.getInt("max.rebalancing.attempts", 3);
        this.rebalancingTimeoutInSeconds = props.getInt("rebalancing.timeout.seconds", 60 * 60);
        this.rebalancingServicePeriod = props.getInt("rebalancing.service.period.ms", 1000);
        this.enableDeleteAfterRebalancing = props.getBoolean("enable.rebalancing.delete", false);

        // network class loader disable by default.
        this.enableNetworkClassLoader = props.getBoolean("enable.network.classloader", false);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515132641/fstmerge_var2_3998126381642946827
        validateParams();
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/src/java/voldemort/server/VoldemortConfig.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public void run() {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515133456/fstmerge_var1_5792700171512520367
        logger.info("Starting voldemort socket server (" + serverName + ") on port " + port);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515133456/fstmerge_base_8347950063555697828
        logger.info("Starting voldemort socket server on port " + port);
=======
        logger.info("Starting  " + serverName + " on port " + port);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515133456/fstmerge_var2_7070051382567626498
        try {
            serverSocket = new ServerSocket();
            serverSocket.bind(new InetSocketAddress(port));
            serverSocket.setReceiveBufferSize(this.socketBufferSize);
            startedStatusQueue.put(SUCCESS);
            while(!isInterrupted() && !serverSocket.isClosed()) {
                final Socket socket = serverSocket.accept();
                configureSocket(socket);
                long sessionId = this.sessionIdSequence.getAndIncrement();
                this.threadPool.execute(new SocketServerSession(activeSessions,
                                                                socket,
                                                                handlerFactory,
                                                                sessionId));
            }
        } catch(BindException e) {
            logger.error("Could not bind to port " + port + ".");
            startedStatusQueue.offer(e);
            throw new VoldemortException(e);
        } catch(SocketException e) {
            startedStatusQueue.offer(e);
            // If we have been manually shutdown, ignore
            if(!isInterrupted())
                logger.error("Error in server: ", e);
        } catch(IOException e) {
            startedStatusQueue.offer(e);
            throw new VoldemortException(e);
        } catch(Throwable t) {
            logger.error(t);
            startedStatusQueue.offer(t);
            if(t instanceof Error)
                throw (Error) t;
            else if(t instanceof RuntimeException)
                throw (RuntimeException) t;
            throw new VoldemortException(t);
        } finally {
            if(serverSocket != null) {
                try {
                    serverSocket.close();
                } catch(IOException e) {
                    logger.warn("Error while shutting down server.", e);
                }
            }

        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/src/java/voldemort/server/socket/SocketServer.java
Conflict type: LineBasedMCFd
Conflict body: 
public VAdminProto.AsyncOperationStatusResponse handleFetchAndUpdate(VAdminProto.InitiateFetchAndUpdateRequest request) {
        final int nodeId = request.getNodeId();
        final List<Integer> partitions = request.getPartitionsList();
        final VoldemortFilter filter = request.hasFilter() ? getFilterFromRequest(request.getFilter())
                                                          : new DefaultVoldemortFilter();
        final String storeName = request.getStore();

        int requestId = asyncRunner.getUniqueRequestId();
        VAdminProto.AsyncOperationStatusResponse.Builder response = VAdminProto.AsyncOperationStatusResponse.newBuilder()
                                                                                                            .setRequestId(requestId)
                                                                                                            .setComplete(false)
                                                                                                            .setDescription("Fetch and update")
                                                                                                            .setStatus("started");

        try {
            asyncRunner.submitOperation(requestId,
                                        new AsyncOperation(requestId, "Fetch and Update") {

                                            @Override
                                            public void operate() {
                                                AdminClient adminClient = RebalanceUtils.createTempAdminClient(voldemortConfig,
                                                                                                               metadataStore.getCluster());
                                                try {
                                                    StorageEngine<ByteArray, byte[]> storageEngine = getStorageEngine(storeName);
                                                    Iterator<Pair<ByteArray, Versioned<byte[]>>> entriesIterator = adminClient.fetchEntries(nodeId,
                                                                                                                                            storeName,
                                                                                                                                            partitions,
                                                                                                                                            filter);
                                                    updateStatus("Initated fetchPartitionEntries");
                                                    EventThrottler throttler = new EventThrottler(voldemortConfig.getStreamMaxWriteBytesPerSec());
                                                    for(long i = 0; entriesIterator.hasNext(); i++) {
                                                        Pair<ByteArray, Versioned<byte[]>> entry = entriesIterator.next();

                                                        try {
                                                            storageEngine.put(entry.getFirst(),
                                                                              entry.getSecond());
                                                        } catch(ObsoleteVersionException e) {
                                                            // log and ignore
                                                            logger.debug("FetchAndUpdate threw ObsoleteVersionException .. Ignoring.");
                                                        }

                                                        throttler.maybeThrottle(entrySize(entry));

                                                        if((i % 1000) == 0) {
                                                            updateStatus(i + " entries processed");
                                                        }
                                                    }
                                                } finally {
                                                    adminClient.stop();
                                                }
                                            }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515133692/fstmerge_var1_1197334510981776700

                                            private AdminClient createTempAdminClient() {
                                                AdminClientConfig config = new AdminClientConfig();
                                                config.setMaxConnectionsPerNode(1);
                                                config.setMaxThreads(1);
                                                config.setConnectionTimeout(voldemortConfig.getAdminConnectionTimeout(),
                                                                            TimeUnit.MILLISECONDS);
                                                config.setSocketTimeout(voldemortConfig.getAdminSocketTimeout(),
                                                                        TimeUnit.MILLISECONDS);
                                                config.setSocketBufferSize(voldemortConfig.getAdminSocketBufferSize());

                                                return new AdminClient(metadataStore.getCluster(),
                                                                       config);
                                            }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515133692/fstmerge_base_3084271220593886062

                                            private AdminClient createTempAdminClient() {
                                                ClientConfig config = new ClientConfig();
                                                config.setMaxConnectionsPerNode(1);
                                                config.setMaxThreads(1);
                                                config.setConnectionTimeout(voldemortConfig.getAdminConnectionTimeout(),
                                                                            TimeUnit.MILLISECONDS);
                                                config.setSocketTimeout(voldemortConfig.getAdminSocketTimeout(),
                                                                        TimeUnit.MILLISECONDS);
                                                config.setSocketBufferSize(voldemortConfig.getAdminSocketBufferSize());

                                                return new ProtoBuffAdminClientRequestFormat(metadataStore.getCluster(),
                                                                                             config);
                                            }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515133692/fstmerge_var2_2549236029076780832
                                        });

        } catch(VoldemortException e) {
            response.setError(ProtoUtils.encodeError(errorCodeMapper, e));
            logger.error("handleFetchAndUpdate failed for request(" + request.toString() + ")", e);
        }

        return response.build();
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/src/java/voldemort/server/protocol/admin/ProtoBuffAdminServiceRequestHandler.java
Conflict type: LineBasedMCFd
Conflict body: 
private VoldemortFilter getFilterFromRequest(VAdminProto.VoldemortFilter request) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515133721/fstmerge_base_7770683659684443711
        VoldemortFilter filter;
=======
        VoldemortFilter filter = null;

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515133721/fstmerge_var2_2105124885990604463
        byte[] classBytes = ProtoUtils.decodeBytes(request.getData()).get();
        String className = request.getName();
        logger.debug("Attempt to load VoldemortFilter class:" + className);

        try {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515133721/fstmerge_var1_8939876152056794501
            if(voldemortConfig.isNetworkClassLoaderEnabled()) {
                // TODO: network class loader was throwing NoClassDefFound for
                // voldemort.server package classes, Need testing and fixes

                logger.warn("NetworkLoader is experimental and should not be used for now.");

                Class<?> cl = networkClassLoader.loadClass(className,
                                                           classBytes,
                                                           0,
                                                           classBytes.length);
                filter = (VoldemortFilter) cl.newInstance();

            } else {
                Class<?> cl = Thread.currentThread().getContextClassLoader().loadClass(className);
                filter = (VoldemortFilter) cl.newInstance();
            }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515133721/fstmerge_base_7770683659684443711
            Class<?> cl = networkClassLoader.loadClass(className, classBytes, 0, classBytes.length);
            filter = (VoldemortFilter) cl.newInstance();
=======
            if(voldemortConfig.isNetworkClassLoaderEnabled()) {
                // TODO: network class loader was throwing NoClassDefFound for
                // voldemort.server package classes, Need testing and fixes
                // before can be reenabled.

                // Class<?> cl = networkClassLoader.loadClass(className,
                // classBytes,
                // 0,
                // classBytes.length);
                // filter = (VoldemortFilter) cl.newInstance();
                //                
                throw new VoldemortException("NetworkLoader is experimental and is disabled for now.");
            } else {
                Class<?> cl = Thread.currentThread().getContextClassLoader().loadClass(className);
                filter = (VoldemortFilter) cl.newInstance();
            }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515133721/fstmerge_var2_2105124885990604463
        } catch(Exception e) {
            throw new VoldemortException("Failed to load and instantiate the filter class", e);
        }

        return filter;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/src/java/voldemort/server/protocol/admin/ProtoBuffAdminServiceRequestHandler.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515138468/fstmerge_var1_5545862401147890364
@SuppressWarnings("unchecked")
    public List<Integer> getRebalancingProxySlaveList() {
        return (List<Integer>) metadataCache.get(REBALANCING_PARTITIONS_LIST_KEY).getValue();
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515138468/fstmerge_base_5015030161223024066
public List<Integer> getRebalancingProxySlaveList() {
        return (List<Integer>) metadataCache.get(REBALANCING_PARTITIONS_LIST_KEY).getValue();
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515138468/fstmerge_var2_4998233041222946050

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/src/java/voldemort/store/metadata/MetadataStore.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515139708/fstmerge_var1_957467273540394382
@BeforeClass
    public static void setUpClass() throws Exception {
        ec2SmokeTestConfig = new Ec2SmokeTestConfig();
        hostNamePairs = createInstances(ec2SmokeTestConfig);
        hostNames = toHostNames(hostNamePairs);
        nodeIds = generateClusterDescriptor(hostNamePairs, "test", ec2SmokeTestConfig);

        if(logger.isInfoEnabled())
            logger.info("Sleeping for 30 seconds to give EC2 instances some time to complete startup");

        Thread.sleep(30000);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515139708/fstmerge_base_6145780118820492701
=======
@BeforeClass
    public static void setUpClass() throws Exception {
        Properties properties = getEc2Properties();
        accessId = properties.getProperty("ec2AccessId");
        secretKey = properties.getProperty("ec2SecretKey");
        ami = properties.getProperty("ec2Ami");
        keyPairId = properties.getProperty("ec2KeyPairId");
        sshPrivateKeyPath = properties.getProperty("ec2SshPrivateKeyPath");
        hostUserId = properties.getProperty("ec2HostUserId");
        sshPrivateKey = sshPrivateKeyPath != null ? new File(sshPrivateKeyPath) : null;
        voldemortRootDirectory = properties.getProperty("ec2VoldemortRootDirectory");
        voldemortHomeDirectory = properties.getProperty("ec2VoldemortHomeDirectory");
        sourceDirectory = new File(properties.getProperty("ec2SourceDirectory"));
        parentDirectory = properties.getProperty("ec2ParentDirectory");
        clusterXmlFile = new File(properties.getProperty("ec2ClusterXmlFile"));
        int ec2InstanceCount = Integer.parseInt(properties.getProperty("ec2InstanceCount"));
        rampTime = Integer.parseInt(properties.getProperty("ec2RampTime"));
        iterations = Integer.parseInt(properties.getProperty("ec2Iterations"));
        numRequests = Integer.parseInt(properties.getProperty("ec2NumRequests"));

        hostNamePairs = createInstances(accessId, secretKey, ami, keyPairId, ec2InstanceCount);

        hostNames = toHostNames(hostNamePairs);

        nodeIds = generateClusterDescriptor(hostNamePairs, "test", clusterXmlFile);

        if(logger.isInfoEnabled())
            logger.info("Sleeping for 30 seconds to give EC2 instances some time to complete startup");

        Thread.sleep(30000);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515139708/fstmerge_var2_4966227344113212171

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/contrib/ec2-testing/test/voldemort/utils/Ec2SmokeTest.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515139713/fstmerge_var1_7539492155075941102
@AfterClass
    public static void tearDownClass() throws Exception {
        if(hostNames != null)
            destroyInstances(hostNames, ec2SmokeTestConfig);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515139713/fstmerge_base_5447597906868674662
=======
@AfterClass
    public static void tearDownClass() throws Exception {
        if(hostNames != null)
            destroyInstances(accessId, secretKey, hostNames);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515139713/fstmerge_var2_4648097260991166578

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/contrib/ec2-testing/test/voldemort/utils/Ec2SmokeTest.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515139718/fstmerge_var1_2974715697995856107
@After
    public void tearDown() throws Exception {
        stopClusterQuiet(hostNames, ec2SmokeTestConfig);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515139718/fstmerge_base_26502823002997888
=======
@After
    public void tearDown() throws Exception {
        stopClusterQuiet(hostNames, sshPrivateKey, hostUserId, voldemortRootDirectory);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515139718/fstmerge_var2_7653914091969907217

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/contrib/ec2-testing/test/voldemort/utils/Ec2SmokeTest.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515139723/fstmerge_var1_4396298579080209092
@Test
    public void testRemoteTest() throws Exception {
        Map<String, String> commands = new HashMap<String, String>();
        int i = 0;
        int numRequests = ec2SmokeTestConfig.numRequests;
        int iterations = ec2SmokeTestConfig.iterations;
        String storeName = "test";
        String bootstrapUrl = "tcp://" + hostNamePairs.get(0).getInternalHostName() + ":6666";

        for(HostNamePair hostNamePair: hostNamePairs) {
            int startKey = i * numRequests;
            int rampTime = i * ec2SmokeTestConfig.rampTime;

            String sleepCommand = "sleep " + rampTime;
            String cdCommand = "cd " + ec2SmokeTestConfig.getVoldemortRootDirectory();
            String remoteTestCommand = "./bin/voldemort-remote-test.sh -w -d --iterations "
                                       + iterations + " --start-key-index " + startKey + " "
                                       + bootstrapUrl + " " + storeName + " " + numRequests;

            commands.put(hostNamePair.getExternalHostName(), sleepCommand + " ; " + cdCommand
                                                             + " ; " + remoteTestCommand);
            i++;
        }

        executeRemoteTest(hostNames, ec2SmokeTestConfig, commands);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515139723/fstmerge_base_6991580388236749071
=======
@Test
    public void testRemoteTest() throws Exception {
        deploy(hostNames, sshPrivateKey, hostUserId, sourceDirectory, parentDirectory);

        try {
            startClusterAsync(hostNames,
                              sshPrivateKey,
                              hostUserId,
                              voldemortRootDirectory,
                              voldemortHomeDirectory,
                              nodeIds);

            executeRemoteTest(hostNamePairs,
                              voldemortRootDirectory,
                              sshPrivateKey,
                              hostUserId,
                              rampTime,
                              iterations,
                              numRequests);
        } finally {
            stopCluster(hostNames, sshPrivateKey, hostUserId, voldemortRootDirectory);
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515139723/fstmerge_var2_7173660609213952613

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/contrib/ec2-testing/test/voldemort/utils/Ec2SmokeTest.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515139728/fstmerge_var1_1896352184972932584
@Test
    public void testTemporaryNodeOffline() throws Exception {
        String offlineHostName = hostNames.get(0);
        Integer nodeId = nodeIds.get(offlineHostName);

        stopClusterNode(offlineHostName, ec2SmokeTestConfig);
        startClusterNode(offlineHostName, ec2SmokeTestConfig, nodeId);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515139728/fstmerge_base_5750926574821892616
=======
@Test
    public void testTemporaryNodeOffline() throws Exception {
        deploy(hostNames, sshPrivateKey, hostUserId, sourceDirectory, parentDirectory);

        try {
            startClusterAsync(hostNames,
                              sshPrivateKey,
                              hostUserId,
                              voldemortRootDirectory,
                              voldemortHomeDirectory,
                              nodeIds);

            String offlineHostName = hostNames.get(0);

            stopClusterNode(offlineHostName, sshPrivateKey, hostUserId, voldemortRootDirectory);

            startClusterNode(offlineHostName,
                             sshPrivateKey,
                             hostUserId,
                             voldemortRootDirectory,
                             voldemortHomeDirectory,
                             nodeIds.get(hostNames.get(0)));
        } finally {
            stopCluster(hostNames, sshPrivateKey, hostUserId, voldemortRootDirectory);
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515139728/fstmerge_var2_8460025799233283597

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f1e5e_604ac/rev_f1e5e-604ac/contrib/ec2-testing/test/voldemort/utils/Ec2SmokeTest.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_49ec7_edc67/rev_49ec7-edc67.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515405461/fstmerge_var1_7822637331536869402
public void testFetchAndUpdate(final SetMultimap<Integer, Integer> from,
                                   final int to,
                                   final String store) {
        for(final Integer node: from.keySet()) {
            timeFunction(new Timed() {

                public void apply() {
                    adminClient.migratePartitions(node,
                                                      to,
                                                      store,
                                                      new ArrayList<Integer>(from.get(node)),
                                                      null);
                }

            }, 1);
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515405461/fstmerge_base_780145764172757346
public void testFetchAndUpdate(final SetMultimap<Integer, Integer> from,
                                   final int to,
                                   final String store) {
        for(final Integer node: from.keySet()) {
            timeFunction(new Timed() {

                public void apply() {
                    adminClient.fetchAndUpdateStreams(node,
                                                      to,
                                                      store,
                                                      new ArrayList<Integer>(from.get(node)),
                                                      null);
                }

            }, 1);
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515405461/fstmerge_var2_1565738650755918113

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_49ec7_edc67/rev_49ec7-edc67/test/integration/voldemort/performance/AdminTest.java
Conflict type: LineBasedMCFd
Conflict body: 
private VoldemortFilter getFilterFromRequest(VAdminProto.VoldemortFilter request) {
        VoldemortFilter filter = null;

        byte[] classBytes = ProtoUtils.decodeBytes(request.getData()).get();
        String className = request.getName();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515419306/fstmerge_base_5016683374873715466
=======
        logger.debug("Attempt to load VoldemortFilter class:" + className);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515419306/fstmerge_var2_4660625092833011482

        try {
            if(voldemortConfig.isNetworkClassLoaderEnabled()) {
                // TODO: network class loader was throwing NoClassDefFound for
                // voldemort.server package classes, Need testing and fixes
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515419306/fstmerge_var1_8216790830926534211
                logger.warn("NetworkLoader is experimental and should not be used for now.");
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515419306/fstmerge_base_5016683374873715466
                // before can be reenabled.
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515419306/fstmerge_var2_4660625092833011482

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515419306/fstmerge_var1_8216790830926534211
                Class<?> cl = networkClassLoader.loadClass(className,
                                                           classBytes,
                                                           0,
                                                           classBytes.length);
                filter = (VoldemortFilter) cl.newInstance();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515419306/fstmerge_base_5016683374873715466
                // Class<?> cl = networkClassLoader.loadClass(className,
                // classBytes,
                // 0,
                // classBytes.length);
                // filter = (VoldemortFilter) cl.newInstance();
                //                
                throw new VoldemortException("NetworkLoader is experimental and is disabled for now.");
=======
                logger.warn("NetworkLoader is experimental and should not be used for now.");

                Class<?> cl = networkClassLoader.loadClass(className,
                                                           classBytes,
                                                           0,
                                                           classBytes.length);
                filter = (VoldemortFilter) cl.newInstance();

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415515419306/fstmerge_var2_4660625092833011482
            } else {
                Class<?> cl = Thread.currentThread().getContextClassLoader().loadClass(className);
                filter = (VoldemortFilter) cl.newInstance();
            }
        } catch(Exception e) {
            throw new VoldemortException("Failed to load and instantiate the filter class", e);
        }

        return filter;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_49ec7_edc67/rev_49ec7-edc67/src/java/voldemort/server/protocol/admin/ProtoBuffAdminServiceRequestHandler.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_72ef0_d4fde/rev_72ef0-d4fde.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_da512_ae698/rev_da512-ae698.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_83ebb_bfe1b/rev_83ebb-bfe1b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_dd972_35520/rev_dd972-35520.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_73f32_53a4c/rev_73f32-53a4c.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516437475/fstmerge_var1_839568473525665641
public void testFetchAndUpdate(final SetMultimap<Integer, Integer> from,
                                   final int to,
                                   final String store) {
        for(final Integer node: from.keySet()) {
            timeFunction(new Timed() {

                public void apply() {
                    adminClient.migratePartitions(node,
                                                      to,
                                                      store,
                                                      new ArrayList<Integer>(from.get(node)),
                                                      null);
                }

            }, 1);
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516437475/fstmerge_base_9009358038310121407
public void testFetchAndUpdate(final SetMultimap<Integer, Integer> from,
                                   final int to,
                                   final String store) {
        for(final Integer node: from.keySet()) {
            timeFunction(new Timed() {

                public void apply() {
                    adminClient.fetchAndUpdateStreams(node,
                                                      to,
                                                      store,
                                                      new ArrayList<Integer>(from.get(node)),
                                                      null);
                }

            }, 1);
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516437475/fstmerge_var2_3211716905285772613

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_73f32_53a4c/rev_73f32-53a4c/test/integration/voldemort/performance/AdminTest.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a7a33_77b90/rev_a7a33-77b90.revisions
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516662786/fstmerge_var1_6854894303082268556
public static void main(String [] args) throws Exception {
        if (args.length < 1 || args.length > 2)
            Utils.croak("USAGE: java VoldemortAdminClientShell bootstrap_url [command_file]");

        String bootstrapUrl = args[0];
        String commandsFileName = "";
        BufferedReader fileReader = null;
        BufferedReader inputReader = null;
        try {
            if (args.length == 2) {
                commandsFileName = args[1];
                fileReader = new BufferedReader(new FileReader(commandsFileName));
            }
            inputReader = new BufferedReader(new InputStreamReader(System.in));
        } catch (IOException e) {
            Utils.croak("Failure to open input stream: " + e.getMessage());
        }

        AdminClient adminClient = null;
        try {
            adminClient = new ProtoBuffAdminClientRequestFormat(bootstrapUrl, new ClientConfig());
        } catch (Exception e) {
            Utils.croak("Couldn't instantiate admin client: " + e.getMessage());
        }

        System.out.println("Created admin client to cluster at " + bootstrapUrl);
        System.out.print(PROMPT);
        if (fileReader != null) {
            processCommands(fileReader, adminClient, true);
            fileReader.close();
        }
        processCommands(inputReader, adminClient, false);


    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516662786/fstmerge_base_1217677182762458897
=======
public static void main(String [] args) throws Exception {
        if (args.length < 1 || args.length > 2)
            Utils.croak("USAGE: java VoldemortAdminClientShell bootstrap_url [command_file]");

        String bootstrapUrl = args[0];
        String commandsFileName = "";
        BufferedReader fileReader = null;
        BufferedReader inputReader = null;
        try {
            if (args.length == 2) {
                commandsFileName = args[1];
                fileReader = new BufferedReader(new FileReader(commandsFileName));
            }
            inputReader = new BufferedReader(new InputStreamReader(System.in));
        } catch (IOException e) {
            Utils.croak("Failure to open input stream: " + e.getMessage());
        }

        AdminClient adminClient = null;
        try {
            adminClient = new AdminClient(bootstrapUrl, new AdminClientConfig());
        } catch (Exception e) {
            Utils.croak("Couldn't instantiate admin client: " + e.getMessage());
        }

        System.out.println("Created admin client to cluster at " + bootstrapUrl);
        System.out.print(PROMPT);
        if (fileReader != null) {
            processCommands(fileReader, adminClient, true);
            fileReader.close();
        }
        processCommands(inputReader, adminClient, false);


    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516662786/fstmerge_var2_3834616927049722731

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a7a33_77b90/rev_a7a33-77b90/src/java/voldemort/utils/VoldemortAdminClientShell.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516662791/fstmerge_var1_7476411426765061980
public static void processCommands(BufferedReader reader, AdminClient adminClient, boolean printCommands)
        throws IOException {
        for (String line = reader.readLine(); line != null; line = reader.readLine()) {
            if (line.trim().equals(""))
                continue;
            if (printCommands)
                System.out.println(line);
            try {
                if (line.toLowerCase().startsWith("getmetadata")) {
                    String[] args = line.substring("getmetadata".length() + 1).split("\\s+");
                    int remoteNodeId = Integer.valueOf(args[0]);
                    String key = args[1];
                    Versioned<String> versioned = adminClient.getRemoteMetadata(remoteNodeId, key);
                    if (versioned == null) {
                        System.out.println("null");
                    } else {
                        System.out.println(versioned.getVersion());
                        System.out.print(": ");
                        System.out.println(versioned.getValue());
                        System.out.println();
                    }
                }
                else if (line.toLowerCase().startsWith("fetchkeys")) {
                    String[] args = line.substring("fetchkeys".length() + 1).split("\\s+");
                    int remoteNodeId = Integer.valueOf(args[0]);
                    String storeName = args[1];
                    List<Integer> partititionList = parseCsv(args[2]);
                    Iterator<ByteArray> partitionKeys =
                            adminClient.fetchPartitionKeys(remoteNodeId, storeName, partititionList, null);
                    BufferedWriter writer = null;
                    try {
                        if (args.length > 3) {
                            writer = new BufferedWriter(new FileWriter(new File(args[3])));
                        } else
                            writer = new BufferedWriter(new OutputStreamWriter(System.out));
                    } catch (IOException e) {
                        System.err.println("Failed to open the output stream");
                        e.printStackTrace();
                    }
                    if (writer != null) {
                        while (partitionKeys.hasNext()) {
                            ByteArray keyByteArray = partitionKeys.next();
                            StringBuilder lineBuilder = new StringBuilder();
                            lineBuilder.append(ByteUtils.getString(keyByteArray.get(), "UTF-8"));
                            lineBuilder.append("\n");
                            writer.write(lineBuilder.toString());
                        }
                        writer.flush();
                    }
                }
                else if (line.toLowerCase().startsWith("fetch")) {
                    String[] args = line.substring("fetch".length() + 1).split("\\s+");
                    int remoteNodeId = Integer.valueOf(args[0]);
                    String storeName = args[1];
                    List<Integer> partititionList = parseCsv(args[2]);
                    Iterator<Pair<ByteArray,Versioned<byte[]>>> partitionEntries =
                            adminClient.fetchPartitionEntries(remoteNodeId, storeName, partititionList, null);
                    BufferedWriter writer = null;
                    try {
                        if (args.length > 3) {
                            writer = new BufferedWriter(new FileWriter(new File(args[3])));
                        } else
                            writer = new BufferedWriter(new OutputStreamWriter(System.out));
                    } catch (IOException e) {
                        System.err.println("Failed to open the output stream");
                        e.printStackTrace();
                    }
                    if (writer != null) {
                        while (partitionEntries.hasNext()) {
                            Pair<ByteArray,Versioned<byte[]>> pair = partitionEntries.next();
                            ByteArray keyByteArray = pair.getFirst();
                            Versioned<byte[]> versioned = pair.getSecond();
                            StringBuilder lineBuilder = new StringBuilder();
                            lineBuilder.append(ByteUtils.getString(keyByteArray.get(), "UTF-8"));
                            lineBuilder.append("\t");
                            lineBuilder.append(versioned.getVersion());
                            lineBuilder.append("\t");
                            lineBuilder.append(ByteUtils.getString(versioned.getValue(), "UTF-8"));
                            lineBuilder.append("\n");
                            writer.write(lineBuilder.toString());
                        }
                        writer.flush();
                    }
                } else if (line.startsWith("help")) {
                    System.out.println("Commands:");
                    System.out.println("getmetadata node_id key -- Get metadata associated with key from node_id.");
                    System.out.println("fetchkeys node_id store_name partitions <file_name> -- Fetch all keys from given partitions" +
                            " (a comma separated list) of store_name on node_id. Optionally, write to file_name.");
                    System.out.println("fetch node_id store_name partitions <file_name> -- Fetch all entries from given partitions" +
                            " (a comma separated list) of store_name on node_id. Optionally, write to file_name.");
                    System.out.println("help -- Print this message.");
                    System.out.println("exit -- Exit from this shell.");
                    System.out.println();
                } else if (line.startsWith("quit") || line.startsWith("exit")) {
                    System.out.println("k k thx bye.");
                    System.exit(0);
                } else {
                    System.err.println("Invalid command.");
                }
            } catch (EndOfFileException e) {
                System.err.println("Expected additional token");
            } catch (VoldemortException e) {
                System.err.println("Exception thrown during operation.");
                e.printStackTrace();
            } catch (ArrayIndexOutOfBoundsException e) {
                System.err.println("Invalid command.");
            } catch (Exception e) {
                System.err.println("Unexpected error:");
                e.printStackTrace(System.err);
            }
            System.out.print(PROMPT);
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516662791/fstmerge_base_2727413358979927686
=======
public static void processCommands(BufferedReader reader, AdminClient adminClient, boolean printCommands)
        throws IOException {
        for (String line = reader.readLine(); line != null; line = reader.readLine()) {
            if (line.trim().equals(""))
                continue;
            if (printCommands)
                System.out.println(line);
            try {
                if (line.toLowerCase().startsWith("getmetadata")) {
                    String[] args = line.substring("getmetadata".length() + 1).split("\\s+");
                    int remoteNodeId = Integer.valueOf(args[0]);
                    String key = args[1];
                    Versioned<String> versioned = adminClient.getRemoteMetadata(remoteNodeId, key);
                    if (versioned == null) {
                        System.out.println("null");
                    } else {
                        System.out.println(versioned.getVersion());
                        System.out.print(": ");
                        System.out.println(versioned.getValue());
                        System.out.println();
                    }
                }
                else if (line.toLowerCase().startsWith("fetchkeys")) {
                    String[] args = line.substring("fetchkeys".length() + 1).split("\\s+");
                    int remoteNodeId = Integer.valueOf(args[0]);
                    String storeName = args[1];
                    List<Integer> partititionList = parseCsv(args[2]);
                    Iterator<ByteArray> partitionKeys =
                            adminClient.fetchKeys(remoteNodeId, storeName, partititionList, null);
                    BufferedWriter writer = null;
                    try {
                        if (args.length > 3) {
                            writer = new BufferedWriter(new FileWriter(new File(args[3])));
                        } else
                            writer = new BufferedWriter(new OutputStreamWriter(System.out));
                    } catch (IOException e) {
                        System.err.println("Failed to open the output stream");
                        e.printStackTrace();
                    }
                    if (writer != null) {
                        while (partitionKeys.hasNext()) {
                            ByteArray keyByteArray = partitionKeys.next();
                            StringBuilder lineBuilder = new StringBuilder();
                            lineBuilder.append(ByteUtils.getString(keyByteArray.get(), "UTF-8"));
                            lineBuilder.append("\n");
                            writer.write(lineBuilder.toString());
                        }
                        writer.flush();
                    }
                }
                else if (line.toLowerCase().startsWith("fetch")) {
                    String[] args = line.substring("fetch".length() + 1).split("\\s+");
                    int remoteNodeId = Integer.valueOf(args[0]);
                    String storeName = args[1];
                    List<Integer> partititionList = parseCsv(args[2]);
                    Iterator<Pair<ByteArray,Versioned<byte[]>>> partitionEntries =
                            adminClient.fetchEntries(remoteNodeId, storeName, partititionList, null);
                    BufferedWriter writer = null;
                    try {
                        if (args.length > 3) {
                            writer = new BufferedWriter(new FileWriter(new File(args[3])));
                        } else
                            writer = new BufferedWriter(new OutputStreamWriter(System.out));
                    } catch (IOException e) {
                        System.err.println("Failed to open the output stream");
                        e.printStackTrace();
                    }
                    if (writer != null) {
                        while (partitionEntries.hasNext()) {
                            Pair<ByteArray,Versioned<byte[]>> pair = partitionEntries.next();
                            ByteArray keyByteArray = pair.getFirst();
                            Versioned<byte[]> versioned = pair.getSecond();
                            StringBuilder lineBuilder = new StringBuilder();
                            lineBuilder.append(ByteUtils.getString(keyByteArray.get(), "UTF-8"));
                            lineBuilder.append("\t");
                            lineBuilder.append(versioned.getVersion());
                            lineBuilder.append("\t");
                            lineBuilder.append(ByteUtils.getString(versioned.getValue(), "UTF-8"));
                            lineBuilder.append("\n");
                            writer.write(lineBuilder.toString());
                        }
                        writer.flush();
                    }
                } else if (line.startsWith("help")) {
                    System.out.println("Commands:");
                    System.out.println("getmetadata node_id key -- Get metadata associated with key from node_id.");
                    System.out.println("fetchkeys node_id store_name partitions <file_name> -- Fetch all keys from given partitions" +
                            " (a comma separated list) of store_name on node_id. Optionally, write to file_name.");
                    System.out.println("fetch node_id store_name partitions <file_name> -- Fetch all entries from given partitions" +
                            " (a comma separated list) of store_name on node_id. Optionally, write to file_name.");
                    System.out.println("help -- Print this message.");
                    System.out.println("exit -- Exit from this shell.");
                    System.out.println();
                } else if (line.startsWith("quit") || line.startsWith("exit")) {
                    System.out.println("k k thx bye.");
                    System.exit(0);
                } else {
                    System.err.println("Invalid command.");
                }
            } catch (EndOfFileException e) {
                System.err.println("Expected additional token");
            } catch (VoldemortException e) {
                System.err.println("Exception thrown during operation.");
                e.printStackTrace();
            } catch (ArrayIndexOutOfBoundsException e) {
                System.err.println("Invalid command.");
            } catch (Exception e) {
                System.err.println("Unexpected error:");
                e.printStackTrace(System.err);
            }
            System.out.print(PROMPT);
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516662791/fstmerge_var2_769531835198394558

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a7a33_77b90/rev_a7a33-77b90/src/java/voldemort/utils/VoldemortAdminClientShell.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public boolean delete(ByteArray key, Version version) throws VoldemortException {
        StoreUtils.assertValidKey(key);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516666306/fstmerge_var1_3436284701474374000
        StoreUtils.assertValidMetadata(key, metadata.getRoutingStrategy(getName()), node);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516666306/fstmerge_base_3777094565511882586
        StoreUtils.assertValidMetadata(key, metadata.getRoutingStrategy(getName()), nodeId);
=======
        StoreUtils.assertValidMetadata(key,
                                       metadata.getRoutingStrategy(getName()),
                                       metadata.getCluster().getNodeById(nodeId));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516666306/fstmerge_var2_1454636321849215954

        return getInnerStore().delete(key, version);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a7a33_77b90/rev_a7a33-77b90/src/java/voldemort/store/invalidmetadata/InvalidMetadataCheckingStore.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public void put(ByteArray key, Versioned<byte[]> value) throws VoldemortException {
        StoreUtils.assertValidKey(key);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516666311/fstmerge_var1_6395135501959241114
        StoreUtils.assertValidMetadata(key, metadata.getRoutingStrategy(getName()), node);

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516666311/fstmerge_base_6933845826673363892
        StoreUtils.assertValidMetadata(key, metadata.getRoutingStrategy(getName()), nodeId);

=======
        StoreUtils.assertValidMetadata(key,
                                       metadata.getRoutingStrategy(getName()),
                                       metadata.getCluster().getNodeById(nodeId));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516666311/fstmerge_var2_7425324536128851411
        getInnerStore().put(key, value);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a7a33_77b90/rev_a7a33-77b90/src/java/voldemort/store/invalidmetadata/InvalidMetadataCheckingStore.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public List<Versioned<byte[]>> get(ByteArray key) throws VoldemortException {
        StoreUtils.assertValidKey(key);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516666316/fstmerge_var1_2335046147701857660
        StoreUtils.assertValidMetadata(key, metadata.getRoutingStrategy(getName()), node);

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516666316/fstmerge_base_2525642081627097607
        StoreUtils.assertValidMetadata(key, metadata.getRoutingStrategy(getName()), nodeId);

=======
        StoreUtils.assertValidMetadata(key,
                                       metadata.getRoutingStrategy(getName()),
                                       metadata.getCluster().getNodeById(nodeId));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516666316/fstmerge_var2_7007391421931163088
        return getInnerStore().get(key);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a7a33_77b90/rev_a7a33-77b90/src/java/voldemort/store/invalidmetadata/InvalidMetadataCheckingStore.java
Conflict type: LineBasedMCFd
Conflict body: 
private void init(int nodeId) {
        logger.info("metadata init().");

        // Required keys
        initCache(CLUSTER_KEY);
        initCache(STORES_KEY);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516666795/fstmerge_var1_7432857295819254779
        initCache(NODE_ID_KEY, nodeId);
        if(getNodeId() != nodeId)
            throw new RuntimeException("Attempt to start previous node:"
                                       + getNodeId()
                                       + " as node:"
                                       + nodeId
                                       + " (Did you copy config directory ? try deleting .temp .version in config dir to force clean) aborting ...");

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516666795/fstmerge_base_6325782140016526520
=======
        initCache(NODE_ID_KEY, nodeId);
        if(getNodeId() != nodeId)
            throw new RuntimeException("Attempt to start previous node:"
                                       + getNodeId()
                                       + " as node:"
                                       + nodeId
                                       + " (delete .temp .version in config dir to force clean) aborting ...");

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516666795/fstmerge_var2_654763259274304774
        // Initialize with default if not present
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516666795/fstmerge_var1_7432857295819254779
        initCache(REBALANCING_SLAVES_LIST_KEY, new ArrayList<Integer>(0));
        initCache(REBALANCING_PARTITIONS_LIST_KEY, new ArrayList<Integer>(0));
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516666795/fstmerge_base_6325782140016526520
        initCache(NODE_ID_KEY, nodeId);
        initCache(REBALANCING_SLAVES_LIST_KEY, new ArrayList<Integer>(0));
        initCache(REBALANCING_PARTITIONS_LIST_KEY, new ArrayList<Integer>(0));
=======
        initCache(REBALANCING_STEAL_INFO, new RebalanceStealInfo(-1,
                                                                 -1,
                                                                 new ArrayList<Integer>(0),
                                                                 Arrays.asList(""),
                                                                 0));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415516666795/fstmerge_var2_654763259274304774
        initCache(SERVER_STATE_KEY, VoldemortState.NORMAL_SERVER.toString());
        initCache(CLUSTER_STATE_KEY, VoldemortState.NORMAL_CLUSTER.toString());

        // set transient values
        updateRoutingStrategies(getCluster(), getStoreDefList());
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a7a33_77b90/rev_a7a33-77b90/src/java/voldemort/store/metadata/MetadataStore.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_92979_7ad2d/rev_92979-7ad2d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_73f32_e4a53/rev_73f32-e4a53.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415517076601/fstmerge_var1_8628906122678134930
public RoutedStore(String name,
                       Map<Integer, Store<ByteArray, byte[]>> innerStores,
                       Cluster cluster,
                       StoreDefinition storeDef,
                       boolean repairReads,
                       ExecutorService threadPool,
                       long timeoutMs,
                       long nodeBannageMs,
                       Time time) {
        if(storeDef.getRequiredReads() < 1)
            throw new IllegalArgumentException("Cannot have a storeDef.getRequiredReads() number less than 1.");
        if(storeDef.getRequiredWrites() < 1)
            throw new IllegalArgumentException("Cannot have a storeDef.getRequiredWrites() number less than 1.");
        if(storeDef.getPreferredReads() < storeDef.getRequiredReads())
            throw new IllegalArgumentException("storeDef.getPreferredReads() must be greater or equal to storeDef.getRequiredReads().");
        if(storeDef.getPreferredWrites() < storeDef.getRequiredWrites())
            throw new IllegalArgumentException("storeDef.getPreferredWrites() must be greater or equal to storeDef.getRequiredWrites().");
        if(storeDef.getPreferredReads() > innerStores.size())
            throw new IllegalArgumentException("storeDef.getPreferredReads() is larger than the total number of nodes!");
        if(storeDef.getPreferredWrites() > innerStores.size())
            throw new IllegalArgumentException("storeDef.getPreferredWrites() is larger than the total number of nodes!");

        this.name = name;
        this.innerStores = new ConcurrentHashMap<Integer, Store<ByteArray, byte[]>>(innerStores);
        this.repairReads = repairReads;
        this.executor = threadPool;
        this.readRepairer = new ReadRepairer<ByteArray, byte[]>();
        this.timeoutMs = timeoutMs;
        this.nodeBannageMs = nodeBannageMs;
        this.time = Utils.notNull(time);
        this.storeDef = storeDef;

        this.routingStrategy = new RoutingStrategyFactory().updateRoutingStrategy(storeDef, cluster);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415517076601/fstmerge_base_5476987480187062388
public RoutedStore(String name,
                       Map<Integer, Store<ByteArray, byte[]>> innerStores,
                       Cluster cluster,
                       StoreDefinition storeDef,
                       boolean repairReads,
                       ExecutorService threadPool,
                       long timeoutMs,
                       long nodeBannageMs,
                       Time time) {
        if(storeDef.getRequiredReads() < 1)
            throw new IllegalArgumentException("Cannot have a storeDef.getRequiredReads() number less than 1.");
        if(storeDef.getRequiredWrites() < 1)
            throw new IllegalArgumentException("Cannot have a storeDef.getRequiredWrites() number less than 1.");
        if(storeDef.getPreferredReads() < storeDef.getRequiredReads())
            throw new IllegalArgumentException("storeDef.getPreferredReads() must be greater or equal to storeDef.getRequiredReads().");
        if(storeDef.getPreferredWrites() < storeDef.getRequiredWrites())
            throw new IllegalArgumentException("storeDef.getPreferredWrites() must be greater or equal to storeDef.getRequiredWrites().");
        if(storeDef.getPreferredReads() > innerStores.size())
            throw new IllegalArgumentException("storeDef.getPreferredReads() is larger than the total number of nodes!");
        if(storeDef.getPreferredWrites() > innerStores.size())
            throw new IllegalArgumentException("storeDef.getPreferredWrites() is larger than the total number of nodes!");

        this.name = name;
        this.innerStores = new ConcurrentHashMap<Integer, Store<ByteArray, byte[]>>(innerStores);
        this.repairReads = repairReads;
        this.executor = threadPool;
        this.readRepairer = new ReadRepairer<ByteArray, byte[]>();
        this.timeoutMs = timeoutMs;
        this.nodeBannageMs = nodeBannageMs;
        this.time = Utils.notNull(time);
        this.cluster = cluster;
        this.storeDef = storeDef;

        this.routingStrategy = new RoutingStrategyFactory().updateRoutingStrategy(storeDef, cluster);
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415517076601/fstmerge_var2_5663112625667429930

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_73f32_e4a53/rev_73f32-e4a53/src/java/voldemort/store/routed/RoutedStore.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_21f82_db421/rev_21f82-db421.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_04731_befa4/rev_04731-befa4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_69be4_ddbba/rev_69be4-ddbba.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d9c19_1b019/rev_d9c19-1b019.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415517882396/fstmerge_var1_180081455428670883
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415517882396/fstmerge_base_8020153983161775484
private void rebalanceAndCheck(Cluster currentCluster,
                                   Cluster targetCluster,
                                   RebalanceClient rebalanceClient,
                                   List<Integer> nodeCheckList) {
        rebalanceClient.rebalance(currentCluster, targetCluster);

        for(int nodeId: nodeCheckList) {
            List<Integer> availablePartitions = targetCluster.getNodeById(nodeId).getPartitionIds();
            List<Integer> unavailablePartitions = getUnavailablePartitions(targetCluster,
                                                                           availablePartitions);

            checkGetEntries(currentCluster.getNodeById(nodeId),
                            targetCluster,
                            unavailablePartitions,
                            availablePartitions);
        }

    }
=======
private void rebalanceAndCheck(Cluster currentCluster,
                                   Cluster targetCluster,
                                   RebalanceClient rebalanceClient,
                                   List<Integer> nodeCheckList) {
        rebalanceClient.rebalance(targetCluster);

        for(int nodeId: nodeCheckList) {
            List<Integer> availablePartitions = targetCluster.getNodeById(nodeId).getPartitionIds();
            List<Integer> unavailablePartitions = getUnavailablePartitions(targetCluster,
                                                                           availablePartitions);

            checkGetEntries(currentCluster.getNodeById(nodeId),
                            targetCluster,
                            unavailablePartitions,
                            availablePartitions);
        }

    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415517882396/fstmerge_var2_6560973029395588633

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d9c19_1b019/rev_d9c19-1b019/test/unit/voldemort/client/rebalance/AbstractRebalanceTest.java
Conflict type: LineBasedMCFd
Conflict body: 
private void attemptRebalance(RebalancePartitionsInfo stealInfo) {
        stealInfo.setAttempt(stealInfo.getAttempt() + 1);
        AdminClient adminClient = RebalanceUtils.createTempAdminClient(voldemortConfig,
                                                                       metadataStore.getCluster());
        int rebalanceAsyncId = rebalanceLocalNode(stealInfo);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415517895129/fstmerge_var1_8621999910833040388
        adminClient.waitForCompletion(stealInfo.getStealerId(),
                                      rebalanceAsyncId,
                                      voldemortConfig.getAdminSocketTimeout(),
                                      TimeUnit.SECONDS);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415517895129/fstmerge_base_1763364134901310034
        for(String storeName: unbalanceStoreList) {
            AdminClient adminClient = RebalanceUtils.createTempAdminClient(voldemortConfig,
                                                                           metadataStore.getCluster());
            try {
                int rebalanceAsyncId = rebalanceLocalNode(storeName, stealInfo);
                
                adminClient.waitForCompletion(stealInfo.getStealerId(),
                                              rebalanceAsyncId,
                                              voldemortConfig.getAdminSocketTimeout(),
                                              TimeUnit.SECONDS);
                // remove store from rebalance list
                stealInfo.getUnbalancedStoreList().remove(storeName);
            } catch(Exception e) {
                logger.warn("rebalanceSubTask:" + stealInfo + " failed for store:" + storeName, e);
            } finally {
                adminClient.stop();
            }
        }
=======
        for(String storeName: unbalanceStoreList) {
            AdminClient adminClient = RebalanceUtils.createTempAdminClient(voldemortConfig,
                                                                           metadataStore.getCluster());
            try {
                int rebalanceAsyncId = rebalanceLocalNode(storeName, stealInfo);

                adminClient.waitForCompletion(stealInfo.getStealerId(),
                                              rebalanceAsyncId,
                                              voldemortConfig.getAdminSocketTimeout(),
                                              TimeUnit.SECONDS);
                // remove store from rebalance list
                stealInfo.getUnbalancedStoreList().remove(storeName);
            } catch(Exception e) {
                logger.warn("rebalanceSubTask:" + stealInfo + " failed for store:" + storeName, e);
            } finally {
                adminClient.stop();
            }
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415517895129/fstmerge_var2_3920429229734279452
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d9c19_1b019/rev_d9c19-1b019/src/java/voldemort/server/rebalance/Rebalancer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415517895134/fstmerge_var1_7935047390132927973
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415517895134/fstmerge_base_6606672015122918780
public int rebalanceLocalNode(final String storeName, final RebalancePartitionsInfo stealInfo) {

        if(!acquireRebalancingPermit()) {
            RebalancePartitionsInfo info = metadataStore.getRebalancingStealInfo();
            throw new VoldemortException("Node "
                                         + metadataStore.getCluster()
                                                        .getNodeById(info.getStealerId())
                                         + " is already rebalancing from " + info.getDonorId()
                                         + " rebalanceInfo:" + info);
        }

        int requestId = asyncRunner.getUniqueRequestId();

        asyncRunner.submitOperation(requestId, new AsyncOperation(requestId, stealInfo.toString()) {

            @Override
            public void operate() throws Exception {
                AdminClient adminClient = RebalanceUtils.createTempAdminClient(voldemortConfig,
                                                                               metadataStore.getCluster());
                try {
                    logger.info("Rebalancer: rebalance " + stealInfo + " starting.");

                    // check and create redirectingSocketStore if needed.
                    checkAndCreateRedirectingSocketStore(storeName,
                                                         adminClient.getAdminClientCluster()
                                                                    .getNodeById(stealInfo.getDonorId()));

                    checkCurrentState(metadataStore, stealInfo);
                    setRebalancingState(metadataStore, stealInfo);

                    migratePartitionsAsyncId = adminClient.migratePartitions(stealInfo.getDonorId(),
                                                                             metadataStore.getNodeId(),
                                                                             storeName,
                                                                             stealInfo.getPartitionList(),
                                                                             null);
                    adminClient.waitForCompletion(metadataStore.getNodeId(),
                                                  migratePartitionsAsyncId,
                                                  voldemortConfig.getAdminSocketTimeout(),
                                                  TimeUnit.SECONDS);

                    logger.info("Rebalancer: rebalance " + stealInfo + " completed successfully.");

                    // clean state only if successfull.
                    metadataStore.cleanAllRebalancingState();
                    if(voldemortConfig.isDeleteAfterRebalancingEnabled()) {
                        logger.warn("Deleting data from donorNode after rebalancing !!");
                        adminClient.deletePartitions(stealInfo.getDonorId(),
                                                     storeName,
                                                     stealInfo.getPartitionList(),
                                                     null);
                        logger.info("Deleted partitions " + stealInfo.getPartitionList()
                                    + " from donorNode:" + stealInfo.getDonorId());
                    }

                } finally {
                    // free the permit in all cases.
                    releaseRebalancingPermit();
                    adminClient.stop();
                    migratePartitionsAsyncId = -1;
                }
            }

            @Override
            @JmxGetter(name = "asyncTaskStatus")
            public AsyncOperationStatus getStatus() {
                if(-1 != migratePartitionsAsyncId)
                    try {
                        updateStatus(asyncRunner.getStatus(migratePartitionsAsyncId));
                    } catch(Exception e) {
                        // ignore
                    }

                return super.getStatus();
            }
        });

        return requestId;
    }
=======
public int rebalanceLocalNode(final String storeName, final RebalancePartitionsInfo stealInfo) {

        if(!acquireRebalancingPermit()) {
            RebalancePartitionsInfo info = metadataStore.getRebalancingStealInfo();
            throw new VoldemortException("Node "
                                         + metadataStore.getCluster()
                                                        .getNodeById(info.getStealerId())
                                         + " is already rebalancing from " + info.getDonorId()
                                         + " rebalanceInfo:" + info);
        }

        int requestId = asyncRunner.getUniqueRequestId();

        asyncRunner.submitOperation(requestId, new AsyncOperation(requestId, stealInfo.toString()) {

            @Override
            public void operate() throws Exception {
                AdminClient adminClient = RebalanceUtils.createTempAdminClient(voldemortConfig,
                                                                               metadataStore.getCluster());
                try {
                    logger.info("Rebalancer: rebalance " + stealInfo + " starting.");

                    // create redirectingSocketStore for redirection.
                    createRedirectingSocketStore(storeName,
                                                 adminClient.getAdminClientCluster()
                                                            .getNodeById(stealInfo.getDonorId()));

                    checkCurrentState(metadataStore, stealInfo);
                    setRebalancingState(metadataStore, stealInfo);

                    migratePartitionsAsyncId = adminClient.migratePartitions(stealInfo.getDonorId(),
                                                                             metadataStore.getNodeId(),
                                                                             storeName,
                                                                             stealInfo.getPartitionList(),
                                                                             null);
                    adminClient.waitForCompletion(metadataStore.getNodeId(),
                                                  migratePartitionsAsyncId,
                                                  voldemortConfig.getAdminSocketTimeout(),
                                                  TimeUnit.SECONDS);

                    logger.info("Rebalancer: rebalance " + stealInfo + " completed successfully.");

                    // clean state only if successfull.
                    metadataStore.cleanAllRebalancingState();
                    if(voldemortConfig.isDeleteAfterRebalancingEnabled()) {
                        logger.warn("Deleting data from donorNode after rebalancing !!");
                        adminClient.deletePartitions(stealInfo.getDonorId(),
                                                     storeName,
                                                     stealInfo.getPartitionList(),
                                                     null);
                        logger.info("Deleted partitions " + stealInfo.getPartitionList()
                                    + " from donorNode:" + stealInfo.getDonorId());
                    }

                } finally {
                    // free the permit in all cases.
                    releaseRebalancingPermit();
                    adminClient.stop();
                    migratePartitionsAsyncId = -1;
                }
            }

            @Override
            @JmxGetter(name = "asyncTaskStatus")
            public AsyncOperationStatus getStatus() {
                if(-1 != migratePartitionsAsyncId)
                    try {
                        updateStatus(asyncRunner.getStatus(migratePartitionsAsyncId));
                    } catch(Exception e) {
                        // ignore
                    }

                return super.getStatus();
            }
        });

        return requestId;
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415517895134/fstmerge_var2_3553118746936503899

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d9c19_1b019/rev_d9c19-1b019/src/java/voldemort/server/rebalance/Rebalancer.java
Conflict type: LineBasedMCFd
Conflict body: 
@Test
    public void testSingleRebalancing() throws Exception {
        int clusterSize = ec2RebalancingTestConfig.getInstanceCount();
        int[][] targetLayout;

        if(spareNode)
            targetLayout = splitLastPartition(partitionMap,
                                              partitionMap[clusterSize - 2].length - 2);
        else
            targetLayout = insertNode(partitionMap, partitionMap[clusterSize - 1].length - 2);

        if(logger.isInfoEnabled())
            logPartitionMap(targetLayout, "Target");

        Cluster targetCluster = ServerTestUtils.getLocalCluster(targetLayout.length,
                                                                getPorts(targetLayout.length),
                                                                targetLayout);

        List<Integer> originalNodes = new ArrayList<Integer>();

        for(Node node: originalCluster.getNodes()) {
            originalNodes.add(node.getId());
        }

        targetCluster = expandCluster(targetCluster.getNumberOfNodes() - clusterSize, targetCluster);
        try {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415517901127/fstmerge_var1_8611963800168956336
            RebalanceController rebalanceClient = new RebalanceController(getBootstrapUrl(Arrays.asList(originalCluster.getNodeById(0).getHost())),
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415517901127/fstmerge_base_2548413969552069112
            RebalanceClient rebalanceClient = new RebalanceClient(getBootstrapUrl(Arrays.asList(originalCluster.getNodeById(0).getHost())),
=======
            RebalanceClient rebalanceClient = new RebalanceClient(getBootstrapUrl(Arrays.asList(originalCluster.getNodeById(0)
                                                                                                               .getHost())),
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415517901127/fstmerge_var2_1603584200971522490
                                                                  new RebalanceClientConfig());
            populateData(originalCluster, originalNodes);
            rebalanceAndCheck(originalCluster,
                              targetCluster,
                              rebalanceClient,
                              spareNode ? Arrays.asList(clusterSize - 1) : originalNodes);
        } finally {
            stopCluster(hostNames, ec2RebalancingTestConfig);
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d9c19_1b019/rev_d9c19-1b019/contrib/ec2-testing/test/voldemort/utils/Ec2RebalancingTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415517901137/fstmerge_var1_492640641317668774
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415517901137/fstmerge_base_527623247967641116
private void rebalanceAndCheck(Cluster currentCluster,
                                   Cluster targetCluster,
                                   RebalanceClient rebalanceClient,
                                   List<Integer> nodeCheckList) {
        rebalanceClient.rebalance(currentCluster, targetCluster);

        for(int nodeId: nodeCheckList) {
            List<Integer> availablePartitions = targetCluster.getNodeById(nodeId).getPartitionIds();
            List<Integer> unavailablePartitions = getUnavailablePartitions(targetCluster,
                                                                           availablePartitions);

            checkGetEntries(currentCluster.getNodeById(nodeId),
                            targetCluster,
                            unavailablePartitions,
                            availablePartitions);
        }

    }
=======
private void rebalanceAndCheck(Cluster currentCluster,
                                   Cluster targetCluster,
                                   RebalanceClient rebalanceClient,
                                   List<Integer> nodeCheckList) {
        rebalanceClient.rebalance(targetCluster);

        for(int nodeId: nodeCheckList) {
            List<Integer> availablePartitions = targetCluster.getNodeById(nodeId).getPartitionIds();
            List<Integer> unavailablePartitions = getUnavailablePartitions(targetCluster,
                                                                           availablePartitions);

            checkGetEntries(currentCluster.getNodeById(nodeId),
                            targetCluster,
                            unavailablePartitions,
                            availablePartitions);
        }

    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415517901137/fstmerge_var2_4036659725844173217

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d9c19_1b019/rev_d9c19-1b019/contrib/ec2-testing/test/voldemort/utils/Ec2RebalancingTest.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a0e20_2c25d/rev_a0e20-2c25d.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518100442/fstmerge_var1_2737962835315103381
public int rebalanceLocalNode(final String storeName, final RebalancePartitionsInfo stealInfo) {

        if(!acquireRebalancingPermit()) {
            RebalancePartitionsInfo info = metadataStore.getRebalancingStealInfo();
            throw new VoldemortException("Node "
                                         + metadataStore.getCluster()
                                                        .getNodeById(info.getStealerId())
                                         + " is already rebalancing from " + info.getDonorId()
                                         + " rebalanceInfo:" + info);
        }

        int requestId = asyncRunner.getUniqueRequestId();

        asyncRunner.submitOperation(requestId, new AsyncOperation(requestId, stealInfo.toString()) {
            
            @Override
            public void stop() {
                // TODO: verify if this is correct
                Thread.currentThread().interrupt();
            }

            @Override
            public void operate() throws Exception {
                AdminClient adminClient = RebalanceUtils.createTempAdminClient(voldemortConfig,
                                                                               metadataStore.getCluster());
                try {
                    logger.info("Rebalancer: rebalance " + stealInfo + " starting.");

                    // check and create redirectingSocketStore if needed.
                    checkAndCreateRedirectingSocketStore(storeName,
                                                         adminClient.getAdminClientCluster()
                                                                    .getNodeById(stealInfo.getDonorId()));

                    checkCurrentState(metadataStore, stealInfo);
                    setRebalancingState(metadataStore, stealInfo);

                    migratePartitionsAsyncId = adminClient.migratePartitions(stealInfo.getDonorId(),
                                                                             metadataStore.getNodeId(),
                                                                             storeName,
                                                                             stealInfo.getPartitionList(),
                                                                             null);
                    adminClient.waitForCompletion(metadataStore.getNodeId(),
                                                  migratePartitionsAsyncId,
                                                  voldemortConfig.getAdminSocketTimeout(),
                                                  TimeUnit.SECONDS);

                    logger.info("Rebalancer: rebalance " + stealInfo + " completed successfully.");

                    // clean state only if successfull.
                    metadataStore.cleanAllRebalancingState();
                    if(voldemortConfig.isDeleteAfterRebalancingEnabled()) {
                        logger.warn("Deleting data from donorNode after rebalancing !!");
                        adminClient.deletePartitions(stealInfo.getDonorId(),
                                                     storeName,
                                                     stealInfo.getPartitionList(),
                                                     null);
                        logger.info("Deleted partitions " + stealInfo.getPartitionList()
                                    + " from donorNode:" + stealInfo.getDonorId());
                    }

                } finally {
                    // free the permit in all cases.
                    releaseRebalancingPermit();
                    adminClient.stop();
                    migratePartitionsAsyncId = -1;
                }
            }

            @Override
            @JmxGetter(name = "asyncTaskStatus")
            public AsyncOperationStatus getStatus() {
                if(-1 != migratePartitionsAsyncId)
                    try {
                        updateStatus(asyncRunner.getStatus(migratePartitionsAsyncId));
                    } catch(Exception e) {
                        // ignore
                    }

                return super.getStatus();
            }
        });

        return requestId;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518100442/fstmerge_base_2539943622826367208
public int rebalanceLocalNode(final String storeName, final RebalancePartitionsInfo stealInfo) {

        if(!acquireRebalancingPermit()) {
            RebalancePartitionsInfo info = metadataStore.getRebalancingStealInfo();
            throw new VoldemortException("Node "
                                         + metadataStore.getCluster()
                                                        .getNodeById(info.getStealerId())
                                         + " is already rebalancing from " + info.getDonorId()
                                         + " rebalanceInfo:" + info);
        }

        int requestId = asyncRunner.getUniqueRequestId();

        asyncRunner.submitOperation(requestId, new AsyncOperation(requestId, stealInfo.toString()) {

            @Override
            public void operate() throws Exception {
                AdminClient adminClient = RebalanceUtils.createTempAdminClient(voldemortConfig,
                                                                               metadataStore.getCluster());
                try {
                    logger.info("Rebalancer: rebalance " + stealInfo + " starting.");

                    // check and create redirectingSocketStore if needed.
                    checkAndCreateRedirectingSocketStore(storeName,
                                                         adminClient.getAdminClientCluster()
                                                                    .getNodeById(stealInfo.getDonorId()));

                    checkCurrentState(metadataStore, stealInfo);
                    setRebalancingState(metadataStore, stealInfo);

                    migratePartitionsAsyncId = adminClient.migratePartitions(stealInfo.getDonorId(),
                                                                             metadataStore.getNodeId(),
                                                                             storeName,
                                                                             stealInfo.getPartitionList(),
                                                                             null);
                    adminClient.waitForCompletion(metadataStore.getNodeId(),
                                                  migratePartitionsAsyncId,
                                                  voldemortConfig.getAdminSocketTimeout(),
                                                  TimeUnit.SECONDS);

                    logger.info("Rebalancer: rebalance " + stealInfo + " completed successfully.");

                    // clean state only if successfull.
                    metadataStore.cleanAllRebalancingState();
                    if(voldemortConfig.isDeleteAfterRebalancingEnabled()) {
                        logger.warn("Deleting data from donorNode after rebalancing !!");
                        adminClient.deletePartitions(stealInfo.getDonorId(),
                                                     storeName,
                                                     stealInfo.getPartitionList(),
                                                     null);
                        logger.info("Deleted partitions " + stealInfo.getPartitionList()
                                    + " from donorNode:" + stealInfo.getDonorId());
                    }

                } finally {
                    // free the permit in all cases.
                    releaseRebalancingPermit();
                    adminClient.stop();
                    migratePartitionsAsyncId = -1;
                }
            }

            @Override
            @JmxGetter(name = "asyncTaskStatus")
            public AsyncOperationStatus getStatus() {
                if(-1 != migratePartitionsAsyncId)
                    try {
                        updateStatus(asyncRunner.getStatus(migratePartitionsAsyncId));
                    } catch(Exception e) {
                        // ignore
                    }

                return super.getStatus();
            }
        });

        return requestId;
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518100442/fstmerge_var2_6828423982594852596

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a0e20_2c25d/rev_a0e20-2c25d/src/java/voldemort/server/rebalance/Rebalancer.java
Conflict type: LineBasedMCFd
Conflict body: 
@BeforeClass
    public static void setUpClass() throws Exception {
        ec2RebalancingTestConfig = new Ec2RebalancingTestConfig();
        hostNamePairs = createInstances(ec2RebalancingTestConfig);
        hostNames = toHostNames(hostNamePairs);

        if(logger.isInfoEnabled())
            logger.info("Sleeping for 30 seconds to give EC2 instances some time to complete startup");

        Thread.sleep(30000);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106795/fstmerge_var1_8755285773408021652
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106795/fstmerge_base_3615383127902543979
        
=======

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106795/fstmerge_var2_2385800576504809375
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a0e20_2c25d/rev_a0e20-2c25d/contrib/ec2-testing/test/voldemort/utils/Ec2RebalancingTest.java
Conflict type: LineBasedMCFd
Conflict body: 
private int[][] getPartitionMap(int nodes, int perNode, boolean spareNode) {
          int limit = spareNode ? nodes - 1 : nodes;
          int[][] partitionMap = new int[nodes][];
          int i, k;

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106805/fstmerge_var1_1700855210480906734
          for (i=0, k=0; i<limit; i++) {
              partitionMap[i] = new int[perNode];
              for (int j=0; j < perNode; j++)
                  partitionMap[i][j] = k++;
          }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106805/fstmerge_base_5933660025556205547
        for (i=0, k=0; i<limit; i++) {
            partitionMap[i] = new int[perNode];
            for (int j=0; j < perNode; j++)
                partitionMap[i][j] = k++;
        }
=======
        for(i = 0, k = 0; i < limit; i++) {
            partitionMap[i] = new int[perNode];
            for(int j = 0; j < perNode; j++)
                partitionMap[i][j] = k++;
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106805/fstmerge_var2_1777030055657818934

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106805/fstmerge_var1_1700855210480906734
          if (spareNode)
              partitionMap[limit] = new int[] {};
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106805/fstmerge_base_5933660025556205547
        if (spareNode)
            partitionMap[limit] = new int[] {};
=======
        if(spareNode)
            partitionMap[limit] = new int[] {};
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106805/fstmerge_var2_1777030055657818934

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106805/fstmerge_var1_1700855210480906734
          return partitionMap;
      }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106805/fstmerge_base_5933660025556205547

        return partitionMap;
    }
=======
        return partitionMap;
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106805/fstmerge_var2_1777030055657818934

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a0e20_2c25d/rev_a0e20-2c25d/contrib/ec2-testing/test/voldemort/utils/Ec2RebalancingTest.java
Conflict type: LineBasedMCFd
Conflict body: 
private static int[][] insertNode(int[][] template, int pivot) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106809/fstmerge_var1_4852883155983222204
          int templateLength = template.length;
          int vectorTailLength = template[templateLength-1].length - pivot;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106809/fstmerge_base_2577109888427305474
        int templateLength = template.length;
        int vectorTailLength = template[templateLength-1].length - pivot;
        
        int[][] layout = new int[templateLength+1][];
        layout[templateLength-1] = new int[pivot];
        layout[templateLength] = new int[vectorTailLength];
=======
        int templateLength = template.length;
        int vectorTailLength = template[templateLength - 1].length - pivot;

        int[][] layout = new int[templateLength + 1][];
        layout[templateLength - 1] = new int[pivot];
        layout[templateLength] = new int[vectorTailLength];
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106809/fstmerge_var2_1945677976597447341

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106809/fstmerge_var1_4852883155983222204
          int[][] layout = new int[templateLength+1][];
          layout[templateLength-1] = new int[pivot];
          layout[templateLength] = new int[vectorTailLength];
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106809/fstmerge_base_2577109888427305474
        System.arraycopy(template, 0, layout, 0,  templateLength-1);
        System.arraycopy(template[templateLength-1], 0, layout[templateLength-1], 0, pivot);
        System.arraycopy(template[templateLength-1], pivot, layout[templateLength], 0, vectorTailLength);
=======
        System.arraycopy(template, 0, layout, 0, templateLength - 1);
        System.arraycopy(template[templateLength - 1], 0, layout[templateLength - 1], 0, pivot);
        System.arraycopy(template[templateLength - 1],
                         pivot,
                         layout[templateLength],
                         0,
                         vectorTailLength);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106809/fstmerge_var2_1945677976597447341

          System.arraycopy(template, 0, layout, 0,  templateLength-1);
          System.arraycopy(template[templateLength-1], 0, layout[templateLength-1], 0, pivot);
          System.arraycopy(template[templateLength-1], pivot, layout[templateLength], 0, vectorTailLength);

          return layout;
      }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a0e20_2c25d/rev_a0e20-2c25d/contrib/ec2-testing/test/voldemort/utils/Ec2RebalancingTest.java
Conflict type: LineBasedMCFd
Conflict body: 
private static int[][] splitLastPartition(int[][] template, int pivot) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106817/fstmerge_var1_2269751174259235441
          int templateLength = template.length;
          int vectorTailLength = template[templateLength-2].length - pivot;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106817/fstmerge_base_3951572535224767452
        int templateLength = template.length;
        int vectorTailLength = template[templateLength-2].length - pivot;
=======
        int templateLength = template.length;
        int vectorTailLength = template[templateLength - 2].length - pivot;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106817/fstmerge_var2_1183424376533360894

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106817/fstmerge_var1_2269751174259235441
          int[][] layout = new int[templateLength][];
          layout[templateLength-2] = new int[pivot];
          layout[templateLength-1] = new int[vectorTailLength];
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106817/fstmerge_base_3951572535224767452
        int[][] layout = new int[templateLength][];
        layout[templateLength-2] = new int[pivot];
        layout[templateLength-1] = new int[vectorTailLength];
=======
        int[][] layout = new int[templateLength][];
        layout[templateLength - 2] = new int[pivot];
        layout[templateLength - 1] = new int[vectorTailLength];
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106817/fstmerge_var2_1183424376533360894

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106817/fstmerge_var1_2269751174259235441
          System.arraycopy(template, 0, layout, 0,  templateLength-2);
          System.arraycopy(template[templateLength-2], 0, layout[templateLength-2], 0, pivot);
          System.arraycopy(template[templateLength-2], pivot, layout[templateLength-1], 0, vectorTailLength);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106817/fstmerge_base_3951572535224767452
        System.arraycopy(template, 0, layout, 0,  templateLength-2);
        System.arraycopy(template[templateLength-2], 0, layout[templateLength-2], 0, pivot);
        System.arraycopy(template[templateLength-2], pivot, layout[templateLength-1], 0, vectorTailLength);
=======
        System.arraycopy(template, 0, layout, 0, templateLength - 2);
        System.arraycopy(template[templateLength - 2], 0, layout[templateLength - 2], 0, pivot);
        System.arraycopy(template[templateLength - 2],
                         pivot,
                         layout[templateLength - 1],
                         0,
                         vectorTailLength);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106817/fstmerge_var2_1183424376533360894

          return layout;
      }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a0e20_2c25d/rev_a0e20-2c25d/contrib/ec2-testing/test/voldemort/utils/Ec2RebalancingTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106822/fstmerge_var1_268685298756267935
private static int[] getPorts(int count) {
          int[] ports = new int[count*3];
          for (int i = 0; i < count; i++) {
              ports[3 * i] = 6665;
              ports[3 * i + 1] = 6666;
              ports[3 * i + 2] = 6667;
          }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106822/fstmerge_base_6128606967572389902
private int[] getPorts(int count) {
        int[] ports = new int[count*3];
        for (int i = 0; i < count; i++) {
            ports[3 * i] = 6665;
            ports[3 * i + 1] = 6666;
            ports[3 * i + 2] = 6667;
        }
=======
private int[] getPorts(int count) {
        int[] ports = new int[count * 3];
        for(int i = 0; i < count; i++) {
            ports[3 * i] = 6665;
            ports[3 * i + 1] = 6666;
            ports[3 * i + 2] = 6667;
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106822/fstmerge_var2_9185694166592086024

          return ports;
      }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a0e20_2c25d/rev_a0e20-2c25d/contrib/ec2-testing/test/voldemort/utils/Ec2RebalancingTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Before
    public void setUp() throws Exception {
        Thread.sleep(5000);
        logger.info("Before()");
        int clusterSize = ec2RebalancingTestConfig.getInstanceCount();
        spareNode = ec2RebalancingTestConfig.addNodes == 0;
        partitionMap = getPartitionMap(clusterSize,
                                       ec2RebalancingTestConfig.partitionsPerNode,
                                       spareNode);

        if(logger.isInfoEnabled())
            logPartitionMap(partitionMap, "Original");

        originalCluster = ServerTestUtils.getLocalCluster(clusterSize,
                                                          getPorts(clusterSize),
                                                          partitionMap);
        nodeIds = generateClusterDescriptor(hostNamePairs,
                                            originalCluster,
                                            ec2RebalancingTestConfig);

        deploy(hostNames, ec2RebalancingTestConfig);
        startClusterAsync(hostNames, ec2RebalancingTestConfig, nodeIds);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106827/fstmerge_var1_22432077759420312
        if (logger.isInfoEnabled())
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106827/fstmerge_base_8439107947300338210
        testEntries = ServerTestUtils.createRandomKeyValueString(ec2RebalancingTestConfig.numKeys);
        originalCluster = updateCluster(originalCluster, nodeIds);

        if (logger.isInfoEnabled())
=======
        testEntries = ServerTestUtils.createRandomKeyValueString(ec2RebalancingTestConfig.numKeys);
        originalCluster = updateCluster(originalCluster, nodeIds);

        if(logger.isInfoEnabled())
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106827/fstmerge_var2_7084103890757164530
            logger.info("Sleeping for 15 seconds to let the Voldemort cluster start");
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106827/fstmerge_base_8439107947300338210
        
=======

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106827/fstmerge_var2_7084103890757164530
        Thread.sleep(15000);

        testEntries = ServerTestUtils.createRandomKeyValueString(ec2RebalancingTestConfig.numKeys);
        originalCluster = updateCluster(originalCluster, nodeIds);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a0e20_2c25d/rev_a0e20-2c25d/contrib/ec2-testing/test/voldemort/utils/Ec2RebalancingTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Ignore
    @Test
    public void testSingleRebalancing() throws Exception {
        int clusterSize = ec2RebalancingTestConfig.getInstanceCount();
        int[][] targetLayout;

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106852/fstmerge_var1_6301088303520798749
        if (spareNode)
            targetLayout = splitLastPartition(partitionMap, partitionMap[clusterSize-2].length-2);
        else
            targetLayout = insertNode(partitionMap, partitionMap[clusterSize-1].length-2);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106852/fstmerge_base_1959163885387723334
        if (spareNode)
            targetLayout = splitLastPartition(partitionMap, partitionMap[clusterSize-2].length-2);
        else 
            targetLayout = insertNode(partitionMap, partitionMap[clusterSize-1].length-2);
=======
        if(spareNode)
            targetLayout = splitLastPartition(partitionMap,
                                              partitionMap[clusterSize - 2].length - 2);
        else
            targetLayout = insertNode(partitionMap, partitionMap[clusterSize - 1].length - 2);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106852/fstmerge_var2_2196432751046917990

        if(logger.isInfoEnabled())
            logPartitionMap(targetLayout, "Target");

        Cluster targetCluster = ServerTestUtils.getLocalCluster(targetLayout.length,
                                                                getPorts(targetLayout.length),
                                                                targetLayout);

        List<Integer> originalNodes = new ArrayList<Integer>();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106852/fstmerge_var1_6301088303520798749
        for (Node node: originalCluster.getNodes()) {
            if (node.getId() == (clusterSize-1) && spareNode)
                break;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106852/fstmerge_base_1959163885387723334

        for (Node node: originalCluster.getNodes()) {
=======

        for(Node node: originalCluster.getNodes()) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106852/fstmerge_var2_2196432751046917990
            originalNodes.add(node.getId());
        }

        try {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106852/fstmerge_var1_6301088303520798749
            targetCluster = expandCluster(targetCluster.getNumberOfNodes() - clusterSize, targetCluster);
            RebalanceClient rebalanceClient = new RebalanceClient(getBootstrapUrl(originalCluster, 0),
                                                                  new RebalanceClientConfig());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106852/fstmerge_base_1959163885387723334
            RebalanceClient rebalanceClient = new RebalanceClient(getBootstrapUrl(Arrays.asList(originalCluster.getNodeById(0).getHost())),
                                                                  new RebalanceClientConfig());
=======

            RebalanceController rebalanceClient = new RebalanceController(getBootstrapUrl(Arrays.asList(originalCluster.getNodeById(0)
                                                                                                                       .getHost())),
                                                                          new RebalanceClientConfig());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415518106852/fstmerge_var2_2196432751046917990
            populateData(originalCluster, originalNodes);
            rebalanceAndCheck(originalCluster,
                              targetCluster,
                              rebalanceClient,
                              originalNodes);
        } finally {
            stopCluster(hostNames, ec2RebalancingTestConfig);
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a0e20_2c25d/rev_a0e20-2c25d/contrib/ec2-testing/test/voldemort/utils/Ec2RebalancingTest.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_059ac_2c168/rev_059ac-2c168.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2a21f_925cc/rev_2a21f-925cc.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a0002_1f6a8/rev_a0002-1f6a8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7de50_954e0/rev_7de50-954e0.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public boolean delete(final ByteArray key, final Version version) throws VoldemortException {
        StoreUtils.assertValidKey(key);
        final List<Node> nodes = availableNodes(routingStrategy.routeRequest(key.get()));

        // quickly fail if there aren't enough live nodes to meet the
        // requirements
        final int numNodes = nodes.size();
        if(numNodes < this.storeDef.getRequiredWrites())
            throw new InsufficientOperationalNodesException("Only " + numNodes
                                                            + " nodes in preference list, but "
                                                            + this.storeDef.getRequiredWrites()
                                                            + " writes required.");

        // A count of the number of successful operations
        final AtomicInteger successes = new AtomicInteger(0);
        final AtomicBoolean deletedSomething = new AtomicBoolean(false);
        // A list of thrown exceptions, indicating the number of failures
        final List<Exception> failures = Collections.synchronizedList(new LinkedList<Exception>());

        // A semaphore indicating the number of completed operations
        // Once inititialized all permits are acquired, after that
        // permits are released when an operation is completed.
        // semaphore.acquire(n) waits for n operations to complete
        final Semaphore semaphore = new Semaphore(0, false);
        // Add the operations to the pool
        for(final Node node: nodes) {
            this.executor.execute(new Runnable() {

                public void run() {
                    try {
                        boolean deleted = innerStores.get(node.getId()).delete(key, version);
                        successes.incrementAndGet();
                        deletedSomething.compareAndSet(false, deleted);
                        failureDetector.recordSuccess(node);
                    } catch(UnreachableStoreException e) {
                        failures.add(e);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415519039136/fstmerge_var1_3649742891428982287
                        markUnavailable(node, e);
                    } catch(VoldemortApplicationException e) {
                        throw e;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415519039136/fstmerge_base_3970926357457929412
                        markUnavailable(node, e);
=======
                        failureDetector.recordException(node, e);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415519039136/fstmerge_var2_2465125244249502541
                    } catch(Exception e) {
                        failures.add(e);
                        logger.warn("Error in DELETE on node " + node.getId() + "("
                                    + node.getHost() + ")", e);
                    } finally {
                        // signal that the operation is complete
                        semaphore.release();
                    }
                }
            });
        }

        int attempts = Math.min(storeDef.getPreferredWrites(), numNodes);
        if(this.storeDef.getPreferredWrites() <= 0) {
            return true;
        } else {
            for(int i = 0; i < numNodes; i++) {
                try {
                    boolean acquired = semaphore.tryAcquire(timeoutMs, TimeUnit.MILLISECONDS);
                    if(!acquired)
                        logger.warn("Delete operation timed out waiting for operation " + i
                                    + " to complete after waiting " + timeoutMs + " ms.");
                    // okay, at least the required number of operations have
                    // completed, were they successful?
                    if(successes.get() >= attempts)
                        return deletedSomething.get();
                } catch(InterruptedException e) {
                    throw new InsufficientOperationalNodesException("Delete operation interrupted!",
                                                                    e);
                }
            }
        }

        // If we get to here, that means we couldn't hit the preferred number
        // of writes, throw an exception if you can't even hit the required
        // number
        if(successes.get() < storeDef.getRequiredWrites())
            throw new InsufficientOperationalNodesException(this.storeDef.getRequiredWrites()
                                                                    + " deletes required, but "
                                                                    + successes.get()
                                                                    + " succeeded.",
                                                            failures);
        else
            return deletedSomething.get();
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7de50_954e0/rev_7de50-954e0/src/java/voldemort/store/routed/RoutedStore.java
Conflict type: LineBasedMCFd
Conflict body: 
public Map<ByteArray, List<Versioned<byte[]>>> getAll(Iterable<ByteArray> keys)
            throws VoldemortException {
        StoreUtils.assertValidKeys(keys);

        Map<ByteArray, List<Versioned<byte[]>>> result = StoreUtils.newEmptyHashMap(keys);

        // Keys for each node needed to satisfy storeDef.getPreferredReads() if
        // no failures.
        Map<Node, List<ByteArray>> nodeToKeysMap = Maps.newHashMap();

        // Keep track of nodes per key that might be needed if there are
        // failures during getAll
        Map<ByteArray, List<Node>> keyToExtraNodesMap = Maps.newHashMap();

        for(ByteArray key: keys) {
            List<Node> availableNodes = availableNodes(routingStrategy.routeRequest(key.get()));

            // quickly fail if there aren't enough nodes to meet the requirement
            checkRequiredReads(availableNodes);
            int preferredReads = storeDef.getPreferredReads();
            List<Node> preferredNodes = Lists.newArrayListWithCapacity(preferredReads);
            List<Node> extraNodes = Lists.newArrayListWithCapacity(3);

            for(Node node: availableNodes) {
                if(preferredNodes.size() < preferredReads)
                    preferredNodes.add(node);
                else
                    extraNodes.add(node);
            }

            for(Node node: preferredNodes) {
                List<ByteArray> nodeKeys = nodeToKeysMap.get(node);
                if(nodeKeys == null) {
                    nodeKeys = Lists.newArrayList();
                    nodeToKeysMap.put(node, nodeKeys);
                }
                nodeKeys.add(key);
            }
            if(!extraNodes.isEmpty()) {
                List<Node> nodes = keyToExtraNodesMap.get(key);
                if(nodes == null)
                    keyToExtraNodesMap.put(key, extraNodes);
                else
                    nodes.addAll(extraNodes);
            }
        }

        List<Callable<GetAllResult>> callables = Lists.newArrayList();
        for(Map.Entry<Node, List<ByteArray>> entry: nodeToKeysMap.entrySet()) {
            final Node node = entry.getKey();
            final Collection<ByteArray> nodeKeys = entry.getValue();
            if(failureDetector.isAvailable(node))
                callables.add(new GetAllCallable(node, nodeKeys));
        }

        // A list of thrown exceptions, indicating the number of failures
        List<Throwable> failures = Lists.newArrayList();
        List<NodeValue<ByteArray, byte[]>> nodeValues = Lists.newArrayList();

        Map<ByteArray, MutableInt> keyToSuccessCount = Maps.newHashMap();
        for(ByteArray key: keys)
            keyToSuccessCount.put(key, new MutableInt(0));

        List<Future<GetAllResult>> futures;
        try {
            // TODO What to do about timeouts? They should be longer as getAll
            // is likely to
            // take longer. At the moment, it's just timeoutMs * 3, but should
            // this be based on the number of the keys?
            futures = executor.invokeAll(callables, timeoutMs * 3, TimeUnit.MILLISECONDS);
        } catch(InterruptedException e) {
            throw new InsufficientOperationalNodesException("getAll operation interrupted.", e);
        }
        for(Future<GetAllResult> f: futures) {
            if(f.isCancelled()) {
                logger.warn("Get operation timed out after " + timeoutMs + " ms.");
                continue;
            }
            try {
                GetAllResult getResult = f.get();
                if(getResult.exception != null) {
                    failures.add(getResult.exception);
                    continue;
                }
                for(ByteArray key: getResult.callable.nodeKeys) {
                    List<Versioned<byte[]>> retrieved = getResult.retrieved.get(key);
                    MutableInt successCount = keyToSuccessCount.get(key);
                    successCount.increment();

                    /*
                     * retrieved can be null if there are no values for the key
                     * provided
                     */
                    if(retrieved != null) {
                        List<Versioned<byte[]>> existing = result.get(key);
                        if(existing == null)
                            result.put(key, Lists.newArrayList(retrieved));
                        else
                            existing.addAll(retrieved);
                    }
                }
                nodeValues.addAll(getResult.nodeValues);

            } catch(InterruptedException e) {
                throw new InsufficientOperationalNodesException("getAll operation interrupted.", e);
            } catch(ExecutionException e) {
                // We catch all Throwables apart from Error in the callable, so
                // the else part
                // should never happen
                if(e.getCause() instanceof Error)
                    throw (Error) e.getCause();
                else
                    logger.error(e.getMessage(), e);
            }
        }

        for(ByteArray key: keys) {
            MutableInt successCountWrapper = keyToSuccessCount.get(key);
            int successCount = successCountWrapper.intValue();
            if(successCount < storeDef.getPreferredReads()) {
                List<Node> extraNodes = keyToExtraNodesMap.get(key);
                if(extraNodes != null) {
                    for(Node node: extraNodes) {
                        try {
                            List<Versioned<byte[]>> values = innerStores.get(node.getId()).get(key);
                            fillRepairReadsValues(nodeValues, key, node, values);
                            List<Versioned<byte[]>> versioneds = result.get(key);
                            if(versioneds == null)
                                result.put(key, Lists.newArrayList(values));
                            else
                                versioneds.addAll(values);
                            failureDetector.recordSuccess(node);
                            if(++successCount >= storeDef.getPreferredReads())
                                break;

                        } catch(UnreachableStoreException e) {
                            failures.add(e);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415519039141/fstmerge_var1_6320749455899824621
                            markUnavailable(node, e);
                        } catch(VoldemortApplicationException e) {
                            throw e;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415519039141/fstmerge_base_7733813342510122308
                            markUnavailable(node, e);
=======
                            failureDetector.recordException(node, e);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415519039141/fstmerge_var2_8731198572871116080
                        } catch(Exception e) {
                            logger.warn("Error in GET_ALL on node " + node.getId() + "("
                                        + node.getHost() + ")", e);
                            failures.add(e);
                        }
                    }
                }
            }
            successCountWrapper.setValue(successCount);
        }

        repairReads(nodeValues);

        for(Map.Entry<ByteArray, MutableInt> mapEntry: keyToSuccessCount.entrySet()) {
            int successCount = mapEntry.getValue().intValue();
            if(successCount < storeDef.getRequiredReads())
                throw new InsufficientOperationalNodesException(this.storeDef.getRequiredReads()
                                                                        + " reads required, but "
                                                                        + successCount
                                                                        + " succeeded.",
                                                                failures);
        }

        return result;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7de50_954e0/rev_7de50-954e0/src/java/voldemort/store/routed/RoutedStore.java
Conflict type: LineBasedMCFd
Conflict body: 
private <R> List<R> get(final ByteArray key,
                            StoreOp<R> fetcher,
                            Function<List<GetResult<R>>, Void> preReturnProcedure)
            throws VoldemortException {
        StoreUtils.assertValidKey(key);
        final List<Node> nodes = availableNodes(routingStrategy.routeRequest(key.get()));

        // quickly fail if there aren't enough nodes to meet the requirement
        checkRequiredReads(nodes);

        final List<GetResult<R>> retrieved = Lists.newArrayList();

        // A count of the number of successful operations
        int successes = 0;
        // A list of thrown exceptions, indicating the number of failures
        final List<Throwable> failures = Lists.newArrayListWithCapacity(3);

        // Do the preferred number of reads in parallel
        int attempts = Math.min(this.storeDef.getPreferredReads(), nodes.size());
        int nodeIndex = 0;
        List<Callable<GetResult<R>>> callables = Lists.newArrayListWithCapacity(attempts);
        for(; nodeIndex < attempts; nodeIndex++) {
            final Node node = nodes.get(nodeIndex);
            callables.add(new GetCallable<R>(node, key, fetcher));
        }

        List<Future<GetResult<R>>> futures;
        try {
            futures = executor.invokeAll(callables, timeoutMs, TimeUnit.MILLISECONDS);
        } catch(InterruptedException e) {
            throw new InsufficientOperationalNodesException("Get operation interrupted!", e);
        }

        for(Future<GetResult<R>> f: futures) {
            if(f.isCancelled()) {
                logger.warn("Get operation timed out after " + timeoutMs + " ms.");
                continue;
            }
            try {
                GetResult<R> getResult = f.get();
                if(getResult.exception != null) {
                    failures.add(getResult.exception);
                    continue;
                }
                ++successes;
                retrieved.add(getResult);
            } catch(InterruptedException e) {
                throw new InsufficientOperationalNodesException("Get operation interrupted!", e);
            } catch(ExecutionException e) {
                // We catch all Throwable subclasses apart from Error in the
                // callable, so the else
                // part should never happen.
                if(e.getCause() instanceof Error)
                    throw (Error) e.getCause();
                else
                    logger.error(e.getMessage(), e);
            }
        }

        // Now if we had any failures we will be short a few reads. Do serial
        // reads to make up for these.
        while(successes < this.storeDef.getPreferredReads() && nodeIndex < nodes.size()) {
            Node node = nodes.get(nodeIndex);
            try {
                retrieved.add(new GetResult<R>(node,
                                               key,
                                               fetcher.execute(innerStores.get(node.getId()), key),
                                               null));
                ++successes;
                failureDetector.recordSuccess(node);
            } catch(UnreachableStoreException e) {
                failures.add(e);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415519039151/fstmerge_var1_7949233987132158153
                markUnavailable(node, e);
            } catch(VoldemortApplicationException e) {
                throw e;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415519039151/fstmerge_base_462391395792891993
                markUnavailable(node, e);
=======
                failureDetector.recordException(node, e);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415519039151/fstmerge_var2_4535268879765681442
            } catch(Exception e) {
                logger.warn("Error in GET on node " + node.getId() + "(" + node.getHost() + ")", e);
                failures.add(e);
            }
            nodeIndex++;
        }

        if(logger.isTraceEnabled())
            logger.trace("GET retrieved the following node values: " + formatNodeValues(retrieved));

        if(preReturnProcedure != null)
            preReturnProcedure.apply(retrieved);

        if(successes >= this.storeDef.getRequiredReads()) {
            List<R> result = Lists.newArrayListWithExpectedSize(retrieved.size());
            for(GetResult<R> getResult: retrieved)
                result.addAll(getResult.retrieved);
            return result;
        } else
            throw new InsufficientOperationalNodesException(this.storeDef.getRequiredReads()
                                                            + " reads required, but " + successes
                                                            + " succeeded.", failures);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7de50_954e0/rev_7de50-954e0/src/java/voldemort/store/routed/RoutedStore.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_9febb_f0561/rev_9febb-f0561.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_aaa5f_b00c1/rev_aaa5f-b00c1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_16934_15bd2/rev_16934-15bd2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_4e699_7b6ee/rev_4e699-7b6ee.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_9c35a_cdf2d/rev_9c35a-cdf2d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_9c35a_cdf2d/rev_9c35a-cdf2d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d9f32_aa571/rev_d9f32-aa571.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public void rebalance(final Cluster targetCluster) {
        Versioned<Cluster> currentVersionedCluster = RebalanceUtils.getLatestCluster(new ArrayList<Integer>(),
                                                                                     adminClient);
        logger.info("Current Cluster configuration:" + currentVersionedCluster);
        logger.info("Target Cluster configuration:" + targetCluster);

        Cluster currentCluster = currentVersionedCluster.getValue();
        adminClient.setAdminClientCluster(currentCluster);

        List<String> storeList = RebalanceUtils.getStoreNameList(currentCluster, adminClient);

        final RebalanceClusterPlan rebalanceClusterPlan = new RebalanceClusterPlan(currentCluster,
                                                                                   targetCluster,
                                                                                   storeList,
                                                                                   rebalanceConfig.isDeleteAfterRebalancingEnabled());
        logger.info(rebalanceClusterPlan);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520449677/fstmerge_base_4677446621439613237
        // add all new nodes to currentCluster
=======
        // add all new nodes to currentCluster and propagate to all
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520449677/fstmerge_var2_4915363243962145370
        currentCluster = getClusterWithNewNodes(currentCluster, targetCluster);
        adminClient.setAdminClientCluster(currentCluster);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520449677/fstmerge_base_4677446621439613237
=======
        Node firstNode = currentCluster.getNodes().iterator().next();
        RebalanceUtils.propagateCluster(adminClient,
                                        currentCluster,
                                        ((VectorClock) currentVersionedCluster.getVersion()).incremented(firstNode.getId(),
                                                                                                         System.currentTimeMillis()),
                                        new ArrayList<Integer>());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520449677/fstmerge_var2_4915363243962145370

        // start all threads
        for(int nThreads = 0; nThreads < this.rebalanceConfig.getMaxParallelRebalancing(); nThreads++) {
            this.executor.execute(new Runnable() {

                public void run() {
                    // pick one node to rebalance from queue
                    while(!rebalanceClusterPlan.getRebalancingTaskQueue().isEmpty()) {

                        RebalanceNodePlan rebalanceTask = rebalanceClusterPlan.getRebalancingTaskQueue()
                                                                              .poll();
                        if(null != rebalanceTask) {
                            int stealerNodeId = rebalanceTask.getStealerNode();
                            List<RebalancePartitionsInfo> rebalanceSubTaskList = rebalanceTask.getRebalanceTaskList();

                            while(rebalanceSubTaskList.size() > 0) {
                                int index = (int) Math.random() * rebalanceSubTaskList.size();
                                RebalancePartitionsInfo rebalanceSubTask = rebalanceSubTaskList.remove(index);
                                logger.info("Starting rebalancing for stealerNode:" + stealerNodeId
                                            + " rebalanceInfo:" + rebalanceSubTask);

                                try {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520449677/fstmerge_var1_6171590446345080137
                                    // TODO : Should not delete data here
                                    int rebalanceAsyncId = startNodeRebalancing(rebalanceSubTask);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520449677/fstmerge_base_4677446621439613237
                                    int rebalanceAsyncId = adminClient.rebalanceNode(rebalanceSubTask);
=======
                                    int rebalanceAsyncId = startNodeRebalancing(rebalanceSubTask);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520449677/fstmerge_var2_4915363243962145370

                                    try {
                                        commitClusterChanges(adminClient.getAdminClientCluster()
                                                                        .getNodeById(stealerNodeId),
                                                             targetCluster,
                                                             rebalanceSubTask);
                                    } catch(Exception e) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520449677/fstmerge_base_4677446621439613237
                                        adminClient.stopAsyncRequest(rebalanceSubTask.getStealerId(),
                                                                     rebalanceAsyncId);
=======
                                        if(-1 != rebalanceAsyncId) {
                                            adminClient.stopAsyncRequest(rebalanceSubTask.getStealerId(),
                                                                         rebalanceAsyncId);
                                        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520449677/fstmerge_var2_4915363243962145370
                                        throw e;
                                    }

                                    adminClient.waitForCompletion(rebalanceSubTask.getStealerId(),
                                                                  rebalanceAsyncId,
                                                                  rebalanceConfig.getRebalancingClientTimeoutSeconds(),
                                                                  TimeUnit.SECONDS);

                                    logger.info("Successfully finished RebalanceSubTask attempt:"
                                                + rebalanceSubTask);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520449677/fstmerge_base_4677446621439613237
=======
                                } catch(UnreachableStoreException e) {
                                    logger.error("StealerNode "
                                                         + stealerNodeId
                                                         + " is unreachable, please make sure it is up and running ..",
                                                 e);
                                } catch(VoldemortRebalancingException e) {
                                    logger.error(e);
                                    for(Exception cause: e.getCauses()) {
                                        logger.error(cause);
                                    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520449677/fstmerge_var2_4915363243962145370
                                } catch(Exception e) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520449677/fstmerge_base_4677446621439613237
                                    logger.warn("rebalancing task (" + rebalanceSubTask
                                                + ") failed with exception:", e);
=======
                                    logger.error("Rebalancing task failed with exception", e);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520449677/fstmerge_var2_4915363243962145370
                                }
                            }
                        }
                    }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520449677/fstmerge_base_4677446621439613237
                    logger.debug("Thread run() finished:\n");
=======
                    logger.info("Thread run() finished:\n");
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520449677/fstmerge_var2_4915363243962145370
                }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520449677/fstmerge_base_4677446621439613237
=======

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520449677/fstmerge_var2_4915363243962145370
            });
        }// for (nThreads ..
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520449677/fstmerge_base_4677446621439613237

=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520449677/fstmerge_var2_4915363243962145370
        executorShutDown(executor);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d9f32_aa571/rev_d9f32-aa571/src/java/voldemort/client/rebalance/RebalanceController.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_e3c26/rev_7763a-e3c26.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520875226/fstmerge_var1_4215283806984882284
private void doOperation(StreamOperations e,
                             int nodeId,
                             String storeName,
                             List<Integer> partitionList) {
        switch(e) {
            case DELETE_PARTITIONS:
                putAlltoStore();
                getAdminClient().deletePartitions(nodeId, storeName, partitionList, null);
                return;
            case FETCH_ENTRIES:
                putAlltoStore();
                consumeIterator(getAdminClient().fetchEntries(nodeId,
                                                                       storeName,
                                                                       partitionList,
                                                                       null));
                return;
            case FETCH_KEYS:
                putAlltoStore();
                consumeIterator(getAdminClient().fetchKeys(nodeId,
                                                                    storeName,
                                                                    partitionList,
                                                                    null));
                return;
            case UPDATE_ENTRIES:
                getAdminClient().updateEntries(nodeId,
                                               storeName,
                                               getRandomlyFailingIterator(ServerTestUtils.createRandomKeyValuePairs(TEST_KEYS)),
                                               null);
                return;
            case TRUNCATE_ENTRIES:
                putAlltoStore();
                getAdminClient().truncate(nodeId, storeName);
                return;

            default:
                throw new RuntimeException("Unknown operation");
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520875226/fstmerge_base_7742823577928882999
private void doOperation(StreamOperations e,
                             int nodeId,
                             String storeName,
                             List<Integer> partitionList) {
        switch(e) {
            case DELETE_PARTITIONS:
                putAlltoStore();
                getAdminClient().deletePartitions(nodeId, storeName, partitionList, null);
                return;
            case FETCH_ENTRIES:
                putAlltoStore();
                consumeIterator(getAdminClient().fetchEntries(nodeId,
                                                                       storeName,
                                                                       partitionList,
                                                                       null));
                return;
            case FETCH_KEYS:
                putAlltoStore();
                consumeIterator(getAdminClient().fetchKeys(nodeId,
                                                                    storeName,
                                                                    partitionList,
                                                                    null));
                return;
            case UPDATE_ENTRIES:
                getAdminClient().updateEntries(nodeId,
                                               storeName,
                                               getRandomlyFailingIterator(ServerTestUtils.createRandomKeyValuePairs(TEST_KEYS)),
                                               null);
                return;
            default:
                throw new RuntimeException("Unknown operation");
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520875226/fstmerge_var2_2301826430846343054

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be/test/unit/voldemort/client/AdminServiceFailureTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520881904/fstmerge_var1_4470248621768996520
public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (hasType()) {
        output.writeEnum(1, getType().getNumber());
      }
      if (hasShouldRoute()) {
        output.writeBool(2, getShouldRoute());
      }
      if (hasStore()) {
        output.writeString(3, getStore());
      }
      if (hasGet()) {
        output.writeMessage(4, getGet());
      }
      if (hasGetAll()) {
        output.writeMessage(5, getGetAll());
      }
      if (hasPut()) {
        output.writeMessage(6, getPut());
      }
      if (hasDelete()) {
        output.writeMessage(7, getDelete());
      }
      getUnknownFields().writeTo(output);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520881904/fstmerge_base_2224468871020222336
@Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
            if(hasType()) {
                output.writeEnum(1, getType().getNumber());
            }
            if(hasShouldRoute()) {
                output.writeBool(2, getShouldRoute());
            }
            if(hasStore()) {
                output.writeString(3, getStore());
            }
            if(hasGet()) {
                output.writeMessage(4, getGet());
            }
            if(hasGetAll()) {
                output.writeMessage(5, getGetAll());
            }
            if(hasPut()) {
                output.writeMessage(6, getPut());
            }
            if(hasDelete()) {
                output.writeMessage(7, getDelete());
            }
            getUnknownFields().writeTo(output);
        }
=======
public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (hasType()) {
        output.writeEnum(1, getType().getNumber());
      }
      if (hasShouldRoute()) {
        output.writeBool(2, getShouldRoute());
      }
      if (hasStore()) {
        output.writeString(3, getStore());
      }
      if (hasGet()) {
        output.writeMessage(4, getGet());
      }
      if (hasGetAll()) {
        output.writeMessage(5, getGetAll());
      }
      if (hasPut()) {
        output.writeMessage(6, getPut());
      }
      if (hasDelete()) {
        output.writeMessage(7, getDelete());
      }
      if (hasRequestRouteType()) {
        output.writeInt32(8, getRequestRouteType());
      }
      getUnknownFields().writeTo(output);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520881904/fstmerge_var2_7453576654888389660

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be/src/java/voldemort/client/protocol/pb/VProto.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520881909/fstmerge_var1_6501265591393584939
public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
    
      size = 0;
      if (hasType()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, getType().getNumber());
      }
      if (hasShouldRoute()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, getShouldRoute());
      }
      if (hasStore()) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(3, getStore());
      }
      if (hasGet()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getGet());
      }
      if (hasGetAll()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getGetAll());
      }
      if (hasPut()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getPut());
      }
      if (hasDelete()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getDelete());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520881909/fstmerge_base_1496496181744305730
@Override
        public int getSerializedSize() {
            int size = memoizedSerializedSize;
            if(size != -1)
                return size;

            size = 0;
            if(hasType()) {
                size += com.google.protobuf.CodedOutputStream.computeEnumSize(1,
                                                                              getType().getNumber());
            }
            if(hasShouldRoute()) {
                size += com.google.protobuf.CodedOutputStream.computeBoolSize(2, getShouldRoute());
            }
            if(hasStore()) {
                size += com.google.protobuf.CodedOutputStream.computeStringSize(3, getStore());
            }
            if(hasGet()) {
                size += com.google.protobuf.CodedOutputStream.computeMessageSize(4, getGet());
            }
            if(hasGetAll()) {
                size += com.google.protobuf.CodedOutputStream.computeMessageSize(5, getGetAll());
            }
            if(hasPut()) {
                size += com.google.protobuf.CodedOutputStream.computeMessageSize(6, getPut());
            }
            if(hasDelete()) {
                size += com.google.protobuf.CodedOutputStream.computeMessageSize(7, getDelete());
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSerializedSize = size;
            return size;
        }
=======
public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
    
      size = 0;
      if (hasType()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, getType().getNumber());
      }
      if (hasShouldRoute()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, getShouldRoute());
      }
      if (hasStore()) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(3, getStore());
      }
      if (hasGet()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getGet());
      }
      if (hasGetAll()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getGetAll());
      }
      if (hasPut()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getPut());
      }
      if (hasDelete()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getDelete());
      }
      if (hasRequestRouteType()) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(8, getRequestRouteType());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520881909/fstmerge_var2_5901628272199418084

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be/src/java/voldemort/client/protocol/pb/VProto.java
Conflict type: LineBasedMCFd
Conflict body: 
public Builder mergeFrom(voldemort.client.protocol.pb.VProto.VoldemortRequest other) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520882031/fstmerge_var1_7715946289026847322
        if (other == voldemort.client.protocol.pb.VProto.VoldemortRequest.getDefaultInstance()) return this;
        if (other.hasType()) {
          setType(other.getType());
        }
        if (other.hasShouldRoute()) {
          setShouldRoute(other.getShouldRoute());
        }
        if (other.hasStore()) {
          setStore(other.getStore());
        }
        if (other.hasGet()) {
          mergeGet(other.getGet());
        }
        if (other.hasGetAll()) {
          mergeGetAll(other.getGetAll());
        }
        if (other.hasPut()) {
          mergePut(other.getPut());
        }
        if (other.hasDelete()) {
          mergeDelete(other.getDelete());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520882031/fstmerge_base_6233539810179371090
                if(other == voldemort.client.protocol.pb.VProto.VoldemortRequest.getDefaultInstance())
                    return this;
                if(other.hasType()) {
                    setType(other.getType());
                }
                if(other.hasShouldRoute()) {
                    setShouldRoute(other.getShouldRoute());
                }
                if(other.hasStore()) {
                    setStore(other.getStore());
                }
                if(other.hasGet()) {
                    mergeGet(other.getGet());
                }
                if(other.hasGetAll()) {
                    mergeGetAll(other.getGetAll());
                }
                if(other.hasPut()) {
                    mergePut(other.getPut());
                }
                if(other.hasDelete()) {
                    mergeDelete(other.getDelete());
                }
                this.mergeUnknownFields(other.getUnknownFields());
                return this;
            }
=======
        if (other == voldemort.client.protocol.pb.VProto.VoldemortRequest.getDefaultInstance()) return this;
        if (other.hasType()) {
          setType(other.getType());
        }
        if (other.hasShouldRoute()) {
          setShouldRoute(other.getShouldRoute());
        }
        if (other.hasStore()) {
          setStore(other.getStore());
        }
        if (other.hasGet()) {
          mergeGet(other.getGet());
        }
        if (other.hasGetAll()) {
          mergeGetAll(other.getGetAll());
        }
        if (other.hasPut()) {
          mergePut(other.getPut());
        }
        if (other.hasDelete()) {
          mergeDelete(other.getDelete());
        }
        if (other.hasRequestRouteType()) {
          setRequestRouteType(other.getRequestRouteType());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520882031/fstmerge_var2_6490313564713260529

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be/src/java/voldemort/client/protocol/pb/VProto.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520882036/fstmerge_base_1904441072557627446
@Override
            public Builder mergeFrom(com.google.protobuf.CodedInputStream input,
                                     com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                com.google.protobuf.UnknownFieldSet.Builder unknownFields = com.google.protobuf.UnknownFieldSet.newBuilder(this.getUnknownFields());
                while(true) {
                    int tag = input.readTag();
                    switch(tag) {
                        case 0:
                            this.setUnknownFields(unknownFields.build());
                            return this;
                        default: {
                            if(!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                                this.setUnknownFields(unknownFields.build());
                                return this;
                            }
                            break;
                        }
                        case 8: {
                            int rawValue = input.readEnum();
                            voldemort.client.protocol.pb.VProto.RequestType value = voldemort.client.protocol.pb.VProto.RequestType.valueOf(rawValue);
                            if(value == null) {
                                unknownFields.mergeVarintField(1, rawValue);
                            } else {
                                setType(value);
                            }
                            break;
                        }
                        case 16: {
                            setShouldRoute(input.readBool());
                            break;
                        }
                        case 26: {
                            setStore(input.readString());
                            break;
                        }
                        case 34: {
                            voldemort.client.protocol.pb.VProto.GetRequest.Builder subBuilder = voldemort.client.protocol.pb.VProto.GetRequest.newBuilder();
                            if(hasGet()) {
                                subBuilder.mergeFrom(getGet());
                            }
                            input.readMessage(subBuilder, extensionRegistry);
                            setGet(subBuilder.buildPartial());
                            break;
                        }
                        case 42: {
                            voldemort.client.protocol.pb.VProto.GetAllRequest.Builder subBuilder = voldemort.client.protocol.pb.VProto.GetAllRequest.newBuilder();
                            if(hasGetAll()) {
                                subBuilder.mergeFrom(getGetAll());
                            }
                            input.readMessage(subBuilder, extensionRegistry);
                            setGetAll(subBuilder.buildPartial());
                            break;
                        }
                        case 50: {
                            voldemort.client.protocol.pb.VProto.PutRequest.Builder subBuilder = voldemort.client.protocol.pb.VProto.PutRequest.newBuilder();
                            if(hasPut()) {
                                subBuilder.mergeFrom(getPut());
                            }
                            input.readMessage(subBuilder, extensionRegistry);
                            setPut(subBuilder.buildPartial());
                            break;
                        }
                        case 58: {
                            voldemort.client.protocol.pb.VProto.DeleteRequest.Builder subBuilder = voldemort.client.protocol.pb.VProto.DeleteRequest.newBuilder();
                            if(hasDelete()) {
                                subBuilder.mergeFrom(getDelete());
                            }
                            input.readMessage(subBuilder, extensionRegistry);
                            setDelete(subBuilder.buildPartial());
                            break;
                        }
                    }
                }
=======
public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder(
            this.getUnknownFields());
        while (true) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              this.setUnknownFields(unknownFields.build());
              return this;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                this.setUnknownFields(unknownFields.build());
                return this;
              }
              break;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520882036/fstmerge_var2_4895092689944739191
            }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520882036/fstmerge_var1_6211376865990683177
            case 8: {
              int rawValue = input.readEnum();
              voldemort.client.protocol.pb.VProto.RequestType value = voldemort.client.protocol.pb.VProto.RequestType.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(1, rawValue);
              } else {
                setType(value);
              }
              break;
            }
            case 16: {
              setShouldRoute(input.readBool());
              break;
            }
            case 26: {
              setStore(input.readString());
              break;
            }
            case 34: {
              voldemort.client.protocol.pb.VProto.GetRequest.Builder subBuilder = voldemort.client.protocol.pb.VProto.GetRequest.newBuilder();
              if (hasGet()) {
                subBuilder.mergeFrom(getGet());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setGet(subBuilder.buildPartial());
              break;
            }
            case 42: {
              voldemort.client.protocol.pb.VProto.GetAllRequest.Builder subBuilder = voldemort.client.protocol.pb.VProto.GetAllRequest.newBuilder();
              if (hasGetAll()) {
                subBuilder.mergeFrom(getGetAll());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setGetAll(subBuilder.buildPartial());
              break;
            }
            case 50: {
              voldemort.client.protocol.pb.VProto.PutRequest.Builder subBuilder = voldemort.client.protocol.pb.VProto.PutRequest.newBuilder();
              if (hasPut()) {
                subBuilder.mergeFrom(getPut());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setPut(subBuilder.buildPartial());
              break;
            }
            case 58: {
              voldemort.client.protocol.pb.VProto.DeleteRequest.Builder subBuilder = voldemort.client.protocol.pb.VProto.DeleteRequest.newBuilder();
              if (hasDelete()) {
                subBuilder.mergeFrom(getDelete());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setDelete(subBuilder.buildPartial());
              break;
            }
          }
        }
      }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520882036/fstmerge_base_1904441072557627446
=======
            case 8: {
              int rawValue = input.readEnum();
              voldemort.client.protocol.pb.VProto.RequestType value = voldemort.client.protocol.pb.VProto.RequestType.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(1, rawValue);
              } else {
                setType(value);
              }
              break;
            }
            case 16: {
              setShouldRoute(input.readBool());
              break;
            }
            case 26: {
              setStore(input.readString());
              break;
            }
            case 34: {
              voldemort.client.protocol.pb.VProto.GetRequest.Builder subBuilder = voldemort.client.protocol.pb.VProto.GetRequest.newBuilder();
              if (hasGet()) {
                subBuilder.mergeFrom(getGet());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setGet(subBuilder.buildPartial());
              break;
            }
            case 42: {
              voldemort.client.protocol.pb.VProto.GetAllRequest.Builder subBuilder = voldemort.client.protocol.pb.VProto.GetAllRequest.newBuilder();
              if (hasGetAll()) {
                subBuilder.mergeFrom(getGetAll());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setGetAll(subBuilder.buildPartial());
              break;
            }
            case 50: {
              voldemort.client.protocol.pb.VProto.PutRequest.Builder subBuilder = voldemort.client.protocol.pb.VProto.PutRequest.newBuilder();
              if (hasPut()) {
                subBuilder.mergeFrom(getPut());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setPut(subBuilder.buildPartial());
              break;
            }
            case 58: {
              voldemort.client.protocol.pb.VProto.DeleteRequest.Builder subBuilder = voldemort.client.protocol.pb.VProto.DeleteRequest.newBuilder();
              if (hasDelete()) {
                subBuilder.mergeFrom(getDelete());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setDelete(subBuilder.buildPartial());
              break;
            }
            case 64: {
              setRequestRouteType(input.readInt32());
              break;
            }
          }
        }
      }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520882036/fstmerge_var2_4895092689944739191

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be/src/java/voldemort/client/protocol/pb/VProto.java
Conflict type: LineBasedMCFd
Conflict body: 
public static AdminRequestType valueOf(int value) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520882243/fstmerge_var1_3859713146596911604
      switch (value) {
        case 0: return GET_METADATA;
        case 1: return UPDATE_METADATA;
        case 2: return UPDATE_PARTITION_ENTRIES;
        case 3: return FETCH_PARTITION_ENTRIES;
        case 4: return DELETE_PARTITION_ENTRIES;
        case 5: return INITIATE_FETCH_AND_UPDATE;
        case 6: return ASYNC_OPERATION_STATUS;
        case 7: return TRUNCATE_ENTRIES;
        default: return null;
      }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520882243/fstmerge_base_3487948913397093790
            switch(value) {
                case 0:
                    return GET_METADATA;
                case 1:
                    return UPDATE_METADATA;
                case 2:
                    return UPDATE_PARTITION_ENTRIES;
                case 3:
                    return FETCH_PARTITION_ENTRIES;
                case 4:
                    return DELETE_PARTITION_ENTRIES;
                case 5:
                    return INITIATE_FETCH_AND_UPDATE;
                case 6:
                    return ASYNC_OPERATION_STATUS;
                default:
                    return null;
            }
        }
=======
      switch (value) {
        case 0: return GET_METADATA;
        case 1: return UPDATE_METADATA;
        case 2: return UPDATE_PARTITION_ENTRIES;
        case 3: return FETCH_PARTITION_ENTRIES;
        case 4: return DELETE_PARTITION_ENTRIES;
        case 5: return INITIATE_FETCH_AND_UPDATE;
        case 6: return ASYNC_OPERATION_STATUS;
        case 7: return INITIATE_REBALANCE_NODE;
        case 8: return ASYNC_OPERATION_STOP;
        case 9: return ASYNC_OPERATION_LIST;
        default: return null;
      }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520882243/fstmerge_var2_6400511907480203958

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ private static final AdminRequestType[] VALUES = {
      GET_METADATA, UPDATE_METADATA, UPDATE_PARTITION_ENTRIES, FETCH_PARTITION_ENTRIES, DELETE_PARTITION_ENTRIES, INITIATE_FETCH_AND_UPDATE, ASYNC_OPERATION_STATUS, TRUNCATE_ENTRIES, 
    }; ##FSTMerge## private static final AdminRequestType[] VALUES = { GET_METADATA, UPDATE_METADATA,
                UPDATE_PARTITION_ENTRIES, FETCH_PARTITION_ENTRIES, DELETE_PARTITION_ENTRIES,
                INITIATE_FETCH_AND_UPDATE, ASYNC_OPERATION_STATUS, }; ##FSTMerge## private static final AdminRequestType[] VALUES = {
      GET_METADATA, UPDATE_METADATA, UPDATE_PARTITION_ENTRIES, FETCH_PARTITION_ENTRIES, DELETE_PARTITION_ENTRIES, INITIATE_FETCH_AND_UPDATE, ASYNC_OPERATION_STATUS, INITIATE_REBALANCE_NODE, ASYNC_OPERATION_STOP, ASYNC_OPERATION_LIST, 
    };
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520885039/fstmerge_var1_1790050954349249980
public final boolean isInitialized() {
      if (!hasCount) return false;
      if (hasError()) {
        if (!getError().isInitialized()) return false;
      }
      return true;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520885039/fstmerge_base_1653707279575507154
@Override
        public final boolean isInitialized() {
            if(!hasCount)
                return false;
            if(hasError()) {
                if(!getError().isInitialized())
                    return false;
            }
            return true;
        }
=======
public final boolean isInitialized() {
      if (hasError()) {
        if (!getError().isInitialized()) return false;
      }
      return true;
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520885039/fstmerge_var2_75915876187808723

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520885819/fstmerge_var1_7175616973839329622
public final boolean isInitialized() {
      if (!hasRequestId) return false;
      if (!hasDescription) return false;
      if (!hasStatus) return false;
      if (!hasComplete) return false;
      if (hasError()) {
        if (!getError().isInitialized()) return false;
      }
      return true;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520885819/fstmerge_base_3549563826701673487
@Override
        public final boolean isInitialized() {
            if(!hasRequestId)
                return false;
            if(!hasDescription)
                return false;
            if(!hasStatus)
                return false;
            if(!hasComplete)
                return false;
            if(hasError()) {
                if(!getError().isInitialized())
                    return false;
            }
            return true;
        }
=======
public final boolean isInitialized() {
      if (hasError()) {
        if (!getError().isInitialized()) return false;
      }
      return true;
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520885819/fstmerge_var2_5553053590064350497

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520886179/fstmerge_var1_7196630877304022087
public final boolean isInitialized() {
      if (!hasType) return false;
      if (hasGetMetadata()) {
        if (!getGetMetadata().isInitialized()) return false;
      }
      if (hasUpdateMetadata()) {
        if (!getUpdateMetadata().isInitialized()) return false;
      }
      if (hasUpdatePartitionEntries()) {
        if (!getUpdatePartitionEntries().isInitialized()) return false;
      }
      if (hasFetchPartitionEntries()) {
        if (!getFetchPartitionEntries().isInitialized()) return false;
      }
      if (hasDeletePartitionEntries()) {
        if (!getDeletePartitionEntries().isInitialized()) return false;
      }
      if (hasInitiateFetchAndUpdate()) {
        if (!getInitiateFetchAndUpdate().isInitialized()) return false;
      }
      if (hasAsyncOperationStatus()) {
        if (!getAsyncOperationStatus().isInitialized()) return false;
      }
      if (hasTruncateEntries()) {
        if (!getTruncateEntries().isInitialized()) return false;
      }
      return true;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520886179/fstmerge_base_6102483712221513523
@Override
        public final boolean isInitialized() {
            if(!hasType)
                return false;
            if(hasGetMetadata()) {
                if(!getGetMetadata().isInitialized())
                    return false;
            }
            if(hasUpdateMetadata()) {
                if(!getUpdateMetadata().isInitialized())
                    return false;
            }
            if(hasUpdatePartitionEntries()) {
                if(!getUpdatePartitionEntries().isInitialized())
                    return false;
            }
            if(hasFetchPartitionEntries()) {
                if(!getFetchPartitionEntries().isInitialized())
                    return false;
            }
            if(hasDeletePartitionEntries()) {
                if(!getDeletePartitionEntries().isInitialized())
                    return false;
            }
            if(hasInitiateFetchAndUpdate()) {
                if(!getInitiateFetchAndUpdate().isInitialized())
                    return false;
            }
            if(hasAsyncOperationStatus()) {
                if(!getAsyncOperationStatus().isInitialized())
                    return false;
            }
            return true;
        }
=======
public final boolean isInitialized() {
      if (!hasType) return false;
      if (hasGetMetadata()) {
        if (!getGetMetadata().isInitialized()) return false;
      }
      if (hasUpdateMetadata()) {
        if (!getUpdateMetadata().isInitialized()) return false;
      }
      if (hasUpdatePartitionEntries()) {
        if (!getUpdatePartitionEntries().isInitialized()) return false;
      }
      if (hasFetchPartitionEntries()) {
        if (!getFetchPartitionEntries().isInitialized()) return false;
      }
      if (hasDeletePartitionEntries()) {
        if (!getDeletePartitionEntries().isInitialized()) return false;
      }
      if (hasInitiateFetchAndUpdate()) {
        if (!getInitiateFetchAndUpdate().isInitialized()) return false;
      }
      if (hasAsyncOperationStatus()) {
        if (!getAsyncOperationStatus().isInitialized()) return false;
      }
      if (hasInitiateRebalanceNode()) {
        if (!getInitiateRebalanceNode().isInitialized()) return false;
      }
      if (hasAsyncOperationStop()) {
        if (!getAsyncOperationStop().isInitialized()) return false;
      }
      if (hasAsyncOperationList()) {
        if (!getAsyncOperationList().isInitialized()) return false;
      }
      return true;
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520886179/fstmerge_var2_4702963457092209006

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520886184/fstmerge_var1_6674872792420801111
public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (hasType()) {
        output.writeEnum(1, getType().getNumber());
      }
      if (hasGetMetadata()) {
        output.writeMessage(2, getGetMetadata());
      }
      if (hasUpdateMetadata()) {
        output.writeMessage(3, getUpdateMetadata());
      }
      if (hasUpdatePartitionEntries()) {
        output.writeMessage(4, getUpdatePartitionEntries());
      }
      if (hasFetchPartitionEntries()) {
        output.writeMessage(5, getFetchPartitionEntries());
      }
      if (hasDeletePartitionEntries()) {
        output.writeMessage(6, getDeletePartitionEntries());
      }
      if (hasInitiateFetchAndUpdate()) {
        output.writeMessage(7, getInitiateFetchAndUpdate());
      }
      if (hasAsyncOperationStatus()) {
        output.writeMessage(8, getAsyncOperationStatus());
      }
      if (hasTruncateEntries()) {
        output.writeMessage(9, getTruncateEntries());
      }
      getUnknownFields().writeTo(output);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520886184/fstmerge_base_257182506025066969
@Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
            if(hasType()) {
                output.writeEnum(1, getType().getNumber());
            }
            if(hasGetMetadata()) {
                output.writeMessage(2, getGetMetadata());
            }
            if(hasUpdateMetadata()) {
                output.writeMessage(3, getUpdateMetadata());
            }
            if(hasUpdatePartitionEntries()) {
                output.writeMessage(4, getUpdatePartitionEntries());
            }
            if(hasFetchPartitionEntries()) {
                output.writeMessage(5, getFetchPartitionEntries());
            }
            if(hasDeletePartitionEntries()) {
                output.writeMessage(6, getDeletePartitionEntries());
            }
            if(hasInitiateFetchAndUpdate()) {
                output.writeMessage(7, getInitiateFetchAndUpdate());
            }
            if(hasAsyncOperationStatus()) {
                output.writeMessage(8, getAsyncOperationStatus());
            }
            getUnknownFields().writeTo(output);
        }
=======
public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (hasType()) {
        output.writeEnum(1, getType().getNumber());
      }
      if (hasGetMetadata()) {
        output.writeMessage(2, getGetMetadata());
      }
      if (hasUpdateMetadata()) {
        output.writeMessage(3, getUpdateMetadata());
      }
      if (hasUpdatePartitionEntries()) {
        output.writeMessage(4, getUpdatePartitionEntries());
      }
      if (hasFetchPartitionEntries()) {
        output.writeMessage(5, getFetchPartitionEntries());
      }
      if (hasDeletePartitionEntries()) {
        output.writeMessage(6, getDeletePartitionEntries());
      }
      if (hasInitiateFetchAndUpdate()) {
        output.writeMessage(7, getInitiateFetchAndUpdate());
      }
      if (hasAsyncOperationStatus()) {
        output.writeMessage(8, getAsyncOperationStatus());
      }
      if (hasInitiateRebalanceNode()) {
        output.writeMessage(9, getInitiateRebalanceNode());
      }
      if (hasAsyncOperationStop()) {
        output.writeMessage(10, getAsyncOperationStop());
      }
      if (hasAsyncOperationList()) {
        output.writeMessage(11, getAsyncOperationList());
      }
      getUnknownFields().writeTo(output);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520886184/fstmerge_var2_4739322239307467758

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520886189/fstmerge_var1_2416761655895914880
public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
    
      size = 0;
      if (hasType()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, getType().getNumber());
      }
      if (hasGetMetadata()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getGetMetadata());
      }
      if (hasUpdateMetadata()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getUpdateMetadata());
      }
      if (hasUpdatePartitionEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getUpdatePartitionEntries());
      }
      if (hasFetchPartitionEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getFetchPartitionEntries());
      }
      if (hasDeletePartitionEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getDeletePartitionEntries());
      }
      if (hasInitiateFetchAndUpdate()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getInitiateFetchAndUpdate());
      }
      if (hasAsyncOperationStatus()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getAsyncOperationStatus());
      }
      if (hasTruncateEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, getTruncateEntries());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520886189/fstmerge_base_3993796671113808638
@Override
        public int getSerializedSize() {
            int size = memoizedSerializedSize;
            if(size != -1)
                return size;

            size = 0;
            if(hasType()) {
                size += com.google.protobuf.CodedOutputStream.computeEnumSize(1,
                                                                              getType().getNumber());
            }
            if(hasGetMetadata()) {
                size += com.google.protobuf.CodedOutputStream.computeMessageSize(2,
                                                                                 getGetMetadata());
            }
            if(hasUpdateMetadata()) {
                size += com.google.protobuf.CodedOutputStream.computeMessageSize(3,
                                                                                 getUpdateMetadata());
            }
            if(hasUpdatePartitionEntries()) {
                size += com.google.protobuf.CodedOutputStream.computeMessageSize(4,
                                                                                 getUpdatePartitionEntries());
            }
            if(hasFetchPartitionEntries()) {
                size += com.google.protobuf.CodedOutputStream.computeMessageSize(5,
                                                                                 getFetchPartitionEntries());
            }
            if(hasDeletePartitionEntries()) {
                size += com.google.protobuf.CodedOutputStream.computeMessageSize(6,
                                                                                 getDeletePartitionEntries());
            }
            if(hasInitiateFetchAndUpdate()) {
                size += com.google.protobuf.CodedOutputStream.computeMessageSize(7,
                                                                                 getInitiateFetchAndUpdate());
            }
            if(hasAsyncOperationStatus()) {
                size += com.google.protobuf.CodedOutputStream.computeMessageSize(8,
                                                                                 getAsyncOperationStatus());
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSerializedSize = size;
            return size;
        }
=======
public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
    
      size = 0;
      if (hasType()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, getType().getNumber());
      }
      if (hasGetMetadata()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getGetMetadata());
      }
      if (hasUpdateMetadata()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getUpdateMetadata());
      }
      if (hasUpdatePartitionEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getUpdatePartitionEntries());
      }
      if (hasFetchPartitionEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getFetchPartitionEntries());
      }
      if (hasDeletePartitionEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getDeletePartitionEntries());
      }
      if (hasInitiateFetchAndUpdate()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getInitiateFetchAndUpdate());
      }
      if (hasAsyncOperationStatus()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getAsyncOperationStatus());
      }
      if (hasInitiateRebalanceNode()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, getInitiateRebalanceNode());
      }
      if (hasAsyncOperationStop()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, getAsyncOperationStop());
      }
      if (hasAsyncOperationList()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, getAsyncOperationList());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520886189/fstmerge_var2_1517964853635747514

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
public Builder mergeFrom(voldemort.client.protocol.pb.VAdminProto.VoldemortAdminRequest other) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520886306/fstmerge_var1_7695442566304043654
        if (other == voldemort.client.protocol.pb.VAdminProto.VoldemortAdminRequest.getDefaultInstance()) return this;
        if (other.hasType()) {
          setType(other.getType());
        }
        if (other.hasGetMetadata()) {
          mergeGetMetadata(other.getGetMetadata());
        }
        if (other.hasUpdateMetadata()) {
          mergeUpdateMetadata(other.getUpdateMetadata());
        }
        if (other.hasUpdatePartitionEntries()) {
          mergeUpdatePartitionEntries(other.getUpdatePartitionEntries());
        }
        if (other.hasFetchPartitionEntries()) {
          mergeFetchPartitionEntries(other.getFetchPartitionEntries());
        }
        if (other.hasDeletePartitionEntries()) {
          mergeDeletePartitionEntries(other.getDeletePartitionEntries());
        }
        if (other.hasInitiateFetchAndUpdate()) {
          mergeInitiateFetchAndUpdate(other.getInitiateFetchAndUpdate());
        }
        if (other.hasAsyncOperationStatus()) {
          mergeAsyncOperationStatus(other.getAsyncOperationStatus());
        }
        if (other.hasTruncateEntries()) {
          mergeTruncateEntries(other.getTruncateEntries());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520886306/fstmerge_base_5065376917338461979
                if(other == voldemort.client.protocol.pb.VAdminProto.VoldemortAdminRequest.getDefaultInstance())
                    return this;
                if(other.hasType()) {
                    setType(other.getType());
                }
                if(other.hasGetMetadata()) {
                    mergeGetMetadata(other.getGetMetadata());
                }
                if(other.hasUpdateMetadata()) {
                    mergeUpdateMetadata(other.getUpdateMetadata());
                }
                if(other.hasUpdatePartitionEntries()) {
                    mergeUpdatePartitionEntries(other.getUpdatePartitionEntries());
                }
                if(other.hasFetchPartitionEntries()) {
                    mergeFetchPartitionEntries(other.getFetchPartitionEntries());
                }
                if(other.hasDeletePartitionEntries()) {
                    mergeDeletePartitionEntries(other.getDeletePartitionEntries());
                }
                if(other.hasInitiateFetchAndUpdate()) {
                    mergeInitiateFetchAndUpdate(other.getInitiateFetchAndUpdate());
                }
                if(other.hasAsyncOperationStatus()) {
                    mergeAsyncOperationStatus(other.getAsyncOperationStatus());
                }
                this.mergeUnknownFields(other.getUnknownFields());
                return this;
            }
=======
        if (other == voldemort.client.protocol.pb.VAdminProto.VoldemortAdminRequest.getDefaultInstance()) return this;
        if (other.hasType()) {
          setType(other.getType());
        }
        if (other.hasGetMetadata()) {
          mergeGetMetadata(other.getGetMetadata());
        }
        if (other.hasUpdateMetadata()) {
          mergeUpdateMetadata(other.getUpdateMetadata());
        }
        if (other.hasUpdatePartitionEntries()) {
          mergeUpdatePartitionEntries(other.getUpdatePartitionEntries());
        }
        if (other.hasFetchPartitionEntries()) {
          mergeFetchPartitionEntries(other.getFetchPartitionEntries());
        }
        if (other.hasDeletePartitionEntries()) {
          mergeDeletePartitionEntries(other.getDeletePartitionEntries());
        }
        if (other.hasInitiateFetchAndUpdate()) {
          mergeInitiateFetchAndUpdate(other.getInitiateFetchAndUpdate());
        }
        if (other.hasAsyncOperationStatus()) {
          mergeAsyncOperationStatus(other.getAsyncOperationStatus());
        }
        if (other.hasInitiateRebalanceNode()) {
          mergeInitiateRebalanceNode(other.getInitiateRebalanceNode());
        }
        if (other.hasAsyncOperationStop()) {
          mergeAsyncOperationStop(other.getAsyncOperationStop());
        }
        if (other.hasAsyncOperationList()) {
          mergeAsyncOperationList(other.getAsyncOperationList());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520886306/fstmerge_var2_421735038299625593

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520886312/fstmerge_base_5283777033650373768
@Override
            public Builder mergeFrom(com.google.protobuf.CodedInputStream input,
                                     com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                com.google.protobuf.UnknownFieldSet.Builder unknownFields = com.google.protobuf.UnknownFieldSet.newBuilder(this.getUnknownFields());
                while(true) {
                    int tag = input.readTag();
                    switch(tag) {
                        case 0:
                            this.setUnknownFields(unknownFields.build());
                            return this;
                        default: {
                            if(!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                                this.setUnknownFields(unknownFields.build());
                                return this;
                            }
                            break;
                        }
                        case 8: {
                            int rawValue = input.readEnum();
                            voldemort.client.protocol.pb.VAdminProto.AdminRequestType value = voldemort.client.protocol.pb.VAdminProto.AdminRequestType.valueOf(rawValue);
                            if(value == null) {
                                unknownFields.mergeVarintField(1, rawValue);
                            } else {
                                setType(value);
                            }
                            break;
                        }
                        case 18: {
                            voldemort.client.protocol.pb.VAdminProto.GetMetadataRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.GetMetadataRequest.newBuilder();
                            if(hasGetMetadata()) {
                                subBuilder.mergeFrom(getGetMetadata());
                            }
                            input.readMessage(subBuilder, extensionRegistry);
                            setGetMetadata(subBuilder.buildPartial());
                            break;
                        }
                        case 26: {
                            voldemort.client.protocol.pb.VAdminProto.UpdateMetadataRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.UpdateMetadataRequest.newBuilder();
                            if(hasUpdateMetadata()) {
                                subBuilder.mergeFrom(getUpdateMetadata());
                            }
                            input.readMessage(subBuilder, extensionRegistry);
                            setUpdateMetadata(subBuilder.buildPartial());
                            break;
                        }
                        case 34: {
                            voldemort.client.protocol.pb.VAdminProto.UpdatePartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.UpdatePartitionEntriesRequest.newBuilder();
                            if(hasUpdatePartitionEntries()) {
                                subBuilder.mergeFrom(getUpdatePartitionEntries());
                            }
                            input.readMessage(subBuilder, extensionRegistry);
                            setUpdatePartitionEntries(subBuilder.buildPartial());
                            break;
                        }
                        case 42: {
                            voldemort.client.protocol.pb.VAdminProto.FetchPartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.FetchPartitionEntriesRequest.newBuilder();
                            if(hasFetchPartitionEntries()) {
                                subBuilder.mergeFrom(getFetchPartitionEntries());
                            }
                            input.readMessage(subBuilder, extensionRegistry);
                            setFetchPartitionEntries(subBuilder.buildPartial());
                            break;
                        }
                        case 50: {
                            voldemort.client.protocol.pb.VAdminProto.DeletePartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.DeletePartitionEntriesRequest.newBuilder();
                            if(hasDeletePartitionEntries()) {
                                subBuilder.mergeFrom(getDeletePartitionEntries());
                            }
                            input.readMessage(subBuilder, extensionRegistry);
                            setDeletePartitionEntries(subBuilder.buildPartial());
                            break;
                        }
                        case 58: {
                            voldemort.client.protocol.pb.VAdminProto.InitiateFetchAndUpdateRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.InitiateFetchAndUpdateRequest.newBuilder();
                            if(hasInitiateFetchAndUpdate()) {
                                subBuilder.mergeFrom(getInitiateFetchAndUpdate());
                            }
                            input.readMessage(subBuilder, extensionRegistry);
                            setInitiateFetchAndUpdate(subBuilder.buildPartial());
                            break;
                        }
                        case 66: {
                            voldemort.client.protocol.pb.VAdminProto.AsyncOperationStatusRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.AsyncOperationStatusRequest.newBuilder();
                            if(hasAsyncOperationStatus()) {
                                subBuilder.mergeFrom(getAsyncOperationStatus());
                            }
                            input.readMessage(subBuilder, extensionRegistry);
                            setAsyncOperationStatus(subBuilder.buildPartial());
                            break;
                        }
                    }
                }
=======
public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder(
            this.getUnknownFields());
        while (true) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              this.setUnknownFields(unknownFields.build());
              return this;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                this.setUnknownFields(unknownFields.build());
                return this;
              }
              break;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520886312/fstmerge_var2_5051699817942891167
            }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520886312/fstmerge_var1_4540319649803743027
            case 8: {
              int rawValue = input.readEnum();
              voldemort.client.protocol.pb.VAdminProto.AdminRequestType value = voldemort.client.protocol.pb.VAdminProto.AdminRequestType.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(1, rawValue);
              } else {
                setType(value);
              }
              break;
            }
            case 18: {
              voldemort.client.protocol.pb.VAdminProto.GetMetadataRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.GetMetadataRequest.newBuilder();
              if (hasGetMetadata()) {
                subBuilder.mergeFrom(getGetMetadata());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setGetMetadata(subBuilder.buildPartial());
              break;
            }
            case 26: {
              voldemort.client.protocol.pb.VAdminProto.UpdateMetadataRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.UpdateMetadataRequest.newBuilder();
              if (hasUpdateMetadata()) {
                subBuilder.mergeFrom(getUpdateMetadata());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setUpdateMetadata(subBuilder.buildPartial());
              break;
            }
            case 34: {
              voldemort.client.protocol.pb.VAdminProto.UpdatePartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.UpdatePartitionEntriesRequest.newBuilder();
              if (hasUpdatePartitionEntries()) {
                subBuilder.mergeFrom(getUpdatePartitionEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setUpdatePartitionEntries(subBuilder.buildPartial());
              break;
            }
            case 42: {
              voldemort.client.protocol.pb.VAdminProto.FetchPartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.FetchPartitionEntriesRequest.newBuilder();
              if (hasFetchPartitionEntries()) {
                subBuilder.mergeFrom(getFetchPartitionEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setFetchPartitionEntries(subBuilder.buildPartial());
              break;
            }
            case 50: {
              voldemort.client.protocol.pb.VAdminProto.DeletePartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.DeletePartitionEntriesRequest.newBuilder();
              if (hasDeletePartitionEntries()) {
                subBuilder.mergeFrom(getDeletePartitionEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setDeletePartitionEntries(subBuilder.buildPartial());
              break;
            }
            case 58: {
              voldemort.client.protocol.pb.VAdminProto.InitiateFetchAndUpdateRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.InitiateFetchAndUpdateRequest.newBuilder();
              if (hasInitiateFetchAndUpdate()) {
                subBuilder.mergeFrom(getInitiateFetchAndUpdate());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setInitiateFetchAndUpdate(subBuilder.buildPartial());
              break;
            }
            case 66: {
              voldemort.client.protocol.pb.VAdminProto.AsyncOperationStatusRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.AsyncOperationStatusRequest.newBuilder();
              if (hasAsyncOperationStatus()) {
                subBuilder.mergeFrom(getAsyncOperationStatus());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setAsyncOperationStatus(subBuilder.buildPartial());
              break;
            }
            case 74: {
              voldemort.client.protocol.pb.VAdminProto.TruncateEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.TruncateEntriesRequest.newBuilder();
              if (hasTruncateEntries()) {
                subBuilder.mergeFrom(getTruncateEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setTruncateEntries(subBuilder.buildPartial());
              break;
            }
          }
        }
      }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520886312/fstmerge_base_5283777033650373768
=======
            case 8: {
              int rawValue = input.readEnum();
              voldemort.client.protocol.pb.VAdminProto.AdminRequestType value = voldemort.client.protocol.pb.VAdminProto.AdminRequestType.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(1, rawValue);
              } else {
                setType(value);
              }
              break;
            }
            case 18: {
              voldemort.client.protocol.pb.VAdminProto.GetMetadataRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.GetMetadataRequest.newBuilder();
              if (hasGetMetadata()) {
                subBuilder.mergeFrom(getGetMetadata());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setGetMetadata(subBuilder.buildPartial());
              break;
            }
            case 26: {
              voldemort.client.protocol.pb.VAdminProto.UpdateMetadataRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.UpdateMetadataRequest.newBuilder();
              if (hasUpdateMetadata()) {
                subBuilder.mergeFrom(getUpdateMetadata());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setUpdateMetadata(subBuilder.buildPartial());
              break;
            }
            case 34: {
              voldemort.client.protocol.pb.VAdminProto.UpdatePartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.UpdatePartitionEntriesRequest.newBuilder();
              if (hasUpdatePartitionEntries()) {
                subBuilder.mergeFrom(getUpdatePartitionEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setUpdatePartitionEntries(subBuilder.buildPartial());
              break;
            }
            case 42: {
              voldemort.client.protocol.pb.VAdminProto.FetchPartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.FetchPartitionEntriesRequest.newBuilder();
              if (hasFetchPartitionEntries()) {
                subBuilder.mergeFrom(getFetchPartitionEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setFetchPartitionEntries(subBuilder.buildPartial());
              break;
            }
            case 50: {
              voldemort.client.protocol.pb.VAdminProto.DeletePartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.DeletePartitionEntriesRequest.newBuilder();
              if (hasDeletePartitionEntries()) {
                subBuilder.mergeFrom(getDeletePartitionEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setDeletePartitionEntries(subBuilder.buildPartial());
              break;
            }
            case 58: {
              voldemort.client.protocol.pb.VAdminProto.InitiateFetchAndUpdateRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.InitiateFetchAndUpdateRequest.newBuilder();
              if (hasInitiateFetchAndUpdate()) {
                subBuilder.mergeFrom(getInitiateFetchAndUpdate());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setInitiateFetchAndUpdate(subBuilder.buildPartial());
              break;
            }
            case 66: {
              voldemort.client.protocol.pb.VAdminProto.AsyncOperationStatusRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.AsyncOperationStatusRequest.newBuilder();
              if (hasAsyncOperationStatus()) {
                subBuilder.mergeFrom(getAsyncOperationStatus());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setAsyncOperationStatus(subBuilder.buildPartial());
              break;
            }
            case 74: {
              voldemort.client.protocol.pb.VAdminProto.InitiateRebalanceNodeRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.InitiateRebalanceNodeRequest.newBuilder();
              if (hasInitiateRebalanceNode()) {
                subBuilder.mergeFrom(getInitiateRebalanceNode());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setInitiateRebalanceNode(subBuilder.buildPartial());
              break;
            }
            case 82: {
              voldemort.client.protocol.pb.VAdminProto.AsyncOperationStopRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.AsyncOperationStopRequest.newBuilder();
              if (hasAsyncOperationStop()) {
                subBuilder.mergeFrom(getAsyncOperationStop());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setAsyncOperationStop(subBuilder.buildPartial());
              break;
            }
            case 90: {
              voldemort.client.protocol.pb.VAdminProto.AsyncOperationListRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.AsyncOperationListRequest.newBuilder();
              if (hasAsyncOperationList()) {
                subBuilder.mergeFrom(getAsyncOperationList());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setAsyncOperationList(subBuilder.buildPartial());
              break;
            }
          }
        }
      }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520886312/fstmerge_var2_5051699817942891167

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
public VoldemortConfig(Props props) {
        try {
            this.nodeId = props.getInt("node.id");
        } catch(UndefinedPropertyException e) {
            this.nodeId = getIntEnvVariable(VOLDEMORT_NODE_ID_VAR_NAME);
        }
        this.voldemortHome = props.getString("voldemort.home");
        this.dataDirectory = props.getString("data.directory", this.voldemortHome + File.separator
                                                               + "data");
        this.metadataDirectory = props.getString("metadata.directory", voldemortHome
                                                                       + File.separator + "config");

        this.bdbCacheSize = props.getBytes("bdb.cache.size", 200 * 1024 * 1024);
        this.bdbWriteTransactions = props.getBoolean("bdb.write.transactions", false);
        this.bdbFlushTransactions = props.getBoolean("bdb.flush.transactions", false);
        this.bdbDataDirectory = props.getString("bdb.data.directory", this.dataDirectory
                                                                      + File.separator + "bdb");
        this.bdbMaxLogFileSize = props.getBytes("bdb.max.logfile.size", 60 * 1024 * 1024);
        this.bdbBtreeFanout = props.getInt("bdb.btree.fanout", 512);
        this.bdbCheckpointBytes = props.getLong("bdb.checkpoint.interval.bytes", 20 * 1024 * 1024);
        this.bdbCheckpointMs = props.getLong("bdb.checkpoint.interval.ms", 30 * Time.MS_PER_SECOND);
        this.bdbSortedDuplicates = props.getBoolean("bdb.enable.sorted.duplicates", true);
        this.bdbOneEnvPerStore = props.getBoolean("bdb.one.env.per.store", false);
        this.bdbCleanerMinFileUtilization = props.getInt("bdb.cleaner.min.file.utilization", 5);
        this.bdbCleanerMinUtilization = props.getInt("bdb.cleaner.minUtilization", 50);

        // enabling preload make cursor slow for insufficient bdb cache size.
        this.bdbCursorPreload = props.getBoolean("bdb.cursor.preload", false);

        this.readOnlyBackups = props.getInt("readonly.backups", 1);
        this.readOnlySearchStrategy = props.getString("readonly.search.strategy",
                                                      BinarySearchStrategy.class.getName());
        this.readOnlyStorageDir = props.getString("readonly.data.directory", this.dataDirectory
                                                                             + File.separator
                                                                             + "read-only");

        this.slopStoreType = props.getString("slop.store.engine", BdbStorageConfiguration.TYPE_NAME);

        this.mysqlUsername = props.getString("mysql.user", "root");
        this.mysqlPassword = props.getString("mysql.password", "");
        this.mysqlHost = props.getString("mysql.host", "localhost");
        this.mysqlPort = props.getInt("mysql.port", 3306);
        this.mysqlDatabaseName = props.getString("mysql.database", "voldemort");

        this.maxThreads = props.getInt("max.threads", 100);
        this.coreThreads = props.getInt("core.threads", Math.max(1, maxThreads / 2));

        // Admin client should have less threads but very high buffer size.
        this.adminMaxThreads = props.getInt("admin.max.threads", 10);
        this.adminCoreThreads = props.getInt("admin.core.threads", Math.max(1, adminMaxThreads / 2));
        this.adminStreamBufferSize = (int) props.getBytes("admin.streams.buffer.size",
                                                          10 * 1000 * 1000);
        this.adminConnectionTimeout = props.getInt("admin.client.socket.timeout.sec", 60);
        this.adminSocketTimeout = props.getInt("admin.client.socket.timeout.sec", 24 * 60 * 60);

        this.streamMaxReadBytesPerSec = props.getInt("stream.read.byte.per.sec", 10 * 1000 * 1000);
        this.streamMaxWriteBytesPerSec = props.getInt("stream.write.byte.per.sec", 10 * 1000 * 1000);

        this.socketTimeoutMs = props.getInt("socket.timeout.ms", 4000);
        this.socketBufferSize = (int) props.getBytes("socket.buffer.size", 32 * 1024);

        this.useNioConnector = props.getBoolean("enable.nio.connector", false);
        this.nioConnectorSelectors = props.getInt("nio.connector.selectors",
                                                  Runtime.getRuntime().availableProcessors());

        this.clientMaxConnectionsPerNode = props.getInt("client.max.connections.per.node", 5);
        this.clientConnectionTimeoutMs = props.getInt("client.connection.timeout.ms", 400);
        this.clientRoutingTimeoutMs = props.getInt("client.routing.timeout.ms", 5000);
        this.clientMaxThreads = props.getInt("client.max.threads", 100);
        this.clientThreadIdleMs = props.getInt("client.thread.idle.ms", 5000);
        this.clientMaxQueuedRequests = props.getInt("client.max.queued.requests", 1000);

        this.enableHttpServer = props.getBoolean("http.enable", true);
        this.enableSocketServer = props.getBoolean("socket.enable", true);
        this.enableAdminServer = props.getBoolean("admin.enable", true);
        this.enableJmx = props.getBoolean("jmx.enable", true);
        this.enableSlop = props.getBoolean("slop.enable", true);
        this.enableVerboseLogging = props.getBoolean("enable.verbose.logging", true);
        this.enableStatTracking = props.getBoolean("enable.stat.tracking", true);
        this.enableServerRouting = props.getBoolean("enable.server.routing", true);
        this.enableMetadataChecking = props.getBoolean("enable.metadata.checking", true);
        this.enableRedirectRouting = props.getBoolean("enable.redirect.routing", true);
        this.enableGossip = props.getBoolean("enable.gossip", false);
        this.enableRebalanceService = props.getBoolean("enable.rebalancing", true);

        this.gossipInterval = props.getInt("gossip.interval.ms", 30 * 1000);
        this.pusherPollMs = props.getInt("pusher.poll.ms", 2 * 60 * 1000);

        this.schedulerThreads = props.getInt("scheduler.threads", 3);

        this.numCleanupPermits = props.getInt("num.cleanup.permits", 1);

        this.storageConfigurations = props.getList("storage.configs",
                                                   ImmutableList.of(BdbStorageConfiguration.class.getName(),
                                                                    MysqlStorageConfiguration.class.getName(),
                                                                    InMemoryStorageConfiguration.class.getName(),
                                                                    CacheStorageConfiguration.class.getName(),
                                                                    ReadOnlyStorageConfiguration.class.getName()));

        // start at midnight (0-23)
        this.retentionCleanupFirstStartTimeInHour = props.getInt("retention.cleanup.first.start.hour",
                                                                 0);
        // repeat every 24 hours
        this.retentionCleanupScheduledPeriodInHour = props.getInt("retention.cleanup.period.hours",
                                                                  24);

        // save props for access from plugins
        this.allProps = props;

        String requestFormatName = props.getString("request.format",
                                                   RequestFormatType.VOLDEMORT_V1.getCode());
        this.requestFormatType = RequestFormatType.fromCode(requestFormatName);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520887119/fstmerge_var1_76430008534504300
        this.failureDetectorImplementation = props.getString("failuredetector.implementation",
                                                             FailureDetectorConfig.DEFAULT_IMPLEMENTATION_CLASS_NAME);

        // We're changing the property from "client.node.bannage.ms" to
        // "failuredetector.bannage.period" so if we have the old one, migrate
        // it over.
        if(props.containsKey("client.node.bannage.ms")
           && !props.containsKey("failuredetector.bannage.period")) {
            props.put("failuredetector.bannage.period", props.get("client.node.bannage.ms"));
        }

        this.failureDetectorBannagePeriod = props.getLong("failuredetector.bannage.period",
                                                          FailureDetectorConfig.DEFAULT_BANNAGE_PERIOD);
        this.failureDetectorThreshold = props.getInt("failuredetector.threshold",
                                                     FailureDetectorConfig.DEFAULT_THRESHOLD);
        this.failureDetectorThresholdCountMinimum = props.getInt("failuredetector.threshold.countminimum",
                                                                 FailureDetectorConfig.DEFAULT_THRESHOLD_COUNT_MINIMUM);
        this.failureDetectorThresholdInterval = props.getLong("failuredetector.threshold.interval",
                                                              FailureDetectorConfig.DEFAULT_THRESHOLD_INTERVAL);
        this.failureDetectorAsyncRecoveryInterval = props.getLong("failuredetector.asyncrecovery.interval",
                                                                  FailureDetectorConfig.DEFAULT_ASYNC_RECOVERY_INTERVAL);

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520887119/fstmerge_base_906916187863789791
=======
        // rebalancing parameters
        this.maxRebalancingAttempt = props.getInt("max.rebalancing.attempts", Integer.MAX_VALUE);
        this.rebalancingTimeoutInSeconds = props.getInt("rebalancing.timeout.seconds", 60 * 60);
        this.rebalancingServicePeriod = props.getInt("rebalancing.service.period.ms", 1000);

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520887119/fstmerge_var2_8666047295547105935
        // network class loader disable by default.
        this.enableNetworkClassLoader = props.getBoolean("enable.network.classloader", false);

        validateParams();
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be/src/java/voldemort/server/VoldemortConfig.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520888182/fstmerge_var1_2107934476722895858
public void handleRequest(final DataInputStream inputStream, final DataOutputStream outputStream)
            throws IOException {
        // Another protocol buffers bug here, temp. work around
        VoldemortAdminRequest.Builder request = VoldemortAdminRequest.newBuilder();
        int size = inputStream.readInt();
        byte[] input = new byte[size];
        ByteUtils.read(inputStream, input);
        request.mergeFrom(input);
        switch(request.getType()) {
            case GET_METADATA:
                ProtoUtils.writeMessage(outputStream, handleGetMetadata(request.getGetMetadata()));
                break;
            case UPDATE_METADATA:
                ProtoUtils.writeMessage(outputStream,
                                        handleUpdateMetadata(request.getUpdateMetadata()));
                break;
            case DELETE_PARTITION_ENTRIES:
                ProtoUtils.writeMessage(outputStream,
                                        handleDeletePartitionEntries(request.getDeletePartitionEntries()));
                break;
            case FETCH_PARTITION_ENTRIES:
                handleFetchPartitionEntries(request.getFetchPartitionEntries(), outputStream);
                break;
            case UPDATE_PARTITION_ENTRIES:
                handleUpdatePartitionEntries(request.getUpdatePartitionEntries(),
                                             inputStream,
                                             outputStream);
                break;
            case INITIATE_FETCH_AND_UPDATE:
                ProtoUtils.writeMessage(outputStream,
                                        handleFetchAndUpdate(request.getInitiateFetchAndUpdate()));
                break;
            case ASYNC_OPERATION_STATUS:
                ProtoUtils.writeMessage(outputStream,
                                        handleAsyncStatus(request.getAsyncOperationStatus()));
                break;
            case TRUNCATE_ENTRIES:
                ProtoUtils.writeMessage(outputStream,
                                        handleTruncateEntries(request.getTruncateEntries()));
                break;
            default:
                throw new VoldemortException("Unkown operation " + request.getType());
        }

    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520888182/fstmerge_base_3630273059163841728
public void handleRequest(final DataInputStream inputStream, final DataOutputStream outputStream)
            throws IOException {
        // Another protocol buffers bug here, temp. work around
        VoldemortAdminRequest.Builder request = VoldemortAdminRequest.newBuilder();
        int size = inputStream.readInt();
        byte[] input = new byte[size];
        ByteUtils.read(inputStream, input);
        request.mergeFrom(input);
        switch(request.getType()) {
            case GET_METADATA:
                ProtoUtils.writeMessage(outputStream, handleGetMetadata(request.getGetMetadata()));
                break;
            case UPDATE_METADATA:
                ProtoUtils.writeMessage(outputStream,
                                        handleUpdateMetadata(request.getUpdateMetadata()));
                break;
            case DELETE_PARTITION_ENTRIES:
                ProtoUtils.writeMessage(outputStream,
                                        handleDeletePartitionEntries(request.getDeletePartitionEntries()));
                break;
            case FETCH_PARTITION_ENTRIES:
                handleFetchPartitionEntries(request.getFetchPartitionEntries(), outputStream);
                break;
            case UPDATE_PARTITION_ENTRIES:
                handleUpdatePartitionEntries(request.getUpdatePartitionEntries(),
                                             inputStream,
                                             outputStream);
                break;
            case INITIATE_FETCH_AND_UPDATE:
                ProtoUtils.writeMessage(outputStream,
                                        handleFetchAndUpdate(request.getInitiateFetchAndUpdate()));
                break;
            case ASYNC_OPERATION_STATUS:
                ProtoUtils.writeMessage(outputStream,
                                        handleAsyncStatus(request.getAsyncOperationStatus()));
                break;
            default:
                throw new VoldemortException("Unkown operation " + request.getType());
        }

    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520888182/fstmerge_var2_1674830139240417187

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be/src/java/voldemort/server/protocol/admin/ProtoBuffAdminServiceRequestHandler.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520888717/fstmerge_var1_5171411176598590719
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520888717/fstmerge_base_5985399441721437455
public Node(int id,
                String host,
                int httpPort,
                int socketPort,
                int adminPort,
                List<Integer> partitions,
                NodeStatus status) {
        this.id = id;
        this.host = Utils.notNull(host);
        this.httpPort = httpPort;
        this.socketPort = socketPort;
        this.status = status;
        this.partitions = ImmutableList.copyOf(partitions);

        // fix default value for adminPort if not defined
        if(adminPort == -1) {
            adminPort = socketPort + 1;
            logger.warn("admin-port not defined for node:" + id + " using default value:"
                        + adminPort + " as (socket_port + 1):");
        }

        this.adminPort = adminPort;
    }
=======
public Node(int id,
                String host,
                int httpPort,
                int socketPort,
                int adminPort,
                List<Integer> partitions,
                NodeStatus status) {
        this.id = id;
        this.host = Utils.notNull(host);
        this.httpPort = httpPort;
        this.socketPort = socketPort;
        this.status = status;
        this.partitions = ImmutableList.copyOf(partitions);

        // fix default value for adminPort if not defined
        if(adminPort == -1) {
            adminPort = socketPort + 1;
            logger.warn("admin-port not defined for node:" + id
                        + " using default value(socket_port + 1):" + adminPort);
        }

        this.adminPort = adminPort;
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520888717/fstmerge_var2_3306303056866606722

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be/src/java/voldemort/cluster/Node.java
Conflict type: LineBasedMCFd
Conflict body: 
public boolean delete(final ByteArray key, final Version version) throws VoldemortException {
        StoreUtils.assertValidKey(key);
        final List<Node> nodes = availableNodes(routingStrategy.routeRequest(key.get()));

        // quickly fail if there aren't enough live nodes to meet the
        // requirements
        final int numNodes = nodes.size();
        if(numNodes < this.storeDef.getRequiredWrites())
            throw new InsufficientOperationalNodesException("Only " + numNodes
                                                            + " nodes in preference list, but "
                                                            + this.storeDef.getRequiredWrites()
                                                            + " writes required.");

        // A count of the number of successful operations
        final AtomicInteger successes = new AtomicInteger(0);
        final AtomicBoolean deletedSomething = new AtomicBoolean(false);
        // A list of thrown exceptions, indicating the number of failures
        final List<Exception> failures = Collections.synchronizedList(new LinkedList<Exception>());

        // A semaphore indicating the number of completed operations
        // Once inititialized all permits are acquired, after that
        // permits are released when an operation is completed.
        // semaphore.acquire(n) waits for n operations to complete
        final Semaphore semaphore = new Semaphore(0, false);
        // Add the operations to the pool
        for(final Node node: nodes) {
            this.executor.execute(new Runnable() {

                public void run() {
                    try {
                        boolean deleted = innerStores.get(node.getId()).delete(key, version);
                        successes.incrementAndGet();
                        deletedSomething.compareAndSet(false, deleted);
                        failureDetector.recordSuccess(node);
                    } catch(UnreachableStoreException e) {
                        failures.add(e);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520892146/fstmerge_var1_8730079562693275393
                        failureDetector.recordException(node, e);
                    } catch(VoldemortApplicationException e) {
                        throw e;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520892146/fstmerge_base_6959404179747211587
                        markUnavailable(node, e);
=======
                        markUnavailable(node, e);
                    } catch(VoldemortApplicationException e) {
                        throw e;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520892146/fstmerge_var2_7187674744025959885
                    } catch(Exception e) {
                        failures.add(e);
                        logger.warn("Error in DELETE on node " + node.getId() + "("
                                    + node.getHost() + ")", e);
                    } finally {
                        // signal that the operation is complete
                        semaphore.release();
                    }
                }
            });
        }

        int attempts = Math.min(storeDef.getPreferredWrites(), numNodes);
        if(this.storeDef.getPreferredWrites() <= 0) {
            return true;
        } else {
            for(int i = 0; i < numNodes; i++) {
                try {
                    boolean acquired = semaphore.tryAcquire(timeoutMs, TimeUnit.MILLISECONDS);
                    if(!acquired)
                        logger.warn("Delete operation timed out waiting for operation " + i
                                    + " to complete after waiting " + timeoutMs + " ms.");
                    // okay, at least the required number of operations have
                    // completed, were they successful?
                    if(successes.get() >= attempts)
                        return deletedSomething.get();
                } catch(InterruptedException e) {
                    throw new InsufficientOperationalNodesException("Delete operation interrupted!",
                                                                    e);
                }
            }
        }

        // If we get to here, that means we couldn't hit the preferred number
        // of writes, throw an exception if you can't even hit the required
        // number
        if(successes.get() < storeDef.getRequiredWrites())
            throw new InsufficientOperationalNodesException(this.storeDef.getRequiredWrites()
                                                                    + " deletes required, but "
                                                                    + successes.get()
                                                                    + " succeeded.",
                                                            failures);
        else
            return deletedSomething.get();
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be/src/java/voldemort/store/routed/RoutedStore.java
Conflict type: LineBasedMCFd
Conflict body: 
public Map<ByteArray, List<Versioned<byte[]>>> getAll(Iterable<ByteArray> keys)
            throws VoldemortException {
        StoreUtils.assertValidKeys(keys);

        Map<ByteArray, List<Versioned<byte[]>>> result = StoreUtils.newEmptyHashMap(keys);

        // Keys for each node needed to satisfy storeDef.getPreferredReads() if
        // no failures.
        Map<Node, List<ByteArray>> nodeToKeysMap = Maps.newHashMap();

        // Keep track of nodes per key that might be needed if there are
        // failures during getAll
        Map<ByteArray, List<Node>> keyToExtraNodesMap = Maps.newHashMap();

        for(ByteArray key: keys) {
            List<Node> availableNodes = availableNodes(routingStrategy.routeRequest(key.get()));

            // quickly fail if there aren't enough nodes to meet the requirement
            checkRequiredReads(availableNodes);
            int preferredReads = storeDef.getPreferredReads();
            List<Node> preferredNodes = Lists.newArrayListWithCapacity(preferredReads);
            List<Node> extraNodes = Lists.newArrayListWithCapacity(3);

            for(Node node: availableNodes) {
                if(preferredNodes.size() < preferredReads)
                    preferredNodes.add(node);
                else
                    extraNodes.add(node);
            }

            for(Node node: preferredNodes) {
                List<ByteArray> nodeKeys = nodeToKeysMap.get(node);
                if(nodeKeys == null) {
                    nodeKeys = Lists.newArrayList();
                    nodeToKeysMap.put(node, nodeKeys);
                }
                nodeKeys.add(key);
            }
            if(!extraNodes.isEmpty()) {
                List<Node> nodes = keyToExtraNodesMap.get(key);
                if(nodes == null)
                    keyToExtraNodesMap.put(key, extraNodes);
                else
                    nodes.addAll(extraNodes);
            }
        }

        List<Callable<GetAllResult>> callables = Lists.newArrayList();
        for(Map.Entry<Node, List<ByteArray>> entry: nodeToKeysMap.entrySet()) {
            final Node node = entry.getKey();
            final Collection<ByteArray> nodeKeys = entry.getValue();
            if(failureDetector.isAvailable(node))
                callables.add(new GetAllCallable(node, nodeKeys));
        }

        // A list of thrown exceptions, indicating the number of failures
        List<Throwable> failures = Lists.newArrayList();
        List<NodeValue<ByteArray, byte[]>> nodeValues = Lists.newArrayList();

        Map<ByteArray, MutableInt> keyToSuccessCount = Maps.newHashMap();
        for(ByteArray key: keys)
            keyToSuccessCount.put(key, new MutableInt(0));

        List<Future<GetAllResult>> futures;
        try {
            // TODO What to do about timeouts? They should be longer as getAll
            // is likely to
            // take longer. At the moment, it's just timeoutMs * 3, but should
            // this be based on the number of the keys?
            futures = executor.invokeAll(callables, timeoutMs * 3, TimeUnit.MILLISECONDS);
        } catch(InterruptedException e) {
            throw new InsufficientOperationalNodesException("getAll operation interrupted.", e);
        }
        for(Future<GetAllResult> f: futures) {
            if(f.isCancelled()) {
                logger.warn("Get operation timed out after " + timeoutMs + " ms.");
                continue;
            }
            try {
                GetAllResult getResult = f.get();
                if(getResult.exception != null) {
                    if(getResult.exception instanceof VoldemortApplicationException) {
                        throw (VoldemortException) getResult.exception;
                    }
                    failures.add(getResult.exception);
                    continue;
                }
                for(ByteArray key: getResult.callable.nodeKeys) {
                    List<Versioned<byte[]>> retrieved = getResult.retrieved.get(key);
                    MutableInt successCount = keyToSuccessCount.get(key);
                    successCount.increment();

                    /*
                     * retrieved can be null if there are no values for the key
                     * provided
                     */
                    if(retrieved != null) {
                        List<Versioned<byte[]>> existing = result.get(key);
                        if(existing == null)
                            result.put(key, Lists.newArrayList(retrieved));
                        else
                            existing.addAll(retrieved);
                    }
                }
                nodeValues.addAll(getResult.nodeValues);

            } catch(InterruptedException e) {
                throw new InsufficientOperationalNodesException("getAll operation interrupted.", e);
            } catch(ExecutionException e) {
                // We catch all Throwables apart from Error in the callable, so
                // the else part
                // should never happen
                if(e.getCause() instanceof Error)
                    throw (Error) e.getCause();
                else
                    logger.error(e.getMessage(), e);
            }
        }

        for(ByteArray key: keys) {
            MutableInt successCountWrapper = keyToSuccessCount.get(key);
            int successCount = successCountWrapper.intValue();
            if(successCount < storeDef.getPreferredReads()) {
                List<Node> extraNodes = keyToExtraNodesMap.get(key);
                if(extraNodes != null) {
                    for(Node node: extraNodes) {
                        try {
                            List<Versioned<byte[]>> values = innerStores.get(node.getId()).get(key);
                            fillRepairReadsValues(nodeValues, key, node, values);
                            List<Versioned<byte[]>> versioneds = result.get(key);
                            if(versioneds == null)
                                result.put(key, Lists.newArrayList(values));
                            else
                                versioneds.addAll(values);
                            failureDetector.recordSuccess(node);
                            if(++successCount >= storeDef.getPreferredReads())
                                break;

                        } catch(UnreachableStoreException e) {
                            failures.add(e);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520892152/fstmerge_var1_1989292360051626894
                            failureDetector.recordException(node, e);
                        } catch(VoldemortApplicationException e) {
                            throw e;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520892152/fstmerge_base_7763299026540769272
                            markUnavailable(node, e);
=======
                            markUnavailable(node, e);
                        } catch(VoldemortApplicationException e) {
                            throw e;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520892152/fstmerge_var2_3402143321203617370
                        } catch(Exception e) {
                            logger.warn("Error in GET_ALL on node " + node.getId() + "("
                                        + node.getHost() + ")", e);
                            failures.add(e);
                        }
                    }
                }
            }
            successCountWrapper.setValue(successCount);
        }

        repairReads(nodeValues);

        for(Map.Entry<ByteArray, MutableInt> mapEntry: keyToSuccessCount.entrySet()) {
            int successCount = mapEntry.getValue().intValue();
            if(successCount < storeDef.getRequiredReads())
                throw new InsufficientOperationalNodesException(this.storeDef.getRequiredReads()
                                                                        + " reads required, but "
                                                                        + successCount
                                                                        + " succeeded.",
                                                                failures);
        }

        return result;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be/src/java/voldemort/store/routed/RoutedStore.java
Conflict type: LineBasedMCFd
Conflict body: 
private <R> List<R> get(final ByteArray key,
                            StoreOp<R> fetcher,
                            Function<List<GetResult<R>>, Void> preReturnProcedure)
            throws VoldemortException {
        StoreUtils.assertValidKey(key);
        final List<Node> nodes = availableNodes(routingStrategy.routeRequest(key.get()));

        // quickly fail if there aren't enough nodes to meet the requirement
        checkRequiredReads(nodes);

        final List<GetResult<R>> retrieved = Lists.newArrayList();

        // A count of the number of successful operations
        int successes = 0;
        // A list of thrown exceptions, indicating the number of failures
        final List<Throwable> failures = Lists.newArrayListWithCapacity(3);

        // Do the preferred number of reads in parallel
        int attempts = Math.min(this.storeDef.getPreferredReads(), nodes.size());
        int nodeIndex = 0;
        List<Callable<GetResult<R>>> callables = Lists.newArrayListWithCapacity(attempts);
        for(; nodeIndex < attempts; nodeIndex++) {
            final Node node = nodes.get(nodeIndex);
            callables.add(new GetCallable<R>(node, key, fetcher));
        }

        List<Future<GetResult<R>>> futures;
        try {
            futures = executor.invokeAll(callables, timeoutMs, TimeUnit.MILLISECONDS);
        } catch(InterruptedException e) {
            throw new InsufficientOperationalNodesException("Get operation interrupted!", e);
        }

        for(Future<GetResult<R>> f: futures) {
            if(f.isCancelled()) {
                logger.warn("Get operation timed out after " + timeoutMs + " ms.");
                continue;
            }
            try {
                GetResult<R> getResult = f.get();
                if(getResult.exception != null) {
                    if(getResult.exception instanceof VoldemortApplicationException) {
                        throw (VoldemortException) getResult.exception;
                    }
                    failures.add(getResult.exception);
                    continue;
                }
                ++successes;
                retrieved.add(getResult);
            } catch(InterruptedException e) {
                throw new InsufficientOperationalNodesException("Get operation interrupted!", e);
            } catch(ExecutionException e) {
                // We catch all Throwable subclasses apart from Error in the
                // callable, so the else
                // part should never happen.
                if(e.getCause() instanceof Error)
                    throw (Error) e.getCause();
                else
                    logger.error(e.getMessage(), e);
            }
        }

        // Now if we had any failures we will be short a few reads. Do serial
        // reads to make up for these.
        while(successes < this.storeDef.getPreferredReads() && nodeIndex < nodes.size()) {
            Node node = nodes.get(nodeIndex);
            try {
                retrieved.add(new GetResult<R>(node,
                                               key,
                                               fetcher.execute(innerStores.get(node.getId()), key),
                                               null));
                ++successes;
                failureDetector.recordSuccess(node);
            } catch(UnreachableStoreException e) {
                failures.add(e);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520892162/fstmerge_var1_3250725334238728779
                failureDetector.recordException(node, e);
            } catch(VoldemortApplicationException e) {
                throw e;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520892162/fstmerge_base_6853570295933301527
                markUnavailable(node, e);
=======
                markUnavailable(node, e);
            } catch(VoldemortApplicationException e) {
                throw e;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415520892162/fstmerge_var2_5140948862456463712
            } catch(Exception e) {
                logger.warn("Error in GET on node " + node.getId() + "(" + node.getHost() + ")", e);
                failures.add(e);
            }
            nodeIndex++;
        }

        if(logger.isTraceEnabled())
            logger.trace("GET retrieved the following node values: " + formatNodeValues(retrieved));

        if(preReturnProcedure != null)
            preReturnProcedure.apply(retrieved);

        if(successes >= this.storeDef.getRequiredReads()) {
            List<R> result = Lists.newArrayListWithExpectedSize(retrieved.size());
            for(GetResult<R> getResult: retrieved)
                result.addAll(getResult.retrieved);
            return result;
        } else
            throw new InsufficientOperationalNodesException(this.storeDef.getRequiredReads()
                                                            + " reads required, but " + successes
                                                            + " succeeded.", failures);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7763a_f77be/rev_7763a-f77be/src/java/voldemort/store/routed/RoutedStore.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7d066_6c8e5/rev_7d066-6c8e5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b76b3_d0457/rev_b76b3-d0457.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d604e_88bd6/rev_d604e-88bd6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bdc4b_5e8b8/rev_bdc4b-5e8b8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_36575_e44cf/rev_36575-e44cf.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_371b2_7f263/rev_371b2-7f263.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_4460a_4b0c4/rev_4460a-4b0c4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c3e93_33d85/rev_c3e93-33d85.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415523052194/fstmerge_var1_1001575696619931808
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415523052194/fstmerge_base_3583576599300407293
private void reinit() {
        logger.info("bootstrapping metadata !!");
        this.store = storeFactory.getRawStore(storeName, resolver);
    }
=======
private void reinit() {
        logger.info("bootstrapping metadata.");
        this.store = storeFactory.getRawStore(storeName, resolver);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415523052194/fstmerge_var2_7791067625420651694

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c3e93_33d85/rev_c3e93-33d85/src/java/voldemort/client/DefaultStoreClient.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_45459_54e57/rev_45459-54e57.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c3e93_54e57/rev_c3e93-54e57.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2db07_d9d93/rev_2db07-d9d93.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a2087_4cd01/rev_a2087-4cd01.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f2878_abb89/rev_f2878-abb89.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b3214_c65f1/rev_b3214-c65f1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_af236_25b90/rev_af236-25b90.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d366f_af236/rev_d366f-af236.revisions
Conflict type: LineBasedMCFd
Conflict body: 
private List<Versioned<byte[]>> proxyGet(ByteArray key) throws VoldemortException {
        Node donorNode = metadata.getCluster().getNodeById(metadata.getRebalancingStealInfo()
                                                                   .getDonorId());
        checkNodeAvailable(donorNode);
        long start = System.currentTimeMillis();
        try {
            List<Versioned<byte[]>> values = getRedirectingSocketStore(getName(),
                                                                       metadata.getRebalancingStealInfo()
                                                                               .getDonorId()).get(key);
            failureDetector.recordSuccess(donorNode, System.currentTimeMillis() - start);
            return values;
        } catch(UnreachableStoreException e) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415525222483/fstmerge_var1_5805928588787758609
            failureDetector.recordException(donorNode, System.currentTimeMillis() - start, e);
            throw new ProxyUnreachableException("Failed to reach proxy node " + donorNode, e);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415525222483/fstmerge_base_8446967303236985644
            failureDetector.recordException(donorNode, e);
            throw new ProxyUnreachableException("Failed to reach proxy node "
                                                           + donorNode, e);
=======
            failureDetector.recordException(donorNode, e);
            throw new ProxyUnreachableException("Failed to reach proxy node " + donorNode, e);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415525222483/fstmerge_var2_5718841976801724616
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d366f_af236/rev_d366f-af236/src/java/voldemort/store/rebalancing/RedirectingStore.java
Conflict type: LineBasedMCFd
Conflict body: 
private Map<ByteArray, List<Versioned<byte[]>>> proxyGetAll(Iterable<ByteArray> keys)
            throws VoldemortException {
        Node donorNode = metadata.getCluster().getNodeById(metadata.getRebalancingStealInfo()
                                                                   .getDonorId());
        checkNodeAvailable(donorNode);
        long start = System.currentTimeMillis();
        try {
            Map<ByteArray, List<Versioned<byte[]>>> map = getRedirectingSocketStore(getName(),
                                                                                    metadata.getRebalancingStealInfo()
                                                                                            .getDonorId()).getAll(keys);
            failureDetector.recordSuccess(donorNode, System.currentTimeMillis() - start);
            return map;
        } catch(UnreachableStoreException e) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415525222493/fstmerge_var1_5582346374557532560
            failureDetector.recordException(donorNode, System.currentTimeMillis() - start, e);
            throw new ProxyUnreachableException("Failed to reach proxy node " + donorNode, e);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415525222493/fstmerge_base_811535781866215035
            failureDetector.recordException(donorNode, e);
            throw new ProxyUnreachableException("Failed to reach proxy node "
                                                           + donorNode, e);
=======
            failureDetector.recordException(donorNode, e);
            throw new ProxyUnreachableException("Failed to reach proxy node " + donorNode, e);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415525222493/fstmerge_var2_6314999804957029474
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d366f_af236/rev_d366f-af236/src/java/voldemort/store/rebalancing/RedirectingStore.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b14fa_e153b/rev_b14fa-e153b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_09037_d3d75/rev_09037-d3d75.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b0478_7ad31/rev_b0478-7ad31.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_fb347_6e74d/rev_fb347-6e74d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c8648_99572/rev_c8648-99572.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f3d9c_4fd63/rev_f3d9c-4fd63.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2867c_3b5c3/rev_2867c-3b5c3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_43f89_bffb3/rev_43f89-bffb3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_89429_86ea2/rev_89429-86ea2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e05ea_fa8ab/rev_e05ea-fa8ab.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6f627_c8ee0/rev_6f627-c8ee0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d5ad7_9dce0/rev_d5ad7-9dce0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d2cae_68feb/rev_d2cae-68feb.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d2cae_d5ad7/rev_d2cae-d5ad7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2b0ef_75922/rev_2b0ef-75922.revisions
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415529598923/fstmerge_var1_1263032693991561866
public static ReadOnlyStorageEngineTestInstance create(SearchStrategy strategy,
                                                           File baseDir,
                                                           int testSize,
                                                           int numNodes,
                                                           int repFactor,
                                                           SerializerDefinition keySerDef,
                                                           SerializerDefinition valueSerDef)
            throws Exception {
        // create some test data
        Map<String, String> data = createTestData(testSize);
        JsonReader reader = makeTestDataReader(data, baseDir);

        // set up definitions for cluster and store
        List<Node> nodes = new ArrayList<Node>();
        for(int i = 0; i < numNodes; i++) {
            nodes.add(new Node(i,
                               "localhost",
                               8080 + i,
                               6666 + i,
                               7000 + i,
                               Arrays.asList(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3)));
        }
        Cluster cluster = new Cluster("test", nodes);
        StoreDefinition storeDef = new StoreDefinitionBuilder().setName("test")
                                                               .setType(ReadOnlyStorageConfiguration.TYPE_NAME)
                                                               .setKeySerializer(keySerDef)
                                                               .setValueSerializer(valueSerDef)
                                                               .setRoutingPolicy(RoutingTier.CLIENT)
                                                               .setRoutingStrategyType(RoutingStrategyType.CONSISTENT_STRATEGY)
                                                               .setReplicationFactor(repFactor)
                                                               .setPreferredReads(1)
                                                               .setRequiredReads(1)
                                                               .setPreferredWrites(1)
                                                               .setRequiredWrites(1)
                                                               .build();
        RoutingStrategy router = new RoutingStrategyFactory().updateRoutingStrategy(storeDef,
                                                                                    cluster);

        // build store files in outputDir
        File outputDir = TestUtils.createTempDir(baseDir);
        JsonStoreBuilder storeBuilder = new JsonStoreBuilder(reader,
                                                             cluster,
                                                             storeDef,
                                                             router,
                                                             outputDir,
                                                             null,
                                                             testSize / 5,
                                                             1,
                                                             2,
                                                             10000);
        storeBuilder.build();

        File nodeDir = TestUtils.createTempDir(baseDir);
        @SuppressWarnings("unchecked")
        Serializer<String> keySerializer = (Serializer<String>) new DefaultSerializerFactory().getSerializer(keySerDef);
        @SuppressWarnings("unchecked")
        Serializer<String> valueSerializer = (Serializer<String>) new DefaultSerializerFactory().getSerializer(valueSerDef);
        Map<Integer, Store<String, String>> nodeStores = Maps.newHashMap();
        for(int i = 0; i < numNodes; i++) {
            File currNode = new File(nodeDir, Integer.toString(i));
            currNode.mkdirs();
            currNode.deleteOnExit();
            Utils.move(new File(outputDir, "node-" + Integer.toString(i)), new File(currNode,
                                                                                    "version-0"));

            CompressionStrategyFactory comppressionStrategyFactory = new CompressionStrategyFactory();
            CompressionStrategy keyCompressionStrat = comppressionStrategyFactory.get(keySerDef.getCompression());
            CompressionStrategy valueCompressionStrat = comppressionStrategyFactory.get(valueSerDef.getCompression());
            Store<ByteArray, byte[]> innerStore = new CompressingStore(new ReadOnlyStorageEngine("test",
                                                                                                 strategy,
                                                                                                 currNode,
                                                                                                 1),
                                                                       keyCompressionStrat,
                                                                       valueCompressionStrat);

            nodeStores.put(i, SerializingStore.wrap(innerStore, keySerializer, valueSerializer));
        }

        return new ReadOnlyStorageEngineTestInstance(data,
                                                     baseDir,
                                                     nodeStores,
                                                     router,
                                                     keySerializer);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415529598923/fstmerge_base_497701251928357824
=======
public static ReadOnlyStorageEngineTestInstance create(SearchStrategy strategy,
                                                           File baseDir,
                                                           int testSize,
                                                           int numNodes,
                                                           int repFactor,
                                                           SerializerDefinition keySerDef,
                                                           SerializerDefinition valueSerDef)
            throws Exception {
        // create some test data
        Map<String, String> data = createTestData(testSize);
        JsonReader reader = makeTestDataReader(data, baseDir);

        // set up definitions for cluster and store
        List<Node> nodes = new ArrayList<Node>();
        for(int i = 0; i < numNodes; i++) {
            nodes.add(new Node(i,
                               "localhost",
                               8080 + i,
                               6666 + i,
                               7000 + i,
                               Arrays.asList(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3)));
        }
        Cluster cluster = new Cluster("test", nodes);
        StoreDefinition storeDef = new StoreDefinitionBuilder().setName("test")
                                                               .setType(ReadOnlyStorageConfiguration.TYPE_NAME)
                                                               .setKeySerializer(keySerDef)
                                                               .setValueSerializer(valueSerDef)
                                                               .setRoutingPolicy(RoutingTier.CLIENT)
                                                               .setRoutingStrategyType(RoutingStrategyType.CONSISTENT_STRATEGY)
                                                               .setReplicationFactor(repFactor)
                                                               .setPreferredReads(1)
                                                               .setRequiredReads(1)
                                                               .setPreferredWrites(1)
                                                               .setRequiredWrites(1)
                                                               .build();
        RoutingStrategy router = new RoutingStrategyFactory().updateRoutingStrategy(storeDef,
                                                                                    cluster);

        // build store files in outputDir
        File outputDir = TestUtils.createTempDir(baseDir);
        JsonStoreBuilder storeBuilder = new JsonStoreBuilder(reader,
                                                             cluster,
                                                             storeDef,
                                                             router,
                                                             outputDir,
                                                             null,
                                                             testSize / 5,
                                                             1,
                                                             2,
                                                             10000);
        storeBuilder.build();

        File nodeDir = TestUtils.createTempDir(baseDir);
        @SuppressWarnings("unchecked")
        Serializer<String> keySerializer = (Serializer<String>) new DefaultSerializerFactory().getSerializer(keySerDef);
        Serializer<String> valueSerializer = (Serializer<String>) new DefaultSerializerFactory().getSerializer(valueSerDef);
        Map<Integer, Store<String, String>> nodeStores = Maps.newHashMap();
        for(int i = 0; i < numNodes; i++) {
            File currNode = new File(nodeDir, Integer.toString(i));
            currNode.mkdirs();
            currNode.deleteOnExit();
            Utils.move(new File(outputDir, "node-" + Integer.toString(i)), new File(currNode,
                                                                                    "version-0"));

            CompressionStrategyFactory comppressionStrategyFactory = new CompressionStrategyFactory();
            CompressionStrategy keyCompressionStrat = comppressionStrategyFactory.get(keySerDef.getCompression());
            CompressionStrategy valueCompressionStrat = comppressionStrategyFactory.get(valueSerDef.getCompression());
            Store<ByteArray, byte[]> innerStore = new CompressingStore(new ReadOnlyStorageEngine("test",
                                                                                                 strategy,
                                                                                                 currNode,
                                                                                                 1),
                                                                       keyCompressionStrat,
                                                                       valueCompressionStrat);

            nodeStores.put(i, SerializingStore.wrap(innerStore, keySerializer, valueSerializer));
        }

        return new ReadOnlyStorageEngineTestInstance(data,
                                                     baseDir,
                                                     nodeStores,
                                                     router,
                                                     keySerializer);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415529598923/fstmerge_var2_3917907572859423155

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2b0ef_75922/rev_2b0ef-75922/test/unit/voldemort/store/readonly/ReadOnlyStorageEngineTestInstance.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415529616773/fstmerge_var1_3285518747902560416
@SuppressWarnings("unchecked")
        public JsonObjectIterator(JsonReader reader, StoreDefinition storeDefinition) {
            SerializerFactory factory = new DefaultSerializerFactory();

            this.reader = reader;
            this.digest = ByteUtils.getDigest("MD5");
            this.keySerializerDefinition = storeDefinition.getKeySerializer();
            this.valueSerializerDefinition = storeDefinition.getValueSerializer();
            this.keySerializer = (Serializer<Object>) factory.getSerializer(storeDefinition.getKeySerializer());
            this.valueSerializer = (Serializer<Object>) factory.getSerializer(storeDefinition.getValueSerializer());
            this.keyCompressor = new CompressionStrategyFactory().get(keySerializerDefinition.getCompression());
            this.valueCompressor = new CompressionStrategyFactory().get(valueSerializerDefinition.getCompression());
        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415529616773/fstmerge_base_6671067411288791397
=======
public JsonObjectIterator(JsonReader reader, StoreDefinition storeDefinition) {
            SerializerFactory factory = new DefaultSerializerFactory();

            this.reader = reader;
            this.digest = ByteUtils.getDigest("MD5");
            this.keySerializerDefinition = storeDefinition.getKeySerializer();
            this.valueSerializerDefinition = storeDefinition.getValueSerializer();
            this.keySerializer = (Serializer<Object>) factory.getSerializer(storeDefinition.getKeySerializer());
            this.valueSerializer = (Serializer<Object>) factory.getSerializer(storeDefinition.getValueSerializer());
            this.keyCompressor = new CompressionStrategyFactory().get(keySerializerDefinition.getCompression());
            this.valueCompressor = new CompressionStrategyFactory().get(valueSerializerDefinition.getCompression());
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415529616773/fstmerge_var2_5898530142325071670

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2b0ef_75922/rev_2b0ef-75922/src/java/voldemort/store/readonly/JsonStoreBuilder.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_807f8_5bf10/rev_807f8-5bf10.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3ad9a_807f8/rev_3ad9a-807f8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_4ade9_0f9ed/rev_4ade9-0f9ed.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_0dfb7_3b6de/rev_0dfb7-3b6de.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b0407_8974e/rev_b0407-8974e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_0dfb7_8033c/rev_0dfb7-8033c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b6b77_549f4/rev_b6b77-549f4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_df8f8_0852f/rev_df8f8-0852f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_ae6df_c9af7/rev_ae6df-c9af7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c9af7_fb647/rev_c9af7-fb647.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_1f1d0_54c90/rev_1f1d0-54c90.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@Test
    public void testSocketPoolLimitSomeTimeout() throws Exception {
        // start a dummy server
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415533076933/fstmerge_var1_1270415724041674818
        SocketServer server = new SocketServer(7666,
                                               50,
                                               50,
                                               1000,
                                               new SocketRequestHandlerFactory(null,
                                                                               null,
                                                                               null,
                                                                               null,
                                                                               null,
                                                                               null),
                                               "test");
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415533076933/fstmerge_base_5249269646866225195
        SocketServer server = new SocketServer(7666,
                                               50,
                                               50,
                                               1000,
                                               new SocketRequestHandlerFactory(null,
                                                                               null,
                                                                               null,
                                                                               null,
                                                                               null),
                                               "test");
=======
        AbstractSocketService server = ServerTestUtils.getSocketService(useNio,
                                                                        new SocketRequestHandlerFactory(null,
                                                                                                        null,
                                                                                                        null,
                                                                                                        null,
                                                                                                        null),
                                                                        7666,
                                                                        50,
                                                                        50,
                                                                        1000);

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415533076933/fstmerge_var2_8867463266110035085
        server.start();

        final ResourcePoolConfig config = new ResourcePoolConfig().setTimeout(50,
                                                                              TimeUnit.MILLISECONDS)
                                                                  .setMaxPoolSize(20);

        ResourceFactory<SocketDestination, SocketAndStreams> factory = ResourcePoolTestUtils.getSocketPoolFactory();
        final AbstractSocketPoolTest<SocketDestination, SocketAndStreams> test = new AbstractSocketPoolTest<SocketDestination, SocketAndStreams>() {

            @Override
            protected void doSomethingWithResource(SocketDestination key, SocketAndStreams resource)
                    throws Exception {
                Thread.sleep(100);
                int random = (int) (Math.random() * 10);
                if(random >= 5)
                    resource.getSocket().close();
            }

            @Override
            protected SocketDestination getRequestKey() throws Exception {
                return new SocketDestination("localhost", 7666, RequestFormatType.VOLDEMORT_V1);
            }

        };

        // borrow timeout >> doSomething() no timeout expected
        TestStats testStats = test.startTest(factory, config, 50, 200);
        assertEquals("We should see some timeoutRequests", true, testStats.timeoutRequests > 0);
        server.stop();
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_1f1d0_54c90/rev_1f1d0-54c90/test/integration/voldemort/socketpool/SimpleSocketPoolTest.java
Conflict type: LineBasedMCFd
Conflict body: 
private AbstractSocketService getAdminServer(Node node,
                                                 Cluster cluster,
                                                 List<StoreDefinition> storeDefs,
                                                 StorageEngine<ByteArray, byte[]> storageEngine)
            throws IOException {
        StoreRepository storeRepository = new StoreRepository();
        storeRepository.addStorageEngine(storageEngine);
        storeRepository.addLocalStore(storageEngine);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415533077677/fstmerge_var1_1609118013685961254
        return new SocketService(new SocketRequestHandlerFactory(null,
                                                                 storeRepository,
                                                                 ServerTestUtils.createMetadataStore(cluster,
                                                                                                     storeDefs),
                                                                 ServerTestUtils.createServerConfig(0,
                                                                                                    TestUtils.createTempDir()
                                                                                                             .getAbsolutePath(),
                                                                                                    null,
                                                                                                    null,
                                                                                                    new Properties()),
                                                                 null,
                                                                 null),
                                 node.getAdminPort(),
                                 2,
                                 2,
                                 10000,
                                 "test-admin-service",
                                 false);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415533077677/fstmerge_base_6555014981883729178
        return new SocketService(new SocketRequestHandlerFactory(storeRepository,
                                                                 ServerTestUtils.createMetadataStore(cluster,
                                                                                                     storeDefs),
                                                                 ServerTestUtils.createServerConfig(0,
                                                                                                    TestUtils.createTempDir()
                                                                                                             .getAbsolutePath(),
                                                                                                    null,
                                                                                                    null,
                                                                                                    new Properties()),
                                                                 null,
                                                                 null),
                                 node.getAdminPort(),
                                 2,
                                 2,
                                 10000,
                                 "test-admin-service",
                                 false);
=======
        SocketRequestHandlerFactory requestHandlerFactory = new SocketRequestHandlerFactory(storeRepository,
                                                                                            ServerTestUtils.createMetadataStore(cluster,
                                                                                                                                storeDefs),
                                                                                            ServerTestUtils.createServerConfig(useNio,
                                                                                                                               0,
                                                                                                                               TestUtils.createTempDir()
                                                                                                                                        .getAbsolutePath(),
                                                                                                                               null,
                                                                                                                               null,
                                                                                                                               new Properties()),
                                                                                            null,
                                                                                            null);
        return ServerTestUtils.getSocketService(useNio,
                                                requestHandlerFactory,
                                                node.getAdminPort(),
                                                2,
                                                2,
                                                10000);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415533077677/fstmerge_var2_5642439787876931923
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_1f1d0_54c90/rev_1f1d0-54c90/test/unit/voldemort/client/AdminServiceFailureTest.java
Conflict type: LineBasedMCFd
Conflict body: 
public StreamRequestHandler handleRequest(final DataInputStream inputStream,
                                              final DataOutputStream outputStream)
            throws IOException {
        // Another protocol buffers bug here, temp. work around
        VoldemortAdminRequest.Builder request = VoldemortAdminRequest.newBuilder();
        int size = inputStream.readInt();

        if(logger.isTraceEnabled())
            logger.trace("In handleRequest, request specified size of " + size + " bytes");

        if(size < 0)
            throw new IOException("In handleRequest, request specified size of " + size + " bytes");

        byte[] input = new byte[size];
        ByteUtils.read(inputStream, input);
        request.mergeFrom(input);

        switch(request.getType()) {
            case GET_METADATA:
                ProtoUtils.writeMessage(outputStream, handleGetMetadata(request.getGetMetadata()));
                break;
            case UPDATE_METADATA:
                ProtoUtils.writeMessage(outputStream,
                                        handleUpdateMetadata(request.getUpdateMetadata()));
                break;
            case DELETE_PARTITION_ENTRIES:
                ProtoUtils.writeMessage(outputStream,
                                        handleDeletePartitionEntries(request.getDeletePartitionEntries()));
                break;
            case FETCH_PARTITION_ENTRIES:
                return handleFetchPartitionEntries(request.getFetchPartitionEntries());

            case UPDATE_PARTITION_ENTRIES:
                return handleUpdatePartitionEntries(request.getUpdatePartitionEntries());

            case INITIATE_FETCH_AND_UPDATE:
                ProtoUtils.writeMessage(outputStream,
                                        handleFetchAndUpdate(request.getInitiateFetchAndUpdate()));
                break;
            case ASYNC_OPERATION_STATUS:
                ProtoUtils.writeMessage(outputStream,
                                        handleAsyncStatus(request.getAsyncOperationStatus()));
                break;
            case INITIATE_REBALANCE_NODE:
                ProtoUtils.writeMessage(outputStream,
                                        handleRebalanceNode(request.getInitiateRebalanceNode()));
                break;
            case ASYNC_OPERATION_LIST:
                ProtoUtils.writeMessage(outputStream,
                                        handleAsyncOperationList(request.getAsyncOperationList()));
                break;
            case ASYNC_OPERATION_STOP:
                ProtoUtils.writeMessage(outputStream,
                                        handleAsyncOperationStop(request.getAsyncOperationStop()));
                break;
            case TRUNCATE_ENTRIES:
                ProtoUtils.writeMessage(outputStream,
                                        handleTruncateEntries(request.getTruncateEntries()));
                break;
            case ADD_STORE:
                ProtoUtils.writeMessage(outputStream,
                                        handleAddStore(request.getAddStore()));
                break;
            default:
                throw new VoldemortException("Unkown operation " + request.getType());
        }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415533092842/fstmerge_var1_5898416982781492758
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415533092842/fstmerge_base_1980215654033587810

=======

        return null;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415533092842/fstmerge_var2_7135682124328419471
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_1f1d0_54c90/rev_1f1d0-54c90/src/java/voldemort/server/protocol/admin/AdminServiceRequestHandler.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_68179_daa28/rev_68179-daa28.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d5ea5_c2eda/rev_d5ea5-c2eda.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_5755c_0516a/rev_5755c-0516a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7355a_b3b7b/rev_7355a-b3b7b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_9365e_4b99e/rev_9365e-4b99e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d2c88_6ff94/rev_d2c88-6ff94.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b3683_89cad/rev_b3683-89cad.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6af5d_2c7ae/rev_6af5d-2c7ae.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f0190_e219a/rev_f0190-e219a.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public Serializer<?> getSerializer(SerializerDefinition serializerDef) {
        String name = serializerDef.getName();
        if(name.equals(JAVA_SERIALIZER_TYPE_NAME)) {
            return new ObjectSerializer<Object>();
        } else if(name.equals(STRING_SERIALIZER_TYPE_NAME)) {
            return new StringSerializer(serializerDef.hasSchemaInfo() ? serializerDef.getCurrentSchemaInfo()
                                                                     : "UTF8");
        } else if(name.equals(IDENTITY_SERIALIZER_TYPE_NAME)) {
            return new IdentitySerializer();
        } else if(name.equals(JSON_SERIALIZER_TYPE_NAME)) {
            Map<Integer, JsonTypeDefinition> versions = new HashMap<Integer, JsonTypeDefinition>();
            for(Map.Entry<Integer, String> entry: serializerDef.getAllSchemaInfoVersions()
                                                               .entrySet())
                versions.put(entry.getKey(), JsonTypeDefinition.fromJson(entry.getValue()));
            return new JsonTypeSerializer(versions);
        } else if(name.equals(PROTO_BUF_TYPE_NAME)) {
            return new ProtoBufSerializer<Message>(serializerDef.getCurrentSchemaInfo());
        } else if(name.equals(THRIFT_TYPE_NAME)) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415535738173/fstmerge_var1_7548473446254673665
            return new ThriftSerializer<TBase>(serializerDef.getCurrentSchemaInfo());
        } else if(name.equals(AVRO_GENERIC_TYPE_NAME)) {
            return new AvroGenericSerializer(serializerDef.getCurrentSchemaInfo());
        } else if(name.equals(AVRO_SPECIFIC_TYPE_NAME)) {
            return new AvroSpecificSerializer(serializerDef.getCurrentSchemaInfo());
        } else if(name.equals(AVRO_REFLECTIVE_TYPE_NAME)) {
            return new AvroReflectiveSerializer(serializerDef.getCurrentSchemaInfo());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415535738173/fstmerge_base_3609456579749882359
            return new ThriftSerializer<TBase>(serializerDef.getCurrentSchemaInfo());
=======
            return new ThriftSerializer<TBase<?>>(serializerDef.getCurrentSchemaInfo());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415535738173/fstmerge_var2_3152269481435983114
        } else {
            throw new IllegalArgumentException("No known serializer type: "
                                               + serializerDef.getName());
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f0190_e219a/rev_f0190-e219a/src/java/voldemort/serialization/DefaultSerializerFactory.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d0745_e7c10/rev_d0745-e7c10.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_9db25_aa935/rev_9db25-aa935.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_41e1c_68bff/rev_41e1c-68bff.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b9b30_33b5e/rev_b9b30-33b5e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_5c596_98fc3/rev_5c596-98fc3.revisions
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415537230794/fstmerge_var1_5926308126664499310
public AsyncOperationService(SchedulerService scheduler, int cacheSize) {
        super(ServiceType.ASYNC_SCHEDULER);
        operations = Collections.synchronizedMap(new AsyncOperationCache(cacheSize));
        this.scheduler = scheduler;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415537230794/fstmerge_base_7099413354747447138
=======
@SuppressWarnings("unchecked")
    // apache commons collections aren't updated for 1.5 yet
    public AsyncOperationService(SchedulerService scheduler, int cacheSize) {
        super(ServiceType.ASYNC_SCHEDULER);
        operations = Collections.synchronizedMap(new AsyncOperationRepository(cacheSize));
        this.scheduler = scheduler;
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415537230794/fstmerge_var2_5317542445512244381

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_5c596_98fc3/rev_5c596-98fc3/src/java/voldemort/server/protocol/admin/AsyncOperationService.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b4811_7285b/rev_b4811-7285b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_fc1e9_dedf2/rev_fc1e9-dedf2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_368f2_5fa00/rev_368f2-5fa00.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_43f3d_56c93/rev_43f3d-56c93.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_dca5d_0d53b/rev_dca5d-0d53b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a1c96_7c011/rev_a1c96-7c011.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public void registerNodeStores(StoreDefinition def, Cluster cluster, int localNode) {
        Map<Integer, Store<ByteArray, byte[]>> nodeStores = new HashMap<Integer, Store<ByteArray, byte[]>>(cluster.getNumberOfNodes());

        for(Node node: cluster.getNodes()) {
            Store<ByteArray, byte[]> store = getNodeStore(def.getName(), node, localNode);
            this.storeRepository.addNodeStore(node.getId(), store);
            nodeStores.put(node.getId(), store);
        }

        Store<ByteArray, byte[]> store = new NewRoutedStore(def.getName(),
                                                            nodeStores,
                                                            metadata.getCluster(),
                                                            def,
                                                            true,
                                                            this.clientThreadPool,
                                                            voldemortConfig.getRoutingTimeoutMs(),
                                                            failureDetector,
                                                            SystemTime.INSTANCE);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415539010843/fstmerge_var1_2285245693709699219
        routedStore = new RebootstrappingStore(metadata,
                                               storeRepository,
                                               voldemortConfig,
                                               storeFactory,
                                               (RoutedStore) routedStore);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415539010843/fstmerge_base_1320731658990529891
        routedStore = new RebootstrappingStore(metadata,
                                               storeRepository,
                                               voldemortConfig,
                                               socketPool,
                                               (RoutedStore) routedStore);
=======
        store = new RebootstrappingStore(metadata,
                                         storeRepository,
                                         voldemortConfig,
                                         socketPool,
                                         (RoutableStore) store);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415539010843/fstmerge_var2_4300989078939595881

        store = new InconsistencyResolvingStore<ByteArray, byte[]>(store,
                                                                   new VectorClockInconsistencyResolver<byte[]>());
        this.storeRepository.addRoutedStore(store);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a1c96_7c011/rev_a1c96-7c011/src/java/voldemort/server/storage/StorageService.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_92b1a_b0f6d/rev_92b1a-b0f6d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_fc05a_d31b3/rev_fc05a-d31b3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_95517_c0aef/rev_95517-c0aef.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_497c4_6c05f/rev_497c4-6c05f.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public static void main(String[] args) throws Exception {

        OptionParser parser = new OptionParser();
        parser.accepts("r", "execute read operations");
        parser.accepts("w", "execute write operations");
        parser.accepts("d", "execute delete operations");
        parser.accepts("m", "generate a mix of read and write requests");
        parser.accepts("v", "verbose");
        parser.accepts("ignore-nulls", "ignore null values");
        parser.accepts("pipeline-routed-store", "Use the Pipeline RoutedStore");
        parser.accepts("node", "go to this node id").withRequiredArg().ofType(Integer.class);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415540187580/fstmerge_var1_2810208600606146501
        parser.accepts("interval", "print requests on this interval, -1 to disable")
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415540187580/fstmerge_base_996806842576793566
        parser.accepts("interval", "print requests on this interval")
=======
        parser.accepts("interval", "print requests on this interval, -1 disables")
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415540187580/fstmerge_var2_8689353901231287888
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("handshake", "perform a handshake");
        parser.accepts("verify", "verify values read");
        parser.accepts("request-file", "execute specific requests in order").withRequiredArg();
        parser.accepts("start-key-index", "starting point when using int keys. Default = 0")
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("value-size", "size in bytes for random value.  Default = 1024")
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("iterations", "number of times to repeat the test  Default = 1")
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("threads", "max number concurrent worker threads  Default = " + MAX_WORKERS)
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("percent-cached",
                       "percentage of requests to come from previously requested keys; valid values are in range [0..100]; 0 means caching disabled  Default = 0")
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("help");

        OptionSet options = parser.parse(args);

        List<String> nonOptions = options.nonOptionArguments();

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415540187580/fstmerge_base_996806842576793566
        if (options.has("help")) {
=======
        if(options.has("help")) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415540187580/fstmerge_var2_8689353901231287888
            printUsage(System.out, parser);
        }

        if(nonOptions.size() != 3) {
            printUsage(System.err, parser);
        }

        String url = nonOptions.get(0);
        String storeName = nonOptions.get(1);
        int numRequests = Integer.parseInt(nonOptions.get(2));
        String ops = "";
        List<Integer> keys = null;

        Integer startNum = CmdUtils.valueOf(options, "start-key-index", 0);
        Integer valueSize = CmdUtils.valueOf(options, "value-size", 1024);
        Integer numIterations = CmdUtils.valueOf(options, "iterations", 1);
        Integer numThreads = CmdUtils.valueOf(options, "threads", MAX_WORKERS);
        Integer percentCached = CmdUtils.valueOf(options, "percent-cached", 0);

        if(percentCached < 0 || percentCached > 100) {
            printUsage(System.err, parser);
        }

        Integer nodeId = CmdUtils.valueOf(options, "node", 0);
        final Integer interval = CmdUtils.valueOf(options, "interval", 100000);
        final boolean verifyValues = options.has("verify");
        final boolean verbose = options.has("v");

        if(options.has("request-file")) {
            keys = loadKeys((String) options.valueOf("request-file"));
        }

        if(options.has("r")) {
            ops += "r";
        }
        if(options.has("w")) {
            ops += "w";
        }
        if(options.has("d")) {
            ops += "d";
        }
        if(options.has("m")) {
            ops += "m";
        }
        if(ops.length() == 0) {
            ops = "rwd";
        }

        System.out.println("operations : " + ops);
        System.out.println("value size : " + valueSize);
        System.out.println("start index : " + startNum);
        System.out.println("iterations : " + numIterations);
        System.out.println("threads : " + numThreads);
        System.out.println("cache percentage : " + percentCached + "%");

        System.out.println("Bootstraping cluster data.");
        ClientConfig clientConfig = new ClientConfig().setMaxThreads(numThreads)
                                                      .setMaxTotalConnections(numThreads)
                                                      .setMaxConnectionsPerNode(numThreads)
                                                      .setBootstrapUrls(url)
                                                      .setConnectionTimeout(60, TimeUnit.SECONDS)
                                                      .setSocketTimeout(60, TimeUnit.SECONDS)
                                                      .setSocketBufferSize(4 * 1024)
                                                      .setEnablePipelineRoutedStore(options.has("pipeline-routed-store"));
        SocketStoreClientFactory factory = new SocketStoreClientFactory(clientConfig);
        final StoreClient<Object, Object> store = factory.getStoreClient(storeName);
        StoreDefinition storeDef = getStoreDefinition(factory, storeName);

        Class<?> keyType = findKeyType(storeDef);
        final String value = TestUtils.randomLetters(valueSize);
        ExecutorService service = Executors.newFixedThreadPool(numThreads);

        /*
         * send the store a value and then delete it - useful for the NOOP store
         * which will then use that value for other queries
         */

        if(options.has("handshake")) {
            final Object key = getKeyProvider(keyType, startNum, keys, 0).next();

            // We need to delete just in case there's an existing value there
            // that would otherwise cause the test run to bomb out.
            store.delete(key);
            store.put(key, new Versioned<String>(value));
            store.delete(key);
        }

        for(int loopCount = 0; loopCount < numIterations; loopCount++) {

            System.out.println("======================= iteration = " + loopCount
                               + " ======================================");

            if(ops.contains("d")) {
                System.out.println("Beginning delete test.");
                final AtomicInteger successes = new AtomicInteger(0);
                final KeyProvider<?> keyProvider0 = getKeyProvider(keyType,
                                                                   startNum,
                                                                   keys,
                                                                   percentCached);
                final CountDownLatch latch0 = new CountDownLatch(numRequests);
                final long[] requestTimes = new long[numRequests];
                final long start = System.nanoTime();
                for(int i = 0; i < numRequests; i++) {
                    final int j = i;
                    service.execute(new Runnable() {

                        public void run() {
                            try {
                                long startNs = System.nanoTime();
                                store.delete(keyProvider0.next());
                                requestTimes[j] = (System.nanoTime() - startNs) / Time.NS_PER_MS;
                                successes.getAndIncrement();
                            } catch(Exception e) {
                                e.printStackTrace();
                            } finally {
                                latch0.countDown();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415540187580/fstmerge_base_996806842576793566
                                if(j % interval == 0) {
=======
                                if(interval != -1 && j % interval == 0) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415540187580/fstmerge_var2_8689353901231287888
                                    printStatistics("deletes", successes.get(), start);
                                }
                            }
                        }
                    });
                }
                latch0.await();
                printStatistics("deletes", successes.get(), start);
                System.out.println("95th percentile delete latency: "
                                   + TestUtils.quantile(requestTimes, .95) + " ms.");
                System.out.println("99th percentile delete latency: "
                                   + TestUtils.quantile(requestTimes, .99) + " ms.");
            }

            if(ops.contains("w")) {
                final AtomicInteger numWrites = new AtomicInteger(0);
                System.out.println("Beginning write test.");
                final KeyProvider<?> keyProvider1 = getKeyProvider(keyType,
                                                                   startNum,
                                                                   keys,
                                                                   percentCached);
                final CountDownLatch latch1 = new CountDownLatch(numRequests);
                final long[] requestTimes = new long[numRequests];
                final long start = System.nanoTime();
                for(int i = 0; i < numRequests; i++) {
                    final int j = i;
                    service.execute(new Runnable() {

                        public void run() {
                            try {
                                final Object key = keyProvider1.next();
                                store.applyUpdate(new UpdateAction<Object, Object>() {

                                    public void update(StoreClient<Object, Object> storeClient) {
                                        long startNs = System.nanoTime();
                                        storeClient.put(key, value);
                                        requestTimes[j] = (System.nanoTime() - startNs)
                                                          / Time.NS_PER_MS;
                                        numWrites.incrementAndGet();
                                    }
                                }, 64);
                            } catch(Exception e) {
                                if(verbose) {
                                    e.printStackTrace();
                                }
                            } finally {
                                latch1.countDown();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415540187580/fstmerge_base_996806842576793566
                                if(j % interval == 0) {
=======
                                if(interval != -1 && j % interval == 0) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415540187580/fstmerge_var2_8689353901231287888
                                    printStatistics("writes", numWrites.get(), start);
                                }
                            }
                        }
                    });
                }
                latch1.await();
                printStatistics("writes", numWrites.get(), start);
                System.out.println("95th percentile write latency: "
                                   + TestUtils.quantile(requestTimes, .95) + " ms.");
                System.out.println("99th percentile write latency: "
                                   + TestUtils.quantile(requestTimes, .99) + " ms.");
            }

            if(ops.contains("r")) {
                final boolean ignoreNulls = options.has("ignore-nulls");
                final AtomicInteger numReads = new AtomicInteger(0);
                final AtomicInteger numNulls = new AtomicInteger(0);
                System.out.println("Beginning read test.");
                final KeyProvider<?> keyProvider = getKeyProvider(keyType,
                                                                  startNum,
                                                                  keys,
                                                                  percentCached);
                final CountDownLatch latch = new CountDownLatch(numRequests);
                final long[] requestTimes = new long[numRequests];
                final long start = System.nanoTime();
                keyProvider.next();
                for(int i = 0; i < numRequests; i++) {
                    final int j = i;
                    service.execute(new Runnable() {

                        public void run() {
                            try {
                                Object key = keyProvider.next();
                                long startNs = System.nanoTime();
                                Versioned<Object> v = store.get(key);
                                requestTimes[j] = (System.nanoTime() - startNs) / Time.NS_PER_MS;
                                numReads.incrementAndGet();
                                if(v == null) {
                                    numNulls.incrementAndGet();
                                    if(!ignoreNulls) {
                                        throw new Exception("value returned is null for key " + key);
                                    }
                                }

                                if(verifyValues && !value.equals(v.getValue())) {
                                    throw new Exception("value returned isn't same as set value for key "
                                                        + key);
                                }
                            } catch(Exception e) {
                                if(verbose) {
                                    e.printStackTrace();
                                }
                            } finally {
                                latch.countDown();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415540187580/fstmerge_base_996806842576793566
                                if(j % interval == 0) {
=======
                                if(interval != -1 && j % interval == 0) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415540187580/fstmerge_var2_8689353901231287888
                                    printStatistics("reads", numReads.get(), start);
                                    printNulls(numNulls.get(), start);
                                }
                            }
                        }
                    });
                }
                latch.await();
                printStatistics("reads", numReads.get(), start);
                System.out.println("95th percentile read latency: "
                                   + TestUtils.quantile(requestTimes, .95) + " ms.");
                System.out.println("99th percentile read latency: "
                                   + TestUtils.quantile(requestTimes, .99) + " ms.");
            }
        }

        if(ops.contains("m")) {
            final AtomicInteger numNulls = new AtomicInteger(0);
            final AtomicInteger numReads = new AtomicInteger(0);
            final AtomicInteger numWrites = new AtomicInteger(0);
            System.out.println("Beginning mixed test.");
            final KeyProvider<?> keyProvider = getKeyProvider(keyType,
                                                              startNum,
                                                              keys,
                                                              percentCached);
            final CountDownLatch latch = new CountDownLatch(numRequests);
            final long start = System.nanoTime();
            keyProvider.next();
            for(int i = 0; i < numRequests; i++) {
                final int j = i;
                service.execute(new Runnable() {

                    public void run() {
                        try {
                            final Object key = keyProvider.next();

                            store.applyUpdate(new UpdateAction<Object, Object>() {

                                public void update(StoreClient<Object, Object> storeClient) {
                                    Versioned<Object> v = store.get(key);
                                    numReads.incrementAndGet();
                                    if(v != null) {
                                        storeClient.put(key, v);
                                    } else {
                                        numNulls.incrementAndGet();
                                    }
                                    numWrites.incrementAndGet();
                                }
                            }, 64);
                        } catch(Exception e) {
                            if(verbose) {
                                e.printStackTrace();
                            }
                        } finally {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415540187580/fstmerge_base_996806842576793566
                            if(j % interval == 0) {
=======
                            if(interval != -1 && j % interval == 0) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415540187580/fstmerge_var2_8689353901231287888
                                printStatistics("reads", numReads.get(), start);
                                printStatistics("writes", numWrites.get(), start);
                                printNulls(numNulls.get(), start);
                                printStatistics("transactions", j, start);
                            }
                            latch.countDown();

                        }
                    }
                });
            }
            latch.await();
            printStatistics("reads", numReads.get(), start);
            printStatistics("writes", numWrites.get(), start);
        }

        System.exit(0);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_497c4_6c05f/rev_497c4-6c05f/test/integration/voldemort/performance/RemoteTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public FailureDetector createFailureDetector() throws Exception {
        FailureDetectorConfig failureDetectorConfig = new FailureDetectorConfig().setImplementationClassName(ThresholdFailureDetector.class.getName())
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415540189763/fstmerge_var1_1454206222560606368
                                                                                 .setBannagePeriod(BANNAGE_MILLIS)
                                                                                 .setAsyncRecoveryInterval(250)
                                                                                 .setThresholdInterval(500)
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415540189763/fstmerge_base_5414626593287512662
                                                                                 .setBannagePeriod(BANNAGE_MILLIS)
=======
                                                                                 .setThresholdInterval(1000)
                                                                                 .setAsyncRecoveryInterval(250)
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415540189763/fstmerge_var2_3699522863077198123
                                                                                 .setNodes(cluster.getNodes())
                                                                                 .setStoreVerifier(create(cluster.getNodes()))
                                                                                 .setTime(time);

        return create(failureDetectorConfig, true);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_497c4_6c05f/rev_497c4-6c05f/test/unit/voldemort/cluster/failuredetector/ThresholdFailureDetectorTest.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a5334_83b58/rev_a5334-83b58.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3841c_26ae5/rev_3841c-26ae5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_10b86_aeb05/rev_10b86-aeb05.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_0b2ef_d74a4/rev_0b2ef-d74a4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_494d4_07493/rev_494d4-07493.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3363f_37986/rev_3363f-37986.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bd11b_a3d71/rev_bd11b-a3d71.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public static void main(String[] args) throws Exception {

        OptionParser parser = new OptionParser();
        parser.accepts("r", "execute read operations");
        parser.accepts("w", "execute write operations");
        parser.accepts("d", "execute delete operations");
        parser.accepts("m", "generate a mix of read and write requests");
        parser.accepts("v", "verbose");
        parser.accepts("ignore-nulls", "ignore null values");
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415542287299/fstmerge_var1_323540223550832781
        parser.accepts("save-nulls", "save keys which had null to a file")
                .withRequiredArg()
                .ofType(String.class);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415542287299/fstmerge_base_840565117574132322
=======
        parser.accepts("pipeline-routed-store", "Use the Pipeline RoutedStore");
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415542287299/fstmerge_var2_5259079147360418573
        parser.accepts("node", "go to this node id").withRequiredArg().ofType(Integer.class);
        parser.accepts("interval", "print requests on this interval, -1 to disable")
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("selectors", "Number of client selectors to use. Default = " + SELECTORS)
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("handshake", "perform a handshake");
        parser.accepts("verify", "verify values read");
        parser.accepts("request-file", "execute specific requests in order").withRequiredArg();
        parser.accepts("start-key-index", "starting point when using int keys. Default = 0")
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("value-size", "size in bytes for random value.  Default = 1024")
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("iterations", "number of times to repeat the test  Default = 1")
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("threads", "max number concurrent worker threads  Default = " + MAX_WORKERS)
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("percent-cached",
                       "percentage of requests to come from previously requested keys; valid values are in range [0..100]; 0 means caching disabled  Default = 0")
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("help");

        OptionSet options = parser.parse(args);

        List<String> nonOptions = options.nonOptionArguments();

        if(options.has("help")) {
            printUsage(System.out, parser);
        }

        if(nonOptions.size() != 3) {
            printUsage(System.err, parser);
        }

        String url = nonOptions.get(0);
        String storeName = nonOptions.get(1);
        int numRequests = Integer.parseInt(nonOptions.get(2));
        String ops = "";
        List<Integer> keys = null;

        Integer startNum = CmdUtils.valueOf(options, "start-key-index", 0);
        Integer valueSize = CmdUtils.valueOf(options, "value-size", 1024);
        Integer numIterations = CmdUtils.valueOf(options, "iterations", 1);
        Integer numThreads = CmdUtils.valueOf(options, "threads", MAX_WORKERS);
        Integer percentCached = CmdUtils.valueOf(options, "percent-cached", 0);

        if(percentCached < 0 || percentCached > 100) {
            printUsage(System.err, parser);
        }

        // TODO: are we still using this?
        // Integer nodeId = CmdUtils.valueOf(options, "node", 0);
        final Integer interval = CmdUtils.valueOf(options, "interval", 100000);
        int selectors = CmdUtils.valueOf(options, "selectors", SELECTORS);
        final boolean verifyValues = options.has("verify");
        final boolean verbose = options.has("v");

        if(options.has("request-file")) {
            keys = loadKeys((String) options.valueOf("request-file"));
        }

        final BufferedWriter nullWriter;
        if (options.has("save-nulls")) {
            nullWriter = new BufferedWriter(new FileWriter((String) options.valueOf("save-nulls")));
        } else {
            nullWriter = null;
        }

        if(options.has("r")) {
            ops += "r";
        }
        if(options.has("w")) {
            ops += "w";
        }
        if(options.has("d")) {
            ops += "d";
        }
        if(options.has("m")) {
            ops += "m";
        }
        if(ops.length() == 0) {
            ops = "rwd";
        }

        System.out.println("operations : " + ops);
        System.out.println("value size : " + valueSize);
        System.out.println("start index : " + startNum);
        System.out.println("iterations : " + numIterations);
        System.out.println("threads : " + numThreads);
        System.out.println("cache percentage : " + percentCached + "%");

        System.out.println("Bootstraping cluster data.");
        ClientConfig clientConfig = new ClientConfig().setMaxThreads(numThreads)
                                                      .setMaxTotalConnections(numThreads)
                                                      .setMaxConnectionsPerNode(numThreads)
                                                      .setBootstrapUrls(url)
                                                      .setConnectionTimeout(60, TimeUnit.SECONDS)
                                                      .setSocketTimeout(60, TimeUnit.SECONDS)
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415542287299/fstmerge_var1_323540223550832781
                                                      .setFailureDetectorRequestLengthThreshold(TimeUnit.SECONDS.toMillis(60))
                                                      .setSocketBufferSize(4 * 1024);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415542287299/fstmerge_base_840565117574132322
                                                      .setSocketBufferSize(4 * 1024);
=======
                                                      .setSocketBufferSize(4 * 1024)
                                                      .setEnablePipelineRoutedStore(options.has("pipeline-routed-store"))
                                                      .setSelectors(selectors);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415542287299/fstmerge_var2_5259079147360418573
        SocketStoreClientFactory factory = new SocketStoreClientFactory(clientConfig);
        final StoreClient<Object, Object> store = factory.getStoreClient(storeName);
        StoreDefinition storeDef = getStoreDefinition(factory, storeName);

        Class<?> keyType = findKeyType(storeDef);
        final String value = TestUtils.randomLetters(valueSize);
        ExecutorService service = Executors.newFixedThreadPool(numThreads);

        /*
         * send the store a value and then delete it - useful for the NOOP store
         * which will then use that value for other queries
         */

        if(options.has("handshake")) {
            final Object key = getKeyProvider(keyType, startNum, keys, 0).next();

            // We need to delete just in case there's an existing value there
            // that would otherwise cause the test run to bomb out.
            store.delete(key);
            store.put(key, new Versioned<String>(value));
            store.delete(key);
        }

        for(int loopCount = 0; loopCount < numIterations; loopCount++) {

            System.out.println("======================= iteration = " + loopCount
                               + " ======================================");

            if(ops.contains("d")) {
                System.out.println("Beginning delete test.");
                final AtomicInteger successes = new AtomicInteger(0);
                final KeyProvider<?> keyProvider0 = getKeyProvider(keyType,
                                                                   startNum,
                                                                   keys,
                                                                   percentCached);
                final CountDownLatch latch0 = new CountDownLatch(numRequests);
                final long[] requestTimes = new long[numRequests];
                final long start = System.nanoTime();
                for(int i = 0; i < numRequests; i++) {
                    final int j = i;
                    service.execute(new Runnable() {

                        public void run() {
                            try {
                                long startNs = System.nanoTime();
                                store.delete(keyProvider0.next());
                                requestTimes[j] = (System.nanoTime() - startNs) / Time.NS_PER_MS;
                                successes.getAndIncrement();
                            } catch(Exception e) {
                                e.printStackTrace();
                            } finally {
                                latch0.countDown();
                                if(interval != -1 && j % interval == 0) {
                                    printStatistics("deletes", successes.get(), start);
                                }
                            }
                        }
                    });
                }
                latch0.await();
                printStatistics("deletes", successes.get(), start);
                System.out.println("95th percentile delete latency: "
                                   + TestUtils.quantile(requestTimes, .95) + " ms.");
                System.out.println("99th percentile delete latency: "
                                   + TestUtils.quantile(requestTimes, .99) + " ms.");
            }

            if(ops.contains("w")) {
                final AtomicInteger numWrites = new AtomicInteger(0);
                System.out.println("Beginning write test.");
                final KeyProvider<?> keyProvider1 = getKeyProvider(keyType,
                                                                   startNum,
                                                                   keys,
                                                                   percentCached);
                final CountDownLatch latch1 = new CountDownLatch(numRequests);
                final long[] requestTimes = new long[numRequests];
                final long start = System.nanoTime();
                for(int i = 0; i < numRequests; i++) {
                    final int j = i;
                    service.execute(new Runnable() {

                        public void run() {
                            try {
                                final Object key = keyProvider1.next();
                                store.applyUpdate(new UpdateAction<Object, Object>() {

                                    @Override
                                    public void update(StoreClient<Object, Object> storeClient) {
                                        long startNs = System.nanoTime();
                                        storeClient.put(key, value);
                                        requestTimes[j] = (System.nanoTime() - startNs)
                                                          / Time.NS_PER_MS;
                                        numWrites.incrementAndGet();
                                    }
                                }, 64);
                            } catch(Exception e) {
                                if(verbose) {
                                    e.printStackTrace();
                                }
                            } finally {
                                latch1.countDown();
                                if(interval != -1 && j % interval == 0) {
                                    printStatistics("writes", numWrites.get(), start);
                                }
                            }
                        }
                    });
                }
                latch1.await();
                printStatistics("writes", numWrites.get(), start);
                System.out.println("95th percentile write latency: "
                                   + TestUtils.quantile(requestTimes, .95) + " ms.");
                System.out.println("99th percentile write latency: "
                                   + TestUtils.quantile(requestTimes, .99) + " ms.");
            }

            if(ops.contains("r")) {
                final boolean ignoreNulls = options.has("ignore-nulls");
                final AtomicInteger numReads = new AtomicInteger(0);
                final AtomicInteger numNulls = new AtomicInteger(0);
                System.out.println("Beginning read test.");
                final KeyProvider<?> keyProvider = getKeyProvider(keyType,
                                                                  startNum,
                                                                  keys,
                                                                  percentCached);
                final CountDownLatch latch = new CountDownLatch(numRequests);
                final long[] requestTimes = new long[numRequests];
                final long start = System.nanoTime();
                keyProvider.next();
                for(int i = 0; i < numRequests; i++) {
                    final int j = i;
                    service.execute(new Runnable() {

                        public void run() {
                            try {
                                Object key = keyProvider.next();
                                long startNs = System.nanoTime();
                                Versioned<Object> v = store.get(key);
                                requestTimes[j] = (System.nanoTime() - startNs) / Time.NS_PER_MS;
                                numReads.incrementAndGet();
                                if(v == null) {
                                    numNulls.incrementAndGet();
                                    if(!ignoreNulls) {
                                        throw new Exception("value returned is null for key " + key);
                                    }
                                    if (nullWriter != null) {
                                        nullWriter.write(key.toString() + "\n");
                                    }
                                }
                                if(verifyValues && !value.equals(v.getValue())) {
                                    throw new Exception("value returned isn't same as set value for key "
                                                        + key);
                                }
                            } catch(Exception e) {
                                if(verbose) {
                                    e.printStackTrace();
                                }
                            } finally {
                                latch.countDown();
                                if(interval != -1 && j % interval == 0) {
                                    printStatistics("reads", numReads.get(), start);
                                    printNulls(numNulls.get(), start);
                                }
                            }
                        }
                    });
                }
                latch.await();
                printStatistics("reads", numReads.get(), start);
                System.out.println("95th percentile read latency: "
                                   + TestUtils.quantile(requestTimes, .95) + " ms.");
                System.out.println("99th percentile read latency: "
                                   + TestUtils.quantile(requestTimes, .99) + " ms.");
            }
        }

        if(ops.contains("m")) {
            final AtomicInteger numNulls = new AtomicInteger(0);
            final AtomicInteger numReads = new AtomicInteger(0);
            final AtomicInteger numWrites = new AtomicInteger(0);
            System.out.println("Beginning mixed test.");
            final KeyProvider<?> keyProvider = getKeyProvider(keyType,
                                                              startNum,
                                                              keys,
                                                              percentCached);
            final CountDownLatch latch = new CountDownLatch(numRequests);
            final long start = System.nanoTime();
            keyProvider.next();
            for(int i = 0; i < numRequests; i++) {
                final int j = i;
                service.execute(new Runnable() {

                    public void run() {
                        try {
                            final Object key = keyProvider.next();

                            store.applyUpdate(new UpdateAction<Object, Object>() {

                                @Override
                                public void update(StoreClient<Object, Object> storeClient) {
                                    Versioned<Object> v = store.get(key);
                                    numReads.incrementAndGet();
                                    if(v != null) {
                                        storeClient.put(key, v);
                                    } else {
                                        numNulls.incrementAndGet();
                                        if (nullWriter != null) {
                                            try {
                                                nullWriter.write(key.toString() + "\n");
                                            } catch (IOException e) {
                                                e.printStackTrace();
                                            }
                                        }
                                    }
                                    numWrites.incrementAndGet();
                                }
                            }, 64);
                        } catch(Exception e) {
                            if(verbose) {
                                e.printStackTrace();
                            }
                        } finally {
                            if(interval != -1 && j % interval == 0) {
                                printStatistics("reads", numReads.get(), start);
                                printStatistics("writes", numWrites.get(), start);
                                printNulls(numNulls.get(), start);
                                printStatistics("transactions", j, start);
                            }
                            latch.countDown();

                        }
                    }
                });
            }
            latch.await();
            printStatistics("reads", numReads.get(), start);
            printStatistics("writes", numWrites.get(), start);
        }

        if (nullWriter != null) {
            nullWriter.close();
        }
        
        System.exit(0);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bd11b_a3d71/rev_bd11b-a3d71/test/integration/voldemort/performance/RemoteTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415542291634/fstmerge_var1_4950783796043632328
@Experimental
    public static void executeFetchEntries(Integer nodeId,
                                           AdminClient adminClient,
                                           List<Integer> partitionIdList,
                                           String outputDir,
                                           List<String> storeNames,
                                           boolean useAscii) throws IOException {
        List<StoreDefinition> storeDefinitionList = adminClient.getRemoteStoreDefList(nodeId).getValue();
        Map<String, StoreDefinition> storeDefinitionMap = Maps.newHashMap();
        for (StoreDefinition storeDefinition: storeDefinitionList) {
            storeDefinitionMap.put(storeDefinition.getName(), storeDefinition);
        }

        File directory = new File(outputDir);
        if (directory.exists() || directory.mkdir()) {
            List<String> stores = storeNames;
            if (stores == null) {
                stores = Lists.newArrayList();
                stores.addAll(storeDefinitionMap.keySet());
            }
            for (String store: stores) {
                System.out.println("Fetching entries in partitions " + Joiner.on(", ").join(partitionIdList) + " of " + store);
                Iterator<Pair<ByteArray, Versioned<byte[]>>> entriesIterator = adminClient.fetchEntries(nodeId,
                                                                                                           store,
                                                                                                           partitionIdList,
                                                                                                           null,
												           false);
                File outputFile = new File(directory, store + ".entries");
                if (useAscii) {
                    StoreDefinition storeDefinition = storeDefinitionMap.get(store);
                    writeEntriesAscii(entriesIterator, outputFile, storeDefinition);
                } else {
                    writeEntriesBinary(entriesIterator, outputFile);
                }

            }
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415542291634/fstmerge_base_6852156102612315232
@Experimental
    public static void executeFetchEntries(Integer nodeId,
                                           AdminClient adminClient,
                                           List<Integer> partitionIdList,
                                           String outputDir,
                                           List<String> storeNames,
                                           boolean useAscii) throws IOException {
        List<StoreDefinition> storeDefinitionList = adminClient.getRemoteStoreDefList(nodeId).getValue();
        Map<String, StoreDefinition> storeDefinitionMap = Maps.newHashMap();
        for (StoreDefinition storeDefinition: storeDefinitionList) {
            storeDefinitionMap.put(storeDefinition.getName(), storeDefinition);
        }

        File directory = new File(outputDir);
        if (directory.exists() || directory.mkdir()) {
            List<String> stores = storeNames;
            if (stores == null) {
                stores = Lists.newArrayList();
                stores.addAll(storeDefinitionMap.keySet());
            }
            for (String store: stores) {
                System.out.println("Fetching entries in partitions " + Joiner.on(", ").join(partitionIdList) + " of " + store);
                Iterator<Pair<ByteArray, Versioned<byte[]>>> entriesIterator = adminClient.fetchEntries(nodeId,
                                                                                                           store,
                                                                                                           partitionIdList,
                                                                                                           null);
                File outputFile = new File(directory, store + ".entries");
                if (useAscii) {
                    StoreDefinition storeDefinition = storeDefinitionMap.get(store);
                    writeEntriesAscii(entriesIterator, outputFile, storeDefinition);
                } else {
                    writeEntriesBinary(entriesIterator, outputFile);
                }

            }
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415542291634/fstmerge_var2_5343800348975343595

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bd11b_a3d71/rev_bd11b-a3d71/src/java/voldemort/VoldemortAdminTool.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bd11b_f37b6/rev_bd11b-f37b6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_76198_148a4/rev_76198-148a4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_4baec_c75ba/rev_4baec-c75ba.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3e197_26a2b/rev_3e197-26a2b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2f5de_e5a49/rev_2f5de-e5a49.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544078109/fstmerge_var1_1191108300127289562
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544078109/fstmerge_base_7405658618488501210
@Override
    public StoreClient<String, String> getStore(Props propsA, Props propsB) throws Exception {
        Cluster cluster = new ClusterMapper().readCluster(new FileReader(propsA.getString("metadata.directory")
                                                                         + File.separator
                                                                         + "/cluster.xml"));
        Map<Integer, Store<ByteArray, byte[]>> clientMapping = Maps.newHashMap();
        VoldemortConfig voldemortConfig = new VoldemortConfig(propsA);
        StorageConfiguration conf = new BdbStorageConfiguration(voldemortConfig);
        for(Node node: cluster.getNodes())
            clientMapping.put(node.getId(), conf.getStore("test" + node.getId()));

        InconsistencyResolver<Versioned<String>> resolver = new VectorClockInconsistencyResolver<String>();

        FailureDetectorConfig failureDetectorConfig = new FailureDetectorConfig(voldemortConfig).setNodes(cluster.getNodes())
                                                                                                .setStoreVerifier(new BasicStoreVerifier<ByteArray, byte[]>(clientMapping,
                                                                                                                                                            new ByteArray("key".getBytes())));
        FailureDetector failureDetector = create(failureDetectorConfig, false);

        Store<ByteArray, byte[]> store = new RoutedStore("test",
                                                         clientMapping,
                                                         cluster,
                                                         ServerTestUtils.getStoreDef("test",
                                                                                     1,
                                                                                     1,
                                                                                     1,
                                                                                     1,
                                                                                     1,
                                                                                     RoutingStrategyType.CONSISTENT_STRATEGY),
                                                         10,
                                                         true,
                                                         10000L,
                                                         failureDetector);
        /*
         * public DefaultStoreClient(String storeName,
         * InconsistencyResolver<Versioned<V>> resolver, StoreClientFactory
         * storeFactory, int maxMetadataRefreshAttempts) {
         */
        Store<String, String> serializingStore = SerializingStore.wrap(store,
                                                                       new StringSerializer(),
                                                                       new StringSerializer());
        Store<String, String> resolvingStore = new InconsistencyResolvingStore<String, String>(serializingStore,
                                                                                               resolver);
        StoreClientFactory factory = new StaticStoreClientFactory(resolvingStore);
        return new DefaultStoreClient<String, String>(store.getName(), resolver, factory, 1);
    }
=======
@Override
    public StoreClient<String, String> getStore(Props propsA, Props propsB) throws Exception {
        Cluster cluster = new ClusterMapper().readCluster(new FileReader(propsA.getString("metadata.directory")
                                                                         + File.separator
                                                                         + "/cluster.xml"));
        Map<Integer, Store<ByteArray, byte[]>> clientMapping = Maps.newHashMap();
        ExecutorService threadPool = Executors.newFixedThreadPool(10);
        VoldemortConfig voldemortConfig = new VoldemortConfig(propsA);
        StorageConfiguration conf = new BdbStorageConfiguration(voldemortConfig);
        for(Node node: cluster.getNodes()) {
            StorageEngine<ByteArray, byte[]> store = conf.getStore("test" + node.getId());
            clientMapping.put(node.getId(), store);
        }

        InconsistencyResolver<Versioned<String>> resolver = new VectorClockInconsistencyResolver<String>();

        FailureDetectorConfig failureDetectorConfig = new FailureDetectorConfig(voldemortConfig).setNodes(cluster.getNodes())
                                                                                                .setStoreVerifier(new BasicStoreVerifier<ByteArray, byte[]>(clientMapping,
                                                                                                                                                            new ByteArray("key".getBytes())));
        FailureDetector failureDetector = create(failureDetectorConfig, false);

        StoreDefinition storeDef = ServerTestUtils.getStoreDef("test",
                                                               1,
                                                               1,
                                                               1,
                                                               1,
                                                               1,
                                                               RoutingStrategyType.CONSISTENT_STRATEGY);
        RoutedStoreFactory routedStoreFactory = new RoutedStoreFactory(voldemortConfig.isPipelineRoutedStoreEnabled(),
                                                                       threadPool,
                                                                       voldemortConfig.getClientRoutingTimeoutMs());

        RoutedStore store = routedStoreFactory.create(cluster,
                                                      storeDef,
                                                      clientMapping,
                                                      true,
                                                      failureDetector);
        /*
         * public DefaultStoreClient(String storeName,
         * InconsistencyResolver<Versioned<V>> resolver, StoreClientFactory
         * storeFactory, int maxMetadataRefreshAttempts) {
         */
        Store<String, String> serializingStore = SerializingStore.wrap(store,
                                                                       new StringSerializer(),
                                                                       new StringSerializer());
        Store<String, String> resolvingStore = new InconsistencyResolvingStore<String, String>(serializingStore,
                                                                                               resolver);
        StoreClientFactory factory = new StaticStoreClientFactory(resolvingStore);
        return new DefaultStoreClient<String, String>(store.getName(), resolver, factory, 1);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544078109/fstmerge_var2_8951910160986456369

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2f5de_e5a49/rev_2f5de-e5a49/test/integration/voldemort/performance/LocalRoutedStoreLoadTest.java
Conflict type: LineBasedMCFd
Conflict body: 
public static void main (String [] args) throws Exception {
        OptionParser parser = new OptionParser();
        parser.accepts("help", "print help information");
        parser.accepts("url", "[REQUIRED] bootstrap URL")
              .withRequiredArg()
              .describedAs("bootstrap-url")
              .ofType(String.class);
        parser.accepts("node", "[REQUIRED] node id")
              .withRequiredArg()
              .describedAs("node-id")
              .ofType(Integer.class);
        parser.accepts("delete-partitions", "Delete partitions")
              .withRequiredArg()
              .describedAs("partition-ids")
              .withValuesSeparatedBy(',')
              .ofType(Integer.class);
        parser.accepts("restore", "Restore from replication");
        parser.accepts("ascii", "Fetch keys as ASCII");
        parser.accepts("parallelism", "Parallelism")
              .withRequiredArg()
              .describedAs("parallelism")
              .ofType(Integer.class);
        parser.accepts("fetch-keys", "Fetch keys")
              .withRequiredArg()
              .describedAs("partition-ids")
              .withValuesSeparatedBy(',')
              .ofType(Integer.class);
        parser.accepts("fetch-values", "Fetch values")
              .withRequiredArg()
              .describedAs("partition-ids")
              .withValuesSeparatedBy(',')
              .ofType(Integer.class);
        parser.accepts("outdir", "Output directory")
              .withRequiredArg()
              .describedAs("output-directory")
              .ofType(String.class);
        parser.accepts("stores", "Store names")
              .withRequiredArg()
              .describedAs("store-names")
              .withValuesSeparatedBy(',')
              .ofType(String.class);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544083216/fstmerge_var1_7073192808760527687
        parser.accepts("add-stores", "Add stores in this stores.xml")
              .withRequiredArg()
              .describedAs("stores.xml")
              .ofType(String.class);
        parser.accepts("delete-store", "Delete store")
              .withRequiredArg()
              .describedAs("store-name")
              .ofType(String.class);
        parser.accepts("update-entries", "[EXPERIMENTAL] Insert or update entries")
              .withRequiredArg()
              .describedAs("input-directory")
              .ofType(String.class);
        
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544083216/fstmerge_base_8717783995821381305
        parser.accepts("add-stores", "Add stores in this stores.xml")
              .withRequiredArg()
              .describedAs("stores.xml")
              .ofType(String.class);
        parser.accepts("update-entries", "[EXPERIMENTAL] Insert or update entries")
              .withRequiredArg()
              .describedAs("input-directory")
              .ofType(String.class);
        
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544083216/fstmerge_var2_4155436330242786739
        OptionSet options = parser.parse(args);

        if (options.has("help")) {
            parser.printHelpOn(System.out);
            System.exit(0);
        }

        Set<String> missing = CmdUtils.missing(options,
						"url",
                                               "node");
        if (missing.size() > 0) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544083216/fstmerge_var1_7073192808760527687
            // Not the most elegant way to do this
            if (!(missing.equals(ImmutableSet.of("node")) && (options.has("add-stores") || options.has("delete-store")))) {
                System.err.println("Missing required arguments: " + Joiner.on(", ").join(missing));
                parser.printHelpOn(System.err);
                System.exit(1);
            }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544083216/fstmerge_base_8717783995821381305
            // Not the most elegant way to do this
            if (!(missing.equals(ImmutableSet.of("node")) && options.has("add-stores"))) {
                System.err.println("Missing required arguments: " + Joiner.on(", ").join(missing));
                parser.printHelpOn(System.err);
                System.exit(1);
            }
=======
            System.err.println("Missing required arguments: " + Joiner.on(", ").join(missing));
            parser.printHelpOn(System.err);
            System.exit(1);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544083216/fstmerge_var2_4155436330242786739
        }

        String url = (String) options.valueOf("url");
        Integer nodeId = (Integer) options.valueOf("node");
        Integer parallelism = CmdUtils.valueOf(options, "parallelism", 5);

        AdminClient adminClient = new AdminClient(url, new AdminClientConfig());

        String ops = "";
        if (options.has("delete-partitions")) {
            ops += "d";
        }
        if (options.has("fetch-keys")) {
            ops += "k";
        }
        if (options.has("fetch-values")) {
            ops += "v";
        }
        if (options.has("restore")) {
            ops += "r";
        }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544083216/fstmerge_var1_7073192808760527687
        if (options.has("add-stores")) {
            ops += "a";
        }
        if (options.has("update-entries")) {
            ops += "u";
        }
        if (options.has("delete-store")) {
            ops += "s";
        }
        if(ops.length() < 1) {
            Utils.croak("At least one of (delete-partitions, restore, add-node, fetch-entries, fetch-keys, add-stores, delete-store, update-entries) must be specified");
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544083216/fstmerge_base_8717783995821381305
        if (options.has("add-stores")) {
            ops += "a";
        }
        if (options.has("update-entries")) {
            ops += "u";
        }
        if (ops.length() < 1) {
            Utils.croak("At least one of (delete-partitions, restore, add-node, fetch-entries, fetch-keys) must be specified");
=======
        if (ops.length() < 1) {
            Utils.croak("At least one of (delete-partitions, restore, add-node) must be specified");
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544083216/fstmerge_var2_4155436330242786739
        }

        List<String> storeNames = null;

        if (options.has("stores")) {
            // For some reason one can't just do @SuppressWarnings without identifier following it
            @SuppressWarnings("unchecked")
            List<String> temp = (List<String>) options.valuesOf("stores");
            storeNames = temp;
        }

        try {
            if (ops.contains("d")) {
                System.out.println("Starting delete-partitions");
                @SuppressWarnings("unchecked")
                List<Integer> partitionIdList = (List<Integer>) options.valuesOf("delete-partitions");
                executeDeletePartitions(nodeId, adminClient, partitionIdList, storeNames);
                System.out.println("Finished delete-partitions");
            }
            if (ops.contains("r")) {
                System.out.println("Starting restore");
                adminClient.restoreDataFromReplications(nodeId, parallelism);
                System.err.println("Finished restore");
            }
            if (ops.contains("k")) {
                if (!options.has("outdir")) {
                    Utils.croak("Directory name (outdir) must be specified for fetch-keys");
                }
                String outputDir = (String) options.valueOf("outdir");
                boolean useAscii = options.has("ascii");
                System.out.println("Starting fetch keys");
                @SuppressWarnings("unchecked")
                List<Integer> partitionIdList = (List<Integer>) options.valuesOf("fetch-keys");
                executeFetchKeys(nodeId,
                                 adminClient,
                                 partitionIdList,
                                 outputDir,
                                 storeNames,
                                 useAscii);
            }
            if (ops.contains("v")) {
                if (!options.has("outdir")) {
                    Utils.croak("Directory name (outdir) must be specified for fetch-values");
                }
                String outputDir = (String) options.valueOf("outdir");
                boolean useAscii = options.has("ascii");
                @SuppressWarnings("unchecked")
                List<Integer> partitionIdList = (List<Integer>) options.valuesOf("fetch-values");
                executeFetchValues(nodeId,
                                   adminClient,
                                   partitionIdList,
                                   outputDir,
                                   storeNames,
                                   useAscii);
            }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544083216/fstmerge_var1_7073192808760527687
            if (ops.contains("a")) {
                String storesXml = (String) options.valueOf("add-stores");
                executeAddStores(adminClient, storesXml, storeNames);
            }
            if (ops.contains("u")) {
                String inputDir = (String) options.valueOf("update-entries");
                boolean useAscii = options.has("ascii");
                executeUpdateEntries(nodeId, adminClient, storeNames, inputDir, useAscii);

            }
            if(ops.contains("s")) {
                String storeName = (String) options.valueOf("delete-store");
                executeDeleteStore(adminClient, storeName);
            }
        } catch(Exception e) {
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544083216/fstmerge_base_8717783995821381305
            if (ops.contains("a")) {
                String storesXml = (String) options.valueOf("add-stores");
                executeAddStores(adminClient,
                                 storesXml,
                                 storeNames);
            }
            if (ops.contains("u")) {
                String inputDir = (String) options.valueOf("update-entries");
                boolean useAscii = options.has("ascii");
                executeUpdateEntries(nodeId,
                                     adminClient,
                                     storeNames,
                                     inputDir,
                                     useAscii);
                
            }
        } catch (Exception e) {
=======
        } catch (Exception e) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544083216/fstmerge_var2_4155436330242786739
            e.printStackTrace();
            Utils.croak(e.getMessage());
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2f5de_e5a49/rev_2f5de-e5a49/src/java/voldemort/VoldemortAdminTool.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544083255/fstmerge_var1_4984768917563778929
@Experimental
    public static void executeFetchEntries(Integer nodeId,
                                           AdminClient adminClient,
                                           List<Integer> partitionIdList,
                                           String outputDir,
                                           List<String> storeNames,
                                           boolean useAscii) throws IOException {
        List<StoreDefinition> storeDefinitionList = adminClient.getRemoteStoreDefList(nodeId).getValue();
        Map<String, StoreDefinition> storeDefinitionMap = Maps.newHashMap();
        for (StoreDefinition storeDefinition: storeDefinitionList) {
            storeDefinitionMap.put(storeDefinition.getName(), storeDefinition);
        }

        File directory = new File(outputDir);
        if (directory.exists() || directory.mkdir()) {
            List<String> stores = storeNames;
            if (stores == null) {
                stores = Lists.newArrayList();
                stores.addAll(storeDefinitionMap.keySet());
            }
            for (String store: stores) {
                System.out.println("Fetching entries in partitions " + Joiner.on(", ").join(partitionIdList) + " of " + store);
                Iterator<Pair<ByteArray, Versioned<byte[]>>> entriesIterator = adminClient.fetchEntries(nodeId,
                                                                                                           store,
                                                                                                           partitionIdList,
                                                                                                           null,
                                                                                                           false);
                File outputFile = new File(directory, store + ".entries");
                if (useAscii) {
                    StoreDefinition storeDefinition = storeDefinitionMap.get(store);
                    writeEntriesAscii(entriesIterator, outputFile, storeDefinition);
                } else {
                    writeEntriesBinary(entriesIterator, outputFile);
                }

            }
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544083255/fstmerge_base_5261098409368942682
@Experimental
    public static void executeFetchEntries(Integer nodeId,
                                           AdminClient adminClient,
                                           List<Integer> partitionIdList,
                                           String outputDir,
                                           List<String> storeNames,
                                           boolean useAscii) throws IOException {
        List<StoreDefinition> storeDefinitionList = adminClient.getRemoteStoreDefList(nodeId).getValue();
        Map<String, StoreDefinition> storeDefinitionMap = Maps.newHashMap();
        for (StoreDefinition storeDefinition: storeDefinitionList) {
            storeDefinitionMap.put(storeDefinition.getName(), storeDefinition);
        }

        File directory = new File(outputDir);
        if (directory.exists() || directory.mkdir()) {
            List<String> stores = storeNames;
            if (stores == null) {
                stores = Lists.newArrayList();
                stores.addAll(storeDefinitionMap.keySet());
            }
            for (String store: stores) {
                System.out.println("Fetching entries in partitions " + Joiner.on(", ").join(partitionIdList) + " of " + store);
                Iterator<Pair<ByteArray, Versioned<byte[]>>> entriesIterator = adminClient.fetchEntries(nodeId,
                                                                                                           store,
                                                                                                           partitionIdList,
                                                                                                           null,
												           false);
                File outputFile = new File(directory, store + ".entries");
                if (useAscii) {
                    StoreDefinition storeDefinition = storeDefinitionMap.get(store);
                    writeEntriesAscii(entriesIterator, outputFile, storeDefinition);
                } else {
                    writeEntriesBinary(entriesIterator, outputFile);
                }

            }
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544083255/fstmerge_var2_1166029728651600103

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2f5de_e5a49/rev_2f5de-e5a49/src/java/voldemort/VoldemortAdminTool.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544083264/fstmerge_var1_3496432161730052982
private static Iterator<Pair<ByteArray,Versioned<byte[]>>> readEntriesAscii(File inputDir,
                                                                                String storeName,
                                                                                StoreDefinition storeDefinition)
                   throws IOException {
        File inputFile = new File(inputDir, storeName + ".entries");
        if(!inputFile.exists()) {
            throw new FileNotFoundException("File " + inputFile.getAbsolutePath() + " does not exist!");
        }

        return new AbstractIterator<Pair<ByteArray, Versioned<byte[]>>> () {

            @Override
            protected Pair<ByteArray, Versioned<byte[]>> computeNext() {
                System.err.println("Updating stores from ASCII/JSON data is not yet supported!");
                return endOfData();
            }
        };
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544083264/fstmerge_base_606214178614277688
private static Iterator<Pair<ByteArray,Versioned<byte[]>>> readEntriesAscii(File inputDir,
                                                                                String storeName,
                                                                                StoreDefinition storeDefinition)
                   throws IOException {
        File inputFile = new File(inputDir, storeName + ".entries");
        if (!inputFile.exists()) {
            throw new FileNotFoundException("File " + inputFile.getAbsolutePath() + " does not exist!");
        }

        return new AbstractIterator<Pair<ByteArray, Versioned<byte[]>>> () {
            @Override
            protected Pair<ByteArray, Versioned<byte[]>> computeNext() {
                System.err.println("Updating stores from ASCII/JSON data is not yet supported!");
                return endOfData();
            }
        };
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544083264/fstmerge_var2_4667041340802137298

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2f5de_e5a49/rev_2f5de-e5a49/src/java/voldemort/VoldemortAdminTool.java
Conflict type: LineBasedMCFd
Conflict body: 
public void registerNodeStores(StoreDefinition def, Cluster cluster, int localNode) {
        Map<Integer, Store<ByteArray, byte[]>> nodeStores = new HashMap<Integer, Store<ByteArray, byte[]>>(cluster.getNumberOfNodes());
        Map<Integer, NonblockingStore> nonblockingStores = new HashMap<Integer, NonblockingStore>(cluster.getNumberOfNodes());

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544096495/fstmerge_var1_4192077010043545628
        try {
            for(Node node: cluster.getNodes()) {
                Store<ByteArray, byte[]> store = getNodeStore(def.getName(), node, localNode);
                this.storeRepository.addNodeStore(node.getId(), store);
                nodeStores.put(node.getId(), store);
            }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544096495/fstmerge_base_687557574079656326
        for(Node node: cluster.getNodes()) {
            Store<ByteArray, byte[]> store = getNodeStore(def.getName(), node, localNode);
            this.storeRepository.addNodeStore(node.getId(), store);
            nodeStores.put(node.getId(), store);
        }
=======
        for(Node node: cluster.getNodes()) {
            Store<ByteArray, byte[]> store = getNodeStore(def.getName(), node, localNode);
            this.storeRepository.addNodeStore(node.getId(), store);
            nodeStores.put(node.getId(), store);

            NonblockingStore nonblockingStore = routedStoreFactory.toNonblockingStore(store);
            nonblockingStores.put(node.getId(), nonblockingStore);
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544096495/fstmerge_var2_2030602091059536340

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544096495/fstmerge_var1_4192077010043545628
            Store<ByteArray, byte[]> routedStore = new RoutedStore(def.getName(),
                                                                   nodeStores,
                                                                   metadata.getCluster(),
                                                                   def,
                                                                   true,
                                                                   this.clientThreadPool,
                                                                   voldemortConfig.getRoutingTimeoutMs(),
                                                                   failureDetector,
                                                                   SystemTime.INSTANCE);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544096495/fstmerge_base_687557574079656326
        Store<ByteArray, byte[]> routedStore = new RoutedStore(def.getName(),
                                                               nodeStores,
                                                               metadata.getCluster(),
                                                               def,
                                                               true,
                                                               this.clientThreadPool,
                                                               voldemortConfig.getRoutingTimeoutMs(),
                                                               failureDetector,
                                                               SystemTime.INSTANCE);
=======
        Store<ByteArray, byte[]> store = routedStoreFactory.create(cluster,
                                                                   def,
                                                                   nodeStores,
                                                                   nonblockingStores,
                                                                   true,
                                                                   failureDetector);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544096495/fstmerge_var2_2030602091059536340

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544096495/fstmerge_var1_4192077010043545628
            routedStore = new RebootstrappingStore(metadata,
                                                   storeRepository,
                                                   voldemortConfig,
                                                   socketPool,
                                                   (RoutedStore) routedStore);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544096495/fstmerge_base_687557574079656326
        routedStore = new RebootstrappingStore(metadata,
                                               storeRepository,
                                               voldemortConfig,
                                               socketPool,
                                               (RoutedStore) routedStore);
=======
        store = new RebootstrappingStore(metadata,
                                         storeRepository,
                                         voldemortConfig,
                                         (RoutedStore) store,
                                         storeFactory);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544096495/fstmerge_var2_2030602091059536340

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544096495/fstmerge_var1_4192077010043545628
            routedStore = new InconsistencyResolvingStore<ByteArray, byte[]>(routedStore,
                                                                             new VectorClockInconsistencyResolver<byte[]>());
            this.storeRepository.addRoutedStore(routedStore);
        } catch (Exception e) {
            // Roll back
            for(Node node: cluster.getNodes())
                this.storeRepository.removeNodeStore(def.getName(), node.getId());
            throw new VoldemortException(e);
        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544096495/fstmerge_base_687557574079656326
        routedStore = new InconsistencyResolvingStore<ByteArray, byte[]>(routedStore,
                                                                         new VectorClockInconsistencyResolver<byte[]>());
        this.storeRepository.addRoutedStore(routedStore);
=======
        store = new InconsistencyResolvingStore<ByteArray, byte[]>(store,
                                                                   new VectorClockInconsistencyResolver<byte[]>());
        this.storeRepository.addRoutedStore(store);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415544096495/fstmerge_var2_2030602091059536340
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2f5de_e5a49/rev_2f5de-e5a49/src/java/voldemort/server/storage/StorageService.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_8ada0_e03d7/rev_8ada0-e03d7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_8ada0_b59a6/rev_8ada0-b59a6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f9687_83bfb/rev_f9687-83bfb.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public FailureDetector getFailureDetector() {
        // first check: avoids locking as the field is volatile
        FailureDetector result = failureDetector;
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415545237401/fstmerge_var1_7318732696472304613
        if (result == null) {
            String clusterXml = bootstrapMetadataWithRetries(MetadataStore.CLUSTER_KEY, bootstrapUrls);
            Cluster cluster = clusterMapper.readCluster(new StringReader(clusterXml), false);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415545237401/fstmerge_base_894227189192023457
        if (result == null) {
            String clusterXml = bootstrapMetadataWithRetries(MetadataStore.CLUSTER_KEY, bootstrapUrls);
            Cluster cluster = clusterMapper.readCluster(new StringReader(clusterXml));
=======
        if(result == null) {
            String clusterXml = bootstrapMetadataWithRetries(MetadataStore.CLUSTER_KEY,
                                                             bootstrapUrls);
            Cluster cluster = clusterMapper.readCluster(new StringReader(clusterXml));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415545237401/fstmerge_var2_1576801473960956158
            synchronized(this) {
                // second check: avoids double initialization
                result = failureDetector;
                if(result == null)
                    failureDetector = result = initFailureDetector(config, cluster.getNodes());
            }
        }

        return result;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f9687_83bfb/rev_f9687-83bfb/src/java/voldemort/client/AbstractStoreClientFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415545257395/fstmerge_var1_5276614288594812147
public Cluster readCluster(Reader input) {
        return readCluster(input, true);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415545257395/fstmerge_base_4252113560513870328
@SuppressWarnings("unchecked")
    public Cluster readCluster(Reader input) {
        try {
            SAXBuilder builder = new SAXBuilder(false);
            Document doc = builder.build(input);
            Validator validator = this.schema.newValidator();
            validator.validate(new JDOMSource(doc));
            Element root = doc.getRootElement();
            if(!root.getName().equals(CLUSTER_ELMT))
                throw new MappingException("Invalid root element: "
                                           + doc.getRootElement().getName());
            String name = root.getChildText(CLUSTER_NAME_ELMT);
            List<Node> nodes = new ArrayList<Node>();
            for(Element node: (List<Element>) root.getChildren(SERVER_ELMT))
                nodes.add(readServer(node));
            return new Cluster(name, nodes);
        } catch(JDOMException e) {
            throw new MappingException(e);
        } catch(SAXException e) {
            throw new MappingException(e);
        } catch(IOException e) {
            throw new MappingException(e);
        }
=======
@SuppressWarnings("unchecked")
    public Cluster readCluster(Reader input) {
        try {
            SAXBuilder builder = new SAXBuilder(false);
            Document doc = builder.build(input);
            Validator validator = this.schema.newValidator();
            validator.validate(new JDOMSource(doc));
            Element root = doc.getRootElement();
            if(!root.getName().equals(CLUSTER_ELMT))
                throw new MappingException("Invalid root element: "
                                           + doc.getRootElement().getName());
            String name = root.getChildText(CLUSTER_NAME_ELMT);

            List<Zone> zones = new ArrayList<Zone>();
            for(Element node: (List<Element>) root.getChildren(ZONE_ELMT))
                zones.add(readZone(node));

            List<Node> servers = new ArrayList<Node>();
            for(Element node: (List<Element>) root.getChildren(SERVER_ELMT))
                servers.add(readServer(node));
            return new Cluster(name, servers, zones);
        } catch(JDOMException e) {
            throw new MappingException(e);
        } catch(SAXException e) {
            throw new MappingException(e);
        } catch(IOException e) {
            throw new MappingException(e);
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415545257395/fstmerge_var2_966713745532119766
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f9687_83bfb/rev_f9687-83bfb/src/java/voldemort/xml/ClusterMapper.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_95098_e88d3/rev_95098-e88d3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3ba4e_994c5/rev_3ba4e-994c5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_68387_0209a/rev_68387-0209a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_60d50_b6396/rev_60d50-b6396.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_042da_6f1cf/rev_042da-6f1cf.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_8c724_13fbb/rev_8c724-13fbb.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e12fd_01329/rev_e12fd-01329.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_1f21e_61f4d/rev_1f21e-61f4d.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public List<Versioned<byte[]>> get(ByteArray key) throws VoldemortException {
        StoreUtils.assertValidKey(key);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415548633087/fstmerge_var1_2929175854692212535
        byte[] keyMd5 = ByteUtils.md5(key.get());
        try {
            fileModificationLock.readLock().lock();
            int chunk = fileSet.getChunkForKey(keyMd5);
            int location = searchStrategy.indexOf(fileSet.indexFileFor(chunk),
                                                  keyMd5,
                                                  fileSet.getIndexFileSize(chunk));
            if(location >= 0) {
                byte[] value = readValue(chunk, location);
                return Collections.singletonList(Versioned.value(value));
            } else {
                return Collections.emptyList();
            }
        } finally {
            fileModificationLock.readLock().unlock();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415548633087/fstmerge_base_6580039549046820515
        byte[] keyMd5 = ByteUtils.md5(key.get());
        int chunk = fileSet.getChunkForKey(keyMd5);
        int location = searchStrategy.indexOf(fileSet.indexFileFor(chunk),
                                              keyMd5,
                                              fileSet.getIndexFileSize(chunk));
        if(location >= 0) {
            byte[] value = readValue(chunk, location);
            return Collections.singletonList(Versioned.value(value));
        } else {
            return Collections.emptyList();
=======
        int chunk = fileSet.getChunkForKey(key.get());
        int location = searchStrategy.indexOf(fileSet.indexFileFor(chunk),
                                              ByteUtils.md5(key.get()),
                                              fileSet.getIndexFileSize(chunk));
        if(location >= 0) {
            byte[] value = readValue(chunk, location);
            return Collections.singletonList(Versioned.value(value));
        } else {
            return Collections.emptyList();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415548633087/fstmerge_var2_2223893513360650419
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_1f21e_61f4d/rev_1f21e-61f4d/src/java/voldemort/store/readonly/ReadOnlyStorageEngine.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a24eb_47170/rev_a24eb-47170.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public static void main(String[] args) throws FileNotFoundException, IOException {
        OptionParser parser = new OptionParser();
        parser.accepts("help", "print usage information");
        parser.accepts("threads", "number of threads").withRequiredArg().ofType(Integer.class);
        parser.accepts("requests", "[REQUIRED] number of requests")
              .withRequiredArg()
              .ofType(Integer.class);
        parser.accepts("store-dir", "[REQUIRED] store directory")
              .withRequiredArg()
              .describedAs("directory");
        parser.accepts("cluster-xml", "Path to cluster.xml").withRequiredArg().describedAs("path");
        parser.accepts("node-id", "Id of node")
              .withRequiredArg()
              .ofType(Integer.class)
              .describedAs("node-id");
        parser.accepts("search-strategy", "class of the search strategy to use")
              .withRequiredArg()
              .describedAs("class_name");
        parser.accepts("build", "If present, first build the data");
        parser.accepts("num-values", "The number of values in the store")
              .withRequiredArg()
              .describedAs("count")
              .ofType(Integer.class);
        parser.accepts("num-chunks", "The number of chunks per partition")
              .withRequiredArg()
              .describedAs("chunks")
              .ofType(Integer.class);
        parser.accepts("internal-sort-size", "The number of items to sort in memory at a time")
              .withRequiredArg()
              .describedAs("size")
              .ofType(Integer.class);
        parser.accepts("value-size", "The size of the values in the store")
              .withRequiredArg()
              .describedAs("size")
              .ofType(Integer.class);
        parser.accepts("working-dir", "The directory in which to store temporary data")
              .withRequiredArg()
              .describedAs("dir");
        parser.accepts("gzip", "Compress the intermediate temp files used in building the store");
        parser.accepts("request-file", "file get request ids from").withRequiredArg();
        OptionSet options = parser.parse(args);

        if(options.has("help")) {
            parser.printHelpOn(System.out);
            System.exit(0);
        }

        CmdUtils.croakIfMissing(parser, options, "requests", "store-dir");

        final int numThreads = CmdUtils.valueOf(options, "threads", 10);
        final int numRequests = (Integer) options.valueOf("requests");
        final int internalSortSize = CmdUtils.valueOf(options, "internal-sort-size", 500000);
        int numValues = numRequests;
        final String inputFile = (String) options.valueOf("request-file");
        final String searcherClass = CmdUtils.valueOf(options,
                                                      "search-strategy",
                                                      BinarySearchStrategy.class.getName()).trim();
        final boolean gzipIntermediate = options.has("gzip");
        final SearchStrategy searcher = (SearchStrategy) ReflectUtils.callConstructor(ReflectUtils.loadClass(searcherClass));
        final File workingDir = new File(CmdUtils.valueOf(options,
                                                          "working-dir",
                                                          System.getProperty("java.io.tmpdir")));
        String storeDir = (String) options.valueOf("store-dir");

        Cluster cluster = null;
        int nodeId = 0;

        SerializerDefinition sdef = new SerializerDefinition("json", "'string'");
        StoreDefinition storeDef = new StoreDefinitionBuilder().setName("test")
                                                               .setKeySerializer(sdef)
                                                               .setValueSerializer(sdef)
                                                               .setRequiredReads(1)
                                                               .setReplicationFactor(1)
                                                               .setRequiredWrites(1)
                                                               .setType("read-only")
                                                               .setRoutingStrategyType(RoutingStrategyType.CONSISTENT_STRATEGY)
                                                               .setRoutingPolicy(RoutingTier.CLIENT)
                                                               .build();

        if(options.has("build")) {
            CmdUtils.croakIfMissing(parser, options, "num-values", "value-size");
            numValues = (Integer) options.valueOf("num-values");
            int numChunks = 1;
            if(options.has("num-chunks"))
                numChunks = (Integer) options.valueOf("num-chunks");
            int valueSize = (Integer) options.valueOf("value-size");

            // generate test data
            File temp = File.createTempFile("json-data", ".txt.gz", workingDir);
            temp.deleteOnExit();
            System.out.println("Generating test data in " + temp);
            OutputStream outputStream = new GZIPOutputStream(new FileOutputStream(temp));
            Writer writer = new BufferedWriter(new OutputStreamWriter(outputStream),
                                               10 * 1024 * 1024);
            String value = TestUtils.randomLetters(valueSize);
            for(int i = 0; i < numValues; i++) {
                writer.write("\"");
                writer.write(Integer.toString(i));
                writer.write("\" \"");
                writer.write(value);
                writer.write("\"");
                writer.write("\n");
            }
            writer.close();
            writer = null;

            System.out.println("Building store.");
            InputStream inputStream = new GZIPInputStream(new FileInputStream(temp));
            Reader r = new BufferedReader(new InputStreamReader(inputStream), 1 * 1024 * 1024);
            File output = TestUtils.createTempDir(workingDir);
            File tempDir = TestUtils.createTempDir(workingDir);

            cluster = ServerTestUtils.getLocalCluster(1);
            nodeId = 0;

            JsonStoreBuilder builder = new JsonStoreBuilder(new JsonReader(r),
                                                            cluster,
                                                            storeDef,
                                                            new ConsistentRoutingStrategy(cluster.getNodes(),
                                                                                          1),
                                                            output,
                                                            tempDir,
                                                            internalSortSize,
                                                            2,
                                                            numChunks,
                                                            64 * 1024,
                                                            gzipIntermediate);
            builder.build();

            // copy to store dir
            File dir = new File(storeDir);
            Utils.rm(dir);
            dir.mkdirs();
            System.out.println("Moving store data from " + output + " to " + dir);
            boolean copyWorked = new File(output, "node-0").renameTo(new File(dir, "version-0"));
            if(!copyWorked)
                Utils.croak("Copy of data from " + output + " to " + dir + " failed.");
        } else {
            CmdUtils.croakIfMissing(parser, options, "cluster-xml", "node-id");

            String clusterXmlPath = (String) options.valueOf("cluster-xml");
            nodeId = (Integer) options.valueOf("node-id");

            File clusterXml = new File(clusterXmlPath);
            if(!clusterXml.exists()) {
                Utils.croak("Cluster.xml does not exist");
            }
            cluster = new ClusterMapper().readCluster(clusterXml);

        }

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549543614/fstmerge_var1_7347717948187100935
        final Store<ByteArray, byte[]> store = new ReadOnlyStorageEngine("test",
                                                                         searcher,
                                                                         new RoutingStrategyFactory().updateRoutingStrategy(storeDef,
                                                                                                                            cluster),
                                                                         nodeId,
                                                                         new File(storeDir),
                                                                         0);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549543614/fstmerge_base_4303375085505921299
        final Store<ByteArray, byte[]> store = new ReadOnlyStorageEngine("test",
                                                                         searcher,
                                                                         new File(storeDir),
                                                                         0);
=======
        final Store<ByteArray, byte[], byte[]> store = new ReadOnlyStorageEngine("test",
                                                                                 searcher,
                                                                                 new File(storeDir),
                                                                                 0);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549543614/fstmerge_var2_323114888374120500

        final AtomicInteger obsoletes = new AtomicInteger(0);
        final AtomicInteger nullResults = new AtomicInteger(0);
        final AtomicInteger totalResults = new AtomicInteger(0);

        final BlockingQueue<String> requestIds = new ArrayBlockingQueue<String>(20000);
        final Executor executor = Executors.newFixedThreadPool(1);

        // if they have given us a file make a request generator that reads from
        // it, otherwise just generate random values
        final int numVals = numValues;
        Runnable requestGenerator;
        if(inputFile == null) {
            requestGenerator = new Runnable() {

                public void run() {
                    System.out.println("Generating random requests.");
                    Random random = new Random();
                    try {
                        while(true)
                            requestIds.put(Integer.toString(random.nextInt(numRequests) % numVals));
                    } catch(InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            };
        } else {
            requestGenerator = new Runnable() {

                public void run() {
                    try {
                        System.out.println("Using request file to generate requests.");
                        BufferedReader reader = new BufferedReader(new FileReader(inputFile),
                                                                   1000000);
                        while(true) {
                            String line = reader.readLine();
                            if(line == null)
                                return;
                            requestIds.put(line.trim());
                        }
                    } catch(Exception e) {
                        e.printStackTrace();
                    }
                }
            };
        }
        executor.execute(requestGenerator);

        final Serializer<Object> keySerializer = new JsonTypeSerializer(JsonTypeDefinition.fromJson("'string'"),
                                                                        true);
        final AtomicInteger current = new AtomicInteger();
        final int progressIncrement = numRequests / 5;
        PerformanceTest readWriteTest = new PerformanceTest() {

            @Override
            public void doOperation(int index) throws Exception {
                try {
                    totalResults.incrementAndGet();
                    int curr = current.getAndIncrement();
                    List<Versioned<byte[]>> results = store.get(new ByteArray(keySerializer.toBytes(requestIds.take())),
                                                                null);
                    if(curr % progressIncrement == 0)
                        System.out.println(curr);

                    if(results.size() == 0)
                        nullResults.incrementAndGet();

                } catch(ObsoleteVersionException e) {
                    obsoletes.incrementAndGet();
                }
            }
        };
        System.out.println("Running test...");
        readWriteTest.run(numRequests, numThreads);
        System.out.println("Random Access Read Only store Results:");
        System.out.println("Null reads ratio:" + (nullResults.doubleValue())
                           / totalResults.doubleValue());
        readWriteTest.printStats();
        System.exit(0);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/test/integration/voldemort/performance/ReadOnlyStorePerformanceTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Test
    public void testMultipleDonors() throws Exception {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545688/fstmerge_base_325716721034077187
        Cluster currentCluster = ServerTestUtils.getLocalCluster(4, new int[][] {
                       { 0, 2 }, { 1, 3, 5 }, { 4, 6 }, {} });
        Cluster targetCluster = ServerTestUtils.getLocalCluster(4, new int[][] {
                       { 0  }, { 1, 3 }, { 4, 6 }, { 2, 5 } });
=======
        Cluster currentCluster = ServerTestUtils.getLocalCluster(4, new int[][] { { 0, 2 },
                { 1, 3, 5 }, { 4, 6 }, {} });
        Cluster targetCluster = ServerTestUtils.getLocalCluster(4, new int[][] { { 0 }, { 1, 3 },
                { 4, 6 }, { 2, 5 } });
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545688/fstmerge_var2_7982100141198478237

        List<Integer> serverList = Arrays.asList(0, 1, 2, 3);
        Cluster updatedCluster = startServers(currentCluster, storeDefFile, serverList, null);
        targetCluster = updateCluster(targetCluster);

        RebalanceClientConfig config = new RebalanceClientConfig();
        config.setMaxParallelRebalancing(2);
        config.setMaxParallelDonors(2);

        RebalanceController rebalanceClient = new RebalanceController(getBootstrapUrl(updatedCluster,
                                                                                      0),
                                                                      config);
        try {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545688/fstmerge_var1_7891944398810148355
            populateData(updatedCluster, Arrays.asList(0, 1, 2), rebalanceClient.getAdminClient());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545688/fstmerge_base_325716721034077187
            populateData(updatedCluster, Arrays.asList(0,1,2));
=======
            populateData(updatedCluster, Arrays.asList(0, 1, 2));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545688/fstmerge_var2_7982100141198478237
            rebalanceAndCheck(updatedCluster, targetCluster, rebalanceClient, Arrays.asList(3));
        } finally {
            // stop servers
            stopServer(serverList);
        }

    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/test/unit/voldemort/client/rebalance/AbstractRebalanceTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Test
    public void testMultipleDonorsMultipleStealers() throws Exception {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545693/fstmerge_base_292623949550895690
        Cluster currentCluster = ServerTestUtils.getLocalCluster(4, new int[][] {
                       { 0, 2, 4, 6 }, { 1, 3, 5 }, {}, {} });
        Cluster targetCluster = ServerTestUtils.getLocalCluster(4, new int[][] {
                       { 0, 4  }, { 1 }, { 6, 3 }, { 2, 5 } });
=======
        Cluster currentCluster = ServerTestUtils.getLocalCluster(4, new int[][] { { 0, 2, 4, 6 },
                { 1, 3, 5 }, {}, {} });
        Cluster targetCluster = ServerTestUtils.getLocalCluster(4, new int[][] { { 0, 4 }, { 1 },
                { 6, 3 }, { 2, 5 } });
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545693/fstmerge_var2_4093568531646629000

        List<Integer> serverList = Arrays.asList(0, 1, 2, 3);
        Cluster updatedCluster = startServers(currentCluster, storeDefFile, serverList, null);
        targetCluster = updateCluster(targetCluster);

        RebalanceClientConfig config = new RebalanceClientConfig();
        config.setMaxParallelRebalancing(2);
        config.setMaxParallelDonors(2);
        RebalanceController rebalanceClient = new RebalanceController(getBootstrapUrl(updatedCluster,
                                                                                      0),
                                                                      config);
        try {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545693/fstmerge_var1_3362413524321255751
            populateData(updatedCluster, Arrays.asList(0, 1), rebalanceClient.getAdminClient());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545693/fstmerge_base_292623949550895690
            populateData(updatedCluster, Arrays.asList(0,1));
=======
            populateData(updatedCluster, Arrays.asList(0, 1));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545693/fstmerge_var2_4093568531646629000
            rebalanceAndCheck(updatedCluster, targetCluster, rebalanceClient, Arrays.asList(3));
        } finally {
            // stop servers
            stopServer(serverList);
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/test/unit/voldemort/client/rebalance/AbstractRebalanceTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Test
    public void testProxyGetDuringRebalancing() throws Exception {
        final Cluster currentCluster = ServerTestUtils.getLocalCluster(2, new int[][] {
                { 0, 1, 2, 3 }, {} });

        final Cluster targetCluster = ServerTestUtils.getLocalCluster(2, new int[][] { {},
                { 0, 1, 2, 3 } });

        // start servers 0 , 1 only
        final List<Integer> serverList = Arrays.asList(0, 1);
        final Cluster updatedCluster = startServers(currentCluster, storeDefFile, serverList, null);

        ExecutorService executors = Executors.newFixedThreadPool(2);
        final AtomicBoolean rebalancingToken = new AtomicBoolean(false);
        final List<Exception> exceptions = Collections.synchronizedList(new ArrayList<Exception>());

        RebalanceClientConfig rebalanceClientConfig = new RebalanceClientConfig();
        rebalanceClientConfig.setMaxParallelDonors(2);
        rebalanceClientConfig.setMaxParallelRebalancing(2);

        final RebalanceController rebalanceClient = new RebalanceController(getBootstrapUrl(updatedCluster,
                                                                                            0),
                                                                            rebalanceClientConfig);

        // populate data now.
        populateData(updatedCluster, Arrays.asList(0), rebalanceClient.getAdminClient());

        final SocketStoreClientFactory factory = new SocketStoreClientFactory(new ClientConfig().setBootstrapUrls(getBootstrapUrl(updatedCluster,
                                                                                                                                  0))
                                                                                                .setSocketTimeout(120,
                                                                                                                  TimeUnit.SECONDS));

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545697/fstmerge_var1_3716938319063480930
        final StoreClient<String, String> storeClient = new DefaultStoreClient<String, String>(testStoreNameRW,
                                                                                               null,
                                                                                               factory,
                                                                                               3);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545697/fstmerge_base_263361633793286261
        final StoreClient<String, String> storeClient = new DefaultStoreClient<String, String>(testStoreName,
                                                                                               null,
                                                                                               factory,
                                                                                               3);
=======
        final StoreClient<String, String, String> storeClient = new DefaultStoreClient<String, String, String>(testStoreName,
                                                                                                               null,
                                                                                                               factory,
                                                                                                               3);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545697/fstmerge_var2_8831927563729135300
        final boolean[] masterNodeResponded = { false, false };

        // start get operation.
        executors.execute(new Runnable() {

            public void run() {
                try {
                    List<String> keys = new ArrayList<String>(testEntries.keySet());

                    int nRequests = 0;
                    while(!rebalancingToken.get()) {
                        // should always able to get values.
                        int index = (int) (Math.random() * keys.size());

                        // should get a valid value
                        try {
                            nRequests++;
                            Versioned<String> value = storeClient.get(keys.get(index));
                            assertNotSame("StoreClient get() should not return null.", null, value);
                            assertEquals("Value returned should be good",
                                         new Versioned<String>(testEntries.get(keys.get(index))),
                                         value);
                            int masterNode = storeClient.getResponsibleNodes(keys.get(index))
                                                        .get(0)
                                                        .getId();
                            masterNodeResponded[masterNode] = true;

                        } catch(Exception e) {
                            System.out.println(e);
                            e.printStackTrace();
                            exceptions.add(e);
                        }
                    }

                } catch(Exception e) {
                    exceptions.add(e);
                } finally {
                    factory.close();
                }
            }

        });

        executors.execute(new Runnable() {

            public void run() {
                try {

                    Thread.sleep(500);

                    rebalanceAndCheck(updatedCluster,
                                      updateCluster(targetCluster),
                                      rebalanceClient,
                                      Arrays.asList(1));

                    Thread.sleep(500);

                    rebalancingToken.set(true);

                } catch(Exception e) {
                    exceptions.add(e);
                } finally {
                    // stop servers
                    try {
                        stopServer(serverList);
                    } catch(Exception e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        });

        executors.shutdown();
        executors.awaitTermination(300, TimeUnit.SECONDS);

        assertEquals("Client should see values returned master at both (0,1):("
                             + masterNodeResponded[0] + "," + masterNodeResponded[1] + ")",
                     true,
                     masterNodeResponded[0] && masterNodeResponded[1]);

        // check No Exception
        if(exceptions.size() > 0) {
            for(Exception e: exceptions) {
                e.printStackTrace();
            }
            fail("Should not see any exceptions.");
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/test/unit/voldemort/client/rebalance/AbstractRebalanceTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Test
    public void testProxyGetWithMultipleDonors() throws Exception {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545703/fstmerge_base_3958433861841789169
        Cluster currentCluster = ServerTestUtils.getLocalCluster(4, new int[][] {
                       { 0, 2, 4, 6 }, { 1, 3, 5 }, {}, {} });
        final Cluster targetCluster = ServerTestUtils.getLocalCluster(4, new int[][] {
                       { 0, 4  }, { 1 }, { 6, 3 }, { 2, 5 } });

=======
        Cluster currentCluster = ServerTestUtils.getLocalCluster(4, new int[][] { { 0, 2, 4, 6 },
                { 1, 3, 5 }, {}, {} });
        final Cluster targetCluster = ServerTestUtils.getLocalCluster(4, new int[][] { { 0, 4 },
                { 1 }, { 6, 3 }, { 2, 5 } });
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545703/fstmerge_var2_3197293750872807545

        // start servers 0 , 1 only
        final List<Integer> serverList = Arrays.asList(0, 1, 2, 3);
        final Cluster updatedCluster = startServers(currentCluster, storeDefFile, serverList, null);

        ExecutorService executors = Executors.newFixedThreadPool(2);
        final AtomicBoolean rebalancingToken = new AtomicBoolean(false);
        final List<Exception> exceptions = Collections.synchronizedList(new ArrayList<Exception>());

        RebalanceClientConfig rebalanceClientConfig = new RebalanceClientConfig();
        rebalanceClientConfig.setMaxParallelDonors(2);
        rebalanceClientConfig.setMaxParallelRebalancing(2);

        final RebalanceController rebalanceClient = new RebalanceController(getBootstrapUrl(updatedCluster,
                                                                                            0),
                                                                            rebalanceClientConfig);

        // populate data now.
        populateData(updatedCluster, Arrays.asList(0, 1), rebalanceClient.getAdminClient());

        final SocketStoreClientFactory factory = new SocketStoreClientFactory(new ClientConfig().setBootstrapUrls(getBootstrapUrl(updatedCluster,
                                                                                                                                  0))
                                                                                                .setSocketTimeout(120,
                                                                                                                  TimeUnit.SECONDS));

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545703/fstmerge_var1_6541389413829364724
        final StoreClient<String, String> storeClient = new DefaultStoreClient<String, String>(testStoreNameRW,
                                                                                               null,
                                                                                               factory,
                                                                                               3);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545703/fstmerge_base_3958433861841789169
        final StoreClient<String, String> storeClient = new DefaultStoreClient<String, String>(testStoreName,
                                                                                               null,
                                                                                               factory,
                                                                                               3);
=======
        final StoreClient<String, String, String> storeClient = new DefaultStoreClient<String, String, String>(testStoreName,
                                                                                                               null,
                                                                                                               factory,
                                                                                                               3);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545703/fstmerge_var2_3197293750872807545
        final Boolean[] masterNodeResponded = { false, false, false, false };

        // start get operation.
        executors.execute(new Runnable() {

            public void run() {
                try {
                    List<String> keys = new ArrayList<String>(testEntries.keySet());

                    int nRequests = 0;
                    while(!rebalancingToken.get()) {
                        // should always able to get values.
                        int index = (int) (Math.random() * keys.size());

                        // should get a valid value
                        try {
                            nRequests++;
                            Versioned<String> value = storeClient.get(keys.get(index));
                            assertNotSame("StoreClient get() should not return null.", null, value);
                            assertEquals("Value returned should be good",
                                         new Versioned<String>(testEntries.get(keys.get(index))),
                                         value);
                            int masterNode = storeClient.getResponsibleNodes(keys.get(index))
                                                        .get(0)
                                                        .getId();
                            masterNodeResponded[masterNode] = true;

                        } catch(Exception e) {
                            System.out.println(e);
                            e.printStackTrace();
                            exceptions.add(e);
                        }
                    }

                } catch(Exception e) {
                    exceptions.add(e);
                } finally {
                    factory.close();
                }
            }

        });

        executors.execute(new Runnable() {

            public void run() {
                try {

                    Thread.sleep(500);

                    rebalanceAndCheck(updatedCluster,
                                      updateCluster(targetCluster),
                                      rebalanceClient,
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545703/fstmerge_base_3958433861841789169
                                      Arrays.asList(2,3));
=======
                                      Arrays.asList(2, 3));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545703/fstmerge_var2_3197293750872807545

                    Thread.sleep(500);

                    rebalancingToken.set(true);

                } catch(Exception e) {
                    exceptions.add(e);
                } finally {
                    // stop servers
                    try {
                        stopServer(serverList);
                    } catch(Exception e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        });

        executors.shutdown();
        executors.awaitTermination(300, TimeUnit.SECONDS);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545703/fstmerge_base_3958433861841789169
        assertEquals("Client should see values returned master at both (0,1,2,3):(" +
                             Joiner.on(",").join(masterNodeResponded) + ")",
=======
        assertEquals("Client should see values returned master at both (0,1,2,3):("
                             + Joiner.on(",").join(masterNodeResponded) + ")",
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545703/fstmerge_var2_3197293750872807545
                     true,
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545703/fstmerge_base_3958433861841789169
                     masterNodeResponded[0] && masterNodeResponded[1] && masterNodeResponded[2] && masterNodeResponded[3] );
=======
                     masterNodeResponded[0] && masterNodeResponded[1] && masterNodeResponded[2]
                             && masterNodeResponded[3]);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545703/fstmerge_var2_3197293750872807545

        // check No Exception
        if(exceptions.size() > 0) {
            for(Exception e: exceptions) {
                e.printStackTrace();
            }
            fail("Should not see any exceptions.");
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/test/unit/voldemort/client/rebalance/AbstractRebalanceTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Test
    public void testServerSideRouting() throws Exception {
        Cluster localCluster = ServerTestUtils.getLocalCluster(2,
                                                               new int[][] { { 0, 1, 2, 3 }, {} });

        Cluster localTargetCluster = ServerTestUtils.getLocalCluster(2, new int[][] { {},
                { 0, 1, 2, 3 } });

        // start servers 0 , 1 only
        final List<Integer> serverList = Arrays.asList(0, 1);
        final Cluster updatedCluster = startServers(localCluster, storeDefFile, serverList, null);
        final Cluster targetCluster = updateCluster(localTargetCluster);

        ExecutorService executors = Executors.newFixedThreadPool(2);
        final AtomicBoolean rebalancingToken = new AtomicBoolean(false);
        final List<Exception> exceptions = Collections.synchronizedList(new ArrayList<Exception>());

        // populate data now.
        RebalanceClientConfig rebalanceClientConfig = new RebalanceClientConfig();
        rebalanceClientConfig.setMaxParallelDonors(2);
        rebalanceClientConfig.setMaxParallelRebalancing(2);

        final RebalanceController rebalanceClient = new RebalanceController(getBootstrapUrl(updatedCluster,
                                                                                            0),
                                                                            rebalanceClientConfig);

        populateData(updatedCluster, Arrays.asList(0), rebalanceClient.getAdminClient());

        Node node = updatedCluster.getNodeById(0);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545710/fstmerge_var1_6601511542005398122
        final Store<ByteArray, byte[]> serverSideRoutingStore = getSocketStore(testStoreNameRW,
                                                                               node.getHost(),
                                                                               node.getSocketPort(),
                                                                               true);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545710/fstmerge_base_6324717236241302212
        final Store<ByteArray, byte[]> serverSideRoutingStore = getSocketStore(testStoreName,
                                                                               node.getHost(),
                                                                               node.getSocketPort(),
                                                                               true);
=======
        final Store<ByteArray, byte[], byte[]> serverSideRoutingStore = getSocketStore(testStoreName,
                                                                                       node.getHost(),
                                                                                       node.getSocketPort(),
                                                                                       true);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545710/fstmerge_var2_5555249864373244177

        final CountDownLatch latch = new CountDownLatch(1);

        // start get operation.
        executors.execute(new Runnable() {

            public void run() {
                try {
                    List<String> keys = new ArrayList<String>(testEntries.keySet());

                    int nRequests = 0;
                    while(!rebalancingToken.get()) {
                        // should always able to get values.
                        int index = (int) (Math.random() * keys.size());

                        // should get a valid value
                        try {
                            nRequests++;
                            List<Versioned<byte[]>> values = serverSideRoutingStore.get(new ByteArray(ByteUtils.getBytes(keys.get(index),
                                                                                                                         "UTF-8")),
                                                                                        null);

                            assertEquals("serverSideRoutingStore should return value.",
                                         1,
                                         values.size());
                            assertEquals("Value returned should be good",
                                         new Versioned<String>(testEntries.get(keys.get(index))),
                                         new Versioned<String>(ByteUtils.getString(values.get(0)
                                                                                         .getValue(),
                                                                                   "UTF-8"),
                                                               values.get(0).getVersion()));
                        } catch(UnreachableStoreException e) {
                            // ignore
                        } catch(Exception e) {
                            exceptions.add(e);
                        }
                    }

                    latch.countDown();
                } catch(Exception e) {
                    exceptions.add(e);
                }
            }

        });

        executors.execute(new Runnable() {

            public void run() {
                try {

                    Thread.sleep(500);

                    rebalanceAndCheck(updatedCluster,
                                      targetCluster,
                                      rebalanceClient,
                                      Arrays.asList(1));

                    Thread.sleep(500);

                    rebalancingToken.set(true);

                } catch(Exception e) {
                    exceptions.add(e);
                } finally {
                    // stop servers as soon as the client thread has exited its
                    // loop.
                    try {
                        latch.await(300, TimeUnit.SECONDS);
                        stopServer(serverList);
                    } catch(Exception e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        });

        executors.shutdown();
        executors.awaitTermination(300, TimeUnit.SECONDS);

        // check No Exception
        if(exceptions.size() > 0) {
            for(Exception e: exceptions) {
                e.printStackTrace();
            }
            fail("Should not see any exceptions !!");
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/test/unit/voldemort/client/rebalance/AbstractRebalanceTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545715/fstmerge_var1_8989476837125856605
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545715/fstmerge_base_200841301774607855
protected void populateData(Cluster cluster, List<Integer> nodeList) {

        // Create SocketStores for each Node first
        Map<Integer, Store<ByteArray, byte[]>> storeMap = new HashMap<Integer, Store<ByteArray, byte[]>>();
        for(int nodeId: nodeList) {
            Node node = cluster.getNodeById(nodeId);
            storeMap.put(nodeId,
                         getSocketStore(testStoreName, node.getHost(), node.getSocketPort()));

        }

        RoutingStrategy routing = new ConsistentRoutingStrategy(cluster.getNodes(), 1);
        for(Entry<String, String> entry: testEntries.entrySet()) {
            int masterNode = routing.routeRequest(ByteUtils.getBytes(entry.getKey(), "UTF-8"))
                                    .get(0)
                                    .getId();
            if(nodeList.contains(masterNode)) {
                try {
                    ByteArray keyBytes = new ByteArray(ByteUtils.getBytes(entry.getKey(), "UTF-8"));
                    storeMap.get(masterNode)
                            .put(keyBytes,
                                 new Versioned<byte[]>(ByteUtils.getBytes(entry.getValue(), "UTF-8")));
                } catch(ObsoleteVersionException e) {
                    System.out.println("Why are we seeing this at all here ?? ");
                    e.printStackTrace();
                }
            }
        }

        // close all socket stores
        for(Store<ByteArray, byte[]> store: storeMap.values()) {
            store.close();
        }
    }
=======
protected void populateData(Cluster cluster, List<Integer> nodeList) {

        // Create SocketStores for each Node first
        Map<Integer, Store<ByteArray, byte[], byte[]>> storeMap = new HashMap<Integer, Store<ByteArray, byte[], byte[]>>();
        for(int nodeId: nodeList) {
            Node node = cluster.getNodeById(nodeId);
            storeMap.put(nodeId,
                         getSocketStore(testStoreName, node.getHost(), node.getSocketPort()));

        }

        RoutingStrategy routing = new ConsistentRoutingStrategy(cluster.getNodes(), 1);
        for(Entry<String, String> entry: testEntries.entrySet()) {
            int masterNode = routing.routeRequest(ByteUtils.getBytes(entry.getKey(), "UTF-8"))
                                    .get(0)
                                    .getId();
            if(nodeList.contains(masterNode)) {
                try {
                    ByteArray keyBytes = new ByteArray(ByteUtils.getBytes(entry.getKey(), "UTF-8"));
                    storeMap.get(masterNode)
                            .put(keyBytes,
                                 new Versioned<byte[]>(ByteUtils.getBytes(entry.getValue(), "UTF-8")),
                                 null);
                } catch(ObsoleteVersionException e) {
                    System.out.println("Why are we seeing this at all here ?? ");
                    e.printStackTrace();
                }
            }
        }

        // close all socket stores
        for(Store<ByteArray, byte[], byte[]> store: storeMap.values()) {
            store.close();
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545715/fstmerge_var2_1117401906534966701

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/test/unit/voldemort/client/rebalance/AbstractRebalanceTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545732/fstmerge_var1_7703696687782723709
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545732/fstmerge_base_772106137112568430
protected void checkGetEntries(Node node,
                                   Cluster cluster,
                                   List<Integer> unavailablePartitions,
                                   List<Integer> availablePartitions) {
        int matchedEntries = 0;
        RoutingStrategy routing = new ConsistentRoutingStrategy(cluster.getNodes(), 1);

        Store<ByteArray, byte[]> store = getSocketStore(testStoreName,
                                                        node.getHost(),
                                                        node.getSocketPort());

        for(Entry<String, String> entry: testEntries.entrySet()) {
            ByteArray keyBytes = new ByteArray(ByteUtils.getBytes(entry.getKey(), "UTF-8"));

            List<Integer> partitions = routing.getPartitionList(keyBytes.get());

            if(null != unavailablePartitions && unavailablePartitions.containsAll(partitions)) {
                try {
                    List<Versioned<byte[]>> value = store.get(keyBytes);
                    assertEquals("unavailable partitons should return zero size list.",
                                 0,
                                 value.size());
                } catch(InvalidMetadataException e) {
                    // ignore.
                }
            } else if(null != availablePartitions && availablePartitions.containsAll(partitions)) {
                List<Versioned<byte[]>> values = store.get(keyBytes);

                // expecting exactly one version
                assertEquals("Expecting exactly one version", 1, values.size());
                Versioned<byte[]> value = values.get(0);
                // check version matches (expecting base version for all)
                assertEquals("Value version should match", new VectorClock(), value.getVersion());
                // check value matches.
                assertEquals("Value bytes should match",
                             entry.getValue(),
                             ByteUtils.getString(value.getValue(), "UTF-8"));
                matchedEntries++;
            } else {
                // dont care about these
            }
        }

        if(null != availablePartitions && availablePartitions.size() > 0)
            assertNotSame("CheckGetEntries should match some entries.", 0, matchedEntries);
    }
=======
protected void checkGetEntries(Node node,
                                   Cluster cluster,
                                   List<Integer> unavailablePartitions,
                                   List<Integer> availablePartitions) {
        int matchedEntries = 0;
        RoutingStrategy routing = new ConsistentRoutingStrategy(cluster.getNodes(), 1);

        Store<ByteArray, byte[], byte[]> store = getSocketStore(testStoreName,
                                                                node.getHost(),
                                                                node.getSocketPort());

        for(Entry<String, String> entry: testEntries.entrySet()) {
            ByteArray keyBytes = new ByteArray(ByteUtils.getBytes(entry.getKey(), "UTF-8"));

            List<Integer> partitions = routing.getPartitionList(keyBytes.get());

            if(null != unavailablePartitions && unavailablePartitions.containsAll(partitions)) {
                try {
                    List<Versioned<byte[]>> value = store.get(keyBytes, null);
                    assertEquals("unavailable partitons should return zero size list.",
                                 0,
                                 value.size());
                } catch(InvalidMetadataException e) {
                    // ignore.
                }
            } else if(null != availablePartitions && availablePartitions.containsAll(partitions)) {
                List<Versioned<byte[]>> values = store.get(keyBytes, null);

                // expecting exactly one version
                assertEquals("Expecting exactly one version", 1, values.size());
                Versioned<byte[]> value = values.get(0);
                // check version matches (expecting base version for all)
                assertEquals("Value version should match", new VectorClock(), value.getVersion());
                // check value matches.
                assertEquals("Value bytes should match",
                             entry.getValue(),
                             ByteUtils.getString(value.getValue(), "UTF-8"));
                matchedEntries++;
            } else {
                // dont care about these
            }
        }

        if(null != availablePartitions && availablePartitions.size() > 0)
            assertNotSame("CheckGetEntries should match some entries.", 0, matchedEntries);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549545732/fstmerge_var2_4803972244640785258

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/test/unit/voldemort/client/rebalance/AbstractRebalanceTest.java
Conflict type: LineBasedMCFd
Conflict body: 
public static ReadOnlyStorageEngineTestInstance create(SearchStrategy strategy,
                                                           File baseDir,
                                                           int testSize,
                                                           int numNodes,
                                                           int repFactor,
                                                           SerializerDefinition keySerDef,
                                                           SerializerDefinition valueSerDef)
            throws Exception {
        // create some test data
        Map<String, String> data = createTestData(testSize);
        JsonReader reader = makeTestDataReader(data, baseDir);

        // set up definitions for cluster and store
        List<Node> nodes = new ArrayList<Node>();
        for(int i = 0; i < numNodes; i++) {
            nodes.add(new Node(i,
                               "localhost",
                               8080 + i,
                               6666 + i,
                               7000 + i,
                               Arrays.asList(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3)));
        }
        Cluster cluster = new Cluster("test", nodes);
        StoreDefinition storeDef = new StoreDefinitionBuilder().setName("test")
                                                               .setType(ReadOnlyStorageConfiguration.TYPE_NAME)
                                                               .setKeySerializer(keySerDef)
                                                               .setValueSerializer(valueSerDef)
                                                               .setRoutingPolicy(RoutingTier.CLIENT)
                                                               .setRoutingStrategyType(RoutingStrategyType.CONSISTENT_STRATEGY)
                                                               .setReplicationFactor(repFactor)
                                                               .setPreferredReads(1)
                                                               .setRequiredReads(1)
                                                               .setPreferredWrites(1)
                                                               .setRequiredWrites(1)
                                                               .build();
        RoutingStrategy router = new RoutingStrategyFactory().updateRoutingStrategy(storeDef,
                                                                                    cluster);

        // build store files in outputDir
        File outputDir = TestUtils.createTempDir(baseDir);
        JsonStoreBuilder storeBuilder = new JsonStoreBuilder(reader,
                                                             cluster,
                                                             storeDef,
                                                             router,
                                                             outputDir,
                                                             null,
                                                             testSize / 5,
                                                             1,
                                                             2,
                                                             10000,
                                                             false);
        storeBuilder.build();

        File nodeDir = TestUtils.createTempDir(baseDir);
        @SuppressWarnings("unchecked")
        Serializer<String> keySerializer = (Serializer<String>) new DefaultSerializerFactory().getSerializer(keySerDef);
        @SuppressWarnings("unchecked")
        Serializer<String> valueSerializer = (Serializer<String>) new DefaultSerializerFactory().getSerializer(valueSerDef);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549547056/fstmerge_var1_8200763586789040306
        Map<Integer, Store<String, String>> nodeStores = Maps.newHashMap();

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549547056/fstmerge_base_6679011323748014767
        Map<Integer, Store<String, String>> nodeStores = Maps.newHashMap();
=======
        Serializer<String> transSerializer = (Serializer<String>) new StringSerializer();
        Map<Integer, Store<String, String, String>> nodeStores = Maps.newHashMap();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549547056/fstmerge_var2_4369017597193878130
        for(int i = 0; i < numNodes; i++) {
            File currNode = new File(nodeDir, Integer.toString(i));
            currNode.mkdirs();
            currNode.deleteOnExit();
            Utils.move(new File(outputDir, "node-" + Integer.toString(i)), new File(currNode,
                                                                                    "version-0"));

            CompressionStrategyFactory comppressionStrategyFactory = new CompressionStrategyFactory();
            CompressionStrategy keyCompressionStrat = comppressionStrategyFactory.get(keySerDef.getCompression());
            CompressionStrategy valueCompressionStrat = comppressionStrategyFactory.get(valueSerDef.getCompression());
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549547056/fstmerge_var1_8200763586789040306
            Store<ByteArray, byte[]> innerStore = new CompressingStore(new ReadOnlyStorageEngine("test",
                                                                                                 strategy,
                                                                                                 router,
                                                                                                 i,
                                                                                                 currNode,
                                                                                                 1),
                                                                       keyCompressionStrat,
                                                                       valueCompressionStrat);

            nodeStores.put(i, SerializingStore.wrap(innerStore, keySerializer, valueSerializer));
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549547056/fstmerge_base_6679011323748014767
            Store<ByteArray, byte[]> innerStore = new CompressingStore(new ReadOnlyStorageEngine("test",
                                                                                                 strategy,
                                                                                                 currNode,
                                                                                                 1),
                                                                       keyCompressionStrat,
                                                                       valueCompressionStrat);

            nodeStores.put(i, SerializingStore.wrap(innerStore, keySerializer, valueSerializer));
=======
            Store<ByteArray, byte[], byte[]> innerStore = new CompressingStore(new ReadOnlyStorageEngine("test",
                                                                                                         strategy,
                                                                                                         currNode,
                                                                                                         1),
                                                                               keyCompressionStrat,
                                                                               valueCompressionStrat);

            nodeStores.put(i, SerializingStore.wrap(innerStore,
                                                    keySerializer,
                                                    valueSerializer,
                                                    transSerializer));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549547056/fstmerge_var2_4369017597193878130
        }

        return new ReadOnlyStorageEngineTestInstance(data,
                                                     baseDir,
                                                     nodeStores,
                                                     router,
                                                     keySerializer);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/test/unit/voldemort/store/readonly/ReadOnlyStorageEngineTestInstance.java
Conflict type: LineBasedMCFd
Conflict body: 
@Test
    public void testProxyGetAll() {
        Map<ByteArray, byte[]> entryMap = ServerTestUtils.createRandomKeyValuePairs(TEST_VALUES_SIZE);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549547281/fstmerge_var1_4141917338924799708
        Store<ByteArray, byte[]> store = server1.getStoreRepository()
                                                .getStorageEngine(testStoreName);
        for(Entry<ByteArray, byte[]> entry: entryMap.entrySet()) {
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549547281/fstmerge_base_3878195602675246936
        Store<ByteArray, byte[]> store = server1.getStoreRepository()
                       .getStorageEngine(testStoreName);
        for (Entry<ByteArray, byte[]> entry: entryMap.entrySet()) {
=======
        Store<ByteArray, byte[], byte[]> store = server1.getStoreRepository()
                                                        .getStorageEngine(testStoreName);
        for(Entry<ByteArray, byte[]> entry: entryMap.entrySet()) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549547281/fstmerge_var2_4887025715456792065
            store.put(entry.getKey(),
                      Versioned.value(entry.getValue(),
                                      new VectorClock().incremented(0, System.currentTimeMillis())),
                      null);
        }

        server0.getMetadataStore().put(MetadataStore.CLUSTER_KEY, targetCluster);
        server1.getMetadataStore().put(MetadataStore.CLUSTER_KEY, targetCluster);

        incrementVersionAndPut(server0.getMetadataStore(),
                               MetadataStore.SERVER_STATE_KEY,
                               MetadataStore.VoldemortState.REBALANCING_MASTER_SERVER);
        incrementVersionAndPut(server0.getMetadataStore(),
                               MetadataStore.REBALANCING_STEAL_INFO,
                               new RebalancerState(Arrays.asList(new RebalancePartitionsInfo(0,
                                                                                             1,
                                                                                             Arrays.asList(1),
                                                                                             new ArrayList<Integer>(0),
                                                                                             new ArrayList<Integer>(0),
                                                                                             Arrays.asList(testStoreName),
                                                                                             new HashMap<String, String>(),
                                                                                             new HashMap<String, String>(),
                                                                                             0))));
        checkGetAllEntries(entryMap, server0, getRedirectingStore(server0.getMetadataStore(),
                                                                  testStoreName), Arrays.asList(1));
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/test/unit/voldemort/store/rebalancing/RedirectingStoreTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549547303/fstmerge_var1_7381136829910884205
private void checkGetAllEntries(Map<ByteArray, byte[]> entryMap,
                                    VoldemortServer server,
                                    Store<ByteArray, byte[]> store,
                                    List<Integer> availablePartition) {
        RoutingStrategy routing = server.getMetadataStore().getRoutingStrategy(store.getName());
        List<ByteArray> keysInPartitions = new ArrayList<ByteArray>();
        for(ByteArray key: entryMap.keySet()) {
            List<Integer> partitions = routing.getPartitionList(key.get());
            if(availablePartition.containsAll(partitions)) {
                keysInPartitions.add(key);
            }
        }
        Map<ByteArray, List<Versioned<byte[]>>> results = store.getAll(keysInPartitions);
        for(Entry<ByteArray, List<Versioned<byte[]>>> entry: results.entrySet()) {
            assertEquals("Values should match",
                         new String(entry.getValue().get(0).getValue()),
                         new String(entryMap.get(entry.getKey())));
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549547303/fstmerge_base_1819125388210142990
private void checkGetAllEntries(Map<ByteArray, byte[]> entryMap,
                                    VoldemortServer server,
                                    Store<ByteArray, byte[]> store,
                                    List<Integer> availablePartition) {
        RoutingStrategy routing = server.getMetadataStore().getRoutingStrategy(store.getName());
        List<ByteArray> keysInPartitions = new ArrayList<ByteArray>();
        for (ByteArray key: entryMap.keySet()) {
            List<Integer> partitions = routing.getPartitionList(key.get());
            if (availablePartition.containsAll(partitions)) {
                keysInPartitions.add(key);
            }
        }
        Map<ByteArray, List<Versioned<byte[]>>> results = store.getAll(keysInPartitions);
        for (Entry<ByteArray, List<Versioned<byte[]>>> entry: results.entrySet()) {
            assertEquals("Values should match",
                         new String(entry.getValue().get(0).getValue()),
                         new String(entryMap.get(entry.getKey())));
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549547303/fstmerge_var2_6054554808091039566

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/test/unit/voldemort/store/rebalancing/RedirectingStoreTest.java
Conflict type: LineBasedMCFd
Conflict body: 
public VAdminProto.AsyncOperationStatusResponse handleFetchAndUpdate(VAdminProto.InitiateFetchAndUpdateRequest request) {
        final int nodeId = request.getNodeId();
        final List<Integer> partitions = request.getPartitionsList();
        final VoldemortFilter filter = request.hasFilter() ? getFilterFromRequest(request.getFilter(),
                                                                                  voldemortConfig,
                                                                                  networkClassLoader)
                                                          : new DefaultVoldemortFilter();
        final String storeName = request.getStore();

        int requestId = asyncService.getUniqueRequestId();
        VAdminProto.AsyncOperationStatusResponse.Builder response = VAdminProto.AsyncOperationStatusResponse.newBuilder()
                                                                                                            .setRequestId(requestId)
                                                                                                            .setComplete(false)
                                                                                                            .setDescription("Fetch and update")
                                                                                                            .setStatus("started");
        final boolean isReadOnlyStore = metadataStore.getStoreDef(storeName)
                                                     .getType()
                                                     .compareTo(ReadOnlyStorageConfiguration.TYPE_NAME) == 0;

        try {
            asyncService.submitOperation(requestId, new AsyncOperation(requestId,
                                                                       "Fetch and Update") {

                private final AtomicBoolean running = new AtomicBoolean(true);

                @Override
                public void stop() {
                    running.set(false);
                }

                @Override
                public void operate() {
                    AdminClient adminClient = RebalanceUtils.createTempAdminClient(voldemortConfig,
                                                                                   metadataStore.getCluster(),
                                                                                   4,
                                                                                   2);
                    try {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549563584/fstmerge_var1_2181324456467413066
                        StorageEngine<ByteArray, byte[]> storageEngine = getStorageEngine(storeRepository,
                                                                                          storeName);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549563584/fstmerge_base_2384383229507295800
                        StorageEngine<ByteArray, byte[]> storageEngine = getStorageEngine(storeRepository,
                                                                                          storeName);
                        Iterator<Pair<ByteArray, Versioned<byte[]>>> entriesIterator = adminClient.fetchEntries(nodeId,
                                                                                                                storeName,
                                                                                                                partitions,
                                                                                                                filter,
                                                                                                                false);
=======
                        StorageEngine<ByteArray, byte[], byte[]> storageEngine = getStorageEngine(storeRepository,
                                                                                                  storeName);
                        Iterator<Pair<ByteArray, Versioned<byte[]>>> entriesIterator = adminClient.fetchEntries(nodeId,
                                                                                                                storeName,
                                                                                                                partitions,
                                                                                                                filter,
                                                                                                                false);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549563584/fstmerge_var2_8503446453059120638
                        updateStatus("Initated fetchPartitionEntries");
                        EventThrottler throttler = new EventThrottler(voldemortConfig.getStreamMaxWriteBytesPerSec());

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549563584/fstmerge_var1_2181324456467413066
                        if(isReadOnlyStore) {
                            String destinationDir = ((ReadOnlyStorageEngine) storageEngine).getCurrentDirPath();
                            adminClient.fetchPartitionFiles(nodeId,
                                                            storeName,
                                                            partitions,
                                                            destinationDir);

                        } else {
                            Iterator<Pair<ByteArray, Versioned<byte[]>>> entriesIterator = adminClient.fetchEntries(nodeId,
                                                                                                                    storeName,
                                                                                                                    partitions,
                                                                                                                    filter,
                                                                                                                    false);

                            for(long i = 0; running.get() && entriesIterator.hasNext(); i++) {
                                Pair<ByteArray, Versioned<byte[]>> entry = entriesIterator.next();

                                ByteArray key = entry.getFirst();
                                Versioned<byte[]> value = entry.getSecond();
                                try {
                                    storageEngine.put(key, value);
                                } catch(ObsoleteVersionException e) {
                                    // log and ignore
                                    logger.debug("migratePartition threw ObsoleteVersionException, Ignoring.");
                                }

                                throttler.maybeThrottle(key.length() + valueSize(value));
                                if((i % 1000) == 0) {
                                    updateStatus(i + " entries processed");
                                }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549563584/fstmerge_base_2384383229507295800
                            ByteArray key = entry.getFirst();
                            Versioned<byte[]> value = entry.getSecond();
                            try {
                                storageEngine.put(key, value);
                            } catch(ObsoleteVersionException e) {
                                // log and ignore
                                logger.debug("migratePartition threw ObsoleteVersionException, Ignoring.");
=======
                            ByteArray key = entry.getFirst();
                            Versioned<byte[]> value = entry.getSecond();
                            try {
                                storageEngine.put(key, value, null);
                            } catch(ObsoleteVersionException e) {
                                // log and ignore
                                logger.debug("migratePartition threw ObsoleteVersionException, Ignoring.");
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549563584/fstmerge_var2_8503446453059120638
                            }
                        }

                    } finally {
                        adminClient.stop();
                    }
                }
            });

        } catch(VoldemortException e) {
            response.setError(ProtoUtils.encodeError(errorCodeMapper, e));
            logger.error("handleFetchAndUpdate failed for request(" + request.toString() + ")", e);
        }

        return response.build();
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/src/java/voldemort/server/protocol/admin/AdminServiceRequestHandler.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    protected void startInner() {
        registerEngine(metadata);

        /* Initialize storage configurations */
        for(String configClassName: voldemortConfig.getStorageConfigurations())
            initStorageConfig(configClassName);

        /* Initialize view storage configuration */
        storageConfigs.put(ViewStorageConfiguration.TYPE_NAME,
                           new ViewStorageConfiguration(voldemortConfig,
                                                        metadata.getStoreDefList(),
                                                        storeRepository));

        /* Register slop store */
        if(voldemortConfig.isSlopEnabled()) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549563887/fstmerge_var1_191475652553426404
            StorageConfiguration config = storageConfigs.get(voldemortConfig.getSlopStoreType());
            if(config == null)
                throw new ConfigurationException("Attempt to slop store failed");

            StorageEngine<ByteArray, byte[]> slopEngine = config.getStore("slop");

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549563887/fstmerge_base_6573177455512692771
            StorageEngine<ByteArray, byte[]> slopEngine = getStorageEngine("slop",
                                                                           voldemortConfig.getSlopStoreType());
=======
            StorageEngine<ByteArray, byte[], byte[]> slopEngine = getStorageEngine("slop",
                                                                                   voldemortConfig.getSlopStoreType());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549563887/fstmerge_var2_506006308871690838
            registerEngine(slopEngine);
            storeRepository.setSlopStore(SerializingStorageEngine.wrap(slopEngine,
                                                                       new ByteArraySerializer(),
                                                                       new SlopSerializer(),
                                                                       new IdentitySerializer()));
        }
        List<StoreDefinition> storeDefs = new ArrayList<StoreDefinition>(this.metadata.getStoreDefList());
        logger.info("Initializing stores:");

        // first initialize non-view stores
        for(StoreDefinition def: storeDefs)
            if(!def.isView())
                openStore(def);

        // now that we have all our stores, we can initialize views pointing at
        // those stores
        for(StoreDefinition def: storeDefs)
            if(def.isView())
                openStore(def);

        // enable aggregate jmx statistics
        if(voldemortConfig.isStatTrackingEnabled())
            JmxUtils.registerMbean(new StoreStatsJmx(this.storeStats),
                                   JmxUtils.createObjectName("voldemort.store.stats.aggregate",
                                                             "aggregate-perf"));

        logger.info("All stores initialized.");
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/src/java/voldemort/server/storage/StorageService.java
Conflict type: LineBasedMCFd
Conflict body: 
public void openStore(StoreDefinition storeDef) {

        logger.info("Opening store '" + storeDef.getName() + "' (" + storeDef.getType() + ").");
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549563892/fstmerge_var1_4440384041620647111

        StorageConfiguration config = storageConfigs.get(storeDef.getType());
        if(config == null)
            throw new ConfigurationException("Attempt to open store " + storeDef.getName()
                                             + " but " + storeDef.getType()
                                             + " storage engine of type " + storeDef.getType()
                                             + " has not been enabled.");

        if(storeDef.getType().compareTo(ReadOnlyStorageConfiguration.TYPE_NAME) == 0) {
            final RoutingStrategy routingStrategy = new RoutingStrategyFactory().updateRoutingStrategy(storeDef,
                                                                                                       metadata.getCluster());
            ((ReadOnlyStorageConfiguration) config).setRoutingStrategy(routingStrategy);
        }

        final StorageEngine<ByteArray, byte[]> engine = config.getStore(storeDef.getName());
        // Update the routing strategy + add listener to metadata
        if(storeDef.getType().compareTo(ReadOnlyStorageConfiguration.TYPE_NAME) == 0) {
            metadata.addMetadataStoreListener(storeDef.getName(), new MetadataStoreListener() {

                public void updateRoutingStrategy(RoutingStrategy updatedRoutingStrategy) {
                    ((ReadOnlyStorageEngine) engine).setRoutingStrategy(updatedRoutingStrategy);
                }
            });
        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549563892/fstmerge_base_6731181052286398416
        StorageEngine<ByteArray, byte[]> engine = getStorageEngine(storeDef.getName(),
                                                                   storeDef.getType());
=======
        StorageEngine<ByteArray, byte[], byte[]> engine = getStorageEngine(storeDef.getName(),
                                                                           storeDef.getType());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549563892/fstmerge_var2_5348543681945078509

        // openStore() should have atomic semantics
        try {
            registerEngine(engine);

            if(voldemortConfig.isServerRoutingEnabled())
                registerNodeStores(storeDef, metadata.getCluster(), voldemortConfig.getNodeId());

            if(storeDef.hasRetentionPeriod())
                scheduleCleanupJob(storeDef, engine);
        } catch(Exception e) {
            unregisterEngine(storeDef, engine);
            throw new VoldemortException(e);
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/src/java/voldemort/server/storage/StorageService.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549563910/fstmerge_var1_3664341164032858453
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549563910/fstmerge_base_3147337105643119149
private StorageEngine<ByteArray, byte[]> getStorageEngine(String name, String type) {
        StorageConfiguration config = storageConfigs.get(type);
        if(config == null)
            throw new ConfigurationException("Attempt to open store " + name + " but " + type
                                             + " storage engine of type " + type
                                             + " has not been enabled.");
        return config.getStore(name);
    }
=======
private StorageEngine<ByteArray, byte[], byte[]> getStorageEngine(String name, String type) {
        StorageConfiguration config = storageConfigs.get(type);
        if(config == null)
            throw new ConfigurationException("Attempt to open store " + name + " but " + type
                                             + " storage engine of type " + type
                                             + " has not been enabled.");
        return config.getStore(name);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549563910/fstmerge_var2_3965857694544797782

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/src/java/voldemort/server/storage/StorageService.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549568289/fstmerge_var1_4343138914451627421
public List<Versioned<byte[]>> get(ByteArray key) throws VoldemortException {
        StoreUtils.assertValidKey(key);
        try {
            fileModificationLock.readLock().lock();
            int chunk = fileSet.getChunkForKey(key.get());
            if(chunk < 0) {
                logger.warn("Routing strategy used for read-only store is inconsistent");
                return Collections.emptyList();
            }
            int location = searchStrategy.indexOf(fileSet.indexFileFor(chunk),
                                                  ByteUtils.md5(key.get()),
                                                  fileSet.getIndexFileSize(chunk));
            if(location >= 0) {
                byte[] value = readValue(chunk, location);
                return Collections.singletonList(Versioned.value(value));
            } else {
                return Collections.emptyList();
            }
        } finally {
            fileModificationLock.readLock().unlock();
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549568289/fstmerge_base_7390755068637273654
public List<Versioned<byte[]>> get(ByteArray key) throws VoldemortException {
        StoreUtils.assertValidKey(key);
        byte[] keyMd5 = ByteUtils.md5(key.get());
        int chunk = fileSet.getChunkForKey(keyMd5);
        int location = searchStrategy.indexOf(fileSet.indexFileFor(chunk),
                                              keyMd5,
                                              fileSet.getIndexFileSize(chunk));
        if(location >= 0) {
            byte[] value = readValue(chunk, location);
            return Collections.singletonList(Versioned.value(value));
        } else {
            return Collections.emptyList();
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549568289/fstmerge_var2_324641411053396078

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/src/java/voldemort/store/readonly/ReadOnlyStorageEngine.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549568294/fstmerge_var1_9122893320190917270
public Map<ByteArray, List<Versioned<byte[]>>> getAll(Iterable<ByteArray> keys)
            throws VoldemortException {
        StoreUtils.assertValidKeys(keys);
        Map<ByteArray, List<Versioned<byte[]>>> results = StoreUtils.newEmptyHashMap(keys);
        try {
            fileModificationLock.readLock().lock();
            List<KeyValueLocation> keysAndValueLocations = Lists.newArrayList();
            for(ByteArray key: keys) {
                int chunk = fileSet.getChunkForKey(key.get());
                int valueLocation = searchStrategy.indexOf(fileSet.indexFileFor(chunk),
                                                           ByteUtils.md5(key.get()),
                                                           fileSet.getIndexFileSize(chunk));
                if(valueLocation >= 0)
                    keysAndValueLocations.add(new KeyValueLocation(chunk, key, valueLocation));
            }
            Collections.sort(keysAndValueLocations);

            for(KeyValueLocation keyVal: keysAndValueLocations) {
                byte[] value = readValue(keyVal.getChunk(), keyVal.getValueLocation());
                results.put(keyVal.getKey(), Collections.singletonList(Versioned.value(value)));
            }
            return results;
        } finally {
            fileModificationLock.readLock().unlock();
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549568294/fstmerge_base_5843448065358218744
public Map<ByteArray, List<Versioned<byte[]>>> getAll(Iterable<ByteArray> keys)
            throws VoldemortException {
        StoreUtils.assertValidKeys(keys);
        Map<ByteArray, List<Versioned<byte[]>>> results = StoreUtils.newEmptyHashMap(keys);
        try {
            fileModificationLock.readLock().lock();
            List<KeyValueLocation> keysAndValueLocations = Lists.newArrayList();
            for(ByteArray key: keys) {
                byte[] keyMd5 = ByteUtils.md5(key.get());
                int chunk = fileSet.getChunkForKey(keyMd5);
                int valueLocation = searchStrategy.indexOf(fileSet.indexFileFor(chunk),
                                                           keyMd5,
                                                           fileSet.getIndexFileSize(chunk));
                if(valueLocation >= 0)
                    keysAndValueLocations.add(new KeyValueLocation(chunk, key, valueLocation));
            }
            Collections.sort(keysAndValueLocations);

            for(KeyValueLocation keyVal: keysAndValueLocations) {
                byte[] value = readValue(keyVal.getChunk(), keyVal.getValueLocation());
                results.put(keyVal.getKey(), Collections.singletonList(Versioned.value(value)));
            }
            return results;
        } finally {
            fileModificationLock.readLock().unlock();
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549568294/fstmerge_var2_4311130911336052298

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/src/java/voldemort/store/readonly/ReadOnlyStorageEngine.java
Conflict type: LineBasedMCFd
Conflict body: 
private RebalancePartitionsInfo redirectingKey(ByteArray key) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549568982/fstmerge_var1_4450236840788845422
        if(!getName().equals(MetadataStore.METADATA_STORE_NAME)
           && StoreState.REBALANCING.equals(metadata.getStoreState(getName()))) {
            List<Integer> partitionIds = metadata.getRoutingStrategy(getName())
                                                 .getPartitionList(key.get());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549568982/fstmerge_base_6844624077311406943
        if (VoldemortState.REBALANCING_MASTER_SERVER.equals(metadata.getServerState()) &&
            !getName().equals(MetadataStore.METADATA_STORE_NAME)) {
            List<Integer> partitionIds = metadata.getRoutingStrategy(getName()).getPartitionList(key.get());
=======
        if(VoldemortState.REBALANCING_MASTER_SERVER.equals(metadata.getServerState())
           && !getName().equals(MetadataStore.METADATA_STORE_NAME)) {
            List<Integer> partitionIds = metadata.getRoutingStrategy(getName())
                                                 .getPartitionList(key.get());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549568982/fstmerge_var2_6176912412219096440

            return getRebalancePartitionsInfo(partitionIds);
        }

        return null;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/src/java/voldemort/store/rebalancing/RedirectingStore.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public List<Version> getVersions(ByteArray key) {
        RebalancePartitionsInfo stealInfo = redirectingKey(key);

        /**
         * If I am rebalancing for this key, try to do remote get(), put it
         * locally first to get the correct version ignoring any
         * {@link ObsoleteVersionException}.
         */
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549568986/fstmerge_var1_6192036737635299101
        if(stealInfo != null) {
            List<Versioned<byte[]>> proxyValues = proxyGetAndLocalPut(key, stealInfo.getDonorId());
            if(isReadOnly)
                return StoreUtils.getVersions(proxyValues);
        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549568986/fstmerge_base_602148677205922120
        if(stealInfo != null)
            proxyGetAndLocalPut(key, stealInfo.getDonorId());
=======
        if(stealInfo != null)
            proxyGetAndLocalPut(key, stealInfo.getDonorId(), null);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549568986/fstmerge_var2_3076911367918643521

        return getInnerStore().getVersions(key);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/src/java/voldemort/store/rebalancing/RedirectingStore.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569021/fstmerge_var1_1573364538174941860
public RedirectingStore(Store<ByteArray, byte[]> innerStore,
                            MetadataStore metadata,
                            StoreRepository storeRepository,
                            FailureDetector detector,
                            SocketStoreFactory storeFactory) {
        super(innerStore);
        this.metadata = metadata;
        this.storeRepository = storeRepository;
        this.storeFactory = storeFactory;
        this.failureDetector = detector;
        try {
            this.isReadOnly = metadata.getStoreDef(getName())
                                      .getType()
                                      .compareTo(ReadOnlyStorageConfiguration.TYPE_NAME) == 0;
        } catch(Exception e) {
            this.isReadOnly = false;
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569021/fstmerge_base_8516010994503426625
public RedirectingStore(Store<ByteArray, byte[]> innerStore,
                            MetadataStore metadata,
                            StoreRepository storeRepository,
                            FailureDetector detector,
                            SocketStoreFactory storeFactory) {
        super(innerStore);
        this.metadata = metadata;
        this.storeRepository = storeRepository;
        this.storeFactory = storeFactory;
        this.failureDetector = detector;
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569021/fstmerge_var2_6548584817532202808

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/src/java/voldemort/store/rebalancing/RedirectingStore.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569025/fstmerge_var1_3163377123518311371
@Override
    public void put(ByteArray key, Versioned<byte[]> value) throws VoldemortException {
        if(this.isReadOnly)
            throw new UnsupportedOperationException("Put is not supported on this store, it is read-only.");

        RebalancePartitionsInfo stealInfo = redirectingKey(key);

        /**
         * If I am rebalancing for this key, try to do remote get() , put it
         * locally first to get the correct version ignoring any
         * {@link ObsoleteVersionException}
         */
        if(stealInfo != null)
            proxyGetAndLocalPut(key, stealInfo.getDonorId());

        getInnerStore().put(key, value);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569025/fstmerge_base_8513294791830838272
@Override
    public void put(ByteArray key, Versioned<byte[]> value) throws VoldemortException {
        RebalancePartitionsInfo stealInfo = redirectingKey(key);

        /**
         * If I am rebalancing for this key, try to do remote get() , put it
         * locally first to get the correct version ignoring any
         * {@link ObsoleteVersionException}
         */
        if (stealInfo != null)
            proxyGetAndLocalPut(key, stealInfo.getDonorId());

        getInnerStore().put(key, value);
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569025/fstmerge_var2_8879968139760279954

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/src/java/voldemort/store/rebalancing/RedirectingStore.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569030/fstmerge_var1_3727357875100960539
@Override
    public List<Versioned<byte[]>> get(ByteArray key) throws VoldemortException {
        RebalancePartitionsInfo stealInfo = redirectingKey(key);

        /**
         * If I am rebalancing for this key, try to do remote get(), put it
         * locally first to get the correct version ignoring any
         * {@link ObsoleteVersionException}
         */
        if(stealInfo != null) {
            List<Versioned<byte[]>> proxyValues = proxyGetAndLocalPut(key, stealInfo.getDonorId());
            if(isReadOnly)
                return proxyValues;
        }

        return getInnerStore().get(key);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569030/fstmerge_base_3163423095213450797
@Override
    public List<Versioned<byte[]>> get(ByteArray key) throws VoldemortException {
        RebalancePartitionsInfo stealInfo = redirectingKey(key);

        /**
         * If I am rebalancing for this key, try to do remote get(), put it
         * locally first to get the correct version ignoring any
         * {@link ObsoleteVersionException}
         */
        if(stealInfo != null)
            proxyGetAndLocalPut(key, stealInfo.getDonorId());

        return getInnerStore().get(key);
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569030/fstmerge_var2_1798888049408363369

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/src/java/voldemort/store/rebalancing/RedirectingStore.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569034/fstmerge_var1_5104686787778806180
@Override
    public Map<ByteArray, List<Versioned<byte[]>>> getAll(Iterable<ByteArray> keys)
            throws VoldemortException {
        int maxLength = Iterables.size(keys);
        List<ByteArray> redirectingKeys = Lists.newArrayListWithExpectedSize(maxLength);
        List<RebalancePartitionsInfo> rebalancePartitionsInfos = Lists.newArrayListWithExpectedSize(maxLength);
        for(ByteArray key: keys) {
            RebalancePartitionsInfo info;
            info = redirectingKey(key);
            if(info != null) {
                redirectingKeys.add(key);
                rebalancePartitionsInfos.add(info);
            }
        }

        if(!redirectingKeys.isEmpty()) {
            Map<ByteArray, List<Versioned<byte[]>>> proxyKeyValues = proxyGetAllAndLocalPut(redirectingKeys,
                                                                                            rebalancePartitionsInfos);
            if(isReadOnly) {
                return proxyKeyValues;
            }
        }

        return getInnerStore().getAll(keys);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569034/fstmerge_base_6130379882324154163
@Override
    public Map<ByteArray, List<Versioned<byte[]>>> getAll(Iterable<ByteArray> keys)
            throws VoldemortException {
        int maxLength = Iterables.size(keys);
        List<ByteArray> redirectingKeys = Lists.newArrayListWithExpectedSize(maxLength);
        List<RebalancePartitionsInfo> rebalancePartitionsInfos = Lists.newArrayListWithExpectedSize(maxLength);
        for(ByteArray key: keys) {
            RebalancePartitionsInfo info;
            info = redirectingKey(key);
            if(info != null) {
                redirectingKeys.add(key);
                rebalancePartitionsInfos.add(info);
            }
        }


        if(!redirectingKeys.isEmpty())
            proxyGetAllAndLocalPut(redirectingKeys, rebalancePartitionsInfos);

        return getInnerStore().getAll(keys);
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569034/fstmerge_var2_7167603208122687912

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/src/java/voldemort/store/rebalancing/RedirectingStore.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569039/fstmerge_var1_7542324599779089966
private List<Versioned<byte[]>> proxyGet(ByteArray key, int donorNodeId) {
        Node donorNode = metadata.getCluster().getNodeById(donorNodeId);
        checkNodeAvailable(donorNode);
        long startNs = System.nanoTime();
        try {
            Store<ByteArray, byte[]> redirectingStore = getRedirectingSocketStore(getName(),
                                                                                  donorNodeId);
            List<Versioned<byte[]>> values = redirectingStore.get(key);
            recordSuccess(donorNode, startNs);
            return values;
        } catch(UnreachableStoreException e) {
            recordException(donorNode, startNs, e);
            throw new ProxyUnreachableException("Failed to reach proxy node " + donorNode, e);
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569039/fstmerge_base_2534967257362559419
private List<Versioned<byte[]>> proxyGet(ByteArray key, int donorNodeId) {
        Node donorNode = metadata.getCluster().getNodeById(donorNodeId);
        checkNodeAvailable(donorNode);
        long startNs = System.nanoTime();
        try {
            Store<ByteArray, byte[]> redirectingStore = getRedirectingSocketStore(getName(), donorNodeId);
            List<Versioned<byte[]>> values = redirectingStore.get(key);
            recordSuccess(donorNode, startNs);
            return values;
        } catch (UnreachableStoreException e) {
            recordException(donorNode, startNs, e);
            throw new ProxyUnreachableException("Failed to reach proxy node " + donorNode, e);
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569039/fstmerge_var2_7104295743406139474

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/src/java/voldemort/store/rebalancing/RedirectingStore.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569044/fstmerge_var1_5826684934157219590
private Map<ByteArray, List<Versioned<byte[]>>> proxyGetAll(List<ByteArray> keys,
                                                                List<RebalancePartitionsInfo> stealInfoList)
            throws VoldemortException {
        Multimap<Integer, ByteArray> scatterMap = HashMultimap.create(stealInfoList.size(),
                                                                      keys.size());
        int numKeys = 0;
        for(ByteArray key: keys) {
            numKeys++;
            for(RebalancePartitionsInfo stealInfo: stealInfoList) {
                byte[] keyBytes = key.get();

                for(int p: metadata.getRoutingStrategy(getName()).getPartitionList(keyBytes)) {
                    if(stealInfo.getPartitionList().contains(p))
                        scatterMap.put(stealInfo.getDonorId(), key);
                }
            }
        }

        Map<ByteArray, List<Versioned<byte[]>>> gatherMap = Maps.newHashMapWithExpectedSize(numKeys);

        for(int donorNodeId: scatterMap.keySet()) {
            Node donorNode = metadata.getCluster().getNodeById(donorNodeId);
            checkNodeAvailable(donorNode);
            long startNs = System.nanoTime();

            try {
                Map<ByteArray, List<Versioned<byte[]>>> resultsForNode = getRedirectingSocketStore(getName(),
                                                                                                   donorNodeId).getAll(scatterMap.get(donorNodeId));
                recordSuccess(donorNode, startNs);

                for(Map.Entry<ByteArray, List<Versioned<byte[]>>> entry: resultsForNode.entrySet()) {
                    gatherMap.put(entry.getKey(), entry.getValue());
                }
            } catch(UnreachableStoreException e) {
                recordException(donorNode, startNs, e);
                throw new ProxyUnreachableException("Failed to reach proxy node " + donorNode, e);
            }
        }

        return gatherMap;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569044/fstmerge_base_2741945936516080413
private Map<ByteArray, List<Versioned<byte[]>>> proxyGetAll(List<ByteArray> keys,
                                                                List<RebalancePartitionsInfo> stealInfoList)
            throws VoldemortException {
        Multimap<Integer, ByteArray> scatterMap = HashMultimap.create(stealInfoList.size(),
                                                                      keys.size());
        int numKeys=0;
        for (ByteArray key: keys) {
            numKeys++;
            for (RebalancePartitionsInfo stealInfo: stealInfoList) {
                byte[] keyBytes = key.get();
                
                for (int p: metadata.getRoutingStrategy(getName()).getPartitionList(keyBytes)) {
                    if (stealInfo.getPartitionList().contains(p))
                        scatterMap.put(stealInfo.getDonorId(), key);
                }
            }
        }

        Map<ByteArray, List<Versioned<byte[]>>> gatherMap = Maps.newHashMapWithExpectedSize(numKeys);

        for (int donorNodeId: scatterMap.keySet()) {
            Node donorNode = metadata.getCluster().getNodeById(donorNodeId);
            checkNodeAvailable(donorNode);
            long startNs = System.nanoTime();

            try {
                Map<ByteArray, List<Versioned<byte[]>>> resultsForNode = getRedirectingSocketStore(getName(),
                                                                                                   donorNodeId).getAll(scatterMap.get(donorNodeId));
                recordSuccess(donorNode, startNs);

                for (Map.Entry<ByteArray, List<Versioned<byte[]>>> entry: resultsForNode.entrySet()) {
                    gatherMap.put(entry.getKey(), entry.getValue());
                }
            } catch (UnreachableStoreException e) {
                recordException(donorNode, startNs, e);
                throw new ProxyUnreachableException("Failed to reach proxy node " + donorNode, e);
            }
        }

        return gatherMap;
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569044/fstmerge_var2_633402002772924392

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/src/java/voldemort/store/rebalancing/RedirectingStore.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569049/fstmerge_var1_1207959492353938658
private List<Versioned<byte[]>> proxyGetAndLocalPut(ByteArray key, int donorId)
            throws VoldemortException {
        List<Versioned<byte[]>> proxyValues = proxyGet(key, donorId);
        if(!isReadOnly) {
            for(Versioned<byte[]> proxyValue: proxyValues) {
                try {
                    getInnerStore().put(key, proxyValue);
                } catch(ObsoleteVersionException e) {
                    // ignore these
                }
            }
        }
        return proxyValues;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569049/fstmerge_base_4434049599173707878
private void proxyGetAndLocalPut(ByteArray key, int donorId) throws VoldemortException {
        List<Versioned<byte[]>> proxyValues = proxyGet(key, donorId);
        for(Versioned<byte[]> proxyValue: proxyValues) {
            try {
                getInnerStore().put(key, proxyValue);
            } catch(ObsoleteVersionException e) {
                // ignore these
            }
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569049/fstmerge_var2_7491702285760662297

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/src/java/voldemort/store/rebalancing/RedirectingStore.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569053/fstmerge_var1_2890414061144765621
private Map<ByteArray, List<Versioned<byte[]>>> proxyGetAllAndLocalPut(List<ByteArray> keys,
                                                                           List<RebalancePartitionsInfo> stealInfoList)
            throws VoldemortException {
        Map<ByteArray, List<Versioned<byte[]>>> proxyKeyValues = proxyGetAll(keys, stealInfoList);
        if(!isReadOnly) {
            for(Map.Entry<ByteArray, List<Versioned<byte[]>>> keyValuePair: proxyKeyValues.entrySet()) {
                for(Versioned<byte[]> proxyValue: keyValuePair.getValue()) {
                    try {
                        getInnerStore().put(keyValuePair.getKey(), proxyValue);
                    } catch(ObsoleteVersionException e) {
                        // ignore these
                    }
                }
            }
        }
        return proxyKeyValues;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569053/fstmerge_base_3991106593972511376
private void proxyGetAllAndLocalPut(List<ByteArray> keys, List<RebalancePartitionsInfo> stealInfoList) throws VoldemortException {
        Map<ByteArray, List<Versioned<byte[]>>> proxyKeyValues = proxyGetAll(keys, stealInfoList);
        for(Map.Entry<ByteArray, List<Versioned<byte[]>>> keyValuePair: proxyKeyValues.entrySet()) {
            for(Versioned<byte[]> proxyValue: keyValuePair.getValue()) {
                try {
                    getInnerStore().put(keyValuePair.getKey(), proxyValue);
                } catch(ObsoleteVersionException e) {
                    // ignore these
                }
            }
        }

    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549569053/fstmerge_var2_3446222561066571675

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/src/java/voldemort/store/rebalancing/RedirectingStore.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549570820/fstmerge_var1_6338144706495527712
public MetadataStore(Store<String, String> innerStore, int nodeId) {
        this.innerStore = innerStore;
        this.metadataCache = new HashMap<String, Versioned<Object>>();
        this.storeNameTolisteners = new ConcurrentHashMap<String, MetadataStoreListener>();

        init(nodeId);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549570820/fstmerge_base_4909460132813269756
public MetadataStore(Store<String, String> innerStore, int nodeId) {
        this.innerStore = innerStore;
        this.metadataCache = new HashMap<String, Versioned<Object>>();

        init(nodeId);
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549570820/fstmerge_var2_5572765852031817694

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/src/java/voldemort/store/metadata/MetadataStore.java
Conflict type: LineBasedMCFd
Conflict body: 
public void testHadoopBuild() throws Exception {
        // create test data
        Map<String, String> values = new HashMap<String, String>();
        File testDir = TestUtils.createTempDir();
        File tempDir = new File(testDir, "temp"), tempDir2 = new File(testDir, "temp2");
        File outputDir = new File(testDir, "output"), outputDir2 = new File(testDir, "output2");
        File storeDir = TestUtils.createTempDir(testDir);
        for(int i = 0; i < 200; i++)
            values.put(Integer.toString(i), Integer.toBinaryString(i));

        // write test data to text file
        File inputFile = File.createTempFile("input", ".txt", testDir);
        inputFile.deleteOnExit();
        StringBuilder contents = new StringBuilder();
        for(Map.Entry<String, String> entry: values.entrySet())
            contents.append(entry.getKey() + "\t" + entry.getValue() + "\n");
        FileUtils.writeStringToFile(inputFile, contents.toString());

        String storeName = "test";
        SerializerDefinition serDef = new SerializerDefinition("string");
        Cluster cluster = ServerTestUtils.getLocalCluster(1);

        // Test backwards compatibility
        StoreDefinition def = new StoreDefinitionBuilder().setName(storeName)
                                                          .setType(ReadOnlyStorageConfiguration.TYPE_NAME)
                                                          .setKeySerializer(serDef)
                                                          .setValueSerializer(serDef)
                                                          .setRoutingPolicy(RoutingTier.CLIENT)
                                                          .setRoutingStrategyType(RoutingStrategyType.CONSISTENT_STRATEGY)
                                                          .setReplicationFactor(1)
                                                          .setPreferredReads(1)
                                                          .setRequiredReads(1)
                                                          .setPreferredWrites(1)
                                                          .setRequiredWrites(1)
                                                          .build();
        HadoopStoreBuilder builder = new HadoopStoreBuilder(new Configuration(),
                                                            TextStoreMapper.class,
                                                            TextInputFormat.class,
                                                            cluster,
                                                            def,
                                                            64 * 1024,
                                                            new Path(tempDir2.getAbsolutePath()),
                                                            new Path(outputDir2.getAbsolutePath()),
                                                            new Path(inputFile.getAbsolutePath()));
        builder.build();

        builder = new HadoopStoreBuilder(new Configuration(),
                                         TextStoreMapper.class,
                                         TextInputFormat.class,
                                         cluster,
                                         def,
                                         64 * 1024,
                                         new Path(tempDir.getAbsolutePath()),
                                         new Path(outputDir.getAbsolutePath()),
                                         new Path(inputFile.getAbsolutePath()),
                                         CheckSumType.MD5);
        builder.build();

        // Check if checkSum is generated in outputDir
        File nodeFile = new File(outputDir, "node-0");
        File checkSumFile = new File(nodeFile, "md5checkSum.txt");
        assertTrue(checkSumFile.exists());

        // Check contents of checkSum file
        byte[] md5 = new byte[16];
        DataInputStream in = new DataInputStream(new FileInputStream(checkSumFile));
        in.read(md5);
        in.close();

        byte[] checkSumBytes = CheckSumTests.calculateCheckSum(nodeFile.listFiles(),
                                                               CheckSumType.MD5);
        assertEquals(0, ByteUtils.compare(checkSumBytes, md5));

        // check if fetching works
        HdfsFetcher fetcher = new HdfsFetcher();

        // Fetch to version directory
        File versionDir = new File(storeDir, "version-0");
        fetcher.fetch(nodeFile.getAbsolutePath(), versionDir.getAbsolutePath());
        assertTrue(versionDir.exists());

        // open store
        @SuppressWarnings("unchecked")
        Serializer<Object> serializer = (Serializer<Object>) new DefaultSerializerFactory().getSerializer(serDef);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549571985/fstmerge_var1_1506883558364657441
        Store<Object, Object> store = SerializingStore.wrap(new ReadOnlyStorageEngine(storeName,
                                                                                      new BinarySearchStrategy(),
                                                                                      new RoutingStrategyFactory().updateRoutingStrategy(def,
                                                                                                                                         cluster),
                                                                                      0,
                                                                                      storeDir,
                                                                                      1),
                                                            serializer,
                                                            serializer);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549571985/fstmerge_base_2938315839488174240
        Store<Object, Object> store = SerializingStore.wrap(new ReadOnlyStorageEngine(storeName,
                                                                                      new BinarySearchStrategy(),
                                                                                      storeDir,
                                                                                      1),
                                                            serializer,
                                                            serializer);
=======
        Store<Object, Object, Object> store = SerializingStore.wrap(new ReadOnlyStorageEngine(storeName,
                                                                                              new BinarySearchStrategy(),
                                                                                              storeDir,
                                                                                              1),
                                                                    serializer,
                                                                    serializer,
                                                                    serializer);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415549571985/fstmerge_var2_8322969377091074314

        // check values
        for(Map.Entry<String, String> entry: values.entrySet()) {
            List<Versioned<Object>> found = store.get(entry.getKey(), null);
            assertEquals("Incorrect number of results", 1, found.size());
            assertEquals(entry.getValue(), found.get(0).getValue());
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_01fad_566b4/rev_01fad-566b4/contrib/hadoop-store-builder/test/voldemort/store/readonly/mr/HadoopStoreBuilderTest.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550063620/fstmerge_var1_4705540226847465189
public ForceFailStore(Store<K, V> innerStore) {
        this(innerStore, new VoldemortException("Operation failed!"));
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550063620/fstmerge_base_6718650640820180980
public ForceFailStore(Store<K, V> innerStore) {
        super(innerStore);
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550063620/fstmerge_var2_834549708188694802

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/test/common/voldemort/store/ForceFailStore.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    protected void setUp() throws Exception {
        repo = new StoreRepository();
        repo.setSlopStore(new InMemoryStorageEngine<ByteArray, Slop, byte[]>("slop"));
        repo.addNodeStore(0, new InMemoryStorageEngine<ByteArray, byte[], byte[]>(STORE_NAME));
        repo.addNodeStore(1, new InMemoryStorageEngine<ByteArray, byte[], byte[]>(STORE_NAME));
        this.failingNodeId = 2;
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550064129/fstmerge_var1_8035964279578800163

        repo.addNodeStore(failingNodeId, new FailingStore<ByteArray, byte[]>(STORE_NAME));
        pusher = new SlopPusherJob(repo, makeCluster(3), new NoopFailureDetector(), 10 * 1000 * 1000);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550064129/fstmerge_base_6908910488046655188
        repo.addNodeStore(failingNodeId, new FailingStore<ByteArray, byte[]>(STORE_NAME));
        pusher = new SlopPusherJob(repo);
=======
        repo.addNodeStore(failingNodeId, new FailingStore<ByteArray, byte[], byte[]>(STORE_NAME));
        pusher = new SlopPusherJob(repo);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550064129/fstmerge_var2_7117134199683189083
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/test/unit/voldemort/scheduled/SlopPusherTest.java
Conflict type: LineBasedMCFd
Conflict body: 
private void checkPush(Versioned<Slop>[] delivered, Versioned<Slop>[] undelivered) {
        // now all the delivered slop should be gone and the various stores
        // should have
        // those items
        for(Versioned<Slop> vs: delivered) {
            // check that all the slops are in the stores
            // and no new slops have appeared
            // and the SloppyStore is now empty
            Slop slop = vs.getValue();
            assertEquals("Slop remains.", 0, repo.getSlopStore().get(slop.makeKey(), null).size());
            assertTrue(bytesEqual(slop.getValue(), repo.getNodeStore(STORE_NAME, slop.getNodeId())
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550064135/fstmerge_var1_4682001859853275968
                                                       .get(slop.getKey())
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550064135/fstmerge_base_2647964862294370988
                                                       .get(slop.makeKey())
=======
                                                       .get(slop.makeKey(), null)
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550064135/fstmerge_var2_8175442337938292011
                                                       .get(0)
                                                       .getValue()));
        }
        // check that all undelivered slop is undelivered
        for(Versioned<Slop> vs: undelivered) {
            Slop slop = vs.getValue();
            assertEquals("Slop is gone!", 1, repo.getSlopStore().get(slop.makeKey(), null).size());
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/test/unit/voldemort/scheduled/SlopPusherTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@SuppressWarnings("unchecked")
    public <K, V, T> Store<K, V, T> getRawStore(String storeName,
                                                InconsistencyResolver<Versioned<V>> resolver) {
        // Get cluster and store metadata
        String clusterXml = bootstrapMetadataWithRetries(MetadataStore.CLUSTER_KEY, bootstrapUrls);
        Cluster cluster = clusterMapper.readCluster(new StringReader(clusterXml), false);
        String storesXml = bootstrapMetadataWithRetries(MetadataStore.STORES_KEY, bootstrapUrls);
        List<StoreDefinition> storeDefs = storeMapper.readStoreList(new StringReader(storesXml),
                                                                    false);
        StoreDefinition storeDef = null;
        for(StoreDefinition d: storeDefs)
            if(d.getName().equals(storeName))
                storeDef = d;
        if(storeDef == null)
            throw new BootstrapFailureException("Unknown store '" + storeName + "'.");

        boolean repairReads = !storeDef.isView();

        // construct mapping
        Map<Integer, Store<ByteArray, byte[], byte[]>> clientMapping = Maps.newHashMap();
        Map<Integer, NonblockingStore> nonblockingStores = Maps.newHashMap();

        Map<Integer, Store<ByteArray, Slop>> slopStores = null;
        if (config.isHintedHandoffEnabled() && storeDef.isHintedHandoffEnabled())
            slopStores = Maps.newHashMap();

        for(Node node: cluster.getNodes()) {
            Store<ByteArray, byte[], byte[]> store = getStore(storeDef.getName(),
                                                              node.getHost(),
                                                              getPort(node),
                                                              this.requestFormatType);
            Store<ByteArray, byte[], byte[]> loggingStore = new LoggingStore(store);
            clientMapping.put(node.getId(), loggingStore);

            NonblockingStore nonblockingStore = routedStoreFactory.toNonblockingStore(store);
            nonblockingStores.put(node.getId(), nonblockingStore);

            if(slopStores != null) {
                Store<ByteArray, Slop> slopStore = SerializingStore.wrap(getStore("slop",
                                                                                  node.getHost(),
                                                                                  getPort(node),
                                                                                  this.requestFormatType),
                                                                         slopKeySerializer,
                                                                         slopValueSerializer);
                slopStores.put(node.getId(), slopStore);
            }
        }

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550065603/fstmerge_var1_3724104428245025731
        Store<ByteArray, byte[]> store = routedStoreFactory.create(cluster,
                                                                   storeDef,
                                                                   clientMapping,
                                                                   nonblockingStores,
                                                                   slopStores,
                                                                   repairReads,
                                                                   clientZoneId,
                                                                   getFailureDetector());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550065603/fstmerge_base_7922326967504435161
        Store<ByteArray, byte[]> store = routedStoreFactory.create(cluster,
                                                                   storeDef,
                                                                   clientMapping,
                                                                   nonblockingStores,
                                                                   repairReads,
                                                                   clientZoneId,
                                                                   getFailureDetector());
=======
        Store<ByteArray, byte[], byte[]> store = routedStoreFactory.create(cluster,
                                                                           storeDef,
                                                                           clientMapping,
                                                                           nonblockingStores,
                                                                           repairReads,
                                                                           clientZoneId,
                                                                           getFailureDetector());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550065603/fstmerge_var2_3115566921304293045

        if(isJmxEnabled) {
            StatTrackingStore statStore = new StatTrackingStore(store, this.stats);
            store = statStore;
            JmxUtils.registerMbean(new StoreStatsJmx(statStore.getStats()),
                                   JmxUtils.createObjectName(JmxUtils.getPackageName(store.getClass()),
                                                             store.getName() + jmxId()));
        }

        if(storeDef.getKeySerializer().hasCompression()
           || storeDef.getValueSerializer().hasCompression()) {
            store = new CompressingStore(store,
                                         getCompressionStrategy(storeDef.getKeySerializer()),
                                         getCompressionStrategy(storeDef.getValueSerializer()));
        }

        Serializer<K> keySerializer = (Serializer<K>) serializerFactory.getSerializer(storeDef.getKeySerializer());
        Serializer<V> valueSerializer = (Serializer<V>) serializerFactory.getSerializer(storeDef.getValueSerializer());

        if(storeDef.isView() && (storeDef.getTransformsSerializer() == null))
            throw new SerializationException("Transforms serializer must be specified with a view ");

        Serializer<T> transformsSerializer = (Serializer<T>) serializerFactory.getSerializer(storeDef.getTransformsSerializer() != null ? storeDef.getTransformsSerializer()
                                                                                                                                       : new SerializerDefinition("identity"));

        Store<K, V, T> serializedStore = SerializingStore.wrap(store,
                                                               keySerializer,
                                                               valueSerializer,
                                                               transformsSerializer);

        // Add inconsistency resolving decorator, using their inconsistency
        // resolver (if they gave us one)
        InconsistencyResolver<Versioned<V>> secondaryResolver = resolver == null ? new TimeBasedInconsistencyResolver()
                                                                                : resolver;
        serializedStore = new InconsistencyResolvingStore<K, V, T>(serializedStore,
                                                                   new ChainedResolver<Versioned<V>>(new VectorClockInconsistencyResolver(),
                                                                                                     secondaryResolver));
        return serializedStore;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/src/java/voldemort/client/AbstractStoreClientFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    protected void startInner() {
        registerEngine(metadata);

        /* Initialize storage configurations */
        for(String configClassName: voldemortConfig.getStorageConfigurations())
            initStorageConfig(configClassName);

        /* Initialize view storage configuration */
        storageConfigs.put(ViewStorageConfiguration.TYPE_NAME,
                           new ViewStorageConfiguration(voldemortConfig,
                                                        metadata.getStoreDefList(),
                                                        storeRepository));

        /* Register slop store */
        if(voldemortConfig.isSlopEnabled()) {
            StorageConfiguration config = storageConfigs.get(voldemortConfig.getSlopStoreType());
            if(config == null)
                throw new ConfigurationException("Attempt to slop store failed");

            StorageEngine<ByteArray, byte[], byte[]> slopEngine = config.getStore("slop");

            registerEngine(slopEngine);
            storeRepository.setSlopStore(SerializingStorageEngine.wrap(slopEngine,
                                                                       new ByteArraySerializer(),
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550080795/fstmerge_var1_4612050216424464145
                                                                       new SlopSerializer()));
            
            scheduler.schedule(new SlopPusherJob(storeRepository,
                                                 metadata.getCluster(),
                                                 failureDetector,
                                                 voldemortConfig.getSlopMaxWriteBytesPerSec()),
                               new Date(),
                               voldemortConfig.getSlopFrequencyMs());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550080795/fstmerge_base_3274780413331067696
                                                                       new SlopSerializer()));
=======
                                                                       new SlopSerializer(),
                                                                       new IdentitySerializer()));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550080795/fstmerge_var2_3303730693934443348
        }
        List<StoreDefinition> storeDefs = new ArrayList<StoreDefinition>(this.metadata.getStoreDefList());
        logger.info("Initializing stores:");

        // first initialize non-view stores
        for(StoreDefinition def: storeDefs)
            if(!def.isView())
                openStore(def);

        // now that we have all our stores, we can initialize views pointing at
        // those stores
        for(StoreDefinition def: storeDefs)
            if(def.isView())
                openStore(def);

        // enable aggregate jmx statistics
        if(voldemortConfig.isStatTrackingEnabled())
            JmxUtils.registerMbean(new StoreStatsJmx(this.storeStats),
                                   JmxUtils.createObjectName("voldemort.store.stats.aggregate",
                                                             "aggregate-perf"));

        logger.info("All stores initialized.");
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/src/java/voldemort/server/storage/StorageService.java
Conflict type: LineBasedMCFd
Conflict body: 
public void registerNodeStores(StoreDefinition def, Cluster cluster, int localNode) {
        Map<Integer, Store<ByteArray, byte[], byte[]>> nodeStores = new HashMap<Integer, Store<ByteArray, byte[], byte[]>>(cluster.getNumberOfNodes());
        Map<Integer, NonblockingStore> nonblockingStores = new HashMap<Integer, NonblockingStore>(cluster.getNumberOfNodes());
        try {
            for(Node node: cluster.getNodes()) {
                Store<ByteArray, byte[], byte[]> store = getNodeStore(def.getName(),
                                                                      node,
                                                                      localNode);
                this.storeRepository.addNodeStore(node.getId(), store);
                nodeStores.put(node.getId(), store);

                NonblockingStore nonblockingStore = routedStoreFactory.toNonblockingStore(store);
                nonblockingStores.put(node.getId(), nonblockingStore);
            }

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550080805/fstmerge_var1_713933598968426366
            Store<ByteArray, byte[]> store = routedStoreFactory.create(cluster,
                                                                       def,
                                                                       nodeStores,
                                                                       nonblockingStores,
                                                                       null,
                                                                       true,
                                                                       cluster.getNodeById(localNode)
                                                                              .getZoneId(),
                                                                       failureDetector);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550080805/fstmerge_base_7528414416469833832
            Store<ByteArray, byte[]> store = routedStoreFactory.create(cluster,
                                                                       def,
                                                                       nodeStores,
                                                                       nonblockingStores,
                                                                       true,
                                                                       cluster.getNodeById(localNode)
                                                                              .getZoneId(),
                                                                       failureDetector);
=======
            Store<ByteArray, byte[], byte[]> store = routedStoreFactory.create(cluster,
                                                                               def,
                                                                               nodeStores,
                                                                               nonblockingStores,
                                                                               true,
                                                                               cluster.getNodeById(localNode)
                                                                                      .getZoneId(),
                                                                               failureDetector);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550080805/fstmerge_var2_4506359585848363167

            store = new RebootstrappingStore(metadata,
                                             storeRepository,
                                             voldemortConfig,
                                             (RoutedStore) store,
                                             storeFactory);

            store = new InconsistencyResolvingStore<ByteArray, byte[], byte[]>(store,
                                                                               new VectorClockInconsistencyResolver<byte[]>());
            this.storeRepository.addRoutedStore(store);
        } catch(Exception e) {
            // Roll back
            for(Node node: cluster.getNodes())
                this.storeRepository.removeNodeStore(def.getName(), node.getId());
            throw new VoldemortException(e);
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/src/java/voldemort/server/storage/StorageService.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550080854/fstmerge_var1_138861817773427470
public void registerEngine(StorageEngine<ByteArray, byte[]> engine) {
        Cluster cluster = this.metadata.getCluster();
        storeRepository.addStorageEngine(engine);

        /* Now add any store wrappers that are enabled */
        Store<ByteArray, byte[]> store = engine;
        if(voldemortConfig.isVerboseLoggingEnabled())
            store = new LoggingStore<ByteArray, byte[]>(store,
                                                        cluster.getName(),
                                                        SystemTime.INSTANCE);
        if(!"slop".equals(store.getName())) {
            if(voldemortConfig.isRedirectRoutingEnabled())
                store = new RedirectingStore(store,
                                             metadata,
                                             storeRepository,
                                             failureDetector,
                                             storeFactory);

            if(voldemortConfig.isMetadataCheckingEnabled())
                store = new InvalidMetadataCheckingStore(metadata.getNodeId(), store, metadata);
        }

        if(voldemortConfig.isStatTrackingEnabled()) {
            StatTrackingStore<ByteArray, byte[]> statStore = new StatTrackingStore<ByteArray, byte[]>(store,
                                                                                                      this.storeStats);
            store = statStore;
            if(voldemortConfig.isJmxEnabled()) {

                MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
                ObjectName name = JmxUtils.createObjectName(JmxUtils.getPackageName(store.getClass()),
                                                            store.getName());

                synchronized(mbeanServer) {
                    if(mbeanServer.isRegistered(name))
                        JmxUtils.unregisterMbean(mbeanServer, name);
                    JmxUtils.registerMbean(mbeanServer,
                                           JmxUtils.createModelMBean(new StoreStatsJmx(statStore.getStats())),
                                           name);
                }
            }
        }

        storeRepository.addLocalStore(store);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550080854/fstmerge_base_1928724303504390406
public void registerEngine(StorageEngine<ByteArray, byte[]> engine) {
        Cluster cluster = this.metadata.getCluster();
        storeRepository.addStorageEngine(engine);

        /* Now add any store wrappers that are enabled */
        Store<ByteArray, byte[]> store = engine;
        if(voldemortConfig.isVerboseLoggingEnabled())
            store = new LoggingStore<ByteArray, byte[]>(store,
                                                        cluster.getName(),
                                                        SystemTime.INSTANCE);

        if(voldemortConfig.isRedirectRoutingEnabled())
            store = new RedirectingStore(store,
                                         metadata,
                                         storeRepository,
                                         failureDetector,
                                         storeFactory);

        if(voldemortConfig.isMetadataCheckingEnabled())
            store = new InvalidMetadataCheckingStore(metadata.getNodeId(), store, metadata);

        if(voldemortConfig.isStatTrackingEnabled()) {
            StatTrackingStore<ByteArray, byte[]> statStore = new StatTrackingStore<ByteArray, byte[]>(store,
                                                                                                      this.storeStats);
            store = statStore;
            if(voldemortConfig.isJmxEnabled()) {

                MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
                ObjectName name = JmxUtils.createObjectName(JmxUtils.getPackageName(store.getClass()),
                                                            store.getName());

                synchronized(mbeanServer) {
                    if(mbeanServer.isRegistered(name))
                        JmxUtils.unregisterMbean(mbeanServer, name);
                    JmxUtils.registerMbean(mbeanServer,
                                           JmxUtils.createModelMBean(new StoreStatsJmx(statStore.getStats())),
                                           name);
                }
            }
        }

        storeRepository.addLocalStore(store);
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550080854/fstmerge_var2_2983207718166150582

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/src/java/voldemort/server/storage/StorageService.java
Conflict type: LineBasedMCFd
Conflict body: 
public void run() {
        logger.debug("Pushing slop...");
        int slopsPushed = 0;
        int attemptedPushes = 0;
        ClosableIterator<Pair<ByteArray, Versioned<Slop>>> iterator = null;
        try {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550081095/fstmerge_var1_1771079914834441235
            StorageEngine<ByteArray, Slop> slopStore = storeRepo.getSlopStore();
            EventThrottler throttler = new EventThrottler(maxWriteBytesPerSec);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550081095/fstmerge_base_1911758250981499771
            StorageEngine<ByteArray, Slop> slopStore = storeRepo.getSlopStore();
=======
            StorageEngine<ByteArray, Slop, byte[]> slopStore = storeRepo.getSlopStore();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550081095/fstmerge_var2_2976883153064205133
            iterator = slopStore.entries();
            while(iterator.hasNext()) {
                if(Thread.interrupted())
                    throw new InterruptedException("Task cancelled!");
                attemptedPushes++;

                if(attemptedPushes % 1000 == 0)
                    logger.info("Attempted pushing " + attemptedPushes + " slops");

                try {
                    Pair<ByteArray, Versioned<Slop>> keyAndVal = iterator.next();
                    Versioned<Slop> versioned = keyAndVal.getSecond();
                    Slop slop = versioned.getValue();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550081095/fstmerge_var1_1771079914834441235
                    Node node = cluster.getNodeById(slop.getNodeId());
                    if(failureDetector.isAvailable(node)) {
                        Store<ByteArray, byte[]> store = storeRepo.getNodeStore(slop.getStoreName(),
                                                                                node.getId());
                        Long startNs = System.nanoTime();
                        try {
                            int nBytes = slop.getKey().length();
                            if(slop.getOperation() == Operation.PUT) {
                                store.put(slop.getKey(),
                                          new Versioned<byte[]>(slop.getValue(), versioned.getVersion()));
                                nBytes += slop.getValue().length +
                                          ((VectorClock) versioned.getVersion()).sizeInBytes() + 1;

                            }
                            else if(slop.getOperation() == Operation.DELETE)
                                store.delete(slop.getKey(), versioned.getVersion());
                            else
                                logger.error("Unknown slop operation: " + slop.getOperation());
                            failureDetector.recordSuccess(node, deltaMs(startNs));
                            slopStore.delete(slop.makeKey(), versioned.getVersion());
                            slopsPushed++;

                            throttler.maybeThrottle(nBytes);
                        } catch(ObsoleteVersionException e) {
                            // okay it is old, just delete it
                            slopStore.delete(slop.makeKey(), versioned.getVersion());
                        } catch(UnreachableStoreException e) {
                            failureDetector.recordException(node, deltaMs(startNs), e);
                        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550081095/fstmerge_base_1911758250981499771
                    Store<ByteArray, byte[]> store = storeRepo.getNodeStore(slop.getStoreName(),
                                                                            slop.getNodeId());
                    try {
                        if(slop.getOperation() == Operation.PUT)
                            store.put(keyAndVal.getFirst(),
                                      new Versioned<byte[]>(slop.getValue(), versioned.getVersion()));
                        else if(slop.getOperation() == Operation.DELETE)
                            store.delete(keyAndVal.getFirst(), versioned.getVersion());
                        else
                            logger.error("Unknown slop operation: " + slop.getOperation());
                        slopStore.delete(slop.makeKey(), versioned.getVersion());
                        slopsPushed++;
                    } catch(ObsoleteVersionException e) {
                        // okay it is old, just delete it
                        slopStore.delete(slop.makeKey(), versioned.getVersion());
=======
                    Store<ByteArray, byte[], byte[]> store = storeRepo.getNodeStore(slop.getStoreName(),
                                                                                    slop.getNodeId());
                    try {
                        if(slop.getOperation() == Operation.PUT)
                            store.put(keyAndVal.getFirst(),
                                      new Versioned<byte[]>(slop.getValue(), versioned.getVersion()),
                                      slop.getTransforms());
                        else if(slop.getOperation() == Operation.DELETE)
                            store.delete(keyAndVal.getFirst(), versioned.getVersion());
                        else
                            logger.error("Unknown slop operation: " + slop.getOperation());
                        slopStore.delete(slop.makeKey(), versioned.getVersion());
                        slopsPushed++;
                    } catch(ObsoleteVersionException e) {
                        // okay it is old, just delete it
                        slopStore.delete(slop.makeKey(), versioned.getVersion());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550081095/fstmerge_var2_2976883153064205133
                    }
                } catch(Exception e) {
                    logger.error(e);
                }
            }
        } catch(Exception e) {
            logger.error(e);
        } finally {
            try {
                if(iterator != null)
                    iterator.close();
            } catch(Exception e) {
                logger.error("Failed to close iterator.", e);
            }
        }

        // typically not useful to hear that 0 items were attempted so log as
        // debug
        logger.log(attemptedPushes > 0 ? Level.INFO : Level.DEBUG,
                   "Attempted " + attemptedPushes + " hinted handoff pushes of which "
                           + slopsPushed + " succeeded.");
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/src/java/voldemort/server/scheduler/SlopPusherJob.java
Conflict type: LineBasedMCFd
Conflict body: 
public StoreDefinition build() {
        return new StoreDefinition(this.getName(),
                                   this.getType(),
                                   this.getKeySerializer(),
                                   this.getValueSerializer(),
                                   this.getTransformsSerializer(),
                                   this.getRoutingPolicy(),
                                   this.getRoutingStrategyType(),
                                   this.getReplicationFactor(),
                                   this.getPreferredReads(),
                                   this.getRequiredReads(),
                                   this.getPreferredWrites(),
                                   this.getRequiredWrites(),
                                   this.getViewOf(),
                                   this.getView(),
                                   this.getZoneReplicationFactor(),
                                   this.getZoneCountReads(),
                                   this.getZoneCountWrites(),
                                   this.getRetentionPeriodDays(),
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550083662/fstmerge_var1_649435773811760476
                                   this.getRetentionScanThrottleRate(),
                                   this.isHintedHandoffEnabled(),
                                   this.getHintedHandoffStrategy(),
                                   this.getHintPrefListSize());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550083662/fstmerge_base_5985452665498850640
                                   this.getRetentionScanThrottleRate());
=======
                                   this.getRetentionScanThrottleRate(),
                                   this.getSerializerFactory());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550083662/fstmerge_var2_5532317381063215621
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/src/java/voldemort/store/StoreDefinitionBuilder.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public boolean equals(Object o) {
        if(this == o)
            return true;
        else if(o == null)
            return false;
        else if(!(o.getClass() == StoreDefinition.class))
            return false;

        StoreDefinition def = (StoreDefinition) o;
        return getName().equals(def.getName())
               && getType().equals(def.getType())
               && getReplicationFactor() == def.getReplicationFactor()
               && getRequiredReads() == def.getRequiredReads()
               && Objects.equal(getPreferredReads(), def.getPreferredReads())
               && getRequiredWrites() == def.getRequiredWrites()
               && Objects.equal(getPreferredWrites(), def.getPreferredWrites())
               && getKeySerializer().equals(def.getKeySerializer())
               && getValueSerializer().equals(def.getValueSerializer())
               && Objects.equal(getTransformsSerializer() != null ? getTransformsSerializer()
                                                                 : null,
                                def.getTransformsSerializer() != null ? def.getTransformsSerializer()
                                                                     : null)
               && getRoutingPolicy() == def.getRoutingPolicy()
               && Objects.equal(getViewTargetStoreName(), def.getViewTargetStoreName())
               && Objects.equal(getValueTransformation() != null ? getValueTransformation().getClass()
                                                                : null,
                                def.getValueTransformation() != null ? def.getValueTransformation()
                                                                          .getClass() : null)
               && Objects.equal(getZoneReplicationFactor() != null ? getZoneReplicationFactor().getClass()
                                                                  : null,
                                def.getZoneReplicationFactor() != null ? def.getZoneReplicationFactor()
                                                                            .getClass()
                                                                      : null)
               && Objects.equal(getZoneCountReads(), def.getZoneCountReads())
               && Objects.equal(getZoneCountWrites(), def.getZoneCountWrites())
               && Objects.equal(getRetentionDays(), def.getRetentionDays())
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550083824/fstmerge_var1_5333049653226923303
               && Objects.equal(getRetentionScanThrottleRate(), def.getRetentionScanThrottleRate())
               && Objects.equal(isHintedHandoffEnabled(), def.isHintedHandoffEnabled())
               && Objects.equal(getHintedHandoffStrategyType(), def.getHintedHandoffStrategyType())
               && Objects.equal(getHintPrefListSize(), def.getHintPrefListSize());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550083824/fstmerge_base_3428412356153768392
               && Objects.equal(getRetentionScanThrottleRate(), def.getRetentionScanThrottleRate());
=======
               && Objects.equal(getRetentionScanThrottleRate(), def.getRetentionScanThrottleRate())
               && Objects.equal(getSerializerFactory() != null ? getSerializerFactory() : null,
                                def.getSerializerFactory() != null ? def.getSerializerFactory()
                                                                  : null);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550083824/fstmerge_var2_1155093535099676185
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/src/java/voldemort/store/StoreDefinition.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public int hashCode() {
        return Objects.hashCode(getName(),
                                getType(),
                                getKeySerializer(),
                                getValueSerializer(),
                                getTransformsSerializer(),
                                getRoutingPolicy(),
                                getRoutingStrategyType(),
                                getReplicationFactor(),
                                getRequiredReads(),
                                getRequiredWrites(),
                                getPreferredReads(),
                                getPreferredWrites(),
                                getViewTargetStoreName(),
                                getValueTransformation() == null ? null
                                                                : getValueTransformation().getClass(),
                                getZoneReplicationFactor() == null ? null
                                                                  : getZoneReplicationFactor().getClass(),
                                getZoneCountReads(),
                                getZoneCountWrites(),
                                getRetentionDays(),
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550083828/fstmerge_var1_2081881110099799536
                                getRetentionScanThrottleRate(),
                                isHintedHandoffEnabled(),
                                hasHintedHandoffStrategyType() ? getHintedHandoffStrategyType() : null,
                                hasHintPreflistSize() ? getHintPrefListSize() : null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550083828/fstmerge_base_5315370773315728506
                                getRetentionScanThrottleRate());
=======
                                getRetentionScanThrottleRate(),
                                getSerializerFactory());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550083828/fstmerge_var2_5418875214522099485
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/src/java/voldemort/store/StoreDefinition.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public String toString() {
        return "StoreDefinition(name = " + getName() + ", type = " + getType()
               + ", key-serializer = " + getKeySerializer() + ", value-serializer = "
               + getValueSerializer() + ", routing = " + getRoutingPolicy()
               + ", routing-strategy = " + getRoutingStrategyType() + ", replication = "
               + getReplicationFactor() + ", required-reads = " + getRequiredReads()
               + ", preferred-reads = " + getPreferredReads() + ", required-writes = "
               + getRequiredWrites() + ", preferred-writes = " + getPreferredWrites()
               + ", view-target = " + getViewTargetStoreName() + ", value-transformation = "
               + getValueTransformation() + ", retention-days = " + getRetentionDays()
               + ", throttle-rate = " + getRetentionScanThrottleRate() + ", zone-count-reads = "
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550083831/fstmerge_var1_3582925647402270053
               + getZoneCountReads() + ", zone-count-writes = " + getZoneCountWrites()
               + ", enable-hinted-handoff = " + isHintedHandoffEnabled()
               + ", hinted-handoff-strategy = " + getHintedHandoffStrategyType()
               + ", hint-preflist-size = " + getHintPrefListSize() + ")";
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550083831/fstmerge_base_6904893173351547083
               + getZoneCountReads() + ", zone-count-writes = " + getZoneCountWrites() + ")";
=======
               + getZoneCountReads() + ", zone-count-writes = " + getZoneCountWrites()
               + ", serializer factory = " + getSerializerFactory() + ")";
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550083831/fstmerge_var2_3643100622113142439
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/src/java/voldemort/store/StoreDefinition.java
Conflict type: LineBasedMCFd
Conflict body: 
public boolean delete(final ByteArray key, final Version version) throws VoldemortException {
        StoreUtils.assertValidKey(key);

        BasicPipelineData<Boolean> pipelineData = new BasicPipelineData<Boolean>();
        if(zoneRoutingEnabled)
            pipelineData.setZonesRequired(storeDef.getZoneCountWrites());
        else
            pipelineData.setZonesRequired(null);
        pipelineData.setStoreName(name);
        Pipeline pipeline = new Pipeline(Operation.DELETE, timeoutMs, TimeUnit.MILLISECONDS);
        pipeline.setEnableHintedHandoff(isHintedHandoffEnabled());

        HintedHandoff hintedHandoff = null;

        if(isHintedHandoffEnabled())
            hintedHandoff = new HintedHandoff(failureDetector,
                                              slopStores,
                                              handoffStrategy,
                                              pipelineData.getFailedNodes());

        StoreRequest<Boolean> blockingDelete = new StoreRequest<Boolean>() {

            public Boolean request(Store<ByteArray, byte[], byte[]> store) {
                return store.delete(key, version);
            }

        };

        pipeline.addEventAction(Event.STARTED,
                                new ConfigureNodes<Boolean, BasicPipelineData<Boolean>>(pipelineData,
                                                                                        Event.CONFIGURED,
                                                                                        failureDetector,
                                                                                        storeDef.getRequiredWrites(),
                                                                                        routingStrategy,
                                                                                        key,
                                                                                        clientZone));
        pipeline.addEventAction(Event.CONFIGURED,
                                new PerformParallelRequests<Boolean, BasicPipelineData<Boolean>>(pipelineData,
                                                                                                 isHintedHandoffEnabled()
                                                                                                 ? Event.RESPONSES_RECEIVED
                                                                                                 : Event.COMPLETED,
                                                                                                 key,
                                                                                                 failureDetector,
                                                                                                 storeDef.getPreferredWrites(),
                                                                                                 storeDef.getRequiredWrites(),
                                                                                                 timeoutMs,
                                                                                                 nonblockingStores,
                                                                                                 hintedHandoff,
                                                                                                 version,
                                                                                                 Event.INSUFFICIENT_SUCCESSES,
                                                                                                 Event.INSUFFICIENT_ZONES));
        pipeline.addEventAction(Event.INSUFFICIENT_SUCCESSES,
                                new PerformSerialRequests<Boolean, BasicPipelineData<Boolean>>(pipelineData,
                                                                                               isHintedHandoffEnabled()
                                                                                               ? Event.RESPONSES_RECEIVED
                                                                                               : Event.COMPLETED,
                                                                                               key,
                                                                                               failureDetector,
                                                                                               innerStores,
                                                                                               storeDef.getPreferredWrites(),
                                                                                               storeDef.getRequiredWrites(),
                                                                                               blockingDelete,
                                                                                               null));

        if(zoneRoutingEnabled)
            pipeline.addEventAction(Event.INSUFFICIENT_ZONES,
                                    new PerformZoneSerialRequests<Boolean, BasicPipelineData<Boolean>>(pipelineData,
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086033/fstmerge_var1_3819575518090529697
                                                                                                       isHintedHandoffEnabled()
                                                                                                       ? Event.RESPONSES_RECEIVED
                                                                                                       : Event.COMPLETED,
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086033/fstmerge_base_216860825593682400
                                                                                                       repairReads ? Event.RESPONSES_RECEIVED
                                                                                                                  : Event.COMPLETED,
=======
                                                                                                       Event.COMPLETED,
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086033/fstmerge_var2_1019383353802864741
                                                                                                       key,
                                                                                                       failureDetector,
                                                                                                       innerStores,
                                                                                                       blockingDelete));

        if(isHintedHandoffEnabled()) {
            pipeline.addEventAction(Event.RESPONSES_RECEIVED, new PerformDeleteHintedHandoff(pipelineData,
                                                                                             Event.COMPLETED,
                                                                                             key,
                                                                                             version,
                                                                                             hintedHandoff));
            pipeline.addEventAction(Event.ABORTED, new PerformDeleteHintedHandoff(pipelineData,
                                                                                  Event.ERROR,
                                                                                  key,
                                                                                  version,
                                                                                  hintedHandoff));
        }
        
        pipeline.addEvent(Event.STARTED);
        pipeline.execute();

        if(pipelineData.getFatalError() != null)
            throw pipelineData.getFatalError();

        for(Response<ByteArray, Boolean> response: pipelineData.getResponses()) {
            if(response.getValue().booleanValue())
                return true;
        }

        return false;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/src/java/voldemort/store/routed/PipelineRoutedStore.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086043/fstmerge_var1_2723241355912068105
public List<Versioned<byte[]>> get(final ByteArray key) {
        StoreUtils.assertValidKey(key);

        BasicPipelineData<List<Versioned<byte[]>>> pipelineData = new BasicPipelineData<List<Versioned<byte[]>>>();
        if(zoneRoutingEnabled)
            pipelineData.setZonesRequired(storeDef.getZoneCountReads());
        else
            pipelineData.setZonesRequired(null);

        final Pipeline pipeline = new Pipeline(Operation.GET, timeoutMs, TimeUnit.MILLISECONDS);

        StoreRequest<List<Versioned<byte[]>>> blockingStoreRequest = new StoreRequest<List<Versioned<byte[]>>>() {

            public List<Versioned<byte[]>> request(Store<ByteArray, byte[]> store) {
                return store.get(key);
            }

        };

        pipeline.addEventAction(Event.STARTED,
                                new ConfigureNodes<List<Versioned<byte[]>>, BasicPipelineData<List<Versioned<byte[]>>>>(pipelineData,
                                                                                                                        Event.CONFIGURED,
                                                                                                                        failureDetector,
                                                                                                                        storeDef.getRequiredReads(),
                                                                                                                        routingStrategy,
                                                                                                                        key,
                                                                                                                        clientZone));
        pipeline.addEventAction(Event.CONFIGURED,
                                new PerformParallelRequests<List<Versioned<byte[]>>, BasicPipelineData<List<Versioned<byte[]>>>>(pipelineData,
                                                                                                                                 repairReads ? Event.RESPONSES_RECEIVED
                                                                                                                                            : Event.COMPLETED,
                                                                                                                                 key,
                                                                                                                                 failureDetector,
                                                                                                                                 storeDef.getPreferredReads(),
                                                                                                                                 storeDef.getRequiredReads(),
                                                                                                                                 timeoutMs,
                                                                                                                                 nonblockingStores,
                                                                                                                                 null,
                                                                                                                                 null,
                                                                                                                                 Event.INSUFFICIENT_SUCCESSES,
                                                                                                                                 Event.INSUFFICIENT_ZONES));
        pipeline.addEventAction(Event.INSUFFICIENT_SUCCESSES,
                                new PerformSerialRequests<List<Versioned<byte[]>>, BasicPipelineData<List<Versioned<byte[]>>>>(pipelineData,
                                                                                                                               repairReads ? Event.RESPONSES_RECEIVED
                                                                                                                                           : Event.COMPLETED,
                                                                                                                               key,
                                                                                                                               failureDetector,
                                                                                                                               innerStores,
                                                                                                                               storeDef.getPreferredReads(),
                                                                                                                               storeDef.getRequiredReads(),
                                                                                                                               blockingStoreRequest,
                                                                                                                               null));

        if(repairReads)
            pipeline.addEventAction(Event.RESPONSES_RECEIVED,
                                    new ReadRepair<BasicPipelineData<List<Versioned<byte[]>>>>(pipelineData,
                                                                                               Event.COMPLETED,
                                                                                               storeDef.getPreferredReads(),
                                                                                               timeoutMs,
                                                                                               nonblockingStores,
                                                                                               readRepairer));

        if(zoneRoutingEnabled)
            pipeline.addEventAction(Event.INSUFFICIENT_ZONES,
                                    new PerformZoneSerialRequests<List<Versioned<byte[]>>, BasicPipelineData<List<Versioned<byte[]>>>>(pipelineData,
                                                                                                                                       repairReads ? Event.RESPONSES_RECEIVED
                                                                                                                                                   : Event.COMPLETED,
                                                                                                                                       key,
                                                                                                                                       failureDetector,
                                                                                                                                       innerStores,
                                                                                                                                       blockingStoreRequest));

        pipeline.addEvent(Event.STARTED);
        pipeline.execute();

        if(pipelineData.getFatalError() != null)
            throw pipelineData.getFatalError();

        List<Versioned<byte[]>> results = new ArrayList<Versioned<byte[]>>();

        for(Response<ByteArray, List<Versioned<byte[]>>> response: pipelineData.getResponses()) {
            List<Versioned<byte[]>> value = response.getValue();

            if(value != null)
                results.addAll(value);
        }

        return results;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086043/fstmerge_base_5071896319572910095
public List<Versioned<byte[]>> get(final ByteArray key) {
        StoreUtils.assertValidKey(key);

        BasicPipelineData<List<Versioned<byte[]>>> pipelineData = new BasicPipelineData<List<Versioned<byte[]>>>();
        if(zoneRoutingEnabled)
            pipelineData.setZonesRequired(storeDef.getZoneCountReads());
        else
            pipelineData.setZonesRequired(null);

        final Pipeline pipeline = new Pipeline(Operation.GET, timeoutMs, TimeUnit.MILLISECONDS);

        NonblockingStoreRequest nonblockingStoreRequest = new NonblockingStoreRequest() {

            public void submit(Node node, NonblockingStore store, NonblockingStoreCallback callback) {
                store.submitGetRequest(key, callback);
            }

        };

        StoreRequest<List<Versioned<byte[]>>> blockingStoreRequest = new StoreRequest<List<Versioned<byte[]>>>() {

            public List<Versioned<byte[]>> request(Store<ByteArray, byte[]> store) {
                return store.get(key);
            }

        };

        pipeline.addEventAction(Event.STARTED,
                                new ConfigureNodes<List<Versioned<byte[]>>, BasicPipelineData<List<Versioned<byte[]>>>>(pipelineData,
                                                                                                                        Event.CONFIGURED,
                                                                                                                        failureDetector,
                                                                                                                        storeDef.getRequiredReads(),
                                                                                                                        routingStrategy,
                                                                                                                        key,
                                                                                                                        clientZone));
        pipeline.addEventAction(Event.CONFIGURED,
                                new PerformParallelRequests<List<Versioned<byte[]>>, BasicPipelineData<List<Versioned<byte[]>>>>(pipelineData,
                                                                                                                                 repairReads ? Event.RESPONSES_RECEIVED
                                                                                                                                            : Event.COMPLETED,
                                                                                                                                 key,
                                                                                                                                 failureDetector,
                                                                                                                                 storeDef.getPreferredReads(),
                                                                                                                                 storeDef.getRequiredReads(),
                                                                                                                                 timeoutMs,
                                                                                                                                 nonblockingStores,
                                                                                                                                 nonblockingStoreRequest,
                                                                                                                                 Event.INSUFFICIENT_SUCCESSES,
                                                                                                                                 Event.INSUFFICIENT_ZONES));
        pipeline.addEventAction(Event.INSUFFICIENT_SUCCESSES,
                                new PerformSerialRequests<List<Versioned<byte[]>>, BasicPipelineData<List<Versioned<byte[]>>>>(pipelineData,
                                                                                                                               repairReads ? Event.RESPONSES_RECEIVED
                                                                                                                                          : Event.COMPLETED,
                                                                                                                               key,
                                                                                                                               failureDetector,
                                                                                                                               innerStores,
                                                                                                                               storeDef.getPreferredReads(),
                                                                                                                               storeDef.getRequiredReads(),
                                                                                                                               blockingStoreRequest,
                                                                                                                               null));

        if(repairReads)
            pipeline.addEventAction(Event.RESPONSES_RECEIVED,
                                    new ReadRepair<BasicPipelineData<List<Versioned<byte[]>>>>(pipelineData,
                                                                                               Event.COMPLETED,
                                                                                               storeDef.getPreferredReads(),
                                                                                               nonblockingStores,
                                                                                               readRepairer));

        if(zoneRoutingEnabled)
            pipeline.addEventAction(Event.INSUFFICIENT_ZONES,
                                    new PerformZoneSerialRequests<List<Versioned<byte[]>>, BasicPipelineData<List<Versioned<byte[]>>>>(pipelineData,
                                                                                                                                       repairReads ? Event.RESPONSES_RECEIVED
                                                                                                                                                  : Event.COMPLETED,
                                                                                                                                       key,
                                                                                                                                       failureDetector,
                                                                                                                                       innerStores,
                                                                                                                                       blockingStoreRequest));

        pipeline.addEvent(Event.STARTED);
        pipeline.execute();

        if(pipelineData.getFatalError() != null)
            throw pipelineData.getFatalError();

        List<Versioned<byte[]>> results = new ArrayList<Versioned<byte[]>>();

        for(Response<ByteArray, List<Versioned<byte[]>>> response: pipelineData.getResponses()) {
            List<Versioned<byte[]>> value = response.getValue();

            if(value != null)
                results.addAll(value);
        }

        return results;
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086043/fstmerge_var2_6083652432691965717

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/src/java/voldemort/store/routed/PipelineRoutedStore.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086048/fstmerge_var1_6217679074429111603
public Map<ByteArray, List<Versioned<byte[]>>> getAll(Iterable<ByteArray> keys)
            throws VoldemortException {
        StoreUtils.assertValidKeys(keys);

        GetAllPipelineData pipelineData = new GetAllPipelineData();
        if(zoneRoutingEnabled)
            pipelineData.setZonesRequired(storeDef.getZoneCountReads());
        else
            pipelineData.setZonesRequired(null);
        Pipeline pipeline = new Pipeline(Operation.GET_ALL, timeoutMs, TimeUnit.MILLISECONDS);

        pipeline.addEventAction(Event.STARTED,
                                new GetAllConfigureNodes(pipelineData,
                                                         Event.CONFIGURED,
                                                         failureDetector,
                                                         storeDef.getPreferredReads(),
                                                         storeDef.getRequiredReads(),
                                                         routingStrategy,
                                                         keys,
                                                         clientZone));
        pipeline.addEventAction(Event.CONFIGURED,
                                new PerformParallelGetAllRequests(pipelineData,
                                                                  Event.INSUFFICIENT_SUCCESSES,
                                                                  failureDetector,
                                                                  timeoutMs,
                                                                  nonblockingStores));
        pipeline.addEventAction(Event.INSUFFICIENT_SUCCESSES,
                                new PerformSerialGetAllRequests(pipelineData,
                                                                repairReads ? Event.RESPONSES_RECEIVED
                                                                            : Event.COMPLETED,
                                                                keys,
                                                                failureDetector,
                                                                innerStores,
                                                                storeDef.getPreferredReads(),
                                                                storeDef.getRequiredReads()));

        if(repairReads)
            pipeline.addEventAction(Event.RESPONSES_RECEIVED,
                                    new GetAllReadRepair(pipelineData,
                                                         Event.COMPLETED,
                                                         storeDef.getPreferredReads(),
                                                         timeoutMs,
                                                         nonblockingStores,
                                                         readRepairer));

        pipeline.addEvent(Event.STARTED);
        pipeline.execute();

        if(pipelineData.getFatalError() != null)
            throw pipelineData.getFatalError();

        return pipelineData.getResult();
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086048/fstmerge_base_2423337181652438637
public Map<ByteArray, List<Versioned<byte[]>>> getAll(Iterable<ByteArray> keys)
            throws VoldemortException {
        StoreUtils.assertValidKeys(keys);

        GetAllPipelineData pipelineData = new GetAllPipelineData();
        if(zoneRoutingEnabled)
            pipelineData.setZonesRequired(storeDef.getZoneCountReads());
        else
            pipelineData.setZonesRequired(null);
        Pipeline pipeline = new Pipeline(Operation.GET_ALL, timeoutMs, TimeUnit.MILLISECONDS);

        pipeline.addEventAction(Event.STARTED,
                                new GetAllConfigureNodes(pipelineData,
                                                         Event.CONFIGURED,
                                                         failureDetector,
                                                         storeDef.getPreferredReads(),
                                                         storeDef.getRequiredReads(),
                                                         routingStrategy,
                                                         keys,
                                                         clientZone));
        pipeline.addEventAction(Event.CONFIGURED,
                                new PerformParallelGetAllRequests(pipelineData,
                                                                  Event.INSUFFICIENT_SUCCESSES,
                                                                  failureDetector,
                                                                  timeoutMs,
                                                                  nonblockingStores));
        pipeline.addEventAction(Event.INSUFFICIENT_SUCCESSES,
                                new PerformSerialGetAllRequests(pipelineData,
                                                                repairReads ? Event.RESPONSES_RECEIVED
                                                                           : Event.COMPLETED,
                                                                keys,
                                                                failureDetector,
                                                                innerStores,
                                                                storeDef.getPreferredReads(),
                                                                storeDef.getRequiredReads()));

        if(repairReads)
            pipeline.addEventAction(Event.RESPONSES_RECEIVED,
                                    new GetAllReadRepair(pipelineData,
                                                         Event.COMPLETED,
                                                         storeDef.getPreferredReads(),
                                                         nonblockingStores,
                                                         readRepairer));

        pipeline.addEvent(Event.STARTED);
        pipeline.execute();

        if(pipelineData.getFatalError() != null)
            throw pipelineData.getFatalError();

        return pipelineData.getResult();
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086048/fstmerge_var2_4036238074795295196

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/src/java/voldemort/store/routed/PipelineRoutedStore.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086054/fstmerge_var1_6414203484173447760
public void put(ByteArray key, Versioned<byte[]> versioned) throws VoldemortException {
        StoreUtils.assertValidKey(key);
        PutPipelineData pipelineData = new PutPipelineData();
        if(zoneRoutingEnabled)
            pipelineData.setZonesRequired(storeDef.getZoneCountWrites());
        else
            pipelineData.setZonesRequired(null);
        pipelineData.setStartTimeNs(System.nanoTime());
        pipelineData.setStoreName(name);

        Pipeline pipeline = new Pipeline(Operation.PUT, timeoutMs, TimeUnit.MILLISECONDS);
        pipeline.setEnableHintedHandoff(isHintedHandoffEnabled());

        HintedHandoff hintedHandoff = null;


        if(isHintedHandoffEnabled())
            hintedHandoff = new HintedHandoff(failureDetector,
                                              slopStores,
                                              handoffStrategy,
                                              pipelineData.getFailedNodes());

        pipeline.addEventAction(Event.STARTED,
                                new ConfigureNodes<Void, PutPipelineData>(pipelineData,
                                                                          Event.CONFIGURED,
                                                                          failureDetector,
                                                                          storeDef.getRequiredWrites(),
                                                                          routingStrategy,
                                                                          key,
                                                                          clientZone));
        pipeline.addEventAction(Event.CONFIGURED,
                                new PerformSerialPutRequests(pipelineData,
                                                             isHintedHandoffEnabled()
                                                             ? Event.RESPONSES_RECEIVED
                                                             : Event.COMPLETED,
                                                             key,
                                                             failureDetector,
                                                             innerStores,
                                                             storeDef.getRequiredWrites(),
                                                             versioned,
                                                             time,
                                                             Event.MASTER_DETERMINED));
        pipeline.addEventAction(Event.MASTER_DETERMINED,
                                new PerformParallelPutRequests(pipelineData,
                                                               Event.RESPONSES_RECEIVED,
                                                               key,
                                                               failureDetector,
                                                               storeDef.getPreferredWrites(),
                                                               storeDef.getRequiredWrites(),
                                                               timeoutMs,
                                                               nonblockingStores,
                                                               hintedHandoff));
        if(isHintedHandoffEnabled()) {
            pipeline.addEventAction(Event.ABORTED, new PerformPutHintedHandoff(pipelineData,
                                                                               Event.ERROR,
                                                                               key,
                                                                               versioned,
                                                                               hintedHandoff,
                                                                               time));
            pipeline.addEventAction(Event.RESPONSES_RECEIVED, new PerformPutHintedHandoff(pipelineData,
                                                                                          Event.HANDOFF_FINISHED,
                                                                                          key,
                                                                                          versioned,
                                                                                          hintedHandoff,
                                                                                          time));
            pipeline.addEventAction(Event.HANDOFF_FINISHED, new IncrementClock(pipelineData,
                                                                               Event.COMPLETED,
                                                                               versioned,
                                                                               time));
        } else
            pipeline.addEventAction(Event.RESPONSES_RECEIVED, new IncrementClock(pipelineData,
                                                                                 Event.COMPLETED,
                                                                                 versioned,
                                                                                 time));

        pipeline.addEvent(Event.STARTED);
        pipeline.execute();

        if(pipelineData.getFatalError() != null)
            throw pipelineData.getFatalError();
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086054/fstmerge_base_7284241586477650355
public void put(ByteArray key, Versioned<byte[]> versioned) throws VoldemortException {
        StoreUtils.assertValidKey(key);

        PutPipelineData pipelineData = new PutPipelineData();
        if(zoneRoutingEnabled)
            pipelineData.setZonesRequired(storeDef.getZoneCountWrites());
        else
            pipelineData.setZonesRequired(null);
        pipelineData.setStartTimeNs(System.nanoTime());

        Pipeline pipeline = new Pipeline(Operation.PUT, timeoutMs, TimeUnit.MILLISECONDS);

        pipeline.addEventAction(Event.STARTED,
                                new ConfigureNodes<Void, PutPipelineData>(pipelineData,
                                                                          Event.CONFIGURED,
                                                                          failureDetector,
                                                                          storeDef.getRequiredWrites(),
                                                                          routingStrategy,
                                                                          key,
                                                                          clientZone));
        pipeline.addEventAction(Event.CONFIGURED,
                                new PerformSerialPutRequests(pipelineData,
                                                             Event.COMPLETED,
                                                             key,
                                                             failureDetector,
                                                             innerStores,
                                                             storeDef.getRequiredWrites(),
                                                             versioned,
                                                             time,
                                                             Event.MASTER_DETERMINED));
        pipeline.addEventAction(Event.MASTER_DETERMINED,
                                new PerformParallelPutRequests(pipelineData,
                                                               Event.RESPONSES_RECEIVED,
                                                               key,
                                                               failureDetector,
                                                               storeDef.getPreferredWrites(),
                                                               storeDef.getRequiredWrites(),
                                                               timeoutMs,
                                                               nonblockingStores));
        pipeline.addEventAction(Event.RESPONSES_RECEIVED, new IncrementClock(pipelineData,
                                                                             Event.COMPLETED,
                                                                             versioned,
                                                                             time));

        pipeline.addEvent(Event.STARTED);
        pipeline.execute();

        if(pipelineData.getFatalError() != null)
            throw pipelineData.getFatalError();
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086054/fstmerge_var2_1800661457000879501

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/src/java/voldemort/store/routed/PipelineRoutedStore.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086447/fstmerge_var1_7881050964885342687
public RoutedStore create(Cluster cluster,
                              StoreDefinition storeDefinition,
                              Map<Integer, Store<ByteArray, byte[]>> nodeStores,
                              boolean repairReads,
                              FailureDetector failureDetector) {
        Map<Integer, NonblockingStore> nonblockingStores = Maps.newHashMap();

        for(Map.Entry<Integer, Store<ByteArray, byte[]>> entry: nodeStores.entrySet())
            nonblockingStores.put(entry.getKey(), toNonblockingStore(entry.getValue()));

        return create(cluster,
                      storeDefinition,
                      nodeStores,
                      nonblockingStores,
                      null,
                      repairReads,
                      Zone.DEFAULT_ZONE_ID,
                      failureDetector);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086447/fstmerge_base_483308126427525034
public RoutedStore create(Cluster cluster,
                              StoreDefinition storeDefinition,
                              Map<Integer, Store<ByteArray, byte[]>> nodeStores,
                              boolean repairReads,
                              FailureDetector failureDetector) {
        Map<Integer, NonblockingStore> nonblockingStores = Maps.newHashMap();

        for(Map.Entry<Integer, Store<ByteArray, byte[]>> entry: nodeStores.entrySet())
            nonblockingStores.put(entry.getKey(), toNonblockingStore(entry.getValue()));

        return create(cluster,
                      storeDefinition,
                      nodeStores,
                      nonblockingStores,
                      repairReads,
                      Zone.DEFAULT_ZONE_ID,
                      failureDetector);
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086447/fstmerge_var2_2896457277372939995

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/src/java/voldemort/store/routed/RoutedStoreFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
public void execute(Pipeline pipeline) {
        insertNodeValues();

        if(nodeValues.size() > 1 && preferred > 1) {
            List<NodeValue<ByteArray, byte[]>> toReadRepair = Lists.newArrayList();

            /*
             * We clone after computing read repairs in the assumption that the
             * output will be smaller than the input. Note that we clone the
             * version, but not the key or value as the latter two are not
             * mutated.
             */
            for(NodeValue<ByteArray, byte[]> v: readRepairer.getRepairs(nodeValues)) {
                Versioned<byte[]> versioned = Versioned.value(v.getVersioned().getValue(),
                                                              ((VectorClock) v.getVersion()).clone());
                toReadRepair.add(new NodeValue<ByteArray, byte[]>(v.getNodeId(),
                                                                  v.getKey(),
                                                                  versioned));
            }

            for(NodeValue<ByteArray, byte[]> v: toReadRepair) {
                try {
                    if(logger.isDebugEnabled())
                        logger.debug("Doing read repair on node " + v.getNodeId() + " for key '"
                                     + v.getKey() + "' with version " + v.getVersion() + ".");

                    NonblockingStore store = nonblockingStores.get(v.getNodeId());
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086490/fstmerge_var1_8023338564794790818
                    store.submitPutRequest(v.getKey(), v.getVersioned(), null, timeoutMs);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086490/fstmerge_base_8415982562725948047
                    store.submitPutRequest(v.getKey(), v.getVersioned(), null);
=======
                    store.submitPutRequest(v.getKey(), v.getVersioned(), null, null);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086490/fstmerge_var2_8980640755151519438
                } catch(VoldemortApplicationException e) {
                    if(logger.isDebugEnabled())
                        logger.debug("Read repair cancelled due to application level exception on node "
                                     + v.getNodeId()
                                     + " for key '"
                                     + v.getKey()
                                     + "' with version " + v.getVersion() + ": " + e.getMessage());
                } catch(Exception e) {
                    logger.debug("Read repair failed: ", e);
                }
            }
        }

        pipeline.addEvent(completeEvent);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/src/java/voldemort/store/routed/action/AbstractReadRepair.java
Conflict type: LineBasedMCFd
Conflict body: 
@SuppressWarnings("unchecked")
    public void execute(final Pipeline pipeline) {
        int attempts = pipelineData.getNodeToKeysMap().size();
        final Map<Integer, Response<Iterable<ByteArray>, Object>> responses = new ConcurrentHashMap<Integer, Response<Iterable<ByteArray>, Object>>();
        final CountDownLatch latch = new CountDownLatch(attempts);

        if(logger.isTraceEnabled())
            logger.trace("Attempting " + attempts + " " + pipeline.getOperation().getSimpleName()
                         + " operations in parallel");

        Map<ByteArray, byte[]> transforms = pipelineData.getTransforms();

        for(Map.Entry<Node, List<ByteArray>> entry: pipelineData.getNodeToKeysMap().entrySet()) {
            final Node node = entry.getKey();
            final Collection<ByteArray> keys = entry.getValue();

            NonblockingStoreCallback callback = new NonblockingStoreCallback() {

                public void requestComplete(Object result, long requestTime) {
                    if(logger.isTraceEnabled())
                        logger.trace(pipeline.getOperation().getSimpleName()
                                     + " response received (" + requestTime + " ms.) from node "
                                     + node.getId());

                    Response<Iterable<ByteArray>, Object> response = new Response<Iterable<ByteArray>, Object>(node,
                                                                                                               keys,
                                                                                                               result,
                                                                                                               requestTime);
                    responses.put(node.getId(), response);
                    latch.countDown();

                    // Note errors that come in after the pipeline has finished.
                    // These will *not* get a chance to be called in the loop of
                    // responses below.
                    if(pipeline.isFinished() && response.getValue() instanceof Exception)
                        handleResponseError(response, pipeline, failureDetector);
                }

            };

            if(logger.isTraceEnabled())
                logger.trace("Submitting " + pipeline.getOperation().getSimpleName()
                             + " request on node " + node.getId());

            NonblockingStore store = nonblockingStores.get(node.getId());
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086567/fstmerge_var1_2088854922165444761
            store.submitGetAllRequest(keys, callback, timeoutMs);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086567/fstmerge_base_3853551017073540330
            store.submitGetAllRequest(keys, callback);
=======
            store.submitGetAllRequest(keys, transforms, callback);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086567/fstmerge_var2_8025242418012073520
        }

        try {
            latch.await(timeoutMs * 3, TimeUnit.MILLISECONDS);
        } catch(InterruptedException e) {
            if(logger.isEnabledFor(Level.WARN))
                logger.warn(e, e);
        }

        for(Response<Iterable<ByteArray>, Object> response: responses.values()) {
            if(response.getValue() instanceof Exception) {
                if(handleResponseError(response, pipeline, failureDetector))
                    return;
            } else {
                Map<ByteArray, List<Versioned<byte[]>>> values = (Map<ByteArray, List<Versioned<byte[]>>>) response.getValue();

                for(ByteArray key: response.getKey()) {
                    MutableInt successCount = pipelineData.getSuccessCount(key);
                    successCount.increment();

                    List<Versioned<byte[]>> retrieved = values.get(key);
                    /*
                     * retrieved can be null if there are no values for the key
                     * provided
                     */
                    if(retrieved != null) {
                        List<Versioned<byte[]>> existing = pipelineData.getResult().get(key);

                        if(existing == null)
                            pipelineData.getResult().put(key, Lists.newArrayList(retrieved));
                        else
                            existing.addAll(retrieved);
                    }

                    HashSet<Integer> zoneResponses = null;
                    if(pipelineData.getKeyToZoneResponse().containsKey(key)) {
                        zoneResponses = pipelineData.getKeyToZoneResponse().get(key);
                    } else {
                        zoneResponses = new HashSet<Integer>();
                    }
                    zoneResponses.add(response.getNode().getZoneId());
                }

                pipelineData.getResponses()
                            .add(new Response<Iterable<ByteArray>, Map<ByteArray, List<Versioned<byte[]>>>>(response.getNode(),
                                                                                                            response.getKey(),
                                                                                                            values,
                                                                                                            response.getRequestTime()));
                failureDetector.recordSuccess(response.getNode(), response.getRequestTime());
            }
        }

        pipeline.addEvent(completeEvent);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/src/java/voldemort/store/routed/action/PerformParallelGetAllRequests.java
Conflict type: LineBasedMCFd
Conflict body: 
public void execute(final Pipeline pipeline) {
        Node master = pipelineData.getMaster();
        final Versioned<byte[]> versionedCopy = pipelineData.getVersionedCopy();

        if(logger.isDebugEnabled())
            logger.debug("Serial put requests determined master node as " + master.getId()
                         + ", submitting remaining requests in parallel");

        List<Node> nodes = pipelineData.getNodes();
        int firstParallelNodeIndex = nodes.indexOf(master) + 1;
        int attempts = nodes.size() - firstParallelNodeIndex;
        int blocks = Math.min(preferred - 1, attempts);

        final Map<Integer, Response<ByteArray, Object>> responses = new ConcurrentHashMap<Integer, Response<ByteArray, Object>>();
        final CountDownLatch attemptsLatch = new CountDownLatch(attempts);
        final CountDownLatch blocksLatch = new CountDownLatch(blocks);

        if(logger.isTraceEnabled())
            logger.trace("Attempting " + attempts + " " + pipeline.getOperation().getSimpleName()
                         + " operations in parallel");

        for(int i = firstParallelNodeIndex; i < (firstParallelNodeIndex + attempts); i++) {
            final Node node = nodes.get(i);
            pipelineData.incrementNodeIndex();

            NonblockingStoreCallback callback = new NonblockingStoreCallback() {

                public void requestComplete(Object result, long requestTime) {
                    if(logger.isTraceEnabled())
                        logger.trace(pipeline.getOperation().getSimpleName()
                                     + " response received (" + requestTime + " ms.) from node "
                                     + node.getId());

                    Response<ByteArray, Object> response = new Response<ByteArray, Object>(node,
                                                                                           key,
                                                                                           result,
                                                                                           requestTime);
                    responses.put(node.getId(), response);

                    if(isHintedHandoffEnabled() && pipeline.isFinished()) {
                        if(response.getValue() instanceof UnreachableStoreException) {
                            Slop slop = new Slop(pipelineData.getStoreName(),
                                                 Slop.Operation.PUT,
                                                 key,
                                                 versionedCopy.getValue(),
                                                 node.getId(),
                                                 new Date());
                            pipelineData.addFailedNode(node);
                            hintedHandoff.sendHint(node, versionedCopy.getVersion(), slop);
                        }
                    }

                    attemptsLatch.countDown();
                    blocksLatch.countDown();

                    if(logger.isTraceEnabled())
                        logger.trace(attemptsLatch.getCount() + " attempts remaining. Will block "
                                     + " for " + blocksLatch.getCount() + " more ");

                    // Note errors that come in after the pipeline has finished.
                    // These will *not* get a chance to be called in the loop of
                    // responses below.
                    if(pipeline.isFinished() && response.getValue() instanceof Exception)
                        handleResponseError(response, pipeline, failureDetector);
                }

            };

            if(logger.isTraceEnabled())
                logger.trace("Submitting " + pipeline.getOperation().getSimpleName()
                             + " request on node " + node.getId());

            NonblockingStore store = nonblockingStores.get(node.getId());
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086601/fstmerge_var1_7260605839643606761
            store.submitPutRequest(key, versionedCopy, callback, timeoutMs);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086601/fstmerge_base_939418425401152621
            store.submitPutRequest(key, versionedCopy, callback);
=======
            store.submitPutRequest(key, versionedCopy, transforms, callback);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086601/fstmerge_var2_442807294252385895
        }

        try {
            long ellapsedNs = System.nanoTime() - pipelineData.getStartTimeNs();
            long remainingNs = (timeoutMs * Time.NS_PER_MS) - ellapsedNs;
            if(remainingNs > 0)
                blocksLatch.await(remainingNs, TimeUnit.NANOSECONDS);
        } catch(InterruptedException e) {
            if(logger.isEnabledFor(Level.WARN))
                logger.warn(e, e);
        }

        for(Entry<Integer, Response<ByteArray, Object>> responseEntry: responses.entrySet()) {
            Response<ByteArray, Object> response = responseEntry.getValue();
            if(response.getValue() instanceof Exception) {
                if(handleResponseError(response, pipeline, failureDetector))
                    return;
            } else {
                pipelineData.incrementSuccesses();
                failureDetector.recordSuccess(response.getNode(), response.getRequestTime());
                pipelineData.getZoneResponses().add(response.getNode().getZoneId());
                responses.remove(responseEntry.getKey());
            }
        }

        boolean quorumSatisfied = true;
        if(pipelineData.getSuccesses() < required) {
            long ellapsedNs = System.nanoTime() - pipelineData.getStartTimeNs();
            long remainingNs = (timeoutMs * Time.NS_PER_MS) - ellapsedNs;
            if(remainingNs > 0) {
                try {
                    attemptsLatch.await(remainingNs, TimeUnit.NANOSECONDS);
                } catch(InterruptedException e) {
                    if(logger.isEnabledFor(Level.WARN))
                        logger.warn(e, e);
                }

                for(Entry<Integer, Response<ByteArray, Object>> responseEntry: responses.entrySet()) {
                    Response<ByteArray, Object> response = responseEntry.getValue();
                    if(response.getValue() instanceof Exception) {
                        if(handleResponseError(response, pipeline, failureDetector))
                            return;
                    } else {
                        pipelineData.incrementSuccesses();
                        failureDetector.recordSuccess(response.getNode(), response.getRequestTime());
                        pipelineData.getZoneResponses().add(response.getNode().getZoneId());
                        responses.remove(responseEntry.getKey());
                    }
                }
            }

            if(pipelineData.getSuccesses() < required) {
                pipelineData.setFatalError(new InsufficientOperationalNodesException(required
                                                                                             + " "
                                                                                             + pipeline.getOperation()
                                                                                                       .getSimpleName()
                                                                                             + "s required, but only "
                                                                                             + pipelineData.getSuccesses()
                                                                                             + " succeeded",
                                                                                     pipelineData.getFailures()));
                pipeline.abort();
                quorumSatisfied = false;
            }
        }

        if(quorumSatisfied) {
            if(pipelineData.getZonesRequired() != null) {

                int zonesSatisfied = pipelineData.getZoneResponses().size();
                if(zonesSatisfied >= (pipelineData.getZonesRequired() + 1)) {
                    pipeline.addEvent(completeEvent);
                } else {
                    long timeMs = (System.nanoTime() - pipelineData.getStartTimeNs())
                                  / Time.NS_PER_MS;

                    if((timeoutMs - timeMs) > 0) {
                        try {
                            attemptsLatch.await(timeoutMs - timeMs, TimeUnit.MILLISECONDS);
                        } catch(InterruptedException e) {
                            if(logger.isEnabledFor(Level.WARN))
                                logger.warn(e, e);
                        }

                        for(Entry<Integer, Response<ByteArray, Object>> responseEntry: responses.entrySet()) {
                            Response<ByteArray, Object> response = responseEntry.getValue();
                            if(response.getValue() instanceof Exception) {
                                if(handleResponseError(response, pipeline, failureDetector))
                                    return;
                            } else {
                                pipelineData.incrementSuccesses();
                                failureDetector.recordSuccess(response.getNode(),
                                                              response.getRequestTime());
                                pipelineData.getZoneResponses().add(response.getNode().getZoneId());
                                responses.remove(responseEntry.getKey());
                            }
                        }
                    }

                    if(pipelineData.getZoneResponses().size() >= (pipelineData.getZonesRequired() + 1)) {
                        pipeline.addEvent(completeEvent);
                    } else {
                        pipelineData.setFatalError(new InsufficientZoneResponsesException((pipelineData.getZonesRequired() + 1)
                                                                                          + " "
                                                                                          + pipeline.getOperation()
                                                                                                    .getSimpleName()
                                                                                          + "s required zone, but only "
                                                                                          + zonesSatisfied
                                                                                          + " succeeded"));
                        pipeline.abort();
                    }
                }

            } else {
                pipeline.addEvent(completeEvent);
            }
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/src/java/voldemort/store/routed/action/PerformParallelPutRequests.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086902/fstmerge_var1_5734539711853309150
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086902/fstmerge_base_8919103510009019377
public void submitGetVersionsRequest(final ByteArray key, NonblockingStoreCallback callback) {
        submit(new StoreRequest<List<Version>>() {

            public List<Version> request(Store<ByteArray, byte[]> store) {
                return innerStore.getVersions(key);
            }

        }, callback);
    }
=======
public void submitGetVersionsRequest(final ByteArray key, NonblockingStoreCallback callback) {
        submit(new StoreRequest<List<Version>>() {

            public List<Version> request(Store<ByteArray, byte[], byte[]> store) {
                return innerStore.getVersions(key);
            }

        }, callback);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086902/fstmerge_var2_1988667170787575742

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/src/java/voldemort/store/nonblockingstore/ThreadPoolBasedNonblockingStoreImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086907/fstmerge_var1_1114252354919251125
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086907/fstmerge_base_22874498027505932
public void submitDeleteRequest(final ByteArray key,
                                    final Version version,
                                    NonblockingStoreCallback callback) {
        submit(new StoreRequest<Boolean>() {

            public Boolean request(Store<ByteArray, byte[]> store) {
                return innerStore.delete(key, version);
            }

        }, callback);
    }
=======
public void submitDeleteRequest(final ByteArray key,
                                    final Version version,
                                    NonblockingStoreCallback callback) {
        submit(new StoreRequest<Boolean>() {

            public Boolean request(Store<ByteArray, byte[], byte[]> store) {
                return innerStore.delete(key, version);
            }

        }, callback);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415550086907/fstmerge_var2_6310500454681462074

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6efd9_d55c7/rev_6efd9-d55c7/src/java/voldemort/store/nonblockingstore/ThreadPoolBasedNonblockingStoreImpl.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b9e13_09865/rev_b9e13-09865.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_dba17_cc749/rev_dba17-cc749.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6a899_d00bf/rev_6a899-d00bf.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_36bd7_06be2/rev_36bd7-06be2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_ededa_17adc/rev_ededa-17adc.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_83e29_06bb3/rev_83e29-06bb3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_67443_a5fc0/rev_67443-a5fc0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_012ba_46a88/rev_012ba-46a88.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_9c679_f8849/rev_9c679-f8849.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e846d_1cb55/rev_e846d-1cb55.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_98e70_d4ed7/rev_98e70-d4ed7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_47a30_051ba/rev_47a30-051ba.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_47a30_4157f/rev_47a30-4157f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_05721_a1be5/rev_05721-a1be5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_23b70_c6a90/rev_23b70-c6a90.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_1ea0b_12b94/rev_1ea0b-12b94.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_8bd8f_78ad6/rev_8bd8f-78ad6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f92c8_d3a06/rev_f92c8-d3a06.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6fa13_ed430/rev_6fa13-ed430.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b4618_67942/rev_b4618-67942.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_258f1_db422/rev_258f1-db422.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e8672_8bd8f/rev_e8672-8bd8f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d3985_b1eb9/rev_d3985-b1eb9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_899b5_90904/rev_899b5-90904.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_77092_899b5/rev_77092-899b5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_70fd0_cd725/rev_70fd0-cd725.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_70fd0_059c7/rev_70fd0-059c7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_11693_6d245/rev_11693-6d245.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_cecc5_979f5/rev_cecc5-979f5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_34346_f8351/rev_34346-f8351.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b01a8_17d5b/rev_b01a8-17d5b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b01a8_e601d/rev_b01a8-e601d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b01a8_23e60/rev_b01a8-23e60.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public void migrate() {

        final HashMultimap<String, RebalancePartitionsInfo> completedTasks = HashMultimap.create();
        final AtomicInteger completed = new AtomicInteger(0);

        // Parse the check point file and check if any tasks are done
        if(new File(checkpointFolder).exists()) {

            if(!Utils.isReadableDir(checkpointFolder)) {
                logger.error("The checkpoint folder " + checkpointFolder + " cannot be read");
                return;
            }
            // Check point folder exists, lets parse the individual
            // completedTasks
            logger.info("Check point file exists, parsing it...");
            for(String storeName: storeNames) {
                if(!new File(checkpointFolder, storeName).exists()) {
                    logger.info("No check point file for store " + storeName);
                    completedTasks.putAll(storeName, new ArrayList<RebalancePartitionsInfo>());
                } else {
                    // Some tasks for this store got over
                    List<String> completedTasksLines = null;

                    // Check if any previous tasks for
                    try {
                        completedTasksLines = FileUtils.readLines(new File(checkpointFolder,
                                                                           storeName));
                    } catch(IOException e) {
                        logger.error("Could not read the check point file for store name "
                                     + storeName, e);
                        return;
                    }

                    for(String completedTaskLine: completedTasksLines) {
                        completedTasks.put(storeName,
                                           RebalancePartitionsInfo.create(completedTaskLine));
                    }
                    logger.info("Completed tasks for " + storeName + " = "
                                + completedTasks.get(storeName).size());
                    completed.addAndGet(completedTasks.get(storeName).size());
                }
            }
        } else {
            logger.info("Check point folder does not exist. Starting a new one at "
                        + checkpointFolder);
            Utils.mkdirs(new File(checkpointFolder));
        }
        logger.info(" ============================================== ");

        if(donorNodePlans.size() == 0) {
            logger.info("Nothing to move around");
            return;
        }

        int t = 0;
        for(List<RebalancePartitionsInfo> rebalancePartitionsInfos: donorNodePlans.values())
            t += rebalancePartitionsInfos.size();
        final int total = t * storeNames.size();

        final long startedAt = System.currentTimeMillis();

        /**
         * Lets move all the donor nodes into grandfathering state. First
         * generate all donor node ids and corresponding migration plans
         */
        logger.info("Changing state of donor nodes " + donorNodePlans.keySet());
        final CountDownLatch latch = new CountDownLatch(stealerNodeIds.size());
        try {
            changeToGrandfather();

            /**
             * Do all the stealer nodes sequentially, while each store can be
             * done in parallel for all the respective donor nodes
             */

            final AtomicInteger numStealersCompleted = new AtomicInteger(0);
            for(final int stealerNodeId: stealerNodeIds) {
                executor.submit(new Runnable() {

                    public void run() {
                        try {
                            RebalanceNodePlan nodePlan = stealerNodePlans.get(stealerNodeId);
                            if(nodePlan == null) {
                                logger.info("No plan for stealer node id " + stealerNodeId);
                                return;
                            }
                            List<RebalancePartitionsInfo> partitionInfo = nodePlan.getRebalanceTaskList();

                            logger.info("Working on stealer node id " + stealerNodeId);
                            for(String storeName: storeNames) {

                                Set<Pair<Integer, Integer>> pending = Sets.newHashSet();
                                HashMap<Pair<Integer, Integer>, RebalancePartitionsInfo> pendingTasks = Maps.newHashMap();

                                for(RebalancePartitionsInfo r: partitionInfo) {
                                    if(completedTasks.get(storeName).contains(r)) {
                                        logger.info("-- Not doing task from donorId "
                                                    + r.getDonorId() + " to " + r.getStealerId()
                                                    + " with store " + storeName
                                                    + " since it is already done");
                                        continue;
                                    }
                                    logger.info("-- Started migration from donorId "
                                                + r.getDonorId() + " to " + stealerNodeId
                                                + " for store " + storeName);
                                    if(!simulation) {
                                        int attemptId = adminClient.migratePartitions(r.getDonorId(),
                                                                                      stealerNodeId,
                                                                                      storeName,
                                                                                      r.getPartitionList(),
                                                                                      null);
                                        pending.add(Pair.create(r.getDonorId(), attemptId));
                                        pendingTasks.put(Pair.create(r.getDonorId(), attemptId), r);
                                    }
                                }

                                while(!pending.isEmpty()) {
                                    long delay = 1000;
                                    Set<Pair<Integer, Integer>> currentPending = ImmutableSet.copyOf(pending);
                                    for(Pair<Integer, Integer> pair: currentPending) {
                                        AsyncOperationStatus status = adminClient.getAsyncRequestStatus(stealerNodeId,
                                                                                                        pair.getSecond());
                                        logger.info("Status of move from " + pair.getFirst()
                                                    + " to " + stealerNodeId + ": "
                                                    + status.getStatus());
                                        if(status.hasException()) {
                                            throw new VoldemortException(status.getException());
                                        }
                                        if(status.isComplete()) {
                                            logger.info("-- Completed migration from donorId "
                                                        + pair.getFirst() + " to " + stealerNodeId
                                                        + " for store " + storeName);
                                            logger.info("-- " + completed.incrementAndGet()
                                                        + " out of " + total + " tasks completed");
                                            pending.remove(pair);

                                            // Write the task to file
                                            // immediately
                                            BufferedWriter out = null;
                                            try {
                                                out = new BufferedWriter(new FileWriter(new File(checkpointFolder,
                                                                                                 storeName),
                                                                                        true));
                                                out.write(pendingTasks.get(pair).toJsonString()
                                                          + "\n");
                                            } catch(Exception e) {
                                                logger.error("Failure while writing check point for store "
                                                             + storeName + ". Emitting it here ");
                                                logger.error("Checkpoint failure ("
                                                             + storeName
                                                             + "):"
                                                             + pendingTasks.get(pair)
                                                                           .toJsonString());
                                            } finally {
                                                if(out != null) {
                                                    out.flush();
                                                    out.close();
                                                }
                                            }

                                            long velocity = (System.currentTimeMillis() - startedAt)
                                                            / completed.get();
                                            long eta = (total - completed.get()) * velocity
                                                       / Time.MS_PER_SECOND;
                                            logger.info("-- Estimated " + eta
                                                        + " seconds until completion");
                                        }
                                    }
                                    try {
                                        Thread.sleep(delay);
                                        if(delay < 30000)
                                            delay *= 2;
                                    } catch(InterruptedException e) {
                                        throw new VoldemortException(e);
                                    }
                                }
                            }
                        } catch(Exception e) {
                            logger.error("Exception for stealer node " + stealerNodeId, e);
                            while(latch.getCount() > 0)
                                latch.countDown();
                            executor.shutdownNow();
                            throw new VoldemortException(e);
                        } finally {
                            latch.countDown();
                            logger.info("Number of stealers completed - "
                                        + numStealersCompleted.incrementAndGet());
                        }
                    }
                });
            }
            latch.await();
        } catch(Exception e) {
            logger.error("Exception in full process", e);
            executor.shutdownNow();
            throw new VoldemortException(e);
        } finally {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415575051589/fstmerge_var1_4446300695980739993
            // Move all nodes in grandfathered state back to normal
            if(donorStates != null && transitionToNormal) {
                changeToNormal();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415575051589/fstmerge_base_1355802248101458080
            if(!(executor.isShutdown() || executor.isTerminated())) {
                try {
                    latch.await();
                } catch(InterruptedException e)  {
                    logger.error(e, e);
                    throw new VoldemortException(e);
                } finally {
                    // Move all nodes in grandfathered state back to normal
                    if(donorStates != null && transitionToNormal) {
                        changeToNormal();
                    }
                    executor.shutdown();
                }
=======
            // Move all nodes in grandfathered state back to normal
            if(donorStates != null && transitionToNormal) {
                changeToNormal();
            }
            if(!(executor.isShutdown() || executor.isTerminated())) {
                try {
                    latch.await();
                } catch(InterruptedException e)  {
                    logger.error(e, e);
                } finally {

                    executor.shutdown();
                }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415575051589/fstmerge_var2_7143158492068445934
            }
            executor.shutdown();

        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b01a8_23e60/rev_b01a8-23e60/src/java/voldemort/client/rebalance/MigratePartitions.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7d5e3_02513/rev_7d5e3-02513.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_983db_ba151/rev_983db-ba151.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b9d88_52c3f/rev_b9d88-52c3f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_4ec9f_2f4f8/rev_4ec9f-2f4f8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_51c3a_26678/rev_51c3a-26678.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a76d9_98864/rev_a76d9-98864.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_1e950_f6ce3/rev_1e950-f6ce3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_dcd9d_6e128/rev_dcd9d-6e128.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d4556_1e950/rev_d4556-1e950.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_8fea1_204f5/rev_8fea1-204f5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bac0f_4bc49/rev_bac0f-4bc49.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_475b8_ad0a6/rev_475b8-ad0a6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_475b8_ad057/rev_475b8-ad057.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d3272_c4dfa/rev_d3272-c4dfa.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b452a_2601a/rev_b452a-2601a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_5231f_63153/rev_5231f-63153.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_5df0a_b91a2/rev_5df0a-b91a2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7cb86_1a8ec/rev_7cb86-1a8ec.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7cb86_40031/rev_7cb86-40031.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_dbdf0_e8dc2/rev_dbdf0-e8dc2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b7ccb_aa4d7/rev_b7ccb-aa4d7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_ea2f2_6140f/rev_ea2f2-6140f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_50c04_5608a/rev_50c04-5608a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b255d_207b9/rev_b255d-207b9.revisions
Conflict type: LineBasedMCFd
Conflict body: 
protected FetchPartitionFileStreamRequestHandler(VAdminProto.FetchPartitionFilesRequest request,
                                                     MetadataStore metadataStore,
                                                     VoldemortConfig voldemortConfig,
                                                     StoreRepository storeRepository,
                                                     StreamStats stats) {
        this.request = request;
        StoreDefinition storeDef = metadataStore.getStoreDef(request.getStore());
        boolean isReadOnly = storeDef.getType().compareTo(ReadOnlyStorageConfiguration.TYPE_NAME) == 0;
        if(!isReadOnly) {
            throw new VoldemortException("Should be fetching partition files only for read-only stores");
        }

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415600559147/fstmerge_var1_5762937279652040867
        this.replicaToPartitionList = ProtoUtils.decodePartitionTuple(request.getReplicaToPartitionList());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415600559147/fstmerge_base_4393040708705024133
        HashMap<Integer, List<Integer>> localReplicaToPartitionList = ProtoUtils.decodePartitionTuple(request.getReplicaToPartitionList());
=======
        ReadOnlyStorageEngine storageEngine = AdminServiceRequestHandler.getReadOnlyStorageEngine(metadataStore,
                                                                                                  storeRepository,
                                                                                                  request.getStore());

        HashMap<Integer, List<Integer>> localReplicaToPartitionList = ProtoUtils.decodePartitionTuple(request.getReplicaToPartitionList());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415600559147/fstmerge_var2_2524888111318929379

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415600559147/fstmerge_var1_5762937279652040867
        this.storageEngine = AdminServiceRequestHandler.getReadOnlyStorageEngine(metadataStore,
                                                                                 storeRepository,
                                                                                 request.getStore());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415600559147/fstmerge_base_4393040708705024133
        // Filter the replica to partition mapping so as to include only till
        // the number of replicas
        this.replicaToPartitionList = Maps.newHashMap();
        for(int replicaType = 0; replicaType < storeDef.getReplicationFactor(); replicaType++) {
            if(localReplicaToPartitionList.containsKey(replicaType)) {
                this.replicaToPartitionList.put(replicaType,
                                                localReplicaToPartitionList.get(replicaType));
            }
        }
        this.storageEngine = AdminServiceRequestHandler.getReadOnlyStorageEngine(metadataStore,
                                                                                 storeRepository,
                                                                                 request.getStore());
=======
        // Filter the replica to partition mapping so as to include only till
        // the number of replicas
        this.replicaToPartitionList = Lists.newArrayList();
        for(int replicaType = 0; replicaType < storeDef.getReplicationFactor(); replicaType++) {
            if(localReplicaToPartitionList.containsKey(replicaType)) {
                List<Integer> partitionList = localReplicaToPartitionList.get(replicaType);
                for(Iterator<Integer> it = partitionList.iterator(); it.hasNext();) {
                    this.replicaToPartitionList.add(new Pair<Integer, Integer>(replicaType,
                                                                               it.next()));
                }
            }
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415600559147/fstmerge_var2_2524888111318929379

        this.blockSize = voldemortConfig.getAllProps()
                                        .getLong("partition.buffer.size.bytes",
                                                 voldemortConfig.getAdminSocketBufferSize());
        this.storeDir = new File(storageEngine.getCurrentDirPath());
        this.throttler = new EventThrottler(voldemortConfig.getStreamMaxReadBytesPerSec());
        this.stats = stats;
        this.handle = stats.makeHandle(StreamStats.Operation.FETCH_FILE,
                                       RebalanceUtils.flattenPartitionTuples(new HashSet<Pair<Integer, Integer>>(replicaToPartitionList)));
        this.partitionIterator = Collections.unmodifiableList(replicaToPartitionList).iterator();
        this.fetchStatus = FetchStatus.next_partition;
        this.currentChunkId = 0;
        this.indexFile = null;
        this.dataFile = null;
        this.chunkedFileWriter = null;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b255d_207b9/rev_b255d-207b9/src/java/voldemort/server/protocol/admin/FetchPartitionFileStreamRequestHandler.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b648f_8359f/rev_b648f-8359f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e8ecc_50c04/rev_e8ecc-50c04.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_946e0_e635e/rev_946e0-e635e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e52f4_72bfb/rev_e52f4-72bfb.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b66ec_f2e82/rev_b66ec-f2e82.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_0893e_b8d8a/rev_0893e-b8d8a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2c0af_8e620/rev_2c0af-8e620.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_8c07e_c1315/rev_8c07e-c1315.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_cca94_7376c/rev_cca94-7376c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d8f6c_46a0e/rev_d8f6c-46a0e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_de9ff_242fc/rev_de9ff-242fc.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_de9ff_50c3a/rev_de9ff-50c3a.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@SuppressWarnings("unchecked")
    public static void main(String[] args) throws Exception {
        OptionParser parser = new OptionParser();
        parser.accepts("help", "print help information");
        parser.accepts("url", "[REQUIRED] bootstrap URL")
              .withRequiredArg()
              .describedAs("bootstrap-url")
              .ofType(String.class);
        parser.accepts("node", "node id")
              .withRequiredArg()
              .describedAs("node-id")
              .ofType(Integer.class);
        parser.accepts("delete-partitions", "Delete partitions")
              .withRequiredArg()
              .describedAs("partition-ids")
              .withValuesSeparatedBy(',')
              .ofType(Integer.class);
        parser.accepts("restore",
                       "Restore from replication [ Optional parallelism param - Default - 5 ]")
              .withOptionalArg()
              .describedAs("parallelism")
              .ofType(Integer.class);
        parser.accepts("ascii", "Fetch keys as ASCII");
        parser.accepts("fetch-keys", "Fetch keys")
              .withOptionalArg()
              .describedAs("partition-ids")
              .withValuesSeparatedBy(',')
              .ofType(Integer.class);
        parser.accepts("fetch-entries", "Fetch full entries")
              .withOptionalArg()
              .describedAs("partition-ids")
              .withValuesSeparatedBy(',')
              .ofType(Integer.class);
        parser.accepts("outdir", "Output directory")
              .withRequiredArg()
              .describedAs("output-directory")
              .ofType(String.class);
        parser.accepts("stores", "Store names")
              .withRequiredArg()
              .describedAs("store-names")
              .withValuesSeparatedBy(',')
              .ofType(String.class);
        parser.accepts("add-stores", "Add stores in this stores.xml")
              .withRequiredArg()
              .describedAs("stores.xml containing just the new stores")
              .ofType(String.class);
        parser.accepts("delete-store", "Delete store")
              .withRequiredArg()
              .describedAs("store-name")
              .ofType(String.class);
        parser.accepts("update-entries", "Insert or update entries")
              .withRequiredArg()
              .describedAs("input-directory")
              .ofType(String.class);
        parser.accepts("get-metadata",
                       "retreive metadata information " + MetadataStore.METADATA_KEYS)
              .withOptionalArg()
              .describedAs("metadata-key")
              .ofType(String.class);
        parser.accepts("check-metadata",
                       "retreive metadata information from all nodes and checks if they are consistent across [ "
                               + MetadataStore.CLUSTER_KEY + " | " + MetadataStore.STORES_KEY
                               + " | " + MetadataStore.SERVER_STATE_KEY + " ]")
              .withRequiredArg()
              .describedAs("metadata-key")
              .ofType(String.class);
        parser.accepts("ro-metadata",
                       "retrieve version information [current | max | storage-format]")
              .withRequiredArg()
              .describedAs("type")
              .ofType(String.class);
        parser.accepts("truncate", "truncate a store")
              .withRequiredArg()
              .describedAs("store-name")
              .ofType(String.class);
        parser.accepts("set-metadata",
                       "Forceful setting of metadata [ " + MetadataStore.CLUSTER_KEY + " | "
                               + MetadataStore.STORES_KEY + " | " + MetadataStore.SERVER_STATE_KEY
                               + " | " + MetadataStore.REBALANCING_STEAL_INFO + " ]")
              .withRequiredArg()
              .describedAs("metadata-key")
              .ofType(String.class);
        parser.accepts("set-metadata-value",
                       "The value for the set-metadata [ " + MetadataStore.CLUSTER_KEY + " | "
                               + MetadataStore.STORES_KEY + ", "
                               + MetadataStore.REBALANCING_STEAL_INFO
                               + " ] - xml file location, [ " + MetadataStore.SERVER_STATE_KEY
                               + " ] - " + MetadataStore.VoldemortState.NORMAL_SERVER + ","
                               + MetadataStore.VoldemortState.REBALANCING_MASTER_SERVER)
              .withRequiredArg()
              .describedAs("metadata-value")
              .ofType(String.class);
        parser.accepts("key-distribution", "Prints the current key distribution of the cluster");
        parser.accepts("clear-rebalancing-metadata", "Remove the metadata related to rebalancing");
        parser.accepts("async",
                       "a) Get a list of async job ids [get] b) Stop async job ids [stop] ")
              .withRequiredArg()
              .describedAs("op-type")
              .ofType(String.class);
        parser.accepts("async-id", "Comma separated list of async ids to stop")
              .withOptionalArg()
              .describedAs("job-ids")
              .withValuesSeparatedBy(',')
              .ofType(Integer.class);

        OptionSet options = parser.parse(args);

        if(options.has("help")) {
            printHelp(System.out, parser);
            System.exit(0);
        }

        Set<String> missing = CmdUtils.missing(options, "url", "node");
        if(missing.size() > 0) {
            // Not the most elegant way to do this
            if(!(missing.equals(ImmutableSet.of("node"))
                 && (options.has("add-stores") || options.has("delete-store")
                     || options.has("ro-metadata") || options.has("set-metadata")
                     || options.has("get-metadata") || options.has("check-metadata") || options.has("key-distribution"))
                 || options.has("truncate") || options.has("clear-rebalancing-metadata") || options.has("async"))) {
                System.err.println("Missing required arguments: " + Joiner.on(", ").join(missing));
                printHelp(System.err, parser);
                System.exit(1);
            }
        }

        String url = (String) options.valueOf("url");
        Integer nodeId = CmdUtils.valueOf(options, "node", -1);
        int parallelism = CmdUtils.valueOf(options, "restore", 5);

        AdminClient adminClient = new AdminClient(url, new AdminClientConfig());

        String ops = "";
        if(options.has("delete-partitions")) {
            ops += "d";
        }
        if(options.has("fetch-keys")) {
            ops += "k";
        }
        if(options.has("fetch-entries")) {
            ops += "v";
        }
        if(options.has("restore")) {
            ops += "r";
        }
        if(options.has("add-stores")) {
            ops += "a";
        }
        if(options.has("update-entries")) {
            ops += "u";
        }
        if(options.has("delete-store")) {
            ops += "s";
        }
        if(options.has("get-metadata")) {
            ops += "g";
        }
        if(options.has("ro-metadata")) {
            ops += "e";
        }
        if(options.has("truncate")) {
            ops += "t";
        }
        if(options.has("set-metadata")) {
            ops += "m";
        }
        if(options.has("check-metadata")) {
            ops += "c";
        }
        if(options.has("key-distribution")) {
            ops += "y";
        }
        if(options.has("clear-rebalancing-metadata")) {
            ops += "i";
        }
        if(options.has("async")) {
            ops += "b";
        }
        if(ops.length() < 1) {
            Utils.croak("At least one of (delete-partitions, restore, add-node, fetch-entries, "
                        + "fetch-keys, add-stores, delete-store, update-entries, get-metadata, ro-metadata, "
                        + "set-metadata, check-metadata, key-distribution, clear-rebalancing-metadata, async) "
                        + "must be specified");
        }

        List<String> storeNames = null;

        if(options.has("stores")) {
            List<String> temp = (List<String>) options.valuesOf("stores");
            storeNames = temp;
        }

        String outputDir = null;
        if(options.has("outdir")) {
            outputDir = (String) options.valueOf("outdir");
        }

        try {
            if(ops.contains("d")) {
                System.out.println("Starting delete-partitions");
                List<Integer> partitionIdList = (List<Integer>) options.valuesOf("delete-partitions");
                executeDeletePartitions(nodeId, adminClient, partitionIdList, storeNames);
                System.out.println("Finished delete-partitions");
            }
            if(ops.contains("r")) {
                if(nodeId == -1) {
                    System.err.println("Cannot run restore without node id");
                    System.exit(1);
                }
                System.out.println("Starting restore");
                adminClient.restoreDataFromReplications(nodeId, parallelism);
                System.out.println("Finished restore");
            }
            if(ops.contains("k")) {
                boolean useAscii = options.has("ascii");
                System.out.println("Starting fetch keys");
                List<Integer> partitionIdList = null;
                if(options.hasArgument("fetch-keys"))
                    partitionIdList = (List<Integer>) options.valuesOf("fetch-keys");
                executeFetchKeys(nodeId,
                                 adminClient,
                                 partitionIdList,
                                 outputDir,
                                 storeNames,
                                 useAscii);
            }
            if(ops.contains("v")) {
                boolean useAscii = options.has("ascii");
                System.out.println("Starting fetch entries");
                List<Integer> partitionIdList = null;
                if(options.hasArgument("fetch-entries"))
                    partitionIdList = (List<Integer>) options.valuesOf("fetch-entries");
                executeFetchEntries(nodeId,
                                    adminClient,
                                    partitionIdList,
                                    outputDir,
                                    storeNames,
                                    useAscii);
            }
            if(ops.contains("a")) {
                String storesXml = (String) options.valueOf("add-stores");
                executeAddStores(adminClient, storesXml, nodeId);
            }
            if(ops.contains("u")) {
                String inputDir = (String) options.valueOf("update-entries");
                executeUpdateEntries(nodeId, adminClient, storeNames, inputDir);
            }
            if(ops.contains("s")) {
                String storeName = (String) options.valueOf("delete-store");
                executeDeleteStore(adminClient, storeName, nodeId);
            }
            if(ops.contains("g")) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415623924264/fstmerge_var1_5435438034021907855
                String metadataKey = ALL_METADATA;
                if(options.hasArgument("get-metadata")) {
                    metadataKey = (String) options.valueOf("get-metadata");
                }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415623924264/fstmerge_base_8661767995249211273
                String metadataKey = (String) options.valueOf("get-metadata");
=======
                if(options.has("outdir")) {
                    outputDir = (String) options.valueOf("outdir");
                }
                String metadataKey = (String) options.valueOf("get-metadata");
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415623924264/fstmerge_var2_4282958337291012606
                executeGetMetadata(nodeId, adminClient, metadataKey, outputDir);
            }
            if(ops.contains("e")) {
                String type = (String) options.valueOf("ro-metadata");
                executeROMetadata(nodeId, adminClient, storeNames, type);
            }
            if(ops.contains("t")) {
                String storeName = (String) options.valueOf("truncate");
                executeTruncateStore(nodeId, adminClient, storeName);
            }
            if(ops.contains("c")) {
                String metadataKey = (String) options.valueOf("check-metadata");
                executeCheckMetadata(adminClient, metadataKey);
            }
            if(ops.contains("m")) {
                String metadataKey = (String) options.valueOf("set-metadata");
                if(!options.has("set-metadata-value")) {
                    throw new VoldemortException("Missing set-metadata-value");
                } else {
                    String metadataValue = (String) options.valueOf("set-metadata-value");
                    if(metadataKey.compareTo(MetadataStore.CLUSTER_KEY) == 0) {
                        if(!Utils.isReadableFile(metadataValue))
                            throw new VoldemortException("Cluster xml file path incorrect");
                        ClusterMapper mapper = new ClusterMapper();
                        Cluster newCluster = mapper.readCluster(new File(metadataValue));
                        executeSetMetadata(nodeId,
                                           adminClient,
                                           MetadataStore.CLUSTER_KEY,
                                           mapper.writeCluster(newCluster));
                    } else if(metadataKey.compareTo(MetadataStore.SERVER_STATE_KEY) == 0) {
                        VoldemortState newState = VoldemortState.valueOf(metadataValue);
                        executeSetMetadata(nodeId,
                                           adminClient,
                                           MetadataStore.SERVER_STATE_KEY,
                                           newState.toString());
                    } else if(metadataKey.compareTo(MetadataStore.STORES_KEY) == 0) {
                        if(!Utils.isReadableFile(metadataValue))
                            throw new VoldemortException("Stores definition xml file path incorrect");
                        StoreDefinitionsMapper mapper = new StoreDefinitionsMapper();
                        List<StoreDefinition> storeDefs = mapper.readStoreList(new File(metadataValue));
                        executeSetMetadata(nodeId,
                                           adminClient,
                                           MetadataStore.STORES_KEY,
                                           mapper.writeStoreList(storeDefs));
                    } else if(metadataKey.compareTo(MetadataStore.REBALANCING_STEAL_INFO) == 0) {
                        if(!Utils.isReadableFile(metadataValue))
                            throw new VoldemortException("Rebalancing steal info file path incorrect");
                        String rebalancingStealInfoJsonString = FileUtils.readFileToString(new File(metadataValue));
                        RebalancerState state = RebalancerState.create(rebalancingStealInfoJsonString);
                        executeSetMetadata(nodeId,
                                           adminClient,
                                           MetadataStore.REBALANCING_STEAL_INFO,
                                           state.toJsonString());
                    } else {
                        throw new VoldemortException("Incorrect metadata key");
                    }
                }

            }
            if(ops.contains("y")) {
                executeKeyDistribution(adminClient);
            }
            if(ops.contains("i")) {
                executeClearRebalancing(nodeId, adminClient);
            }
            if(ops.contains("b")) {
                String asyncKey = (String) options.valueOf("async");
                List<Integer> asyncIds = null;
                if(options.hasArgument("async-id"))
                    asyncIds = (List<Integer>) options.valuesOf("async-id");
                executeAsync(nodeId, adminClient, asyncKey, asyncIds);
            }
        } catch(Exception e) {
            e.printStackTrace();
            Utils.croak(e.getMessage());
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_de9ff_50c3a/rev_de9ff-50c3a/src/java/voldemort/VoldemortAdminTool.java
Conflict type: LineBasedMCFd
Conflict body: 
public static void executeGetMetadata(Integer nodeId,
                                          AdminClient adminClient,
                                          String metadataKey,
                                          String outputDir) throws IOException {
        File directory = null;
        if(outputDir != null) {
            directory = new File(outputDir);
            if(!(directory.exists() || directory.mkdir())) {
                Utils.croak("Can't find or create directory " + outputDir);
            }
        }

        List<Integer> nodeIds = Lists.newArrayList();
        if(nodeId < 0) {
            for(Node node: adminClient.getAdminClientCluster().getNodes()) {
                nodeIds.add(node.getId());
            }
        } else {
            nodeIds.add(nodeId);
        }

        List<String> metadataKeys = Lists.newArrayList();
        if(metadataKey.compareTo(ALL_METADATA) == 0) {
            for(Object key: MetadataStore.METADATA_KEYS) {
                metadataKeys.add((String) key);
            }
        } else {
            metadataKeys.add(metadataKey);
        }
        for(Integer currentNodeId: nodeIds) {
            System.out.println(adminClient.getAdminClientCluster()
                                          .getNodeById(currentNodeId)
                                          .getHost()
                               + ":"
                               + adminClient.getAdminClientCluster()
                                            .getNodeById(currentNodeId)
                                            .getId());
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415623924304/fstmerge_var1_7774753897315929847
            for(String key: metadataKeys) {
                System.out.println("Key - " + key);
                Versioned<String> versioned = null;
                try {
                    versioned = adminClient.getRemoteMetadata(currentNodeId, key);
                } catch(Exception e) {
                    System.out.println("Error in retrieving " + e.getMessage());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415623924304/fstmerge_base_6427107243786315906
            Versioned<String> versioned = null;
            try {
                versioned = adminClient.getRemoteMetadata(currentNodeId, metadataKey);
            } catch(Exception e) {
                System.out.println("Error in retrieving " + e.getMessage());
                System.out.println();
                continue;
            }
            if(versioned == null) {
                if(directory == null) {
                    System.out.println("null");
=======
            Versioned<String> versioned = null;
            try {
                versioned = adminClient.getRemoteMetadata(currentNodeId, metadataKey);
            } catch(Exception e) {
                System.out.println("Error in retrieving " + e.getMessage());
                System.out.println();
                continue;
            }

            if(versioned == null) {
                if(directory == null) {
                    System.out.println("null");
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415623924304/fstmerge_var2_3005095457382398081
                    System.out.println();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415623924304/fstmerge_var1_7774753897315929847
                    continue;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415623924304/fstmerge_base_6427107243786315906
                } else {
                    FileUtils.writeStringToFile(new File(directory, "cluster.xml_" + currentNodeId),
                                                "");
=======
                } else {
                    FileUtils.writeStringToFile(new File(directory, metadataKey + "."
                                                                    + currentNodeId), "");
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415623924304/fstmerge_var2_3005095457382398081
                }
                if(versioned == null) {
                    if(directory == null) {
                        System.out.println("null");
                        System.out.println();
                    } else {
                        FileUtils.writeStringToFile(new File(directory, key + "_" + currentNodeId),
                                                    "");
                    }
                } else {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415623924304/fstmerge_var1_7774753897315929847
                    if(directory == null) {
                        System.out.println(versioned.getVersion());
                        System.out.print(": ");
                        System.out.println(versioned.getValue());
                        System.out.println();
                    } else {
                        FileUtils.writeStringToFile(new File(directory, key + "_" + currentNodeId),
                                                    versioned.getValue());
                    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415623924304/fstmerge_base_6427107243786315906
                    FileUtils.writeStringToFile(new File(directory, "cluster.xml_" + currentNodeId),
                                                versioned.getValue());
=======
                    FileUtils.writeStringToFile(new File(directory, metadataKey + "."
                                                                    + currentNodeId),
                                                versioned.getValue());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415623924304/fstmerge_var2_3005095457382398081
                }
            }
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_de9ff_50c3a/rev_de9ff-50c3a/src/java/voldemort/VoldemortAdminTool.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_69ae6_c3b87/rev_69ae6-c3b87.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@SuppressWarnings("unchecked")
    public static void main(String[] args) throws Exception {
        OptionParser parser = new OptionParser();
        parser.accepts("help", "print help information");
        parser.accepts("url", "[REQUIRED] bootstrap URL")
              .withRequiredArg()
              .describedAs("bootstrap-url")
              .ofType(String.class);
        parser.accepts("node", "node id")
              .withRequiredArg()
              .describedAs("node-id")
              .ofType(Integer.class);
        parser.accepts("delete-partitions", "Delete partitions")
              .withRequiredArg()
              .describedAs("partition-ids")
              .withValuesSeparatedBy(',')
              .ofType(Integer.class);
        parser.accepts("restore",
                       "Restore from replication [ Optional parallelism param - Default - 5 ]")
              .withOptionalArg()
              .describedAs("parallelism")
              .ofType(Integer.class);
        parser.accepts("ascii", "Fetch keys as ASCII");
        parser.accepts("fetch-keys", "Fetch keys")
              .withOptionalArg()
              .describedAs("partition-ids")
              .withValuesSeparatedBy(',')
              .ofType(Integer.class);
        parser.accepts("fetch-entries", "Fetch full entries")
              .withOptionalArg()
              .describedAs("partition-ids")
              .withValuesSeparatedBy(',')
              .ofType(Integer.class);
        parser.accepts("outdir", "Output directory")
              .withRequiredArg()
              .describedAs("output-directory")
              .ofType(String.class);
        parser.accepts("stores", "Store names")
              .withRequiredArg()
              .describedAs("store-names")
              .withValuesSeparatedBy(',')
              .ofType(String.class);
        parser.accepts("add-stores", "Add stores in this stores.xml")
              .withRequiredArg()
              .describedAs("stores.xml containing just the new stores")
              .ofType(String.class);
        parser.accepts("delete-store", "Delete store")
              .withRequiredArg()
              .describedAs("store-name")
              .ofType(String.class);
        parser.accepts("update-entries", "Insert or update entries")
              .withRequiredArg()
              .describedAs("input-directory")
              .ofType(String.class);
        parser.accepts("get-metadata",
                       "retreive metadata information " + MetadataStore.METADATA_KEYS)
              .withOptionalArg()
              .describedAs("metadata-key")
              .ofType(String.class);
        parser.accepts("check-metadata",
                       "retreive metadata information from all nodes and checks if they are consistent across [ "
                               + MetadataStore.CLUSTER_KEY + " | " + MetadataStore.STORES_KEY
                               + " | " + MetadataStore.SERVER_STATE_KEY + " ]")
              .withRequiredArg()
              .describedAs("metadata-key")
              .ofType(String.class);
        parser.accepts("ro-metadata",
                       "retrieve version information [current | max | storage-format]")
              .withRequiredArg()
              .describedAs("type")
              .ofType(String.class);
        parser.accepts("truncate", "truncate a store")
              .withRequiredArg()
              .describedAs("store-name")
              .ofType(String.class);
        parser.accepts("set-metadata",
                       "Forceful setting of metadata [ " + MetadataStore.CLUSTER_KEY + " | "
                               + MetadataStore.STORES_KEY + " | " + MetadataStore.SERVER_STATE_KEY
                               + " | " + MetadataStore.REBALANCING_STEAL_INFO + " ]")
              .withRequiredArg()
              .describedAs("metadata-key")
              .ofType(String.class);
        parser.accepts("set-metadata-value",
                       "The value for the set-metadata [ " + MetadataStore.CLUSTER_KEY + " | "
                               + MetadataStore.STORES_KEY + ", "
                               + MetadataStore.REBALANCING_STEAL_INFO
                               + " ] - xml file location, [ " + MetadataStore.SERVER_STATE_KEY
                               + " ] - " + MetadataStore.VoldemortState.NORMAL_SERVER + ","
                               + MetadataStore.VoldemortState.REBALANCING_MASTER_SERVER)
              .withRequiredArg()
              .describedAs("metadata-value")
              .ofType(String.class);
        parser.accepts("key-distribution", "Prints the current key distribution of the cluster");
        parser.accepts("clear-rebalancing-metadata", "Remove the metadata related to rebalancing");
        parser.accepts("async",
                       "a) Get a list of async job ids [get] b) Stop async job ids [stop] ")
              .withRequiredArg()
              .describedAs("op-type")
              .ofType(String.class);
        parser.accepts("async-id", "Comma separated list of async ids to stop")
              .withOptionalArg()
              .describedAs("job-ids")
              .withValuesSeparatedBy(',')
              .ofType(Integer.class);

        OptionSet options = parser.parse(args);

        if(options.has("help")) {
            printHelp(System.out, parser);
            System.exit(0);
        }

        Set<String> missing = CmdUtils.missing(options, "url", "node");
        if(missing.size() > 0) {
            // Not the most elegant way to do this
            if(!(missing.equals(ImmutableSet.of("node"))
                 && (options.has("add-stores") || options.has("delete-store")
                     || options.has("ro-metadata") || options.has("set-metadata")
                     || options.has("get-metadata") || options.has("check-metadata") || options.has("key-distribution"))
                 || options.has("truncate") || options.has("clear-rebalancing-metadata") || options.has("async"))) {
                System.err.println("Missing required arguments: " + Joiner.on(", ").join(missing));
                printHelp(System.err, parser);
                System.exit(1);
            }
        }

        String url = (String) options.valueOf("url");
        Integer nodeId = CmdUtils.valueOf(options, "node", -1);
        int parallelism = CmdUtils.valueOf(options, "restore", 5);

        AdminClient adminClient = new AdminClient(url, new AdminClientConfig());

        String ops = "";
        if(options.has("delete-partitions")) {
            ops += "d";
        }
        if(options.has("fetch-keys")) {
            ops += "k";
        }
        if(options.has("fetch-entries")) {
            ops += "v";
        }
        if(options.has("restore")) {
            ops += "r";
        }
        if(options.has("add-stores")) {
            ops += "a";
        }
        if(options.has("update-entries")) {
            ops += "u";
        }
        if(options.has("delete-store")) {
            ops += "s";
        }
        if(options.has("get-metadata")) {
            ops += "g";
        }
        if(options.has("ro-metadata")) {
            ops += "e";
        }
        if(options.has("truncate")) {
            ops += "t";
        }
        if(options.has("set-metadata")) {
            ops += "m";
        }
        if(options.has("check-metadata")) {
            ops += "c";
        }
        if(options.has("key-distribution")) {
            ops += "y";
        }
        if(options.has("clear-rebalancing-metadata")) {
            ops += "i";
        }
        if(options.has("async")) {
            ops += "b";
        }
        if(ops.length() < 1) {
            Utils.croak("At least one of (delete-partitions, restore, add-node, fetch-entries, "
                        + "fetch-keys, add-stores, delete-store, update-entries, get-metadata, ro-metadata, "
                        + "set-metadata, check-metadata, key-distribution, clear-rebalancing-metadata, async) "
                        + "must be specified");
        }

        List<String> storeNames = null;

        if(options.has("stores")) {
            List<String> temp = (List<String>) options.valuesOf("stores");
            storeNames = temp;
        }

        String outputDir = null;
        if(options.has("outdir")) {
            outputDir = (String) options.valueOf("outdir");
        }

        try {
            if(ops.contains("d")) {
                System.out.println("Starting delete-partitions");
                List<Integer> partitionIdList = (List<Integer>) options.valuesOf("delete-partitions");
                executeDeletePartitions(nodeId, adminClient, partitionIdList, storeNames);
                System.out.println("Finished delete-partitions");
            }
            if(ops.contains("r")) {
                if(nodeId == -1) {
                    System.err.println("Cannot run restore without node id");
                    System.exit(1);
                }
                System.out.println("Starting restore");
                adminClient.restoreDataFromReplications(nodeId, parallelism);
                System.out.println("Finished restore");
            }
            if(ops.contains("k")) {
                boolean useAscii = options.has("ascii");
                System.out.println("Starting fetch keys");
                List<Integer> partitionIdList = null;
                if(options.hasArgument("fetch-keys"))
                    partitionIdList = (List<Integer>) options.valuesOf("fetch-keys");
                executeFetchKeys(nodeId,
                                 adminClient,
                                 partitionIdList,
                                 outputDir,
                                 storeNames,
                                 useAscii);
            }
            if(ops.contains("v")) {
                boolean useAscii = options.has("ascii");
                System.out.println("Starting fetch entries");
                List<Integer> partitionIdList = null;
                if(options.hasArgument("fetch-entries"))
                    partitionIdList = (List<Integer>) options.valuesOf("fetch-entries");
                executeFetchEntries(nodeId,
                                    adminClient,
                                    partitionIdList,
                                    outputDir,
                                    storeNames,
                                    useAscii);
            }
            if(ops.contains("a")) {
                String storesXml = (String) options.valueOf("add-stores");
                executeAddStores(adminClient, storesXml, nodeId);
            }
            if(ops.contains("u")) {
                String inputDir = (String) options.valueOf("update-entries");
                executeUpdateEntries(nodeId, adminClient, storeNames, inputDir);
            }
            if(ops.contains("s")) {
                String storeName = (String) options.valueOf("delete-store");
                executeDeleteStore(adminClient, storeName, nodeId);
            }
            if(ops.contains("g")) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415626051833/fstmerge_var1_2429215501670457921
                if(options.has("outdir")) {
                    outputDir = (String) options.valueOf("outdir");
                }
                String metadataKey = (String) options.valueOf("get-metadata");
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415626051833/fstmerge_base_831541221483627678
                String metadataKey = (String) options.valueOf("get-metadata");
=======
                String metadataKey = ALL_METADATA;
                if(options.hasArgument("get-metadata")) {
                    metadataKey = (String) options.valueOf("get-metadata");
                }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415626051833/fstmerge_var2_5374944785161796475
                executeGetMetadata(nodeId, adminClient, metadataKey, outputDir);
            }
            if(ops.contains("e")) {
                String type = (String) options.valueOf("ro-metadata");
                executeROMetadata(nodeId, adminClient, storeNames, type);
            }
            if(ops.contains("t")) {
                String storeName = (String) options.valueOf("truncate");
                executeTruncateStore(nodeId, adminClient, storeName);
            }
            if(ops.contains("c")) {
                String metadataKey = (String) options.valueOf("check-metadata");
                executeCheckMetadata(adminClient, metadataKey);
            }
            if(ops.contains("m")) {
                String metadataKey = (String) options.valueOf("set-metadata");
                if(!options.has("set-metadata-value")) {
                    throw new VoldemortException("Missing set-metadata-value");
                } else {
                    String metadataValue = (String) options.valueOf("set-metadata-value");
                    if(metadataKey.compareTo(MetadataStore.CLUSTER_KEY) == 0) {
                        if(!Utils.isReadableFile(metadataValue))
                            throw new VoldemortException("Cluster xml file path incorrect");
                        ClusterMapper mapper = new ClusterMapper();
                        Cluster newCluster = mapper.readCluster(new File(metadataValue));
                        executeSetMetadata(nodeId,
                                           adminClient,
                                           MetadataStore.CLUSTER_KEY,
                                           mapper.writeCluster(newCluster));
                    } else if(metadataKey.compareTo(MetadataStore.SERVER_STATE_KEY) == 0) {
                        VoldemortState newState = VoldemortState.valueOf(metadataValue);
                        executeSetMetadata(nodeId,
                                           adminClient,
                                           MetadataStore.SERVER_STATE_KEY,
                                           newState.toString());
                    } else if(metadataKey.compareTo(MetadataStore.STORES_KEY) == 0) {
                        if(!Utils.isReadableFile(metadataValue))
                            throw new VoldemortException("Stores definition xml file path incorrect");
                        StoreDefinitionsMapper mapper = new StoreDefinitionsMapper();
                        List<StoreDefinition> storeDefs = mapper.readStoreList(new File(metadataValue));
                        executeSetMetadata(nodeId,
                                           adminClient,
                                           MetadataStore.STORES_KEY,
                                           mapper.writeStoreList(storeDefs));
                    } else if(metadataKey.compareTo(MetadataStore.REBALANCING_STEAL_INFO) == 0) {
                        if(!Utils.isReadableFile(metadataValue))
                            throw new VoldemortException("Rebalancing steal info file path incorrect");
                        String rebalancingStealInfoJsonString = FileUtils.readFileToString(new File(metadataValue));
                        RebalancerState state = RebalancerState.create(rebalancingStealInfoJsonString);
                        executeSetMetadata(nodeId,
                                           adminClient,
                                           MetadataStore.REBALANCING_STEAL_INFO,
                                           state.toJsonString());
                    } else {
                        throw new VoldemortException("Incorrect metadata key");
                    }
                }

            }
            if(ops.contains("y")) {
                executeKeyDistribution(adminClient);
            }
            if(ops.contains("i")) {
                executeClearRebalancing(nodeId, adminClient);
            }
            if(ops.contains("b")) {
                String asyncKey = (String) options.valueOf("async");
                List<Integer> asyncIds = null;
                if(options.hasArgument("async-id"))
                    asyncIds = (List<Integer>) options.valuesOf("async-id");
                executeAsync(nodeId, adminClient, asyncKey, asyncIds);
            }
        } catch(Exception e) {
            e.printStackTrace();
            Utils.croak(e.getMessage());
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_69ae6_c3b87/rev_69ae6-c3b87/src/java/voldemort/VoldemortAdminTool.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415626051867/fstmerge_base_3141176126139222116
private static void executeGetMetadata(Integer nodeId,
                                           AdminClient adminClient,
                                           String metadataKey,
                                           String outputDir) throws IOException {

=======
public static void executeGetMetadata(Integer nodeId,
                                          AdminClient adminClient,
                                          String metadataKey,
                                          String outputDir) throws IOException {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415626051867/fstmerge_var2_2125639705724976207
        File directory = null;
        if(outputDir != null) {
            directory = new File(outputDir);
            if(!(directory.exists() || directory.mkdir())) {
                Utils.croak("Can't find or create directory " + outputDir);
            }
        }

        List<Integer> nodeIds = Lists.newArrayList();
        if(nodeId < 0) {
            for(Node node: adminClient.getAdminClientCluster().getNodes()) {
                nodeIds.add(node.getId());
            }
        } else {
            nodeIds.add(nodeId);
        }

        List<String> metadataKeys = Lists.newArrayList();
        if(metadataKey.compareTo(ALL_METADATA) == 0) {
            for(Object key: MetadataStore.METADATA_KEYS) {
                metadataKeys.add((String) key);
            }
        } else {
            metadataKeys.add(metadataKey);
        }
        for(Integer currentNodeId: nodeIds) {
            System.out.println(adminClient.getAdminClientCluster()
                                          .getNodeById(currentNodeId)
                                          .getHost()
                               + ":"
                               + adminClient.getAdminClientCluster()
                                            .getNodeById(currentNodeId)
                                            .getId());
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415626051867/fstmerge_var1_5278372062428967825
            Versioned<String> versioned = null;
            try {
                versioned = adminClient.getRemoteMetadata(currentNodeId, metadataKey);
            } catch(Exception e) {
                System.out.println("Error in retrieving " + e.getMessage());
                System.out.println();
                continue;
            }

            if(versioned == null) {
                if(directory == null) {
                    System.out.println("null");
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415626051867/fstmerge_base_3141176126139222116
            Versioned<String> versioned = null;
            try {
                versioned = adminClient.getRemoteMetadata(currentNodeId, metadataKey);
            } catch(Exception e) {
                System.out.println("Error in retrieving " + e.getMessage());
                System.out.println();
                continue;
            }
            if(versioned == null) {
                if(directory == null) {
                    System.out.println("null");
=======
            for(String key: metadataKeys) {
                System.out.println("Key - " + key);
                Versioned<String> versioned = null;
                try {
                    versioned = adminClient.getRemoteMetadata(currentNodeId, key);
                } catch(Exception e) {
                    System.out.println("Error in retrieving " + e.getMessage());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415626051867/fstmerge_var2_2125639705724976207
                    System.out.println();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415626051867/fstmerge_var1_5278372062428967825
                } else {
                    FileUtils.writeStringToFile(new File(directory, metadataKey + "."
                                                                    + currentNodeId), "");
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415626051867/fstmerge_base_3141176126139222116
                } else {
                    FileUtils.writeStringToFile(new File(directory, "cluster.xml_" + currentNodeId),
                                                "");
=======
                    continue;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415626051867/fstmerge_var2_2125639705724976207
                }
                if(versioned == null) {
                    if(directory == null) {
                        System.out.println("null");
                        System.out.println();
                    } else {
                        FileUtils.writeStringToFile(new File(directory, key + "_" + currentNodeId),
                                                    "");
                    }
                } else {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415626051867/fstmerge_var1_5278372062428967825
                    FileUtils.writeStringToFile(new File(directory, metadataKey + "."
                                                                    + currentNodeId),
                                                versioned.getValue());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415626051867/fstmerge_base_3141176126139222116
                    FileUtils.writeStringToFile(new File(directory, "cluster.xml_" + currentNodeId),
                                                versioned.getValue());
=======
                    if(directory == null) {
                        System.out.println(versioned.getVersion());
                        System.out.print(": ");
                        System.out.println(versioned.getValue());
                        System.out.println();
                    } else {
                        FileUtils.writeStringToFile(new File(directory, key + "_" + currentNodeId),
                                                    versioned.getValue());
                    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415626051867/fstmerge_var2_2125639705724976207
                }
            }
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_69ae6_c3b87/rev_69ae6-c3b87/src/java/voldemort/VoldemortAdminTool.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_1ce98_6c31f/rev_1ce98-6c31f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2ac36_351e7/rev_2ac36-351e7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_1ce98_9ed2a/rev_1ce98-9ed2a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2ac36_02420/rev_2ac36-02420.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_351e7_86293/rev_351e7-86293.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a6927_f5628/rev_a6927-f5628.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_57121_2ac36/rev_57121-2ac36.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_57121_784fe/rev_57121-784fe.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_25e29_e8fab/rev_25e29-e8fab.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_abfbe_611dd/rev_abfbe-611dd.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b2be5_c7160/rev_b2be5-c7160.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_8a937_cc8c3/rev_8a937-cc8c3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_9e681_1bf53/rev_9e681-1bf53.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6388c_3fea6/rev_6388c-3fea6.revisions

=========================================================
=========================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public static AdminRequestType valueOf(int value) {
      switch (value) {
        case 0: return GET_METADATA;
        case 1: return UPDATE_METADATA;
        case 2: return UPDATE_PARTITION_ENTRIES;
        case 3: return FETCH_PARTITION_ENTRIES;
        case 4: return DELETE_PARTITION_ENTRIES;
        case 5: return INITIATE_FETCH_AND_UPDATE;
        case 6: return ASYNC_OPERATION_STATUS;
        case 7: return INITIATE_REBALANCE_NODE;
        case 8: return ASYNC_OPERATION_STOP;
        case 9: return ASYNC_OPERATION_LIST;
        case 10: return TRUNCATE_ENTRIES;
        case 11: return ADD_STORE;
        case 12: return DELETE_STORE;
        case 13: return FETCH_STORE;
        case 14: return SWAP_STORE;
        case 15: return ROLLBACK_STORE;
        case 16: return GET_RO_MAX_VERSION_DIR;
        case 17: return GET_RO_CURRENT_VERSION_DIR;
        case 18: return FETCH_PARTITION_FILES;
        case 20: return UPDATE_SLOP_ENTRIES;
        case 22: return FAILED_FETCH_STORE;
        case 23: return GET_RO_STORAGE_FORMAT;
        case 24: return REBALANCE_STATE_CHANGE;
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724953218/fstmerge_var1_3107469212092081279
        case 25: return REPAIR_JOB;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724953218/fstmerge_base_3249151944491866095
=======
        case 25: return INITIATE_REBALANCE_NODE_ON_DONOR;
        case 26: return DELETE_STORE_REBALANCE_STATE;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724953218/fstmerge_var2_5359608522674678521
        default: return null;
      }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ private static final AdminRequestType[] VALUES = {
      GET_METADATA, UPDATE_METADATA, UPDATE_PARTITION_ENTRIES, FETCH_PARTITION_ENTRIES, DELETE_PARTITION_ENTRIES, INITIATE_FETCH_AND_UPDATE, ASYNC_OPERATION_STATUS, INITIATE_REBALANCE_NODE, ASYNC_OPERATION_STOP, ASYNC_OPERATION_LIST, TRUNCATE_ENTRIES, ADD_STORE, DELETE_STORE, FETCH_STORE, SWAP_STORE, ROLLBACK_STORE, GET_RO_MAX_VERSION_DIR, GET_RO_CURRENT_VERSION_DIR, FETCH_PARTITION_FILES, UPDATE_SLOP_ENTRIES, FAILED_FETCH_STORE, GET_RO_STORAGE_FORMAT, REBALANCE_STATE_CHANGE, REPAIR_JOB, 
    }; ##FSTMerge## private static final AdminRequestType[] VALUES = {
      GET_METADATA, UPDATE_METADATA, UPDATE_PARTITION_ENTRIES, FETCH_PARTITION_ENTRIES, DELETE_PARTITION_ENTRIES, INITIATE_FETCH_AND_UPDATE, ASYNC_OPERATION_STATUS, INITIATE_REBALANCE_NODE, ASYNC_OPERATION_STOP, ASYNC_OPERATION_LIST, TRUNCATE_ENTRIES, ADD_STORE, DELETE_STORE, FETCH_STORE, SWAP_STORE, ROLLBACK_STORE, GET_RO_MAX_VERSION_DIR, GET_RO_CURRENT_VERSION_DIR, FETCH_PARTITION_FILES, UPDATE_SLOP_ENTRIES, FAILED_FETCH_STORE, GET_RO_STORAGE_FORMAT, REBALANCE_STATE_CHANGE, 
    }; ##FSTMerge## private static final AdminRequestType[] VALUES = {
      GET_METADATA, UPDATE_METADATA, UPDATE_PARTITION_ENTRIES, FETCH_PARTITION_ENTRIES, DELETE_PARTITION_ENTRIES, INITIATE_FETCH_AND_UPDATE, ASYNC_OPERATION_STATUS, INITIATE_REBALANCE_NODE, ASYNC_OPERATION_STOP, ASYNC_OPERATION_LIST, TRUNCATE_ENTRIES, ADD_STORE, DELETE_STORE, FETCH_STORE, SWAP_STORE, ROLLBACK_STORE, GET_RO_MAX_VERSION_DIR, GET_RO_CURRENT_VERSION_DIR, FETCH_PARTITION_FILES, UPDATE_SLOP_ENTRIES, FAILED_FETCH_STORE, GET_RO_STORAGE_FORMAT, REBALANCE_STATE_CHANGE, INITIATE_REBALANCE_NODE_ON_DONOR, DELETE_STORE_REBALANCE_STATE, 
    };
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
private void initFields() {
      type_ = voldemort.client.protocol.pb.VAdminProto.AdminRequestType.GET_METADATA;
      getMetadata_ = voldemort.client.protocol.pb.VAdminProto.GetMetadataRequest.getDefaultInstance();
      updateMetadata_ = voldemort.client.protocol.pb.VAdminProto.UpdateMetadataRequest.getDefaultInstance();
      updatePartitionEntries_ = voldemort.client.protocol.pb.VAdminProto.UpdatePartitionEntriesRequest.getDefaultInstance();
      fetchPartitionEntries_ = voldemort.client.protocol.pb.VAdminProto.FetchPartitionEntriesRequest.getDefaultInstance();
      deletePartitionEntries_ = voldemort.client.protocol.pb.VAdminProto.DeletePartitionEntriesRequest.getDefaultInstance();
      initiateFetchAndUpdate_ = voldemort.client.protocol.pb.VAdminProto.InitiateFetchAndUpdateRequest.getDefaultInstance();
      asyncOperationStatus_ = voldemort.client.protocol.pb.VAdminProto.AsyncOperationStatusRequest.getDefaultInstance();
      initiateRebalanceNode_ = voldemort.client.protocol.pb.VAdminProto.InitiateRebalanceNodeRequest.getDefaultInstance();
      asyncOperationStop_ = voldemort.client.protocol.pb.VAdminProto.AsyncOperationStopRequest.getDefaultInstance();
      asyncOperationList_ = voldemort.client.protocol.pb.VAdminProto.AsyncOperationListRequest.getDefaultInstance();
      truncateEntries_ = voldemort.client.protocol.pb.VAdminProto.TruncateEntriesRequest.getDefaultInstance();
      addStore_ = voldemort.client.protocol.pb.VAdminProto.AddStoreRequest.getDefaultInstance();
      deleteStore_ = voldemort.client.protocol.pb.VAdminProto.DeleteStoreRequest.getDefaultInstance();
      fetchStore_ = voldemort.client.protocol.pb.VAdminProto.FetchStoreRequest.getDefaultInstance();
      swapStore_ = voldemort.client.protocol.pb.VAdminProto.SwapStoreRequest.getDefaultInstance();
      rollbackStore_ = voldemort.client.protocol.pb.VAdminProto.RollbackStoreRequest.getDefaultInstance();
      getRoMaxVersionDir_ = voldemort.client.protocol.pb.VAdminProto.GetROMaxVersionDirRequest.getDefaultInstance();
      getRoCurrentVersionDir_ = voldemort.client.protocol.pb.VAdminProto.GetROCurrentVersionDirRequest.getDefaultInstance();
      fetchPartitionFiles_ = voldemort.client.protocol.pb.VAdminProto.FetchPartitionFilesRequest.getDefaultInstance();
      updateSlopEntries_ = voldemort.client.protocol.pb.VAdminProto.UpdateSlopEntriesRequest.getDefaultInstance();
      failedFetchStore_ = voldemort.client.protocol.pb.VAdminProto.FailedFetchStoreRequest.getDefaultInstance();
      getRoStorageFormat_ = voldemort.client.protocol.pb.VAdminProto.GetROStorageFormatRequest.getDefaultInstance();
      rebalanceStateChange_ = voldemort.client.protocol.pb.VAdminProto.RebalanceStateChangeRequest.getDefaultInstance();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724965283/fstmerge_var1_8442305239657389698
      repairJob_ = voldemort.client.protocol.pb.VAdminProto.RepairJobRequest.getDefaultInstance();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724965283/fstmerge_base_7053788613494315491
=======
      initiateRebalanceNodeOnDonor_ = voldemort.client.protocol.pb.VAdminProto.InitiateRebalanceNodeOnDonorRequest.getDefaultInstance();
      deleteStoreRebalanceState_ = voldemort.client.protocol.pb.VAdminProto.DeleteStoreRebalanceStateRequest.getDefaultInstance();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724965283/fstmerge_var2_5631269061663529804
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (hasType()) {
        output.writeEnum(1, getType().getNumber());
      }
      if (hasGetMetadata()) {
        output.writeMessage(2, getGetMetadata());
      }
      if (hasUpdateMetadata()) {
        output.writeMessage(3, getUpdateMetadata());
      }
      if (hasUpdatePartitionEntries()) {
        output.writeMessage(4, getUpdatePartitionEntries());
      }
      if (hasFetchPartitionEntries()) {
        output.writeMessage(5, getFetchPartitionEntries());
      }
      if (hasDeletePartitionEntries()) {
        output.writeMessage(6, getDeletePartitionEntries());
      }
      if (hasInitiateFetchAndUpdate()) {
        output.writeMessage(7, getInitiateFetchAndUpdate());
      }
      if (hasAsyncOperationStatus()) {
        output.writeMessage(8, getAsyncOperationStatus());
      }
      if (hasInitiateRebalanceNode()) {
        output.writeMessage(9, getInitiateRebalanceNode());
      }
      if (hasAsyncOperationStop()) {
        output.writeMessage(10, getAsyncOperationStop());
      }
      if (hasAsyncOperationList()) {
        output.writeMessage(11, getAsyncOperationList());
      }
      if (hasTruncateEntries()) {
        output.writeMessage(12, getTruncateEntries());
      }
      if (hasAddStore()) {
        output.writeMessage(13, getAddStore());
      }
      if (hasDeleteStore()) {
        output.writeMessage(14, getDeleteStore());
      }
      if (hasFetchStore()) {
        output.writeMessage(15, getFetchStore());
      }
      if (hasSwapStore()) {
        output.writeMessage(16, getSwapStore());
      }
      if (hasRollbackStore()) {
        output.writeMessage(17, getRollbackStore());
      }
      if (hasGetRoMaxVersionDir()) {
        output.writeMessage(18, getGetRoMaxVersionDir());
      }
      if (hasGetRoCurrentVersionDir()) {
        output.writeMessage(19, getGetRoCurrentVersionDir());
      }
      if (hasFetchPartitionFiles()) {
        output.writeMessage(20, getFetchPartitionFiles());
      }
      if (hasUpdateSlopEntries()) {
        output.writeMessage(22, getUpdateSlopEntries());
      }
      if (hasFailedFetchStore()) {
        output.writeMessage(24, getFailedFetchStore());
      }
      if (hasGetRoStorageFormat()) {
        output.writeMessage(25, getGetRoStorageFormat());
      }
      if (hasRebalanceStateChange()) {
        output.writeMessage(26, getRebalanceStateChange());
      }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724965292/fstmerge_var1_6637317022310411311
      if (hasRepairJob()) {
        output.writeMessage(27, getRepairJob());
      }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724965292/fstmerge_base_4194334747929407822
=======
      if (hasInitiateRebalanceNodeOnDonor()) {
        output.writeMessage(27, getInitiateRebalanceNodeOnDonor());
      }
      if (hasDeleteStoreRebalanceState()) {
        output.writeMessage(28, getDeleteStoreRebalanceState());
      }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724965292/fstmerge_var2_4465712736100700987
      getUnknownFields().writeTo(output);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
    
      size = 0;
      if (hasType()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, getType().getNumber());
      }
      if (hasGetMetadata()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getGetMetadata());
      }
      if (hasUpdateMetadata()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getUpdateMetadata());
      }
      if (hasUpdatePartitionEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getUpdatePartitionEntries());
      }
      if (hasFetchPartitionEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getFetchPartitionEntries());
      }
      if (hasDeletePartitionEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getDeletePartitionEntries());
      }
      if (hasInitiateFetchAndUpdate()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getInitiateFetchAndUpdate());
      }
      if (hasAsyncOperationStatus()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getAsyncOperationStatus());
      }
      if (hasInitiateRebalanceNode()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, getInitiateRebalanceNode());
      }
      if (hasAsyncOperationStop()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, getAsyncOperationStop());
      }
      if (hasAsyncOperationList()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, getAsyncOperationList());
      }
      if (hasTruncateEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(12, getTruncateEntries());
      }
      if (hasAddStore()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(13, getAddStore());
      }
      if (hasDeleteStore()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(14, getDeleteStore());
      }
      if (hasFetchStore()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(15, getFetchStore());
      }
      if (hasSwapStore()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(16, getSwapStore());
      }
      if (hasRollbackStore()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(17, getRollbackStore());
      }
      if (hasGetRoMaxVersionDir()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(18, getGetRoMaxVersionDir());
      }
      if (hasGetRoCurrentVersionDir()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(19, getGetRoCurrentVersionDir());
      }
      if (hasFetchPartitionFiles()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(20, getFetchPartitionFiles());
      }
      if (hasUpdateSlopEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(22, getUpdateSlopEntries());
      }
      if (hasFailedFetchStore()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(24, getFailedFetchStore());
      }
      if (hasGetRoStorageFormat()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(25, getGetRoStorageFormat());
      }
      if (hasRebalanceStateChange()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(26, getRebalanceStateChange());
      }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724965298/fstmerge_var1_3963344421313966887
      if (hasRepairJob()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(27, getRepairJob());
      }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724965298/fstmerge_base_6054026751926414343
=======
      if (hasInitiateRebalanceNodeOnDonor()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(27, getInitiateRebalanceNodeOnDonor());
      }
      if (hasDeleteStoreRebalanceState()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(28, getDeleteStoreRebalanceState());
      }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724965298/fstmerge_var2_680930840128735113
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
public Builder mergeFrom(voldemort.client.protocol.pb.VAdminProto.VoldemortAdminRequest other) {
        if (other == voldemort.client.protocol.pb.VAdminProto.VoldemortAdminRequest.getDefaultInstance()) return this;
        if (other.hasType()) {
          setType(other.getType());
        }
        if (other.hasGetMetadata()) {
          mergeGetMetadata(other.getGetMetadata());
        }
        if (other.hasUpdateMetadata()) {
          mergeUpdateMetadata(other.getUpdateMetadata());
        }
        if (other.hasUpdatePartitionEntries()) {
          mergeUpdatePartitionEntries(other.getUpdatePartitionEntries());
        }
        if (other.hasFetchPartitionEntries()) {
          mergeFetchPartitionEntries(other.getFetchPartitionEntries());
        }
        if (other.hasDeletePartitionEntries()) {
          mergeDeletePartitionEntries(other.getDeletePartitionEntries());
        }
        if (other.hasInitiateFetchAndUpdate()) {
          mergeInitiateFetchAndUpdate(other.getInitiateFetchAndUpdate());
        }
        if (other.hasAsyncOperationStatus()) {
          mergeAsyncOperationStatus(other.getAsyncOperationStatus());
        }
        if (other.hasInitiateRebalanceNode()) {
          mergeInitiateRebalanceNode(other.getInitiateRebalanceNode());
        }
        if (other.hasAsyncOperationStop()) {
          mergeAsyncOperationStop(other.getAsyncOperationStop());
        }
        if (other.hasAsyncOperationList()) {
          mergeAsyncOperationList(other.getAsyncOperationList());
        }
        if (other.hasTruncateEntries()) {
          mergeTruncateEntries(other.getTruncateEntries());
        }
        if (other.hasAddStore()) {
          mergeAddStore(other.getAddStore());
        }
        if (other.hasDeleteStore()) {
          mergeDeleteStore(other.getDeleteStore());
        }
        if (other.hasFetchStore()) {
          mergeFetchStore(other.getFetchStore());
        }
        if (other.hasSwapStore()) {
          mergeSwapStore(other.getSwapStore());
        }
        if (other.hasRollbackStore()) {
          mergeRollbackStore(other.getRollbackStore());
        }
        if (other.hasGetRoMaxVersionDir()) {
          mergeGetRoMaxVersionDir(other.getGetRoMaxVersionDir());
        }
        if (other.hasGetRoCurrentVersionDir()) {
          mergeGetRoCurrentVersionDir(other.getGetRoCurrentVersionDir());
        }
        if (other.hasFetchPartitionFiles()) {
          mergeFetchPartitionFiles(other.getFetchPartitionFiles());
        }
        if (other.hasUpdateSlopEntries()) {
          mergeUpdateSlopEntries(other.getUpdateSlopEntries());
        }
        if (other.hasFailedFetchStore()) {
          mergeFailedFetchStore(other.getFailedFetchStore());
        }
        if (other.hasGetRoStorageFormat()) {
          mergeGetRoStorageFormat(other.getGetRoStorageFormat());
        }
        if (other.hasRebalanceStateChange()) {
          mergeRebalanceStateChange(other.getRebalanceStateChange());
        }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724965425/fstmerge_var1_2686897154496343413
        if (other.hasRepairJob()) {
          mergeRepairJob(other.getRepairJob());
        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724965425/fstmerge_base_6398430962543386187
=======
        if (other.hasInitiateRebalanceNodeOnDonor()) {
          mergeInitiateRebalanceNodeOnDonor(other.getInitiateRebalanceNodeOnDonor());
        }
        if (other.hasDeleteStoreRebalanceState()) {
          mergeDeleteStoreRebalanceState(other.getDeleteStoreRebalanceState());
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724965425/fstmerge_var2_3441138662466896843
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder(
            this.getUnknownFields());
        while (true) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              this.setUnknownFields(unknownFields.build());
              return this;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                this.setUnknownFields(unknownFields.build());
                return this;
              }
              break;
            }
            case 8: {
              int rawValue = input.readEnum();
              voldemort.client.protocol.pb.VAdminProto.AdminRequestType value = voldemort.client.protocol.pb.VAdminProto.AdminRequestType.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(1, rawValue);
              } else {
                setType(value);
              }
              break;
            }
            case 18: {
              voldemort.client.protocol.pb.VAdminProto.GetMetadataRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.GetMetadataRequest.newBuilder();
              if (hasGetMetadata()) {
                subBuilder.mergeFrom(getGetMetadata());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setGetMetadata(subBuilder.buildPartial());
              break;
            }
            case 26: {
              voldemort.client.protocol.pb.VAdminProto.UpdateMetadataRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.UpdateMetadataRequest.newBuilder();
              if (hasUpdateMetadata()) {
                subBuilder.mergeFrom(getUpdateMetadata());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setUpdateMetadata(subBuilder.buildPartial());
              break;
            }
            case 34: {
              voldemort.client.protocol.pb.VAdminProto.UpdatePartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.UpdatePartitionEntriesRequest.newBuilder();
              if (hasUpdatePartitionEntries()) {
                subBuilder.mergeFrom(getUpdatePartitionEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setUpdatePartitionEntries(subBuilder.buildPartial());
              break;
            }
            case 42: {
              voldemort.client.protocol.pb.VAdminProto.FetchPartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.FetchPartitionEntriesRequest.newBuilder();
              if (hasFetchPartitionEntries()) {
                subBuilder.mergeFrom(getFetchPartitionEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setFetchPartitionEntries(subBuilder.buildPartial());
              break;
            }
            case 50: {
              voldemort.client.protocol.pb.VAdminProto.DeletePartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.DeletePartitionEntriesRequest.newBuilder();
              if (hasDeletePartitionEntries()) {
                subBuilder.mergeFrom(getDeletePartitionEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setDeletePartitionEntries(subBuilder.buildPartial());
              break;
            }
            case 58: {
              voldemort.client.protocol.pb.VAdminProto.InitiateFetchAndUpdateRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.InitiateFetchAndUpdateRequest.newBuilder();
              if (hasInitiateFetchAndUpdate()) {
                subBuilder.mergeFrom(getInitiateFetchAndUpdate());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setInitiateFetchAndUpdate(subBuilder.buildPartial());
              break;
            }
            case 66: {
              voldemort.client.protocol.pb.VAdminProto.AsyncOperationStatusRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.AsyncOperationStatusRequest.newBuilder();
              if (hasAsyncOperationStatus()) {
                subBuilder.mergeFrom(getAsyncOperationStatus());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setAsyncOperationStatus(subBuilder.buildPartial());
              break;
            }
            case 74: {
              voldemort.client.protocol.pb.VAdminProto.InitiateRebalanceNodeRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.InitiateRebalanceNodeRequest.newBuilder();
              if (hasInitiateRebalanceNode()) {
                subBuilder.mergeFrom(getInitiateRebalanceNode());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setInitiateRebalanceNode(subBuilder.buildPartial());
              break;
            }
            case 82: {
              voldemort.client.protocol.pb.VAdminProto.AsyncOperationStopRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.AsyncOperationStopRequest.newBuilder();
              if (hasAsyncOperationStop()) {
                subBuilder.mergeFrom(getAsyncOperationStop());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setAsyncOperationStop(subBuilder.buildPartial());
              break;
            }
            case 90: {
              voldemort.client.protocol.pb.VAdminProto.AsyncOperationListRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.AsyncOperationListRequest.newBuilder();
              if (hasAsyncOperationList()) {
                subBuilder.mergeFrom(getAsyncOperationList());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setAsyncOperationList(subBuilder.buildPartial());
              break;
            }
            case 98: {
              voldemort.client.protocol.pb.VAdminProto.TruncateEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.TruncateEntriesRequest.newBuilder();
              if (hasTruncateEntries()) {
                subBuilder.mergeFrom(getTruncateEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setTruncateEntries(subBuilder.buildPartial());
              break;
            }
            case 106: {
              voldemort.client.protocol.pb.VAdminProto.AddStoreRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.AddStoreRequest.newBuilder();
              if (hasAddStore()) {
                subBuilder.mergeFrom(getAddStore());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setAddStore(subBuilder.buildPartial());
              break;
            }
            case 114: {
              voldemort.client.protocol.pb.VAdminProto.DeleteStoreRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.DeleteStoreRequest.newBuilder();
              if (hasDeleteStore()) {
                subBuilder.mergeFrom(getDeleteStore());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setDeleteStore(subBuilder.buildPartial());
              break;
            }
            case 122: {
              voldemort.client.protocol.pb.VAdminProto.FetchStoreRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.FetchStoreRequest.newBuilder();
              if (hasFetchStore()) {
                subBuilder.mergeFrom(getFetchStore());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setFetchStore(subBuilder.buildPartial());
              break;
            }
            case 130: {
              voldemort.client.protocol.pb.VAdminProto.SwapStoreRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.SwapStoreRequest.newBuilder();
              if (hasSwapStore()) {
                subBuilder.mergeFrom(getSwapStore());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setSwapStore(subBuilder.buildPartial());
              break;
            }
            case 138: {
              voldemort.client.protocol.pb.VAdminProto.RollbackStoreRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.RollbackStoreRequest.newBuilder();
              if (hasRollbackStore()) {
                subBuilder.mergeFrom(getRollbackStore());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setRollbackStore(subBuilder.buildPartial());
              break;
            }
            case 146: {
              voldemort.client.protocol.pb.VAdminProto.GetROMaxVersionDirRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.GetROMaxVersionDirRequest.newBuilder();
              if (hasGetRoMaxVersionDir()) {
                subBuilder.mergeFrom(getGetRoMaxVersionDir());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setGetRoMaxVersionDir(subBuilder.buildPartial());
              break;
            }
            case 154: {
              voldemort.client.protocol.pb.VAdminProto.GetROCurrentVersionDirRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.GetROCurrentVersionDirRequest.newBuilder();
              if (hasGetRoCurrentVersionDir()) {
                subBuilder.mergeFrom(getGetRoCurrentVersionDir());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setGetRoCurrentVersionDir(subBuilder.buildPartial());
              break;
            }
            case 162: {
              voldemort.client.protocol.pb.VAdminProto.FetchPartitionFilesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.FetchPartitionFilesRequest.newBuilder();
              if (hasFetchPartitionFiles()) {
                subBuilder.mergeFrom(getFetchPartitionFiles());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setFetchPartitionFiles(subBuilder.buildPartial());
              break;
            }
            case 178: {
              voldemort.client.protocol.pb.VAdminProto.UpdateSlopEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.UpdateSlopEntriesRequest.newBuilder();
              if (hasUpdateSlopEntries()) {
                subBuilder.mergeFrom(getUpdateSlopEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setUpdateSlopEntries(subBuilder.buildPartial());
              break;
            }
            case 194: {
              voldemort.client.protocol.pb.VAdminProto.FailedFetchStoreRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.FailedFetchStoreRequest.newBuilder();
              if (hasFailedFetchStore()) {
                subBuilder.mergeFrom(getFailedFetchStore());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setFailedFetchStore(subBuilder.buildPartial());
              break;
            }
            case 202: {
              voldemort.client.protocol.pb.VAdminProto.GetROStorageFormatRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.GetROStorageFormatRequest.newBuilder();
              if (hasGetRoStorageFormat()) {
                subBuilder.mergeFrom(getGetRoStorageFormat());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setGetRoStorageFormat(subBuilder.buildPartial());
              break;
            }
            case 210: {
              voldemort.client.protocol.pb.VAdminProto.RebalanceStateChangeRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.RebalanceStateChangeRequest.newBuilder();
              if (hasRebalanceStateChange()) {
                subBuilder.mergeFrom(getRebalanceStateChange());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setRebalanceStateChange(subBuilder.buildPartial());
              break;
            }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724965430/fstmerge_var1_7871070038230757271
            case 218: {
              voldemort.client.protocol.pb.VAdminProto.RepairJobRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.RepairJobRequest.newBuilder();
              if (hasRepairJob()) {
                subBuilder.mergeFrom(getRepairJob());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setRepairJob(subBuilder.buildPartial());
              break;
            }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724965430/fstmerge_base_6414750862922340586
=======
            case 218: {
              voldemort.client.protocol.pb.VAdminProto.InitiateRebalanceNodeOnDonorRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.InitiateRebalanceNodeOnDonorRequest.newBuilder();
              if (hasInitiateRebalanceNodeOnDonor()) {
                subBuilder.mergeFrom(getInitiateRebalanceNodeOnDonor());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setInitiateRebalanceNodeOnDonor(subBuilder.buildPartial());
              break;
            }
            case 226: {
              voldemort.client.protocol.pb.VAdminProto.DeleteStoreRebalanceStateRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.DeleteStoreRebalanceStateRequest.newBuilder();
              if (hasDeleteStoreRebalanceState()) {
                subBuilder.mergeFrom(getDeleteStoreRebalanceState());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setDeleteStoreRebalanceState(subBuilder.buildPartial());
              break;
            }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724965430/fstmerge_var2_5991940456782058980
          }
        }
      }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
public StreamRequestHandler handleRequest(final DataInputStream inputStream,
                                              final DataOutputStream outputStream)
            throws IOException {
        // Another protocol buffers bug here, temp. work around
        VoldemortAdminRequest.Builder request = VoldemortAdminRequest.newBuilder();
        int size = inputStream.readInt();

        if(logger.isTraceEnabled())
            logger.trace("In handleRequest, request specified size of " + size + " bytes");

        if(size < 0)
            throw new IOException("In handleRequest, request specified size of " + size + " bytes");

        byte[] input = new byte[size];
        ByteUtils.read(inputStream, input);
        request.mergeFrom(input);

        switch(request.getType()) {
            case GET_METADATA:
                ProtoUtils.writeMessage(outputStream, handleGetMetadata(request.getGetMetadata()));
                break;
            case UPDATE_METADATA:
                ProtoUtils.writeMessage(outputStream,
                                        handleUpdateMetadata(request.getUpdateMetadata()));
                break;
            case DELETE_PARTITION_ENTRIES:
                ProtoUtils.writeMessage(outputStream,
                                        handleDeletePartitionEntries(request.getDeletePartitionEntries()));
                break;
            case FETCH_PARTITION_ENTRIES:
                return handleFetchPartitionEntries(request.getFetchPartitionEntries());

            case UPDATE_PARTITION_ENTRIES:
                return handleUpdatePartitionEntries(request.getUpdatePartitionEntries());

            case INITIATE_FETCH_AND_UPDATE:
                ProtoUtils.writeMessage(outputStream,
                                        handleFetchAndUpdate(request.getInitiateFetchAndUpdate()));
                break;
            case ASYNC_OPERATION_STATUS:
                ProtoUtils.writeMessage(outputStream,
                                        handleAsyncStatus(request.getAsyncOperationStatus()));
                break;
            case INITIATE_REBALANCE_NODE:
                ProtoUtils.writeMessage(outputStream,
                                        handleRebalanceNode(request.getInitiateRebalanceNode()));
                break;
            case INITIATE_REBALANCE_NODE_ON_DONOR:
                ProtoUtils.writeMessage(outputStream,
                                        handleRebalanceNodeOnDonor(request.getInitiateRebalanceNodeOnDonor()));
                break;
            case ASYNC_OPERATION_LIST:
                ProtoUtils.writeMessage(outputStream,
                                        handleAsyncOperationList(request.getAsyncOperationList()));
                break;
            case ASYNC_OPERATION_STOP:
                ProtoUtils.writeMessage(outputStream,
                                        handleAsyncOperationStop(request.getAsyncOperationStop()));
                break;
            case TRUNCATE_ENTRIES:
                ProtoUtils.writeMessage(outputStream,
                                        handleTruncateEntries(request.getTruncateEntries()));
                break;
            case ADD_STORE:
                ProtoUtils.writeMessage(outputStream, handleAddStore(request.getAddStore()));
                break;
            case DELETE_STORE:
                ProtoUtils.writeMessage(outputStream, handleDeleteStore(request.getDeleteStore()));
                break;
            case FETCH_STORE:
                ProtoUtils.writeMessage(outputStream, handleFetchStore(request.getFetchStore()));
                break;
            case SWAP_STORE:
                ProtoUtils.writeMessage(outputStream, handleSwapStore(request.getSwapStore()));
                break;
            case ROLLBACK_STORE:
                ProtoUtils.writeMessage(outputStream,
                                        handleRollbackStore(request.getRollbackStore()));
                break;
            case GET_RO_MAX_VERSION_DIR:
                ProtoUtils.writeMessage(outputStream,
                                        handleGetROMaxVersionDir(request.getGetRoMaxVersionDir()));
                break;
            case GET_RO_CURRENT_VERSION_DIR:
                ProtoUtils.writeMessage(outputStream,
                                        handleGetROCurrentVersionDir(request.getGetRoCurrentVersionDir()));
                break;
            case GET_RO_STORAGE_FORMAT:
                ProtoUtils.writeMessage(outputStream,
                                        handleGetROStorageFormat(request.getGetRoStorageFormat()));
                break;
            case FETCH_PARTITION_FILES:
                return handleFetchPartitionFiles(request.getFetchPartitionFiles());
            case UPDATE_SLOP_ENTRIES:
                return handleUpdateSlopEntries(request.getUpdateSlopEntries());
            case FAILED_FETCH_STORE:
                ProtoUtils.writeMessage(outputStream,
                                        handleFailedFetch(request.getFailedFetchStore()));
                break;
            case REBALANCE_STATE_CHANGE:
                ProtoUtils.writeMessage(outputStream,
                                        handleRebalanceStateChange(request.getRebalanceStateChange()));
                break;
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724968888/fstmerge_var1_7921801600238898409
            case REPAIR_JOB:
                ProtoUtils.writeMessage(outputStream, handleRepairJob(request.getRepairJob()));
                break;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724968888/fstmerge_base_4894891129429282155
=======
            case DELETE_STORE_REBALANCE_STATE:
                ProtoUtils.writeMessage(outputStream,
                                        handleDeleteStoreRebalanceState(request.getDeleteStoreRebalanceState()));
                break;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724968888/fstmerge_var2_2452662951066202854
            default:
                throw new VoldemortException("Unkown operation " + request.getType());
        }

        return null;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/src/java/voldemort/server/protocol/admin/AdminServiceRequestHandler.java
Conflict type: LineBasedMCFd
Conflict body: 
public void generateEntropy(Cluster cluster,
                                List<StoreDefinition> storeDefs,
                                File storeDir,
                                boolean opType) throws IOException {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724972106/fstmerge_var1_9210304256832673299
        generateEntropy(cluster, storeDefs, storeDir, opType, false);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724972106/fstmerge_base_3313619110349019114
        AdminClient adminClient = null;
        try {
            adminClient = new AdminClient(cluster,
                                          new AdminClientConfig().setMaxConnectionsPerNode(storeDefs.size()));

            if(opType) {
                System.out.println("Running entropy calculator");
            } else {
                System.out.println("Generating keys for future entropy calculation");
                Utils.mkdirs(storeDir);
            }
            for(StoreDefinition storeDef: storeDefs) {

                File storesKeyFile = new File(storeDir, storeDef.getName());
                if(AdminClient.restoreStoreEngineBlackList.contains(storeDef.getType())) {
                    System.out.println("Ignoring store " + storeDef.getName());
                    continue;
                } else {
                    System.out.println("Working on store " + storeDef.getName());
                }

                RoutingStrategy strategy = new RoutingStrategyFactory().updateRoutingStrategy(storeDef,
                                                                                              cluster);

                if(!opType) {
                    if(storesKeyFile.exists()) {
                        System.err.println("Key files for " + storeDef.getName()
                                           + " already exists");
                        continue;
                    }
                    FileOutputStream writer = null;
                    try {
                        writer = new FileOutputStream(storesKeyFile);
                        Iterator<ByteArray> keys = null;
                        if(nodeId == -1) {

                            int numKeysPerNode = (int) Math.floor(numKeys
                                                                  / cluster.getNumberOfNodes());
                            for(Node node: cluster.getNodes()) {
                                keys = adminClient.fetchKeys(node.getId(),
                                                             storeDef.getName(),
                                                             cluster.getNodeById(node.getId())
                                                                    .getPartitionIds(),
                                                             null,
                                                             false);
                                for(long keyId = 0; keyId < numKeysPerNode && keys.hasNext(); keyId++) {
                                    ByteArray key = keys.next();
                                    if(RebalanceUtils.getNodeIds(strategy.routeRequest(key.get()))
                                                     .contains(node.getId())) {
                                        writer.write(key.length());
                                        writer.write(key.get());
                                    }
                                }
                            }
                        } else {
                            keys = adminClient.fetchKeys(nodeId,
                                                         storeDef.getName(),
                                                         cluster.getNodeById(nodeId)
                                                                .getPartitionIds(),
                                                         null,
                                                         false);
                            for(long keyId = 0; keyId < numKeys && keys.hasNext(); keyId++) {
                                ByteArray key = keys.next();
                                if(RebalanceUtils.getNodeIds(strategy.routeRequest(key.get()))
                                                 .contains(nodeId)) {
                                    writer.write(key.length());
                                    writer.write(key.get());
                                }
                            }
                        }

                    } finally {
                        if(writer != null)
                            writer.close();
                    }

                } else {

                    if(!(storesKeyFile.exists() && storesKeyFile.canRead())) {
                        System.err.println("Could not find " + storeDef.getName()
                                           + " file to check");
                        continue;
                    }
                    FileInputStream reader = null;
                    SocketStoreFactory socketStoreFactory = new ClientRequestExecutorPool(2,
                                                                                          10000,
                                                                                          100000,
                                                                                          32 * 1024);

                    // Cache connections to all nodes for this store in advance
                    HashMap<Integer, Store<ByteArray, byte[], byte[]>> socketStoresPerNode = Maps.newHashMap();
                    for(Node node: cluster.getNodes()) {
                        socketStoresPerNode.put(node.getId(),
                                                socketStoreFactory.create(storeDef.getName(),
                                                                          node.getHost(),
                                                                          node.getSocketPort(),
                                                                          RequestFormatType.PROTOCOL_BUFFERS,
                                                                          RequestRoutingType.IGNORE_CHECKS));
                    }

                    long foundKeys = 0L;
                    long totalKeys = 0L;
                    try {
                        reader = new FileInputStream(storesKeyFile);
                        while(reader.available() != 0) {
                            int size = reader.read();

                            if(size <= 0) {
                                break;
                            }

                            // Read the key
                            byte[] key = new byte[size];
                            reader.read(key);

                            List<Node> responsibleNodes = strategy.routeRequest(key);
                            boolean missingKey = false;
                            for(Node node: responsibleNodes) {
                                List<Versioned<byte[]>> value = socketStoresPerNode.get(node.getId())
                                                                                   .get(new ByteArray(key),
                                                                                        null);

                                if(value == null || value.size() == 0) {
                                    missingKey = true;
                                }
                            }
                            if(!missingKey)
                                foundKeys++;

                            totalKeys++;

                        }
                        System.out.println("Found = " + foundKeys + " Total = " + totalKeys);
                        if(foundKeys > 0 && totalKeys > 0) {
                            System.out.println("%age found - " + 100.0 * (double) foundKeys
                                               / totalKeys);
                        }
                    } finally {
                        if(reader != null)
                            reader.close();

                        // close all socket stores
                        for(Store<ByteArray, byte[], byte[]> store: socketStoresPerNode.values()) {
                            store.close();
                        }
                    }
                }

            }
        } finally {
            if(adminClient != null)
                adminClient.stop();
        }
=======
        AdminClient adminClient = null;
        try {
            adminClient = new AdminClient(cluster,
                                          new AdminClientConfig().setMaxConnectionsPerNode(storeDefs.size()));

            if(opType) {
                System.out.println("Running entropy calculator");
            } else {
                System.out.println("Generating keys for future entropy calculation");
                Utils.mkdirs(storeDir);
            }
            for(StoreDefinition storeDef: storeDefs) {

                File storesKeyFile = new File(storeDir, storeDef.getName());
                if(AdminClient.restoreStoreEngineBlackList.contains(storeDef.getType())) {
                    System.out.println("Ignoring store " + storeDef.getName());
                    continue;
                } else {
                    System.out.println("Working on store " + storeDef.getName());
                }

                RoutingStrategy strategy = new RoutingStrategyFactory().updateRoutingStrategy(storeDef,
                                                                                              cluster);

                if(!opType) {
                    if(storesKeyFile.exists()) {
                        System.err.println("Key files for " + storeDef.getName()
                                           + " already exists");
                        continue;
                    }
                    FileOutputStream writer = null;
                    try {
                        writer = new FileOutputStream(storesKeyFile);
                        Iterator<ByteArray> keys = null;
                        if(nodeId == -1) {

                            int numKeysPerNode = (int) Math.floor(numKeys
                                                                  / cluster.getNumberOfNodes());
                            for(Node node: cluster.getNodes()) {
                                keys = adminClient.fetchKeys(node.getId(),
                                                             storeDef.getName(),
                                                             cluster.getNodeById(node.getId())
                                                                    .getPartitionIds(),
                                                             null,
                                                             false);
                                for(long keyId = 0; keyId < numKeysPerNode && keys.hasNext(); keyId++) {
                                    ByteArray key = keys.next();
                                    if(RebalanceUtils.getNodeIds(strategy.routeRequest(key.get())
                                                                         .subList(0, 1))
                                                     .contains(node.getId())) {
                                        writer.write(key.length());
                                        writer.write(key.get());
                                    }
                                }
                            }
                        } else {
                            keys = adminClient.fetchKeys(nodeId,
                                                         storeDef.getName(),
                                                         cluster.getNodeById(nodeId)
                                                                .getPartitionIds(),
                                                         null,
                                                         false);
                            for(long keyId = 0; keyId < numKeys && keys.hasNext(); keyId++) {
                                ByteArray key = keys.next();
                                if(RebalanceUtils.getNodeIds(strategy.routeRequest(key.get())
                                                                     .subList(0, 1))
                                                 .contains(nodeId)) {
                                    writer.write(key.length());
                                    writer.write(key.get());
                                }
                            }
                        }

                    } finally {
                        if(writer != null)
                            writer.close();
                    }

                } else {

                    if(!(storesKeyFile.exists() && storesKeyFile.canRead())) {
                        System.err.println("Could not find " + storeDef.getName()
                                           + " file to check");
                        continue;
                    }
                    FileInputStream reader = null;
                    SocketStoreFactory socketStoreFactory = new ClientRequestExecutorPool(2,
                                                                                          10000,
                                                                                          100000,
                                                                                          32 * 1024);

                    // Cache connections to all nodes for this store in advance
                    HashMap<Integer, Store<ByteArray, byte[], byte[]>> socketStoresPerNode = Maps.newHashMap();
                    for(Node node: cluster.getNodes()) {
                        socketStoresPerNode.put(node.getId(),
                                                socketStoreFactory.create(storeDef.getName(),
                                                                          node.getHost(),
                                                                          node.getSocketPort(),
                                                                          RequestFormatType.PROTOCOL_BUFFERS,
                                                                          RequestRoutingType.IGNORE_CHECKS));
                    }

                    long foundKeys = 0L;
                    long totalKeys = 0L;
                    try {
                        reader = new FileInputStream(storesKeyFile);
                        while(reader.available() != 0) {
                            int size = reader.read();

                            if(size <= 0) {
                                break;
                            }

                            // Read the key
                            byte[] key = new byte[size];
                            reader.read(key);

                            List<Node> responsibleNodes = strategy.routeRequest(key);
                            boolean missingKey = false;
                            for(Node node: responsibleNodes) {
                                List<Versioned<byte[]>> value = socketStoresPerNode.get(node.getId())
                                                                                   .get(new ByteArray(key),
                                                                                        null);

                                if(value == null || value.size() == 0) {
                                    missingKey = true;
                                }
                            }
                            if(!missingKey)
                                foundKeys++;

                            totalKeys++;

                        }
                        System.out.println("Found = " + foundKeys + " Total = " + totalKeys);
                        if(foundKeys > 0 && totalKeys > 0) {
                            System.out.println("%age found - " + 100.0 * (double) foundKeys
                                               / totalKeys);
                        }
                    } finally {
                        if(reader != null)
                            reader.close();

                        // close all socket stores
                        for(Store<ByteArray, byte[], byte[]> store: socketStoresPerNode.values()) {
                            store.close();
                        }
                    }
                }

            }
        } finally {
            if(adminClient != null)
                adminClient.stop();
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415724972106/fstmerge_var2_6780578370070446899
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/src/java/voldemort/utils/Entropy.java
Conflict type: NOPATTERN
Conflict body: 
~~FSTMerge~~ DESCRIPTOR = descriptor.FileDescriptor(  name='voldemort-admin.proto',  package='voldemort',  serialized_pb='\n\x15voldemort-admin.proto\x12\tvoldemort\x1a\x16voldemort-client.proto\"!\n\x12GetMetadataRequest\x12\x0b\n\x03key\x18\x01 \x02(\x0c\"]\n\x13GetMetadataResponse\x12%\n\x07version\x18\x01 \x01(\x0b\x32\x14.voldemort.Versioned\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"M\n\x15UpdateMetadataRequest\x12\x0b\n\x03key\x18\x01 \x02(\x0c\x12\'\n\tversioned\x18\x02 \x02(\x0b\x32\x14.voldemort.Versioned\"9\n\x16UpdateMetadataResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"7\n\tFileEntry\x12\x11\n\tfile_name\x18\x01 \x02(\t\x12\x17\n\x0f\x66ile_size_bytes\x18\x02 \x02(\x03\"F\n\x0ePartitionEntry\x12\x0b\n\x03key\x18\x01 \x02(\x0c\x12\'\n\tversioned\x18\x02 \x02(\x0b\x32\x14.voldemort.Versioned\"\x8e\x01\n\x1dUpdatePartitionEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x32\n\x0fpartition_entry\x18\x02 \x02(\x0b\x32\x19.voldemort.PartitionEntry\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\"A\n\x1eUpdatePartitionEntriesResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"-\n\x0fVoldemortFilter\x12\x0c\n\x04name\x18\x01 \x02(\t\x12\x0c\n\x04\x64\x61ta\x18\x02 \x02(\x0c\"\xaf\x01\n\x18UpdateSlopEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x0b\n\x03key\x18\x02 \x02(\x0c\x12\'\n\x07version\x18\x03 \x02(\x0b\x32\x16.voldemort.VectorClock\x12,\n\x0crequest_type\x18\x04 \x02(\x0e\x32\x16.voldemort.RequestType\x12\r\n\x05value\x18\x05 \x01(\x0c\x12\x11\n\ttransform\x18\x06 \x01(\x0c\"<\n\x19UpdateSlopEntriesResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"d\n\x1a\x46\x65tchPartitionFilesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x37\n\x14replica_to_partition\x18\x02 \x03(\x0b\x32\x19.voldemort.PartitionTuple\"\xd7\x01\n\x1c\x46\x65tchPartitionEntriesRequest\x12\x37\n\x14replica_to_partition\x18\x01 \x03(\x0b\x32\x19.voldemort.PartitionTuple\x12\r\n\x05store\x18\x02 \x02(\t\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\x12\x14\n\x0c\x66\x65tch_values\x18\x04 \x01(\x08\x12\x14\n\x0cskip_records\x18\x05 \x01(\x03\x12\x17\n\x0finitial_cluster\x18\x06 \x01(\t\"\x81\x01\n\x1d\x46\x65tchPartitionEntriesResponse\x12\x32\n\x0fpartition_entry\x18\x01 \x01(\x0b\x32\x19.voldemort.PartitionEntry\x12\x0b\n\x03key\x18\x02 \x01(\x0c\x12\x1f\n\x05\x65rror\x18\x03 \x01(\x0b\x32\x10.voldemort.Error\"\xac\x01\n\x1d\x44\x65letePartitionEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x37\n\x14replica_to_partition\x18\x02 \x03(\x0b\x32\x19.voldemort.PartitionTuple\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\x12\x17\n\x0finitial_cluster\x18\x04 \x01(\t\"P\n\x1e\x44\x65letePartitionEntriesResponse\x12\r\n\x05\x63ount\x18\x01 \x01(\x03\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"\xcf\x01\n\x1dInitiateFetchAndUpdateRequest\x12\x0f\n\x07node_id\x18\x01 \x02(\x05\x12\r\n\x05store\x18\x02 \x02(\t\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\x12\x37\n\x14replica_to_partition\x18\x04 \x03(\x0b\x32\x19.voldemort.PartitionTuple\x12\x17\n\x0finitial_cluster\x18\x05 \x01(\t\x12\x10\n\x08optimize\x18\x06 \x01(\x08\"1\n\x1b\x41syncOperationStatusRequest\x12\x12\n\nrequest_id\x18\x01 \x02(\x05\"/\n\x19\x41syncOperationStopRequest\x12\x12\n\nrequest_id\x18\x01 \x02(\x05\"=\n\x1a\x41syncOperationStopResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"2\n\x19\x41syncOperationListRequest\x12\x15\n\rshow_complete\x18\x02 \x02(\x08\"R\n\x1a\x41syncOperationListResponse\x12\x13\n\x0brequest_ids\x18\x01 \x03(\x05\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\":\n\x0ePartitionTuple\x12\x14\n\x0creplica_type\x18\x01 \x02(\x05\x12\x12\n\npartitions\x18\x02 \x03(\x05\"e\n\x16PerStorePartitionTuple\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x37\n\x14replica_to_partition\x18\x02 \x03(\x0b\x32\x19.voldemort.PartitionTuple\"\xf8\x01\n\x19RebalancePartitionInfoMap\x12\x12\n\nstealer_id\x18\x01 \x02(\x05\x12\x10\n\x08\x64onor_id\x18\x02 \x02(\x05\x12\x0f\n\x07\x61ttempt\x18\x03 \x02(\x05\x12\x43\n\x18replica_to_add_partition\x18\x04 \x03(\x0b\x32!.voldemort.PerStorePartitionTuple\x12\x46\n\x1breplica_to_delete_partition\x18\x05 \x03(\x0b\x32!.voldemort.PerStorePartitionTuple\x12\x17\n\x0finitial_cluster\x18\x06 \x02(\t\"f\n\x1cInitiateRebalanceNodeRequest\x12\x46\n\x18rebalance_partition_info\x18\x01 \x02(\x0b\x32$.voldemort.RebalancePartitionInfoMap\"\x8a\x01\n\x1c\x41syncOperationStatusResponse\x12\x12\n\nrequest_id\x18\x01 \x01(\x05\x12\x13\n\x0b\x64\x65scription\x18\x02 \x01(\t\x12\x0e\n\x06status\x18\x03 \x01(\t\x12\x10\n\x08\x63omplete\x18\x04 \x01(\x08\x12\x1f\n\x05\x65rror\x18\x05 \x01(\x0b\x32\x10.voldemort.Error\"\'\n\x16TruncateEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\":\n\x17TruncateEntriesResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"*\n\x0f\x41\x64\x64StoreRequest\x12\x17\n\x0fstoreDefinition\x18\x01 \x02(\t\"3\n\x10\x41\x64\x64StoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"\'\n\x12\x44\x65leteStoreRequest\x12\x11\n\tstoreName\x18\x01 \x02(\t\"6\n\x13\x44\x65leteStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"P\n\x11\x46\x65tchStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\x12\x14\n\x0cpush_version\x18\x03 \x01(\x03\"9\n\x10SwapStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\"P\n\x11SwapStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\x12\x1a\n\x12previous_store_dir\x18\x02 \x01(\t\"@\n\x14RollbackStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x14\n\x0cpush_version\x18\x02 \x02(\x03\"8\n\x15RollbackStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"&\n\x10RepairJobRequest\x12\x12\n\nstore_name\x18\x01 \x01(\t\"4\n\x11RepairJobResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"=\n\x14ROStoreVersionDirMap\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\"/\n\x19GetROMaxVersionDirRequest\x12\x12\n\nstore_name\x18\x01 \x03(\t\"y\n\x1aGetROMaxVersionDirResponse\x12:\n\x11ro_store_versions\x18\x01 \x03(\x0b\x32\x1f.voldemort.ROStoreVersionDirMap\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"3\n\x1dGetROCurrentVersionDirRequest\x12\x12\n\nstore_name\x18\x01 \x03(\t\"}\n\x1eGetROCurrentVersionDirResponse\x12:\n\x11ro_store_versions\x18\x01 \x03(\x0b\x32\x1f.voldemort.ROStoreVersionDirMap\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"/\n\x19GetROStorageFormatRequest\x12\x12\n\nstore_name\x18\x01 \x03(\t\"y\n\x1aGetROStorageFormatResponse\x12:\n\x11ro_store_versions\x18\x01 \x03(\x0b\x32\x1f.voldemort.ROStoreVersionDirMap\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"@\n\x17\x46\x61iledFetchStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\";\n\x18\x46\x61iledFetchStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"\xe6\x01\n\x1bRebalanceStateChangeRequest\x12K\n\x1drebalance_partition_info_list\x18\x01 \x03(\x0b\x32$.voldemort.RebalancePartitionInfoMap\x12\x16\n\x0e\x63luster_string\x18\x02 \x02(\t\x12\x0f\n\x07swap_ro\x18\x03 \x02(\x08\x12\x1f\n\x17\x63hange_cluster_metadata\x18\x04 \x02(\x08\x12\x1e\n\x16\x63hange_rebalance_state\x18\x05 \x02(\x08\x12\x10\n\x08rollback\x18\x06 \x02(\x08\"?\n\x1cRebalanceStateChangeResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"\xd3\x0c\n\x15VoldemortAdminRequest\x12)\n\x04type\x18\x01 \x02(\x0e\x32\x1b.voldemort.AdminRequestType\x12\x33\n\x0cget_metadata\x18\x02 \x01(\x0b\x32\x1d.voldemort.GetMetadataRequest\x12\x39\n\x0fupdate_metadata\x18\x03 \x01(\x0b\x32 .voldemort.UpdateMetadataRequest\x12J\n\x18update_partition_entries\x18\x04 \x01(\x0b\x32(.voldemort.UpdatePartitionEntriesRequest\x12H\n\x17\x66\x65tch_partition_entries\x18\x05 \x01(\x0b\x32\'.voldemort.FetchPartitionEntriesRequest\x12J\n\x18\x64\x65lete_partition_entries\x18\x06 \x01(\x0b\x32(.voldemort.DeletePartitionEntriesRequest\x12K\n\x19initiate_fetch_and_update\x18\x07 \x01(\x0b\x32(.voldemort.InitiateFetchAndUpdateRequest\x12\x46\n\x16\x61sync_operation_status\x18\x08 \x01(\x0b\x32&.voldemort.AsyncOperationStatusRequest\x12H\n\x17initiate_rebalance_node\x18\t \x01(\x0b\x32\'.voldemort.InitiateRebalanceNodeRequest\x12\x42\n\x14\x61sync_operation_stop\x18\n \x01(\x0b\x32$.voldemort.AsyncOperationStopRequest\x12\x42\n\x14\x61sync_operation_list\x18\x0b \x01(\x0b\x32$.voldemort.AsyncOperationListRequest\x12;\n\x10truncate_entries\x18\x0c \x01(\x0b\x32!.voldemort.TruncateEntriesRequest\x12-\n\tadd_store\x18\r \x01(\x0b\x32\x1a.voldemort.AddStoreRequest\x12\x33\n\x0c\x64\x65lete_store\x18\x0e \x01(\x0b\x32\x1d.voldemort.DeleteStoreRequest\x12\x31\n\x0b\x66\x65tch_store\x18\x0f \x01(\x0b\x32\x1c.voldemort.FetchStoreRequest\x12/\n\nswap_store\x18\x10 \x01(\x0b\x32\x1b.voldemort.SwapStoreRequest\x12\x37\n\x0erollback_store\x18\x11 \x01(\x0b\x32\x1f.voldemort.RollbackStoreRequest\x12\x44\n\x16get_ro_max_version_dir\x18\x12 \x01(\x0b\x32$.voldemort.GetROMaxVersionDirRequest\x12L\n\x1aget_ro_current_version_dir\x18\x13 \x01(\x0b\x32(.voldemort.GetROCurrentVersionDirRequest\x12\x44\n\x15\x66\x65tch_partition_files\x18\x14 \x01(\x0b\x32%.voldemort.FetchPartitionFilesRequest\x12@\n\x13update_slop_entries\x18\x16 \x01(\x0b\x32#.voldemort.UpdateSlopEntriesRequest\x12>\n\x12\x66\x61iled_fetch_store\x18\x18 \x01(\x0b\x32\".voldemort.FailedFetchStoreRequest\x12\x43\n\x15get_ro_storage_format\x18\x19 \x01(\x0b\x32$.voldemort.GetROStorageFormatRequest\x12\x46\n\x16rebalance_state_change\x18\x1a \x01(\x0b\x32&.voldemort.RebalanceStateChangeRequest\x12/\n\nrepair_job\x18\x1b \x01(\x0b\x32\x1b.voldemort.RepairJobRequest*\xd9\x04\n\x10\x41\x64minRequestType\x12\x10\n\x0cGET_METADATA\x10\x00\x12\x13\n\x0fUPDATE_METADATA\x10\x01\x12\x1c\n\x18UPDATE_PARTITION_ENTRIES\x10\x02\x12\x1b\n\x17\x46\x45TCH_PARTITION_ENTRIES\x10\x03\x12\x1c\n\x18\x44\x45LETE_PARTITION_ENTRIES\x10\x04\x12\x1d\n\x19INITIATE_FETCH_AND_UPDATE\x10\x05\x12\x1a\n\x16\x41SYNC_OPERATION_STATUS\x10\x06\x12\x1b\n\x17INITIATE_REBALANCE_NODE\x10\x07\x12\x18\n\x14\x41SYNC_OPERATION_STOP\x10\x08\x12\x18\n\x14\x41SYNC_OPERATION_LIST\x10\t\x12\x14\n\x10TRUNCATE_ENTRIES\x10\n\x12\r\n\tADD_STORE\x10\x0b\x12\x10\n\x0c\x44\x45LETE_STORE\x10\x0c\x12\x0f\n\x0b\x46\x45TCH_STORE\x10\r\x12\x0e\n\nSWAP_STORE\x10\x0e\x12\x12\n\x0eROLLBACK_STORE\x10\x0f\x12\x1a\n\x16GET_RO_MAX_VERSION_DIR\x10\x10\x12\x1e\n\x1aGET_RO_CURRENT_VERSION_DIR\x10\x11\x12\x19\n\x15\x46\x45TCH_PARTITION_FILES\x10\x12\x12\x17\n\x13UPDATE_SLOP_ENTRIES\x10\x14\x12\x16\n\x12\x46\x41ILED_FETCH_STORE\x10\x16\x12\x19\n\x15GET_RO_STORAGE_FORMAT\x10\x17\x12\x1a\n\x16REBALANCE_STATE_CHANGE\x10\x18\x12\x0e\n\nREPAIR_JOB\x10\x19\x42-\n\x1cvoldemort.client.protocol.pbB\x0bVAdminProtoH\x01') ##FSTMerge## DESCRIPTOR = descriptor.FileDescriptor(  name='voldemort-admin.proto',  package='voldemort',  serialized_pb='\n\x15voldemort-admin.proto\x12\tvoldemort\x1a\x16voldemort-client.proto\"!\n\x12GetMetadataRequest\x12\x0b\n\x03key\x18\x01 \x02(\x0c\"]\n\x13GetMetadataResponse\x12%\n\x07version\x18\x01 \x01(\x0b\x32\x14.voldemort.Versioned\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"M\n\x15UpdateMetadataRequest\x12\x0b\n\x03key\x18\x01 \x02(\x0c\x12\'\n\tversioned\x18\x02 \x02(\x0b\x32\x14.voldemort.Versioned\"9\n\x16UpdateMetadataResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"7\n\tFileEntry\x12\x11\n\tfile_name\x18\x01 \x02(\t\x12\x17\n\x0f\x66ile_size_bytes\x18\x02 \x02(\x03\"F\n\x0ePartitionEntry\x12\x0b\n\x03key\x18\x01 \x02(\x0c\x12\'\n\tversioned\x18\x02 \x02(\x0b\x32\x14.voldemort.Versioned\"\x8e\x01\n\x1dUpdatePartitionEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x32\n\x0fpartition_entry\x18\x02 \x02(\x0b\x32\x19.voldemort.PartitionEntry\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\"A\n\x1eUpdatePartitionEntriesResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"-\n\x0fVoldemortFilter\x12\x0c\n\x04name\x18\x01 \x02(\t\x12\x0c\n\x04\x64\x61ta\x18\x02 \x02(\x0c\"\xaf\x01\n\x18UpdateSlopEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x0b\n\x03key\x18\x02 \x02(\x0c\x12\'\n\x07version\x18\x03 \x02(\x0b\x32\x16.voldemort.VectorClock\x12,\n\x0crequest_type\x18\x04 \x02(\x0e\x32\x16.voldemort.RequestType\x12\r\n\x05value\x18\x05 \x01(\x0c\x12\x11\n\ttransform\x18\x06 \x01(\x0c\"<\n\x19UpdateSlopEntriesResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"d\n\x1a\x46\x65tchPartitionFilesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x37\n\x14replica_to_partition\x18\x02 \x03(\x0b\x32\x19.voldemort.PartitionTuple\"\xd7\x01\n\x1c\x46\x65tchPartitionEntriesRequest\x12\x37\n\x14replica_to_partition\x18\x01 \x03(\x0b\x32\x19.voldemort.PartitionTuple\x12\r\n\x05store\x18\x02 \x02(\t\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\x12\x14\n\x0c\x66\x65tch_values\x18\x04 \x01(\x08\x12\x14\n\x0cskip_records\x18\x05 \x01(\x03\x12\x17\n\x0finitial_cluster\x18\x06 \x01(\t\"\x81\x01\n\x1d\x46\x65tchPartitionEntriesResponse\x12\x32\n\x0fpartition_entry\x18\x01 \x01(\x0b\x32\x19.voldemort.PartitionEntry\x12\x0b\n\x03key\x18\x02 \x01(\x0c\x12\x1f\n\x05\x65rror\x18\x03 \x01(\x0b\x32\x10.voldemort.Error\"\xac\x01\n\x1d\x44\x65letePartitionEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x37\n\x14replica_to_partition\x18\x02 \x03(\x0b\x32\x19.voldemort.PartitionTuple\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\x12\x17\n\x0finitial_cluster\x18\x04 \x01(\t\"P\n\x1e\x44\x65letePartitionEntriesResponse\x12\r\n\x05\x63ount\x18\x01 \x01(\x03\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"\xcf\x01\n\x1dInitiateFetchAndUpdateRequest\x12\x0f\n\x07node_id\x18\x01 \x02(\x05\x12\r\n\x05store\x18\x02 \x02(\t\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\x12\x37\n\x14replica_to_partition\x18\x04 \x03(\x0b\x32\x19.voldemort.PartitionTuple\x12\x17\n\x0finitial_cluster\x18\x05 \x01(\t\x12\x10\n\x08optimize\x18\x06 \x01(\x08\"1\n\x1b\x41syncOperationStatusRequest\x12\x12\n\nrequest_id\x18\x01 \x02(\x05\"/\n\x19\x41syncOperationStopRequest\x12\x12\n\nrequest_id\x18\x01 \x02(\x05\"=\n\x1a\x41syncOperationStopResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"2\n\x19\x41syncOperationListRequest\x12\x15\n\rshow_complete\x18\x02 \x02(\x08\"R\n\x1a\x41syncOperationListResponse\x12\x13\n\x0brequest_ids\x18\x01 \x03(\x05\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\":\n\x0ePartitionTuple\x12\x14\n\x0creplica_type\x18\x01 \x02(\x05\x12\x12\n\npartitions\x18\x02 \x03(\x05\"e\n\x16PerStorePartitionTuple\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x37\n\x14replica_to_partition\x18\x02 \x03(\x0b\x32\x19.voldemort.PartitionTuple\"\xf8\x01\n\x19RebalancePartitionInfoMap\x12\x12\n\nstealer_id\x18\x01 \x02(\x05\x12\x10\n\x08\x64onor_id\x18\x02 \x02(\x05\x12\x0f\n\x07\x61ttempt\x18\x03 \x02(\x05\x12\x43\n\x18replica_to_add_partition\x18\x04 \x03(\x0b\x32!.voldemort.PerStorePartitionTuple\x12\x46\n\x1breplica_to_delete_partition\x18\x05 \x03(\x0b\x32!.voldemort.PerStorePartitionTuple\x12\x17\n\x0finitial_cluster\x18\x06 \x02(\t\"f\n\x1cInitiateRebalanceNodeRequest\x12\x46\n\x18rebalance_partition_info\x18\x01 \x02(\x0b\x32$.voldemort.RebalancePartitionInfoMap\"\x8a\x01\n\x1c\x41syncOperationStatusResponse\x12\x12\n\nrequest_id\x18\x01 \x01(\x05\x12\x13\n\x0b\x64\x65scription\x18\x02 \x01(\t\x12\x0e\n\x06status\x18\x03 \x01(\t\x12\x10\n\x08\x63omplete\x18\x04 \x01(\x08\x12\x1f\n\x05\x65rror\x18\x05 \x01(\x0b\x32\x10.voldemort.Error\"\'\n\x16TruncateEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\":\n\x17TruncateEntriesResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"*\n\x0f\x41\x64\x64StoreRequest\x12\x17\n\x0fstoreDefinition\x18\x01 \x02(\t\"3\n\x10\x41\x64\x64StoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"\'\n\x12\x44\x65leteStoreRequest\x12\x11\n\tstoreName\x18\x01 \x02(\t\"6\n\x13\x44\x65leteStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"P\n\x11\x46\x65tchStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\x12\x14\n\x0cpush_version\x18\x03 \x01(\x03\"9\n\x10SwapStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\"P\n\x11SwapStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\x12\x1a\n\x12previous_store_dir\x18\x02 \x01(\t\"@\n\x14RollbackStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x14\n\x0cpush_version\x18\x02 \x02(\x03\"8\n\x15RollbackStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"=\n\x14ROStoreVersionDirMap\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\"/\n\x19GetROMaxVersionDirRequest\x12\x12\n\nstore_name\x18\x01 \x03(\t\"y\n\x1aGetROMaxVersionDirResponse\x12:\n\x11ro_store_versions\x18\x01 \x03(\x0b\x32\x1f.voldemort.ROStoreVersionDirMap\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"3\n\x1dGetROCurrentVersionDirRequest\x12\x12\n\nstore_name\x18\x01 \x03(\t\"}\n\x1eGetROCurrentVersionDirResponse\x12:\n\x11ro_store_versions\x18\x01 \x03(\x0b\x32\x1f.voldemort.ROStoreVersionDirMap\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"/\n\x19GetROStorageFormatRequest\x12\x12\n\nstore_name\x18\x01 \x03(\t\"y\n\x1aGetROStorageFormatResponse\x12:\n\x11ro_store_versions\x18\x01 \x03(\x0b\x32\x1f.voldemort.ROStoreVersionDirMap\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"@\n\x17\x46\x61iledFetchStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\";\n\x18\x46\x61iledFetchStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"\xe6\x01\n\x1bRebalanceStateChangeRequest\x12K\n\x1drebalance_partition_info_list\x18\x01 \x03(\x0b\x32$.voldemort.RebalancePartitionInfoMap\x12\x16\n\x0e\x63luster_string\x18\x02 \x02(\t\x12\x0f\n\x07swap_ro\x18\x03 \x02(\x08\x12\x1f\n\x17\x63hange_cluster_metadata\x18\x04 \x02(\x08\x12\x1e\n\x16\x63hange_rebalance_state\x18\x05 \x02(\x08\x12\x10\n\x08rollback\x18\x06 \x02(\x08\"?\n\x1cRebalanceStateChangeResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"\xa2\x0c\n\x15VoldemortAdminRequest\x12)\n\x04type\x18\x01 \x02(\x0e\x32\x1b.voldemort.AdminRequestType\x12\x33\n\x0cget_metadata\x18\x02 \x01(\x0b\x32\x1d.voldemort.GetMetadataRequest\x12\x39\n\x0fupdate_metadata\x18\x03 \x01(\x0b\x32 .voldemort.UpdateMetadataRequest\x12J\n\x18update_partition_entries\x18\x04 \x01(\x0b\x32(.voldemort.UpdatePartitionEntriesRequest\x12H\n\x17\x66\x65tch_partition_entries\x18\x05 \x01(\x0b\x32\'.voldemort.FetchPartitionEntriesRequest\x12J\n\x18\x64\x65lete_partition_entries\x18\x06 \x01(\x0b\x32(.voldemort.DeletePartitionEntriesRequest\x12K\n\x19initiate_fetch_and_update\x18\x07 \x01(\x0b\x32(.voldemort.InitiateFetchAndUpdateRequest\x12\x46\n\x16\x61sync_operation_status\x18\x08 \x01(\x0b\x32&.voldemort.AsyncOperationStatusRequest\x12H\n\x17initiate_rebalance_node\x18\t \x01(\x0b\x32\'.voldemort.InitiateRebalanceNodeRequest\x12\x42\n\x14\x61sync_operation_stop\x18\n \x01(\x0b\x32$.voldemort.AsyncOperationStopRequest\x12\x42\n\x14\x61sync_operation_list\x18\x0b \x01(\x0b\x32$.voldemort.AsyncOperationListRequest\x12;\n\x10truncate_entries\x18\x0c \x01(\x0b\x32!.voldemort.TruncateEntriesRequest\x12-\n\tadd_store\x18\r \x01(\x0b\x32\x1a.voldemort.AddStoreRequest\x12\x33\n\x0c\x64\x65lete_store\x18\x0e \x01(\x0b\x32\x1d.voldemort.DeleteStoreRequest\x12\x31\n\x0b\x66\x65tch_store\x18\x0f \x01(\x0b\x32\x1c.voldemort.FetchStoreRequest\x12/\n\nswap_store\x18\x10 \x01(\x0b\x32\x1b.voldemort.SwapStoreRequest\x12\x37\n\x0erollback_store\x18\x11 \x01(\x0b\x32\x1f.voldemort.RollbackStoreRequest\x12\x44\n\x16get_ro_max_version_dir\x18\x12 \x01(\x0b\x32$.voldemort.GetROMaxVersionDirRequest\x12L\n\x1aget_ro_current_version_dir\x18\x13 \x01(\x0b\x32(.voldemort.GetROCurrentVersionDirRequest\x12\x44\n\x15\x66\x65tch_partition_files\x18\x14 \x01(\x0b\x32%.voldemort.FetchPartitionFilesRequest\x12@\n\x13update_slop_entries\x18\x16 \x01(\x0b\x32#.voldemort.UpdateSlopEntriesRequest\x12>\n\x12\x66\x61iled_fetch_store\x18\x18 \x01(\x0b\x32\".voldemort.FailedFetchStoreRequest\x12\x43\n\x15get_ro_storage_format\x18\x19 \x01(\x0b\x32$.voldemort.GetROStorageFormatRequest\x12\x46\n\x16rebalance_state_change\x18\x1a \x01(\x0b\x32&.voldemort.RebalanceStateChangeRequest*\xc9\x04\n\x10\x41\x64minRequestType\x12\x10\n\x0cGET_METADATA\x10\x00\x12\x13\n\x0fUPDATE_METADATA\x10\x01\x12\x1c\n\x18UPDATE_PARTITION_ENTRIES\x10\x02\x12\x1b\n\x17\x46\x45TCH_PARTITION_ENTRIES\x10\x03\x12\x1c\n\x18\x44\x45LETE_PARTITION_ENTRIES\x10\x04\x12\x1d\n\x19INITIATE_FETCH_AND_UPDATE\x10\x05\x12\x1a\n\x16\x41SYNC_OPERATION_STATUS\x10\x06\x12\x1b\n\x17INITIATE_REBALANCE_NODE\x10\x07\x12\x18\n\x14\x41SYNC_OPERATION_STOP\x10\x08\x12\x18\n\x14\x41SYNC_OPERATION_LIST\x10\t\x12\x14\n\x10TRUNCATE_ENTRIES\x10\n\x12\r\n\tADD_STORE\x10\x0b\x12\x10\n\x0c\x44\x45LETE_STORE\x10\x0c\x12\x0f\n\x0b\x46\x45TCH_STORE\x10\r\x12\x0e\n\nSWAP_STORE\x10\x0e\x12\x12\n\x0eROLLBACK_STORE\x10\x0f\x12\x1a\n\x16GET_RO_MAX_VERSION_DIR\x10\x10\x12\x1e\n\x1aGET_RO_CURRENT_VERSION_DIR\x10\x11\x12\x19\n\x15\x46\x45TCH_PARTITION_FILES\x10\x12\x12\x17\n\x13UPDATE_SLOP_ENTRIES\x10\x14\x12\x16\n\x12\x46\x41ILED_FETCH_STORE\x10\x16\x12\x19\n\x15GET_RO_STORAGE_FORMAT\x10\x17\x12\x1a\n\x16REBALANCE_STATE_CHANGE\x10\x18\x42-\n\x1cvoldemort.client.protocol.pbB\x0bVAdminProtoH\x01') ##FSTMerge## DESCRIPTOR = descriptor.FileDescriptor(  name='voldemort-admin.proto',  package='voldemort',  serialized_pb='\n\x15voldemort-admin.proto\x12\tvoldemort\x1a\x16voldemort-client.proto\"!\n\x12GetMetadataRequest\x12\x0b\n\x03key\x18\x01 \x02(\x0c\"]\n\x13GetMetadataResponse\x12%\n\x07version\x18\x01 \x01(\x0b\x32\x14.voldemort.Versioned\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"M\n\x15UpdateMetadataRequest\x12\x0b\n\x03key\x18\x01 \x02(\x0c\x12\'\n\tversioned\x18\x02 \x02(\x0b\x32\x14.voldemort.Versioned\"9\n\x16UpdateMetadataResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"7\n\tFileEntry\x12\x11\n\tfile_name\x18\x01 \x02(\t\x12\x17\n\x0f\x66ile_size_bytes\x18\x02 \x02(\x03\"F\n\x0ePartitionEntry\x12\x0b\n\x03key\x18\x01 \x02(\x0c\x12\'\n\tversioned\x18\x02 \x02(\x0b\x32\x14.voldemort.Versioned\"\x8e\x01\n\x1dUpdatePartitionEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x32\n\x0fpartition_entry\x18\x02 \x02(\x0b\x32\x19.voldemort.PartitionEntry\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\"A\n\x1eUpdatePartitionEntriesResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"-\n\x0fVoldemortFilter\x12\x0c\n\x04name\x18\x01 \x02(\t\x12\x0c\n\x04\x64\x61ta\x18\x02 \x02(\x0c\"\xaf\x01\n\x18UpdateSlopEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x0b\n\x03key\x18\x02 \x02(\x0c\x12\'\n\x07version\x18\x03 \x02(\x0b\x32\x16.voldemort.VectorClock\x12,\n\x0crequest_type\x18\x04 \x02(\x0e\x32\x16.voldemort.RequestType\x12\r\n\x05value\x18\x05 \x01(\x0c\x12\x11\n\ttransform\x18\x06 \x01(\x0c\"<\n\x19UpdateSlopEntriesResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"d\n\x1a\x46\x65tchPartitionFilesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x37\n\x14replica_to_partition\x18\x02 \x03(\x0b\x32\x19.voldemort.PartitionTuple\"\xd7\x01\n\x1c\x46\x65tchPartitionEntriesRequest\x12\x37\n\x14replica_to_partition\x18\x01 \x03(\x0b\x32\x19.voldemort.PartitionTuple\x12\r\n\x05store\x18\x02 \x02(\t\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\x12\x14\n\x0c\x66\x65tch_values\x18\x04 \x01(\x08\x12\x14\n\x0cskip_records\x18\x05 \x01(\x03\x12\x17\n\x0finitial_cluster\x18\x06 \x01(\t\"\x81\x01\n\x1d\x46\x65tchPartitionEntriesResponse\x12\x32\n\x0fpartition_entry\x18\x01 \x01(\x0b\x32\x19.voldemort.PartitionEntry\x12\x0b\n\x03key\x18\x02 \x01(\x0c\x12\x1f\n\x05\x65rror\x18\x03 \x01(\x0b\x32\x10.voldemort.Error\"\xac\x01\n\x1d\x44\x65letePartitionEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x37\n\x14replica_to_partition\x18\x02 \x03(\x0b\x32\x19.voldemort.PartitionTuple\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\x12\x17\n\x0finitial_cluster\x18\x04 \x01(\t\"P\n\x1e\x44\x65letePartitionEntriesResponse\x12\r\n\x05\x63ount\x18\x01 \x01(\x03\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"\xcf\x01\n\x1dInitiateFetchAndUpdateRequest\x12\x0f\n\x07node_id\x18\x01 \x02(\x05\x12\r\n\x05store\x18\x02 \x02(\t\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\x12\x37\n\x14replica_to_partition\x18\x04 \x03(\x0b\x32\x19.voldemort.PartitionTuple\x12\x17\n\x0finitial_cluster\x18\x05 \x01(\t\x12\x10\n\x08optimize\x18\x06 \x01(\x08\"1\n\x1b\x41syncOperationStatusRequest\x12\x12\n\nrequest_id\x18\x01 \x02(\x05\"/\n\x19\x41syncOperationStopRequest\x12\x12\n\nrequest_id\x18\x01 \x02(\x05\"=\n\x1a\x41syncOperationStopResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"2\n\x19\x41syncOperationListRequest\x12\x15\n\rshow_complete\x18\x02 \x02(\x08\"R\n\x1a\x41syncOperationListResponse\x12\x13\n\x0brequest_ids\x18\x01 \x03(\x05\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\":\n\x0ePartitionTuple\x12\x14\n\x0creplica_type\x18\x01 \x02(\x05\x12\x12\n\npartitions\x18\x02 \x03(\x05\"e\n\x16PerStorePartitionTuple\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x37\n\x14replica_to_partition\x18\x02 \x03(\x0b\x32\x19.voldemort.PartitionTuple\"\xf8\x01\n\x19RebalancePartitionInfoMap\x12\x12\n\nstealer_id\x18\x01 \x02(\x05\x12\x10\n\x08\x64onor_id\x18\x02 \x02(\x05\x12\x0f\n\x07\x61ttempt\x18\x03 \x02(\x05\x12\x43\n\x18replica_to_add_partition\x18\x04 \x03(\x0b\x32!.voldemort.PerStorePartitionTuple\x12\x46\n\x1breplica_to_delete_partition\x18\x05 \x03(\x0b\x32!.voldemort.PerStorePartitionTuple\x12\x17\n\x0finitial_cluster\x18\x06 \x02(\t\"f\n\x1cInitiateRebalanceNodeRequest\x12\x46\n\x18rebalance_partition_info\x18\x01 \x02(\x0b\x32$.voldemort.RebalancePartitionInfoMap\"m\n#InitiateRebalanceNodeOnDonorRequest\x12\x46\n\x18rebalance_partition_info\x18\x01 \x03(\x0b\x32$.voldemort.RebalancePartitionInfoMap\"\x8a\x01\n\x1c\x41syncOperationStatusResponse\x12\x12\n\nrequest_id\x18\x01 \x01(\x05\x12\x13\n\x0b\x64\x65scription\x18\x02 \x01(\t\x12\x0e\n\x06status\x18\x03 \x01(\t\x12\x10\n\x08\x63omplete\x18\x04 \x01(\x08\x12\x1f\n\x05\x65rror\x18\x05 \x01(\x0b\x32\x10.voldemort.Error\"\'\n\x16TruncateEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\":\n\x17TruncateEntriesResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"*\n\x0f\x41\x64\x64StoreRequest\x12\x17\n\x0fstoreDefinition\x18\x01 \x02(\t\"3\n\x10\x41\x64\x64StoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"\'\n\x12\x44\x65leteStoreRequest\x12\x11\n\tstoreName\x18\x01 \x02(\t\"6\n\x13\x44\x65leteStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"P\n\x11\x46\x65tchStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\x12\x14\n\x0cpush_version\x18\x03 \x01(\x03\"9\n\x10SwapStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\"P\n\x11SwapStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\x12\x1a\n\x12previous_store_dir\x18\x02 \x01(\t\"@\n\x14RollbackStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x14\n\x0cpush_version\x18\x02 \x02(\x03\"8\n\x15RollbackStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"=\n\x14ROStoreVersionDirMap\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\"/\n\x19GetROMaxVersionDirRequest\x12\x12\n\nstore_name\x18\x01 \x03(\t\"y\n\x1aGetROMaxVersionDirResponse\x12:\n\x11ro_store_versions\x18\x01 \x03(\x0b\x32\x1f.voldemort.ROStoreVersionDirMap\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"3\n\x1dGetROCurrentVersionDirRequest\x12\x12\n\nstore_name\x18\x01 \x03(\t\"}\n\x1eGetROCurrentVersionDirResponse\x12:\n\x11ro_store_versions\x18\x01 \x03(\x0b\x32\x1f.voldemort.ROStoreVersionDirMap\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"/\n\x19GetROStorageFormatRequest\x12\x12\n\nstore_name\x18\x01 \x03(\t\"y\n\x1aGetROStorageFormatResponse\x12:\n\x11ro_store_versions\x18\x01 \x03(\x0b\x32\x1f.voldemort.ROStoreVersionDirMap\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"@\n\x17\x46\x61iledFetchStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\";\n\x18\x46\x61iledFetchStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"\xe6\x01\n\x1bRebalanceStateChangeRequest\x12K\n\x1drebalance_partition_info_list\x18\x01 \x03(\x0b\x32$.voldemort.RebalancePartitionInfoMap\x12\x16\n\x0e\x63luster_string\x18\x02 \x02(\t\x12\x0f\n\x07swap_ro\x18\x03 \x02(\x08\x12\x1f\n\x17\x63hange_cluster_metadata\x18\x04 \x02(\x08\x12\x1e\n\x16\x63hange_rebalance_state\x18\x05 \x02(\x08\x12\x10\n\x08rollback\x18\x06 \x02(\x08\"?\n\x1cRebalanceStateChangeResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"G\n DeleteStoreRebalanceStateRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x0f\n\x07node_id\x18\x02 \x02(\x05\"D\n!DeleteStoreRebalanceStateResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"\xcf\r\n\x15VoldemortAdminRequest\x12)\n\x04type\x18\x01 \x02(\x0e\x32\x1b.voldemort.AdminRequestType\x12\x33\n\x0cget_metadata\x18\x02 \x01(\x0b\x32\x1d.voldemort.GetMetadataRequest\x12\x39\n\x0fupdate_metadata\x18\x03 \x01(\x0b\x32 .voldemort.UpdateMetadataRequest\x12J\n\x18update_partition_entries\x18\x04 \x01(\x0b\x32(.voldemort.UpdatePartitionEntriesRequest\x12H\n\x17\x66\x65tch_partition_entries\x18\x05 \x01(\x0b\x32\'.voldemort.FetchPartitionEntriesRequest\x12J\n\x18\x64\x65lete_partition_entries\x18\x06 \x01(\x0b\x32(.voldemort.DeletePartitionEntriesRequest\x12K\n\x19initiate_fetch_and_update\x18\x07 \x01(\x0b\x32(.voldemort.InitiateFetchAndUpdateRequest\x12\x46\n\x16\x61sync_operation_status\x18\x08 \x01(\x0b\x32&.voldemort.AsyncOperationStatusRequest\x12H\n\x17initiate_rebalance_node\x18\t \x01(\x0b\x32\'.voldemort.InitiateRebalanceNodeRequest\x12\x42\n\x14\x61sync_operation_stop\x18\n \x01(\x0b\x32$.voldemort.AsyncOperationStopRequest\x12\x42\n\x14\x61sync_operation_list\x18\x0b \x01(\x0b\x32$.voldemort.AsyncOperationListRequest\x12;\n\x10truncate_entries\x18\x0c \x01(\x0b\x32!.voldemort.TruncateEntriesRequest\x12-\n\tadd_store\x18\r \x01(\x0b\x32\x1a.voldemort.AddStoreRequest\x12\x33\n\x0c\x64\x65lete_store\x18\x0e \x01(\x0b\x32\x1d.voldemort.DeleteStoreRequest\x12\x31\n\x0b\x66\x65tch_store\x18\x0f \x01(\x0b\x32\x1c.voldemort.FetchStoreRequest\x12/\n\nswap_store\x18\x10 \x01(\x0b\x32\x1b.voldemort.SwapStoreRequest\x12\x37\n\x0erollback_store\x18\x11 \x01(\x0b\x32\x1f.voldemort.RollbackStoreRequest\x12\x44\n\x16get_ro_max_version_dir\x18\x12 \x01(\x0b\x32$.voldemort.GetROMaxVersionDirRequest\x12L\n\x1aget_ro_current_version_dir\x18\x13 \x01(\x0b\x32(.voldemort.GetROCurrentVersionDirRequest\x12\x44\n\x15\x66\x65tch_partition_files\x18\x14 \x01(\x0b\x32%.voldemort.FetchPartitionFilesRequest\x12@\n\x13update_slop_entries\x18\x16 \x01(\x0b\x32#.voldemort.UpdateSlopEntriesRequest\x12>\n\x12\x66\x61iled_fetch_store\x18\x18 \x01(\x0b\x32\".voldemort.FailedFetchStoreRequest\x12\x43\n\x15get_ro_storage_format\x18\x19 \x01(\x0b\x32$.voldemort.GetROStorageFormatRequest\x12\x46\n\x16rebalance_state_change\x18\x1a \x01(\x0b\x32&.voldemort.RebalanceStateChangeRequest\x12X\n initiate_rebalance_node_on_donor\x18\x1b \x01(\x0b\x32..voldemort.InitiateRebalanceNodeOnDonorRequest\x12Q\n\x1c\x64\x65lete_store_rebalance_state\x18\x1c \x01(\x0b\x32+.voldemort.DeleteStoreRebalanceStateRequest*\x91\x05\n\x10\x41\x64minRequestType\x12\x10\n\x0cGET_METADATA\x10\x00\x12\x13\n\x0fUPDATE_METADATA\x10\x01\x12\x1c\n\x18UPDATE_PARTITION_ENTRIES\x10\x02\x12\x1b\n\x17\x46\x45TCH_PARTITION_ENTRIES\x10\x03\x12\x1c\n\x18\x44\x45LETE_PARTITION_ENTRIES\x10\x04\x12\x1d\n\x19INITIATE_FETCH_AND_UPDATE\x10\x05\x12\x1a\n\x16\x41SYNC_OPERATION_STATUS\x10\x06\x12\x1b\n\x17INITIATE_REBALANCE_NODE\x10\x07\x12\x18\n\x14\x41SYNC_OPERATION_STOP\x10\x08\x12\x18\n\x14\x41SYNC_OPERATION_LIST\x10\t\x12\x14\n\x10TRUNCATE_ENTRIES\x10\n\x12\r\n\tADD_STORE\x10\x0b\x12\x10\n\x0c\x44\x45LETE_STORE\x10\x0c\x12\x0f\n\x0b\x46\x45TCH_STORE\x10\r\x12\x0e\n\nSWAP_STORE\x10\x0e\x12\x12\n\x0eROLLBACK_STORE\x10\x0f\x12\x1a\n\x16GET_RO_MAX_VERSION_DIR\x10\x10\x12\x1e\n\x1aGET_RO_CURRENT_VERSION_DIR\x10\x11\x12\x19\n\x15\x46\x45TCH_PARTITION_FILES\x10\x12\x12\x17\n\x13UPDATE_SLOP_ENTRIES\x10\x14\x12\x16\n\x12\x46\x41ILED_FETCH_STORE\x10\x16\x12\x19\n\x15GET_RO_STORAGE_FORMAT\x10\x17\x12\x1a\n\x16REBALANCE_STATE_CHANGE\x10\x18\x12$\n INITIATE_REBALANCE_NODE_ON_DONOR\x10\x19\x12 \n\x1c\x44\x45LETE_STORE_REBALANCE_STATE\x10\x1a\x42-\n\x1cvoldemort.client.protocol.pbB\x0bVAdminProtoH\x01')
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/clients/python/voldemort/protocol
Conflict type: NOPATTERN
Conflict body: 
~~FSTMerge~~ _ADMINREQUESTTYPE = descriptor.EnumDescriptor(  name='AdminRequestType',  full_name='voldemort.AdminRequestType',  filename=None,  file=DESCRIPTOR,  values=[    descriptor.EnumValueDescriptor(      name='GET_METADATA', index=0, number=0,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='UPDATE_METADATA', index=1, number=1,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='UPDATE_PARTITION_ENTRIES', index=2, number=2,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FETCH_PARTITION_ENTRIES', index=3, number=3,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='DELETE_PARTITION_ENTRIES', index=4, number=4,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='INITIATE_FETCH_AND_UPDATE', index=5, number=5,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ASYNC_OPERATION_STATUS', index=6, number=6,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='INITIATE_REBALANCE_NODE', index=7, number=7,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ASYNC_OPERATION_STOP', index=8, number=8,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ASYNC_OPERATION_LIST', index=9, number=9,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='TRUNCATE_ENTRIES', index=10, number=10,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ADD_STORE', index=11, number=11,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='DELETE_STORE', index=12, number=12,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FETCH_STORE', index=13, number=13,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='SWAP_STORE', index=14, number=14,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ROLLBACK_STORE', index=15, number=15,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='GET_RO_MAX_VERSION_DIR', index=16, number=16,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='GET_RO_CURRENT_VERSION_DIR', index=17, number=17,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FETCH_PARTITION_FILES', index=18, number=18,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='UPDATE_SLOP_ENTRIES', index=19, number=20,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FAILED_FETCH_STORE', index=20, number=22,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='GET_RO_STORAGE_FORMAT', index=21, number=23,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='REBALANCE_STATE_CHANGE', index=22, number=24,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='REPAIR_JOB', index=23, number=25,      options=None,      type=None),  ],  containing_type=None,  options=None,  serialized_start=6204,  serialized_end=6805,) ##FSTMerge## _ADMINREQUESTTYPE = descriptor.EnumDescriptor(  name='AdminRequestType',  full_name='voldemort.AdminRequestType',  filename=None,  file=DESCRIPTOR,  values=[    descriptor.EnumValueDescriptor(      name='GET_METADATA', index=0, number=0,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='UPDATE_METADATA', index=1, number=1,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='UPDATE_PARTITION_ENTRIES', index=2, number=2,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FETCH_PARTITION_ENTRIES', index=3, number=3,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='DELETE_PARTITION_ENTRIES', index=4, number=4,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='INITIATE_FETCH_AND_UPDATE', index=5, number=5,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ASYNC_OPERATION_STATUS', index=6, number=6,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='INITIATE_REBALANCE_NODE', index=7, number=7,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ASYNC_OPERATION_STOP', index=8, number=8,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ASYNC_OPERATION_LIST', index=9, number=9,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='TRUNCATE_ENTRIES', index=10, number=10,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ADD_STORE', index=11, number=11,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='DELETE_STORE', index=12, number=12,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FETCH_STORE', index=13, number=13,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='SWAP_STORE', index=14, number=14,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ROLLBACK_STORE', index=15, number=15,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='GET_RO_MAX_VERSION_DIR', index=16, number=16,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='GET_RO_CURRENT_VERSION_DIR', index=17, number=17,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FETCH_PARTITION_FILES', index=18, number=18,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='UPDATE_SLOP_ENTRIES', index=19, number=20,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FAILED_FETCH_STORE', index=20, number=22,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='GET_RO_STORAGE_FORMAT', index=21, number=23,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='REBALANCE_STATE_CHANGE', index=22, number=24,      options=None,      type=None),  ],  containing_type=None,  options=None,  serialized_start=6061,  serialized_end=6646,) ##FSTMerge## _ADMINREQUESTTYPE = descriptor.EnumDescriptor(  name='AdminRequestType',  full_name='voldemort.AdminRequestType',  filename=None,  file=DESCRIPTOR,  values=[    descriptor.EnumValueDescriptor(      name='GET_METADATA', index=0, number=0,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='UPDATE_METADATA', index=1, number=1,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='UPDATE_PARTITION_ENTRIES', index=2, number=2,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FETCH_PARTITION_ENTRIES', index=3, number=3,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='DELETE_PARTITION_ENTRIES', index=4, number=4,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='INITIATE_FETCH_AND_UPDATE', index=5, number=5,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ASYNC_OPERATION_STATUS', index=6, number=6,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='INITIATE_REBALANCE_NODE', index=7, number=7,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ASYNC_OPERATION_STOP', index=8, number=8,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ASYNC_OPERATION_LIST', index=9, number=9,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='TRUNCATE_ENTRIES', index=10, number=10,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ADD_STORE', index=11, number=11,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='DELETE_STORE', index=12, number=12,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FETCH_STORE', index=13, number=13,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='SWAP_STORE', index=14, number=14,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ROLLBACK_STORE', index=15, number=15,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='GET_RO_MAX_VERSION_DIR', index=16, number=16,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='GET_RO_CURRENT_VERSION_DIR', index=17, number=17,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FETCH_PARTITION_FILES', index=18, number=18,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='UPDATE_SLOP_ENTRIES', index=19, number=20,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FAILED_FETCH_STORE', index=20, number=22,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='GET_RO_STORAGE_FORMAT', index=21, number=23,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='REBALANCE_STATE_CHANGE', index=22, number=24,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='INITIATE_REBALANCE_NODE_ON_DONOR', index=23, number=25,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='DELETE_STORE_REBALANCE_STATE', index=24, number=26,      options=None,      type=None),  ],  containing_type=None,  options=None,  serialized_start=6488,  serialized_end=7145,)
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/clients/python/voldemort/protocol
Conflict type: NOPATTERN
Conflict body: 
~~FSTMerge~~ _ROSTOREVERSIONDIRMAP = descriptor.Descriptor(  name='ROStoreVersionDirMap',  full_name='voldemort.ROStoreVersionDirMap',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='store_name', full_name='voldemort.ROStoreVersionDirMap.store_name', index=0,      number=1, type=9, cpp_type=9, label=2,      has_default_value=False, default_value=unicode("", "utf-8"),      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='store_dir', full_name='voldemort.ROStoreVersionDirMap.store_dir', index=1,      number=2, type=9, cpp_type=9, label=2,      has_default_value=False, default_value=unicode("", "utf-8"),      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=3569,  serialized_end=3630,) ##FSTMerge## _ROSTOREVERSIONDIRMAP = descriptor.Descriptor(  name='ROStoreVersionDirMap',  full_name='voldemort.ROStoreVersionDirMap',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='store_name', full_name='voldemort.ROStoreVersionDirMap.store_name', index=0,      number=1, type=9, cpp_type=9, label=2,      has_default_value=False, default_value=unicode("", "utf-8"),      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='store_dir', full_name='voldemort.ROStoreVersionDirMap.store_dir', index=1,      number=2, type=9, cpp_type=9, label=2,      has_default_value=False, default_value=unicode("", "utf-8"),      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=3475,  serialized_end=3536,) ##FSTMerge## _ROSTOREVERSIONDIRMAP = descriptor.Descriptor(  name='ROStoreVersionDirMap',  full_name='voldemort.ROStoreVersionDirMap',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='store_name', full_name='voldemort.ROStoreVersionDirMap.store_name', index=0,      number=1, type=9, cpp_type=9, label=2,      has_default_value=False, default_value=unicode("", "utf-8"),      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='store_dir', full_name='voldemort.ROStoreVersionDirMap.store_dir', index=1,      number=2, type=9, cpp_type=9, label=2,      has_default_value=False, default_value=unicode("", "utf-8"),      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=3586,  serialized_end=3647,)
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/clients/python/voldemort/protocol
Conflict type: NOPATTERN
Conflict body: 
~~FSTMerge~~ _GETROMAXVERSIONDIRREQUEST = descriptor.Descriptor(  name='GetROMaxVersionDirRequest',  full_name='voldemort.GetROMaxVersionDirRequest',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='store_name', full_name='voldemort.GetROMaxVersionDirRequest.store_name', index=0,      number=1, type=9, cpp_type=9, label=3,      has_default_value=False, default_value=[],      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=3632,  serialized_end=3679,) ##FSTMerge## _GETROMAXVERSIONDIRREQUEST = descriptor.Descriptor(  name='GetROMaxVersionDirRequest',  full_name='voldemort.GetROMaxVersionDirRequest',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='store_name', full_name='voldemort.GetROMaxVersionDirRequest.store_name', index=0,      number=1, type=9, cpp_type=9, label=3,      has_default_value=False, default_value=[],      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=3538,  serialized_end=3585,) ##FSTMerge## _GETROMAXVERSIONDIRREQUEST = descriptor.Descriptor(  name='GetROMaxVersionDirRequest',  full_name='voldemort.GetROMaxVersionDirRequest',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='store_name', full_name='voldemort.GetROMaxVersionDirRequest.store_name', index=0,      number=1, type=9, cpp_type=9, label=3,      has_default_value=False, default_value=[],      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=3649,  serialized_end=3696,)
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/clients/python/voldemort/protocol
Conflict type: NOPATTERN
Conflict body: 
~~FSTMerge~~ _GETROMAXVERSIONDIRRESPONSE = descriptor.Descriptor(  name='GetROMaxVersionDirResponse',  full_name='voldemort.GetROMaxVersionDirResponse',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='ro_store_versions', full_name='voldemort.GetROMaxVersionDirResponse.ro_store_versions', index=0,      number=1, type=11, cpp_type=10, label=3,      has_default_value=False, default_value=[],      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='error', full_name='voldemort.GetROMaxVersionDirResponse.error', index=1,      number=2, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=3681,  serialized_end=3802,) ##FSTMerge## _GETROMAXVERSIONDIRRESPONSE = descriptor.Descriptor(  name='GetROMaxVersionDirResponse',  full_name='voldemort.GetROMaxVersionDirResponse',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='ro_store_versions', full_name='voldemort.GetROMaxVersionDirResponse.ro_store_versions', index=0,      number=1, type=11, cpp_type=10, label=3,      has_default_value=False, default_value=[],      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='error', full_name='voldemort.GetROMaxVersionDirResponse.error', index=1,      number=2, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=3587,  serialized_end=3708,) ##FSTMerge## _GETROMAXVERSIONDIRRESPONSE = descriptor.Descriptor(  name='GetROMaxVersionDirResponse',  full_name='voldemort.GetROMaxVersionDirResponse',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='ro_store_versions', full_name='voldemort.GetROMaxVersionDirResponse.ro_store_versions', index=0,      number=1, type=11, cpp_type=10, label=3,      has_default_value=False, default_value=[],      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='error', full_name='voldemort.GetROMaxVersionDirResponse.error', index=1,      number=2, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=3698,  serialized_end=3819,)
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/clients/python/voldemort/protocol
Conflict type: NOPATTERN
Conflict body: 
~~FSTMerge~~ _GETROCURRENTVERSIONDIRREQUEST = descriptor.Descriptor(  name='GetROCurrentVersionDirRequest',  full_name='voldemort.GetROCurrentVersionDirRequest',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='store_name', full_name='voldemort.GetROCurrentVersionDirRequest.store_name', index=0,      number=1, type=9, cpp_type=9, label=3,      has_default_value=False, default_value=[],      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=3804,  serialized_end=3855,) ##FSTMerge## _GETROCURRENTVERSIONDIRREQUEST = descriptor.Descriptor(  name='GetROCurrentVersionDirRequest',  full_name='voldemort.GetROCurrentVersionDirRequest',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='store_name', full_name='voldemort.GetROCurrentVersionDirRequest.store_name', index=0,      number=1, type=9, cpp_type=9, label=3,      has_default_value=False, default_value=[],      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=3710,  serialized_end=3761,) ##FSTMerge## _GETROCURRENTVERSIONDIRREQUEST = descriptor.Descriptor(  name='GetROCurrentVersionDirRequest',  full_name='voldemort.GetROCurrentVersionDirRequest',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='store_name', full_name='voldemort.GetROCurrentVersionDirRequest.store_name', index=0,      number=1, type=9, cpp_type=9, label=3,      has_default_value=False, default_value=[],      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=3821,  serialized_end=3872,)
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/clients/python/voldemort/protocol
Conflict type: NOPATTERN
Conflict body: 
~~FSTMerge~~ _GETROCURRENTVERSIONDIRRESPONSE = descriptor.Descriptor(  name='GetROCurrentVersionDirResponse',  full_name='voldemort.GetROCurrentVersionDirResponse',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='ro_store_versions', full_name='voldemort.GetROCurrentVersionDirResponse.ro_store_versions', index=0,      number=1, type=11, cpp_type=10, label=3,      has_default_value=False, default_value=[],      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='error', full_name='voldemort.GetROCurrentVersionDirResponse.error', index=1,      number=2, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=3857,  serialized_end=3982,) ##FSTMerge## _GETROCURRENTVERSIONDIRRESPONSE = descriptor.Descriptor(  name='GetROCurrentVersionDirResponse',  full_name='voldemort.GetROCurrentVersionDirResponse',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='ro_store_versions', full_name='voldemort.GetROCurrentVersionDirResponse.ro_store_versions', index=0,      number=1, type=11, cpp_type=10, label=3,      has_default_value=False, default_value=[],      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='error', full_name='voldemort.GetROCurrentVersionDirResponse.error', index=1,      number=2, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=3763,  serialized_end=3888,) ##FSTMerge## _GETROCURRENTVERSIONDIRRESPONSE = descriptor.Descriptor(  name='GetROCurrentVersionDirResponse',  full_name='voldemort.GetROCurrentVersionDirResponse',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='ro_store_versions', full_name='voldemort.GetROCurrentVersionDirResponse.ro_store_versions', index=0,      number=1, type=11, cpp_type=10, label=3,      has_default_value=False, default_value=[],      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='error', full_name='voldemort.GetROCurrentVersionDirResponse.error', index=1,      number=2, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=3874,  serialized_end=3999,)
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/clients/python/voldemort/protocol
Conflict type: NOPATTERN
Conflict body: 
~~FSTMerge~~ _GETROSTORAGEFORMATREQUEST = descriptor.Descriptor(  name='GetROStorageFormatRequest',  full_name='voldemort.GetROStorageFormatRequest',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='store_name', full_name='voldemort.GetROStorageFormatRequest.store_name', index=0,      number=1, type=9, cpp_type=9, label=3,      has_default_value=False, default_value=[],      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=3984,  serialized_end=4031,) ##FSTMerge## _GETROSTORAGEFORMATREQUEST = descriptor.Descriptor(  name='GetROStorageFormatRequest',  full_name='voldemort.GetROStorageFormatRequest',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='store_name', full_name='voldemort.GetROStorageFormatRequest.store_name', index=0,      number=1, type=9, cpp_type=9, label=3,      has_default_value=False, default_value=[],      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=3890,  serialized_end=3937,) ##FSTMerge## _GETROSTORAGEFORMATREQUEST = descriptor.Descriptor(  name='GetROStorageFormatRequest',  full_name='voldemort.GetROStorageFormatRequest',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='store_name', full_name='voldemort.GetROStorageFormatRequest.store_name', index=0,      number=1, type=9, cpp_type=9, label=3,      has_default_value=False, default_value=[],      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=4001,  serialized_end=4048,)
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/clients/python/voldemort/protocol
Conflict type: NOPATTERN
Conflict body: 
~~FSTMerge~~ _GETROSTORAGEFORMATRESPONSE = descriptor.Descriptor(  name='GetROStorageFormatResponse',  full_name='voldemort.GetROStorageFormatResponse',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='ro_store_versions', full_name='voldemort.GetROStorageFormatResponse.ro_store_versions', index=0,      number=1, type=11, cpp_type=10, label=3,      has_default_value=False, default_value=[],      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='error', full_name='voldemort.GetROStorageFormatResponse.error', index=1,      number=2, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=4033,  serialized_end=4154,) ##FSTMerge## _GETROSTORAGEFORMATRESPONSE = descriptor.Descriptor(  name='GetROStorageFormatResponse',  full_name='voldemort.GetROStorageFormatResponse',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='ro_store_versions', full_name='voldemort.GetROStorageFormatResponse.ro_store_versions', index=0,      number=1, type=11, cpp_type=10, label=3,      has_default_value=False, default_value=[],      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='error', full_name='voldemort.GetROStorageFormatResponse.error', index=1,      number=2, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=3939,  serialized_end=4060,) ##FSTMerge## _GETROSTORAGEFORMATRESPONSE = descriptor.Descriptor(  name='GetROStorageFormatResponse',  full_name='voldemort.GetROStorageFormatResponse',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='ro_store_versions', full_name='voldemort.GetROStorageFormatResponse.ro_store_versions', index=0,      number=1, type=11, cpp_type=10, label=3,      has_default_value=False, default_value=[],      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='error', full_name='voldemort.GetROStorageFormatResponse.error', index=1,      number=2, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=4050,  serialized_end=4171,)
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/clients/python/voldemort/protocol
Conflict type: NOPATTERN
Conflict body: 
~~FSTMerge~~ _FAILEDFETCHSTOREREQUEST = descriptor.Descriptor(  name='FailedFetchStoreRequest',  full_name='voldemort.FailedFetchStoreRequest',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='store_name', full_name='voldemort.FailedFetchStoreRequest.store_name', index=0,      number=1, type=9, cpp_type=9, label=2,      has_default_value=False, default_value=unicode("", "utf-8"),      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='store_dir', full_name='voldemort.FailedFetchStoreRequest.store_dir', index=1,      number=2, type=9, cpp_type=9, label=2,      has_default_value=False, default_value=unicode("", "utf-8"),      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=4156,  serialized_end=4220,) ##FSTMerge## _FAILEDFETCHSTOREREQUEST = descriptor.Descriptor(  name='FailedFetchStoreRequest',  full_name='voldemort.FailedFetchStoreRequest',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='store_name', full_name='voldemort.FailedFetchStoreRequest.store_name', index=0,      number=1, type=9, cpp_type=9, label=2,      has_default_value=False, default_value=unicode("", "utf-8"),      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='store_dir', full_name='voldemort.FailedFetchStoreRequest.store_dir', index=1,      number=2, type=9, cpp_type=9, label=2,      has_default_value=False, default_value=unicode("", "utf-8"),      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=4062,  serialized_end=4126,) ##FSTMerge## _FAILEDFETCHSTOREREQUEST = descriptor.Descriptor(  name='FailedFetchStoreRequest',  full_name='voldemort.FailedFetchStoreRequest',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='store_name', full_name='voldemort.FailedFetchStoreRequest.store_name', index=0,      number=1, type=9, cpp_type=9, label=2,      has_default_value=False, default_value=unicode("", "utf-8"),      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='store_dir', full_name='voldemort.FailedFetchStoreRequest.store_dir', index=1,      number=2, type=9, cpp_type=9, label=2,      has_default_value=False, default_value=unicode("", "utf-8"),      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=4173,  serialized_end=4237,)
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/clients/python/voldemort/protocol
Conflict type: NOPATTERN
Conflict body: 
~~FSTMerge~~ _FAILEDFETCHSTORERESPONSE = descriptor.Descriptor(  name='FailedFetchStoreResponse',  full_name='voldemort.FailedFetchStoreResponse',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='error', full_name='voldemort.FailedFetchStoreResponse.error', index=0,      number=1, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=4222,  serialized_end=4281,) ##FSTMerge## _FAILEDFETCHSTORERESPONSE = descriptor.Descriptor(  name='FailedFetchStoreResponse',  full_name='voldemort.FailedFetchStoreResponse',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='error', full_name='voldemort.FailedFetchStoreResponse.error', index=0,      number=1, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=4128,  serialized_end=4187,) ##FSTMerge## _FAILEDFETCHSTORERESPONSE = descriptor.Descriptor(  name='FailedFetchStoreResponse',  full_name='voldemort.FailedFetchStoreResponse',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='error', full_name='voldemort.FailedFetchStoreResponse.error', index=0,      number=1, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=4239,  serialized_end=4298,)
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/clients/python/voldemort/protocol
Conflict type: NOPATTERN
Conflict body: 
~~FSTMerge~~ _REBALANCESTATECHANGEREQUEST = descriptor.Descriptor(  name='RebalanceStateChangeRequest',  full_name='voldemort.RebalanceStateChangeRequest',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='rebalance_partition_info_list', full_name='voldemort.RebalanceStateChangeRequest.rebalance_partition_info_list', index=0,      number=1, type=11, cpp_type=10, label=3,      has_default_value=False, default_value=[],      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='cluster_string', full_name='voldemort.RebalanceStateChangeRequest.cluster_string', index=1,      number=2, type=9, cpp_type=9, label=2,      has_default_value=False, default_value=unicode("", "utf-8"),      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='swap_ro', full_name='voldemort.RebalanceStateChangeRequest.swap_ro', index=2,      number=3, type=8, cpp_type=7, label=2,      has_default_value=False, default_value=False,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='change_cluster_metadata', full_name='voldemort.RebalanceStateChangeRequest.change_cluster_metadata', index=3,      number=4, type=8, cpp_type=7, label=2,      has_default_value=False, default_value=False,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='change_rebalance_state', full_name='voldemort.RebalanceStateChangeRequest.change_rebalance_state', index=4,      number=5, type=8, cpp_type=7, label=2,      has_default_value=False, default_value=False,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='rollback', full_name='voldemort.RebalanceStateChangeRequest.rollback', index=5,      number=6, type=8, cpp_type=7, label=2,      has_default_value=False, default_value=False,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=4284,  serialized_end=4514,) ##FSTMerge## _REBALANCESTATECHANGEREQUEST = descriptor.Descriptor(  name='RebalanceStateChangeRequest',  full_name='voldemort.RebalanceStateChangeRequest',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='rebalance_partition_info_list', full_name='voldemort.RebalanceStateChangeRequest.rebalance_partition_info_list', index=0,      number=1, type=11, cpp_type=10, label=3,      has_default_value=False, default_value=[],      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='cluster_string', full_name='voldemort.RebalanceStateChangeRequest.cluster_string', index=1,      number=2, type=9, cpp_type=9, label=2,      has_default_value=False, default_value=unicode("", "utf-8"),      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='swap_ro', full_name='voldemort.RebalanceStateChangeRequest.swap_ro', index=2,      number=3, type=8, cpp_type=7, label=2,      has_default_value=False, default_value=False,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='change_cluster_metadata', full_name='voldemort.RebalanceStateChangeRequest.change_cluster_metadata', index=3,      number=4, type=8, cpp_type=7, label=2,      has_default_value=False, default_value=False,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='change_rebalance_state', full_name='voldemort.RebalanceStateChangeRequest.change_rebalance_state', index=4,      number=5, type=8, cpp_type=7, label=2,      has_default_value=False, default_value=False,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='rollback', full_name='voldemort.RebalanceStateChangeRequest.rollback', index=5,      number=6, type=8, cpp_type=7, label=2,      has_default_value=False, default_value=False,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=4190,  serialized_end=4420,) ##FSTMerge## _REBALANCESTATECHANGEREQUEST = descriptor.Descriptor(  name='RebalanceStateChangeRequest',  full_name='voldemort.RebalanceStateChangeRequest',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='rebalance_partition_info_list', full_name='voldemort.RebalanceStateChangeRequest.rebalance_partition_info_list', index=0,      number=1, type=11, cpp_type=10, label=3,      has_default_value=False, default_value=[],      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='cluster_string', full_name='voldemort.RebalanceStateChangeRequest.cluster_string', index=1,      number=2, type=9, cpp_type=9, label=2,      has_default_value=False, default_value=unicode("", "utf-8"),      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='swap_ro', full_name='voldemort.RebalanceStateChangeRequest.swap_ro', index=2,      number=3, type=8, cpp_type=7, label=2,      has_default_value=False, default_value=False,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='change_cluster_metadata', full_name='voldemort.RebalanceStateChangeRequest.change_cluster_metadata', index=3,      number=4, type=8, cpp_type=7, label=2,      has_default_value=False, default_value=False,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='change_rebalance_state', full_name='voldemort.RebalanceStateChangeRequest.change_rebalance_state', index=4,      number=5, type=8, cpp_type=7, label=2,      has_default_value=False, default_value=False,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='rollback', full_name='voldemort.RebalanceStateChangeRequest.rollback', index=5,      number=6, type=8, cpp_type=7, label=2,      has_default_value=False, default_value=False,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=4301,  serialized_end=4531,)
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/clients/python/voldemort/protocol
Conflict type: NOPATTERN
Conflict body: 
~~FSTMerge~~ _REBALANCESTATECHANGERESPONSE = descriptor.Descriptor(  name='RebalanceStateChangeResponse',  full_name='voldemort.RebalanceStateChangeResponse',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='error', full_name='voldemort.RebalanceStateChangeResponse.error', index=0,      number=1, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=4516,  serialized_end=4579,) ##FSTMerge## _REBALANCESTATECHANGERESPONSE = descriptor.Descriptor(  name='RebalanceStateChangeResponse',  full_name='voldemort.RebalanceStateChangeResponse',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='error', full_name='voldemort.RebalanceStateChangeResponse.error', index=0,      number=1, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=4422,  serialized_end=4485,) ##FSTMerge## _REBALANCESTATECHANGERESPONSE = descriptor.Descriptor(  name='RebalanceStateChangeResponse',  full_name='voldemort.RebalanceStateChangeResponse',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='error', full_name='voldemort.RebalanceStateChangeResponse.error', index=0,      number=1, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=4533,  serialized_end=4596,)
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/clients/python/voldemort/protocol
Conflict type: NOPATTERN
Conflict body: 
~~FSTMerge~~ _VOLDEMORTADMINREQUEST = descriptor.Descriptor(  name='VoldemortAdminRequest',  full_name='voldemort.VoldemortAdminRequest',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='type', full_name='voldemort.VoldemortAdminRequest.type', index=0,      number=1, type=14, cpp_type=8, label=2,      has_default_value=False, default_value=0,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_metadata', full_name='voldemort.VoldemortAdminRequest.get_metadata', index=1,      number=2, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='update_metadata', full_name='voldemort.VoldemortAdminRequest.update_metadata', index=2,      number=3, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='update_partition_entries', full_name='voldemort.VoldemortAdminRequest.update_partition_entries', index=3,      number=4, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='fetch_partition_entries', full_name='voldemort.VoldemortAdminRequest.fetch_partition_entries', index=4,      number=5, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='delete_partition_entries', full_name='voldemort.VoldemortAdminRequest.delete_partition_entries', index=5,      number=6, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='initiate_fetch_and_update', full_name='voldemort.VoldemortAdminRequest.initiate_fetch_and_update', index=6,      number=7, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='async_operation_status', full_name='voldemort.VoldemortAdminRequest.async_operation_status', index=7,      number=8, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='initiate_rebalance_node', full_name='voldemort.VoldemortAdminRequest.initiate_rebalance_node', index=8,      number=9, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='async_operation_stop', full_name='voldemort.VoldemortAdminRequest.async_operation_stop', index=9,      number=10, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='async_operation_list', full_name='voldemort.VoldemortAdminRequest.async_operation_list', index=10,      number=11, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='truncate_entries', full_name='voldemort.VoldemortAdminRequest.truncate_entries', index=11,      number=12, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='add_store', full_name='voldemort.VoldemortAdminRequest.add_store', index=12,      number=13, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='delete_store', full_name='voldemort.VoldemortAdminRequest.delete_store', index=13,      number=14, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='fetch_store', full_name='voldemort.VoldemortAdminRequest.fetch_store', index=14,      number=15, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='swap_store', full_name='voldemort.VoldemortAdminRequest.swap_store', index=15,      number=16, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='rollback_store', full_name='voldemort.VoldemortAdminRequest.rollback_store', index=16,      number=17, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_ro_max_version_dir', full_name='voldemort.VoldemortAdminRequest.get_ro_max_version_dir', index=17,      number=18, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_ro_current_version_dir', full_name='voldemort.VoldemortAdminRequest.get_ro_current_version_dir', index=18,      number=19, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='fetch_partition_files', full_name='voldemort.VoldemortAdminRequest.fetch_partition_files', index=19,      number=20, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='update_slop_entries', full_name='voldemort.VoldemortAdminRequest.update_slop_entries', index=20,      number=22, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='failed_fetch_store', full_name='voldemort.VoldemortAdminRequest.failed_fetch_store', index=21,      number=24, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_ro_storage_format', full_name='voldemort.VoldemortAdminRequest.get_ro_storage_format', index=22,      number=25, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='rebalance_state_change', full_name='voldemort.VoldemortAdminRequest.rebalance_state_change', index=23,      number=26, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='repair_job', full_name='voldemort.VoldemortAdminRequest.repair_job', index=24,      number=27, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=4582,  serialized_end=6201,) ##FSTMerge## _VOLDEMORTADMINREQUEST = descriptor.Descriptor(  name='VoldemortAdminRequest',  full_name='voldemort.VoldemortAdminRequest',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='type', full_name='voldemort.VoldemortAdminRequest.type', index=0,      number=1, type=14, cpp_type=8, label=2,      has_default_value=False, default_value=0,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_metadata', full_name='voldemort.VoldemortAdminRequest.get_metadata', index=1,      number=2, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='update_metadata', full_name='voldemort.VoldemortAdminRequest.update_metadata', index=2,      number=3, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='update_partition_entries', full_name='voldemort.VoldemortAdminRequest.update_partition_entries', index=3,      number=4, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='fetch_partition_entries', full_name='voldemort.VoldemortAdminRequest.fetch_partition_entries', index=4,      number=5, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='delete_partition_entries', full_name='voldemort.VoldemortAdminRequest.delete_partition_entries', index=5,      number=6, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='initiate_fetch_and_update', full_name='voldemort.VoldemortAdminRequest.initiate_fetch_and_update', index=6,      number=7, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='async_operation_status', full_name='voldemort.VoldemortAdminRequest.async_operation_status', index=7,      number=8, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='initiate_rebalance_node', full_name='voldemort.VoldemortAdminRequest.initiate_rebalance_node', index=8,      number=9, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='async_operation_stop', full_name='voldemort.VoldemortAdminRequest.async_operation_stop', index=9,      number=10, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='async_operation_list', full_name='voldemort.VoldemortAdminRequest.async_operation_list', index=10,      number=11, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='truncate_entries', full_name='voldemort.VoldemortAdminRequest.truncate_entries', index=11,      number=12, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='add_store', full_name='voldemort.VoldemortAdminRequest.add_store', index=12,      number=13, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='delete_store', full_name='voldemort.VoldemortAdminRequest.delete_store', index=13,      number=14, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='fetch_store', full_name='voldemort.VoldemortAdminRequest.fetch_store', index=14,      number=15, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='swap_store', full_name='voldemort.VoldemortAdminRequest.swap_store', index=15,      number=16, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='rollback_store', full_name='voldemort.VoldemortAdminRequest.rollback_store', index=16,      number=17, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_ro_max_version_dir', full_name='voldemort.VoldemortAdminRequest.get_ro_max_version_dir', index=17,      number=18, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_ro_current_version_dir', full_name='voldemort.VoldemortAdminRequest.get_ro_current_version_dir', index=18,      number=19, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='fetch_partition_files', full_name='voldemort.VoldemortAdminRequest.fetch_partition_files', index=19,      number=20, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='update_slop_entries', full_name='voldemort.VoldemortAdminRequest.update_slop_entries', index=20,      number=22, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='failed_fetch_store', full_name='voldemort.VoldemortAdminRequest.failed_fetch_store', index=21,      number=24, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_ro_storage_format', full_name='voldemort.VoldemortAdminRequest.get_ro_storage_format', index=22,      number=25, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='rebalance_state_change', full_name='voldemort.VoldemortAdminRequest.rebalance_state_change', index=23,      number=26, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=4488,  serialized_end=6058,) ##FSTMerge## _VOLDEMORTADMINREQUEST = descriptor.Descriptor(  name='VoldemortAdminRequest',  full_name='voldemort.VoldemortAdminRequest',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='type', full_name='voldemort.VoldemortAdminRequest.type', index=0,      number=1, type=14, cpp_type=8, label=2,      has_default_value=False, default_value=0,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_metadata', full_name='voldemort.VoldemortAdminRequest.get_metadata', index=1,      number=2, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='update_metadata', full_name='voldemort.VoldemortAdminRequest.update_metadata', index=2,      number=3, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='update_partition_entries', full_name='voldemort.VoldemortAdminRequest.update_partition_entries', index=3,      number=4, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='fetch_partition_entries', full_name='voldemort.VoldemortAdminRequest.fetch_partition_entries', index=4,      number=5, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='delete_partition_entries', full_name='voldemort.VoldemortAdminRequest.delete_partition_entries', index=5,      number=6, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='initiate_fetch_and_update', full_name='voldemort.VoldemortAdminRequest.initiate_fetch_and_update', index=6,      number=7, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='async_operation_status', full_name='voldemort.VoldemortAdminRequest.async_operation_status', index=7,      number=8, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='initiate_rebalance_node', full_name='voldemort.VoldemortAdminRequest.initiate_rebalance_node', index=8,      number=9, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='async_operation_stop', full_name='voldemort.VoldemortAdminRequest.async_operation_stop', index=9,      number=10, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='async_operation_list', full_name='voldemort.VoldemortAdminRequest.async_operation_list', index=10,      number=11, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='truncate_entries', full_name='voldemort.VoldemortAdminRequest.truncate_entries', index=11,      number=12, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='add_store', full_name='voldemort.VoldemortAdminRequest.add_store', index=12,      number=13, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='delete_store', full_name='voldemort.VoldemortAdminRequest.delete_store', index=13,      number=14, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='fetch_store', full_name='voldemort.VoldemortAdminRequest.fetch_store', index=14,      number=15, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='swap_store', full_name='voldemort.VoldemortAdminRequest.swap_store', index=15,      number=16, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='rollback_store', full_name='voldemort.VoldemortAdminRequest.rollback_store', index=16,      number=17, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_ro_max_version_dir', full_name='voldemort.VoldemortAdminRequest.get_ro_max_version_dir', index=17,      number=18, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_ro_current_version_dir', full_name='voldemort.VoldemortAdminRequest.get_ro_current_version_dir', index=18,      number=19, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='fetch_partition_files', full_name='voldemort.VoldemortAdminRequest.fetch_partition_files', index=19,      number=20, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='update_slop_entries', full_name='voldemort.VoldemortAdminRequest.update_slop_entries', index=20,      number=22, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='failed_fetch_store', full_name='voldemort.VoldemortAdminRequest.failed_fetch_store', index=21,      number=24, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_ro_storage_format', full_name='voldemort.VoldemortAdminRequest.get_ro_storage_format', index=22,      number=25, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='rebalance_state_change', full_name='voldemort.VoldemortAdminRequest.rebalance_state_change', index=23,      number=26, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='initiate_rebalance_node_on_donor', full_name='voldemort.VoldemortAdminRequest.initiate_rebalance_node_on_donor', index=24,      number=27, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='delete_store_rebalance_state', full_name='voldemort.VoldemortAdminRequest.delete_store_rebalance_state', index=25,      number=28, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=4742,  serialized_end=6485,)
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e4910_c94ab/rev_e4910-c94ab/clients/python/voldemort/protocol

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e332d_9894f/rev_e332d-9894f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_8e117_a3f81/rev_8e117-a3f81.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_74e0d_e4f51/rev_74e0d-e4f51.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    protected void startInner() {
        registerBean(server, JmxUtils.createObjectName(VoldemortServer.class));
        registerBean(cluster, JmxUtils.createObjectName(Cluster.class));
        for(VoldemortService service: services)
            registerBean(service, JmxUtils.createObjectName(service.getClass()));
        for(Store<ByteArray, byte[], byte[]> store: this.storeRepository.getAllStorageEngines()) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415727640608/fstmerge_var1_6690283794644943078
            registerBean(store,
                         JmxUtils.createObjectName(JmxUtils.getPackageName(store.getClass()),
                                                   store.getName()));
            if(store instanceof BdbStorageEngine) {
                // Temp hack for now
                BdbStorageEngine bdbStore = (BdbStorageEngine) store;
                registerBean(bdbStore.getBdbEnvironmentStats(),
                             JmxUtils.createObjectName(JmxUtils.getPackageName(BdbEnvironmentStats.class),
                                                       store.getName()));
            }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415727640608/fstmerge_base_3705136296948549125
            registerBean(store,
                         JmxUtils.createObjectName(JmxUtils.getPackageName(store.getClass()),
                                                   store.getName()));
=======
            if(server.getVoldemortConfig().isEnableJmxClusterName())
                registerBean(store,
                             JmxUtils.createObjectName(this.cluster.getName()
                                                               + "."
                                                               + JmxUtils.getPackageName(store.getClass()),
                                                       store.getName()));
            else
                registerBean(store,
                             JmxUtils.createObjectName(JmxUtils.getPackageName(store.getClass()),
                                                       store.getName()));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415727640608/fstmerge_var2_2158282569676575093
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_74e0d_e4f51/rev_74e0d-e4f51/src/java/voldemort/server/jmx/JmxService.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_74e0d_0ee9c/rev_74e0d-0ee9c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_74e0d_1c3cc/rev_74e0d-1c3cc.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a94de_bf934/rev_a94de-bf934.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d2687_6448e/rev_d2687-6448e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e081a_e03c9/rev_e081a-e03c9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d2687_4d203/rev_d2687-4d203.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c3972_50f24/rev_c3972-50f24.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d2687_0a04c/rev_d2687-0a04c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f13a9_70fcf/rev_f13a9-70fcf.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f8d4c_67e2b/rev_f8d4c-67e2b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_8b135_c7ba9/rev_8b135-c7ba9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_91da5_0f8ab/rev_91da5-0f8ab.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_91da5_0f8ab/rev_91da5-0f8ab.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c856b_d9210/rev_c856b-d9210.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c856b_d9210/rev_c856b-d9210.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6c1d6_02342/rev_6c1d6-02342.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3a369_d213f/rev_3a369-d213f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d73af_2633a/rev_d73af-2633a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_add29_914ea/rev_add29-914ea.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_acd8a_add29/rev_acd8a-add29.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_fe10e_deeff/rev_fe10e-deeff.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a01e4_fc1f0/rev_a01e4-fc1f0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_cd005_0bdf2/rev_cd005-0bdf2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_390f9_a01e4/rev_390f9-a01e4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d2694_ce113/rev_d2694-ce113.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_fd5db_aee11/rev_fd5db-aee11.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public static AdminRequestType valueOf(int value) {
      switch (value) {
        case 0: return GET_METADATA;
        case 1: return UPDATE_METADATA;
        case 2: return UPDATE_PARTITION_ENTRIES;
        case 3: return FETCH_PARTITION_ENTRIES;
        case 4: return DELETE_PARTITION_ENTRIES;
        case 5: return INITIATE_FETCH_AND_UPDATE;
        case 6: return ASYNC_OPERATION_STATUS;
        case 7: return INITIATE_REBALANCE_NODE;
        case 8: return ASYNC_OPERATION_STOP;
        case 9: return ASYNC_OPERATION_LIST;
        case 10: return TRUNCATE_ENTRIES;
        case 11: return ADD_STORE;
        case 12: return DELETE_STORE;
        case 13: return FETCH_STORE;
        case 14: return SWAP_STORE;
        case 15: return ROLLBACK_STORE;
        case 16: return GET_RO_MAX_VERSION_DIR;
        case 17: return GET_RO_CURRENT_VERSION_DIR;
        case 18: return FETCH_PARTITION_FILES;
        case 20: return UPDATE_SLOP_ENTRIES;
        case 22: return FAILED_FETCH_STORE;
        case 23: return GET_RO_STORAGE_FORMAT;
        case 24: return REBALANCE_STATE_CHANGE;
        case 25: return REPAIR_JOB;
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415749401552/fstmerge_var1_3847814360212298386
        case 26: return NATIVE_BACKUP;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415749401552/fstmerge_base_7257204730544395959
=======
        case 26: return INITIATE_REBALANCE_NODE_ON_DONOR;
        case 27: return DELETE_STORE_REBALANCE_STATE;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415749401552/fstmerge_var2_3271736260443408017
        default: return null;
      }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_fd5db_aee11/rev_fd5db-aee11/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ private static final AdminRequestType[] VALUES = {
      GET_METADATA, UPDATE_METADATA, UPDATE_PARTITION_ENTRIES, FETCH_PARTITION_ENTRIES, DELETE_PARTITION_ENTRIES, INITIATE_FETCH_AND_UPDATE, ASYNC_OPERATION_STATUS, INITIATE_REBALANCE_NODE, ASYNC_OPERATION_STOP, ASYNC_OPERATION_LIST, TRUNCATE_ENTRIES, ADD_STORE, DELETE_STORE, FETCH_STORE, SWAP_STORE, ROLLBACK_STORE, GET_RO_MAX_VERSION_DIR, GET_RO_CURRENT_VERSION_DIR, FETCH_PARTITION_FILES, UPDATE_SLOP_ENTRIES, FAILED_FETCH_STORE, GET_RO_STORAGE_FORMAT, REBALANCE_STATE_CHANGE, REPAIR_JOB, NATIVE_BACKUP, 
    }; ##FSTMerge## private static final AdminRequestType[] VALUES = {
      GET_METADATA, UPDATE_METADATA, UPDATE_PARTITION_ENTRIES, FETCH_PARTITION_ENTRIES, DELETE_PARTITION_ENTRIES, INITIATE_FETCH_AND_UPDATE, ASYNC_OPERATION_STATUS, INITIATE_REBALANCE_NODE, ASYNC_OPERATION_STOP, ASYNC_OPERATION_LIST, TRUNCATE_ENTRIES, ADD_STORE, DELETE_STORE, FETCH_STORE, SWAP_STORE, ROLLBACK_STORE, GET_RO_MAX_VERSION_DIR, GET_RO_CURRENT_VERSION_DIR, FETCH_PARTITION_FILES, UPDATE_SLOP_ENTRIES, FAILED_FETCH_STORE, GET_RO_STORAGE_FORMAT, REBALANCE_STATE_CHANGE, REPAIR_JOB, 
    }; ##FSTMerge## private static final AdminRequestType[] VALUES = {
      GET_METADATA, UPDATE_METADATA, UPDATE_PARTITION_ENTRIES, FETCH_PARTITION_ENTRIES, DELETE_PARTITION_ENTRIES, INITIATE_FETCH_AND_UPDATE, ASYNC_OPERATION_STATUS, INITIATE_REBALANCE_NODE, ASYNC_OPERATION_STOP, ASYNC_OPERATION_LIST, TRUNCATE_ENTRIES, ADD_STORE, DELETE_STORE, FETCH_STORE, SWAP_STORE, ROLLBACK_STORE, GET_RO_MAX_VERSION_DIR, GET_RO_CURRENT_VERSION_DIR, FETCH_PARTITION_FILES, UPDATE_SLOP_ENTRIES, FAILED_FETCH_STORE, GET_RO_STORAGE_FORMAT, REBALANCE_STATE_CHANGE, REPAIR_JOB, INITIATE_REBALANCE_NODE_ON_DONOR, DELETE_STORE_REBALANCE_STATE, 
    };
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_fd5db_aee11/rev_fd5db-aee11/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
private void initFields() {
      type_ = voldemort.client.protocol.pb.VAdminProto.AdminRequestType.GET_METADATA;
      getMetadata_ = voldemort.client.protocol.pb.VAdminProto.GetMetadataRequest.getDefaultInstance();
      updateMetadata_ = voldemort.client.protocol.pb.VAdminProto.UpdateMetadataRequest.getDefaultInstance();
      updatePartitionEntries_ = voldemort.client.protocol.pb.VAdminProto.UpdatePartitionEntriesRequest.getDefaultInstance();
      fetchPartitionEntries_ = voldemort.client.protocol.pb.VAdminProto.FetchPartitionEntriesRequest.getDefaultInstance();
      deletePartitionEntries_ = voldemort.client.protocol.pb.VAdminProto.DeletePartitionEntriesRequest.getDefaultInstance();
      initiateFetchAndUpdate_ = voldemort.client.protocol.pb.VAdminProto.InitiateFetchAndUpdateRequest.getDefaultInstance();
      asyncOperationStatus_ = voldemort.client.protocol.pb.VAdminProto.AsyncOperationStatusRequest.getDefaultInstance();
      initiateRebalanceNode_ = voldemort.client.protocol.pb.VAdminProto.InitiateRebalanceNodeRequest.getDefaultInstance();
      asyncOperationStop_ = voldemort.client.protocol.pb.VAdminProto.AsyncOperationStopRequest.getDefaultInstance();
      asyncOperationList_ = voldemort.client.protocol.pb.VAdminProto.AsyncOperationListRequest.getDefaultInstance();
      truncateEntries_ = voldemort.client.protocol.pb.VAdminProto.TruncateEntriesRequest.getDefaultInstance();
      addStore_ = voldemort.client.protocol.pb.VAdminProto.AddStoreRequest.getDefaultInstance();
      deleteStore_ = voldemort.client.protocol.pb.VAdminProto.DeleteStoreRequest.getDefaultInstance();
      fetchStore_ = voldemort.client.protocol.pb.VAdminProto.FetchStoreRequest.getDefaultInstance();
      swapStore_ = voldemort.client.protocol.pb.VAdminProto.SwapStoreRequest.getDefaultInstance();
      rollbackStore_ = voldemort.client.protocol.pb.VAdminProto.RollbackStoreRequest.getDefaultInstance();
      getRoMaxVersionDir_ = voldemort.client.protocol.pb.VAdminProto.GetROMaxVersionDirRequest.getDefaultInstance();
      getRoCurrentVersionDir_ = voldemort.client.protocol.pb.VAdminProto.GetROCurrentVersionDirRequest.getDefaultInstance();
      fetchPartitionFiles_ = voldemort.client.protocol.pb.VAdminProto.FetchPartitionFilesRequest.getDefaultInstance();
      updateSlopEntries_ = voldemort.client.protocol.pb.VAdminProto.UpdateSlopEntriesRequest.getDefaultInstance();
      failedFetchStore_ = voldemort.client.protocol.pb.VAdminProto.FailedFetchStoreRequest.getDefaultInstance();
      getRoStorageFormat_ = voldemort.client.protocol.pb.VAdminProto.GetROStorageFormatRequest.getDefaultInstance();
      rebalanceStateChange_ = voldemort.client.protocol.pb.VAdminProto.RebalanceStateChangeRequest.getDefaultInstance();
      repairJob_ = voldemort.client.protocol.pb.VAdminProto.RepairJobRequest.getDefaultInstance();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415749413717/fstmerge_var1_2258640735274131693
      nativeBackup_ = voldemort.client.protocol.pb.VAdminProto.NativeBackupRequest.getDefaultInstance();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415749413717/fstmerge_base_3831646760966520125
=======
      initiateRebalanceNodeOnDonor_ = voldemort.client.protocol.pb.VAdminProto.InitiateRebalanceNodeOnDonorRequest.getDefaultInstance();
      deleteStoreRebalanceState_ = voldemort.client.protocol.pb.VAdminProto.DeleteStoreRebalanceStateRequest.getDefaultInstance();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415749413717/fstmerge_var2_1364383851923454661
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_fd5db_aee11/rev_fd5db-aee11/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
public final boolean isInitialized() {
      if (!hasType) return false;
      if (hasGetMetadata()) {
        if (!getGetMetadata().isInitialized()) return false;
      }
      if (hasUpdateMetadata()) {
        if (!getUpdateMetadata().isInitialized()) return false;
      }
      if (hasUpdatePartitionEntries()) {
        if (!getUpdatePartitionEntries().isInitialized()) return false;
      }
      if (hasFetchPartitionEntries()) {
        if (!getFetchPartitionEntries().isInitialized()) return false;
      }
      if (hasDeletePartitionEntries()) {
        if (!getDeletePartitionEntries().isInitialized()) return false;
      }
      if (hasInitiateFetchAndUpdate()) {
        if (!getInitiateFetchAndUpdate().isInitialized()) return false;
      }
      if (hasAsyncOperationStatus()) {
        if (!getAsyncOperationStatus().isInitialized()) return false;
      }
      if (hasInitiateRebalanceNode()) {
        if (!getInitiateRebalanceNode().isInitialized()) return false;
      }
      if (hasAsyncOperationStop()) {
        if (!getAsyncOperationStop().isInitialized()) return false;
      }
      if (hasAsyncOperationList()) {
        if (!getAsyncOperationList().isInitialized()) return false;
      }
      if (hasTruncateEntries()) {
        if (!getTruncateEntries().isInitialized()) return false;
      }
      if (hasAddStore()) {
        if (!getAddStore().isInitialized()) return false;
      }
      if (hasDeleteStore()) {
        if (!getDeleteStore().isInitialized()) return false;
      }
      if (hasFetchStore()) {
        if (!getFetchStore().isInitialized()) return false;
      }
      if (hasSwapStore()) {
        if (!getSwapStore().isInitialized()) return false;
      }
      if (hasRollbackStore()) {
        if (!getRollbackStore().isInitialized()) return false;
      }
      if (hasFetchPartitionFiles()) {
        if (!getFetchPartitionFiles().isInitialized()) return false;
      }
      if (hasUpdateSlopEntries()) {
        if (!getUpdateSlopEntries().isInitialized()) return false;
      }
      if (hasFailedFetchStore()) {
        if (!getFailedFetchStore().isInitialized()) return false;
      }
      if (hasRebalanceStateChange()) {
        if (!getRebalanceStateChange().isInitialized()) return false;
      }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415749413723/fstmerge_var1_393202801345544111
      if (hasNativeBackup()) {
        if (!getNativeBackup().isInitialized()) return false;
      }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415749413723/fstmerge_base_626861112587263326
=======
      if (hasInitiateRebalanceNodeOnDonor()) {
        if (!getInitiateRebalanceNodeOnDonor().isInitialized()) return false;
      }
      if (hasDeleteStoreRebalanceState()) {
        if (!getDeleteStoreRebalanceState().isInitialized()) return false;
      }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415749413723/fstmerge_var2_2778738929927472377
      return true;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_fd5db_aee11/rev_fd5db-aee11/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (hasType()) {
        output.writeEnum(1, getType().getNumber());
      }
      if (hasGetMetadata()) {
        output.writeMessage(2, getGetMetadata());
      }
      if (hasUpdateMetadata()) {
        output.writeMessage(3, getUpdateMetadata());
      }
      if (hasUpdatePartitionEntries()) {
        output.writeMessage(4, getUpdatePartitionEntries());
      }
      if (hasFetchPartitionEntries()) {
        output.writeMessage(5, getFetchPartitionEntries());
      }
      if (hasDeletePartitionEntries()) {
        output.writeMessage(6, getDeletePartitionEntries());
      }
      if (hasInitiateFetchAndUpdate()) {
        output.writeMessage(7, getInitiateFetchAndUpdate());
      }
      if (hasAsyncOperationStatus()) {
        output.writeMessage(8, getAsyncOperationStatus());
      }
      if (hasInitiateRebalanceNode()) {
        output.writeMessage(9, getInitiateRebalanceNode());
      }
      if (hasAsyncOperationStop()) {
        output.writeMessage(10, getAsyncOperationStop());
      }
      if (hasAsyncOperationList()) {
        output.writeMessage(11, getAsyncOperationList());
      }
      if (hasTruncateEntries()) {
        output.writeMessage(12, getTruncateEntries());
      }
      if (hasAddStore()) {
        output.writeMessage(13, getAddStore());
      }
      if (hasDeleteStore()) {
        output.writeMessage(14, getDeleteStore());
      }
      if (hasFetchStore()) {
        output.writeMessage(15, getFetchStore());
      }
      if (hasSwapStore()) {
        output.writeMessage(16, getSwapStore());
      }
      if (hasRollbackStore()) {
        output.writeMessage(17, getRollbackStore());
      }
      if (hasGetRoMaxVersionDir()) {
        output.writeMessage(18, getGetRoMaxVersionDir());
      }
      if (hasGetRoCurrentVersionDir()) {
        output.writeMessage(19, getGetRoCurrentVersionDir());
      }
      if (hasFetchPartitionFiles()) {
        output.writeMessage(20, getFetchPartitionFiles());
      }
      if (hasUpdateSlopEntries()) {
        output.writeMessage(22, getUpdateSlopEntries());
      }
      if (hasFailedFetchStore()) {
        output.writeMessage(24, getFailedFetchStore());
      }
      if (hasGetRoStorageFormat()) {
        output.writeMessage(25, getGetRoStorageFormat());
      }
      if (hasRebalanceStateChange()) {
        output.writeMessage(26, getRebalanceStateChange());
      }
      if (hasRepairJob()) {
        output.writeMessage(27, getRepairJob());
      }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415749413728/fstmerge_var1_233904454418740160
      if (hasNativeBackup()) {
        output.writeMessage(28, getNativeBackup());
      }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415749413728/fstmerge_base_8824852120864193094
=======
      if (hasInitiateRebalanceNodeOnDonor()) {
        output.writeMessage(28, getInitiateRebalanceNodeOnDonor());
      }
      if (hasDeleteStoreRebalanceState()) {
        output.writeMessage(29, getDeleteStoreRebalanceState());
      }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415749413728/fstmerge_var2_6763565931833640785
      getUnknownFields().writeTo(output);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_fd5db_aee11/rev_fd5db-aee11/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
    
      size = 0;
      if (hasType()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, getType().getNumber());
      }
      if (hasGetMetadata()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getGetMetadata());
      }
      if (hasUpdateMetadata()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getUpdateMetadata());
      }
      if (hasUpdatePartitionEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getUpdatePartitionEntries());
      }
      if (hasFetchPartitionEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getFetchPartitionEntries());
      }
      if (hasDeletePartitionEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getDeletePartitionEntries());
      }
      if (hasInitiateFetchAndUpdate()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getInitiateFetchAndUpdate());
      }
      if (hasAsyncOperationStatus()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getAsyncOperationStatus());
      }
      if (hasInitiateRebalanceNode()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, getInitiateRebalanceNode());
      }
      if (hasAsyncOperationStop()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, getAsyncOperationStop());
      }
      if (hasAsyncOperationList()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, getAsyncOperationList());
      }
      if (hasTruncateEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(12, getTruncateEntries());
      }
      if (hasAddStore()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(13, getAddStore());
      }
      if (hasDeleteStore()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(14, getDeleteStore());
      }
      if (hasFetchStore()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(15, getFetchStore());
      }
      if (hasSwapStore()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(16, getSwapStore());
      }
      if (hasRollbackStore()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(17, getRollbackStore());
      }
      if (hasGetRoMaxVersionDir()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(18, getGetRoMaxVersionDir());
      }
      if (hasGetRoCurrentVersionDir()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(19, getGetRoCurrentVersionDir());
      }
      if (hasFetchPartitionFiles()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(20, getFetchPartitionFiles());
      }
      if (hasUpdateSlopEntries()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(22, getUpdateSlopEntries());
      }
      if (hasFailedFetchStore()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(24, getFailedFetchStore());
      }
      if (hasGetRoStorageFormat()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(25, getGetRoStorageFormat());
      }
      if (hasRebalanceStateChange()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(26, getRebalanceStateChange());
      }
      if (hasRepairJob()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(27, getRepairJob());
      }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415749413732/fstmerge_var1_256091858416363543
      if (hasNativeBackup()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(28, getNativeBackup());
      }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415749413732/fstmerge_base_6271350703731068247
=======
      if (hasInitiateRebalanceNodeOnDonor()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(28, getInitiateRebalanceNodeOnDonor());
      }
      if (hasDeleteStoreRebalanceState()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(29, getDeleteStoreRebalanceState());
      }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415749413732/fstmerge_var2_6864424058483027087
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_fd5db_aee11/rev_fd5db-aee11/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
public Builder mergeFrom(voldemort.client.protocol.pb.VAdminProto.VoldemortAdminRequest other) {
        if (other == voldemort.client.protocol.pb.VAdminProto.VoldemortAdminRequest.getDefaultInstance()) return this;
        if (other.hasType()) {
          setType(other.getType());
        }
        if (other.hasGetMetadata()) {
          mergeGetMetadata(other.getGetMetadata());
        }
        if (other.hasUpdateMetadata()) {
          mergeUpdateMetadata(other.getUpdateMetadata());
        }
        if (other.hasUpdatePartitionEntries()) {
          mergeUpdatePartitionEntries(other.getUpdatePartitionEntries());
        }
        if (other.hasFetchPartitionEntries()) {
          mergeFetchPartitionEntries(other.getFetchPartitionEntries());
        }
        if (other.hasDeletePartitionEntries()) {
          mergeDeletePartitionEntries(other.getDeletePartitionEntries());
        }
        if (other.hasInitiateFetchAndUpdate()) {
          mergeInitiateFetchAndUpdate(other.getInitiateFetchAndUpdate());
        }
        if (other.hasAsyncOperationStatus()) {
          mergeAsyncOperationStatus(other.getAsyncOperationStatus());
        }
        if (other.hasInitiateRebalanceNode()) {
          mergeInitiateRebalanceNode(other.getInitiateRebalanceNode());
        }
        if (other.hasAsyncOperationStop()) {
          mergeAsyncOperationStop(other.getAsyncOperationStop());
        }
        if (other.hasAsyncOperationList()) {
          mergeAsyncOperationList(other.getAsyncOperationList());
        }
        if (other.hasTruncateEntries()) {
          mergeTruncateEntries(other.getTruncateEntries());
        }
        if (other.hasAddStore()) {
          mergeAddStore(other.getAddStore());
        }
        if (other.hasDeleteStore()) {
          mergeDeleteStore(other.getDeleteStore());
        }
        if (other.hasFetchStore()) {
          mergeFetchStore(other.getFetchStore());
        }
        if (other.hasSwapStore()) {
          mergeSwapStore(other.getSwapStore());
        }
        if (other.hasRollbackStore()) {
          mergeRollbackStore(other.getRollbackStore());
        }
        if (other.hasGetRoMaxVersionDir()) {
          mergeGetRoMaxVersionDir(other.getGetRoMaxVersionDir());
        }
        if (other.hasGetRoCurrentVersionDir()) {
          mergeGetRoCurrentVersionDir(other.getGetRoCurrentVersionDir());
        }
        if (other.hasFetchPartitionFiles()) {
          mergeFetchPartitionFiles(other.getFetchPartitionFiles());
        }
        if (other.hasUpdateSlopEntries()) {
          mergeUpdateSlopEntries(other.getUpdateSlopEntries());
        }
        if (other.hasFailedFetchStore()) {
          mergeFailedFetchStore(other.getFailedFetchStore());
        }
        if (other.hasGetRoStorageFormat()) {
          mergeGetRoStorageFormat(other.getGetRoStorageFormat());
        }
        if (other.hasRebalanceStateChange()) {
          mergeRebalanceStateChange(other.getRebalanceStateChange());
        }
        if (other.hasRepairJob()) {
          mergeRepairJob(other.getRepairJob());
        }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415749413843/fstmerge_var1_5605488479794346476
        if (other.hasNativeBackup()) {
          mergeNativeBackup(other.getNativeBackup());
        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415749413843/fstmerge_base_4264506150177711401
=======
        if (other.hasInitiateRebalanceNodeOnDonor()) {
          mergeInitiateRebalanceNodeOnDonor(other.getInitiateRebalanceNodeOnDonor());
        }
        if (other.hasDeleteStoreRebalanceState()) {
          mergeDeleteStoreRebalanceState(other.getDeleteStoreRebalanceState());
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415749413843/fstmerge_var2_7058189732370927795
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_fd5db_aee11/rev_fd5db-aee11/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: LineBasedMCFd
Conflict body: 
public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder(
            this.getUnknownFields());
        while (true) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              this.setUnknownFields(unknownFields.build());
              return this;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                this.setUnknownFields(unknownFields.build());
                return this;
              }
              break;
            }
            case 8: {
              int rawValue = input.readEnum();
              voldemort.client.protocol.pb.VAdminProto.AdminRequestType value = voldemort.client.protocol.pb.VAdminProto.AdminRequestType.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(1, rawValue);
              } else {
                setType(value);
              }
              break;
            }
            case 18: {
              voldemort.client.protocol.pb.VAdminProto.GetMetadataRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.GetMetadataRequest.newBuilder();
              if (hasGetMetadata()) {
                subBuilder.mergeFrom(getGetMetadata());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setGetMetadata(subBuilder.buildPartial());
              break;
            }
            case 26: {
              voldemort.client.protocol.pb.VAdminProto.UpdateMetadataRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.UpdateMetadataRequest.newBuilder();
              if (hasUpdateMetadata()) {
                subBuilder.mergeFrom(getUpdateMetadata());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setUpdateMetadata(subBuilder.buildPartial());
              break;
            }
            case 34: {
              voldemort.client.protocol.pb.VAdminProto.UpdatePartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.UpdatePartitionEntriesRequest.newBuilder();
              if (hasUpdatePartitionEntries()) {
                subBuilder.mergeFrom(getUpdatePartitionEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setUpdatePartitionEntries(subBuilder.buildPartial());
              break;
            }
            case 42: {
              voldemort.client.protocol.pb.VAdminProto.FetchPartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.FetchPartitionEntriesRequest.newBuilder();
              if (hasFetchPartitionEntries()) {
                subBuilder.mergeFrom(getFetchPartitionEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setFetchPartitionEntries(subBuilder.buildPartial());
              break;
            }
            case 50: {
              voldemort.client.protocol.pb.VAdminProto.DeletePartitionEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.DeletePartitionEntriesRequest.newBuilder();
              if (hasDeletePartitionEntries()) {
                subBuilder.mergeFrom(getDeletePartitionEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setDeletePartitionEntries(subBuilder.buildPartial());
              break;
            }
            case 58: {
              voldemort.client.protocol.pb.VAdminProto.InitiateFetchAndUpdateRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.InitiateFetchAndUpdateRequest.newBuilder();
              if (hasInitiateFetchAndUpdate()) {
                subBuilder.mergeFrom(getInitiateFetchAndUpdate());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setInitiateFetchAndUpdate(subBuilder.buildPartial());
              break;
            }
            case 66: {
              voldemort.client.protocol.pb.VAdminProto.AsyncOperationStatusRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.AsyncOperationStatusRequest.newBuilder();
              if (hasAsyncOperationStatus()) {
                subBuilder.mergeFrom(getAsyncOperationStatus());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setAsyncOperationStatus(subBuilder.buildPartial());
              break;
            }
            case 74: {
              voldemort.client.protocol.pb.VAdminProto.InitiateRebalanceNodeRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.InitiateRebalanceNodeRequest.newBuilder();
              if (hasInitiateRebalanceNode()) {
                subBuilder.mergeFrom(getInitiateRebalanceNode());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setInitiateRebalanceNode(subBuilder.buildPartial());
              break;
            }
            case 82: {
              voldemort.client.protocol.pb.VAdminProto.AsyncOperationStopRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.AsyncOperationStopRequest.newBuilder();
              if (hasAsyncOperationStop()) {
                subBuilder.mergeFrom(getAsyncOperationStop());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setAsyncOperationStop(subBuilder.buildPartial());
              break;
            }
            case 90: {
              voldemort.client.protocol.pb.VAdminProto.AsyncOperationListRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.AsyncOperationListRequest.newBuilder();
              if (hasAsyncOperationList()) {
                subBuilder.mergeFrom(getAsyncOperationList());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setAsyncOperationList(subBuilder.buildPartial());
              break;
            }
            case 98: {
              voldemort.client.protocol.pb.VAdminProto.TruncateEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.TruncateEntriesRequest.newBuilder();
              if (hasTruncateEntries()) {
                subBuilder.mergeFrom(getTruncateEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setTruncateEntries(subBuilder.buildPartial());
              break;
            }
            case 106: {
              voldemort.client.protocol.pb.VAdminProto.AddStoreRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.AddStoreRequest.newBuilder();
              if (hasAddStore()) {
                subBuilder.mergeFrom(getAddStore());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setAddStore(subBuilder.buildPartial());
              break;
            }
            case 114: {
              voldemort.client.protocol.pb.VAdminProto.DeleteStoreRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.DeleteStoreRequest.newBuilder();
              if (hasDeleteStore()) {
                subBuilder.mergeFrom(getDeleteStore());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setDeleteStore(subBuilder.buildPartial());
              break;
            }
            case 122: {
              voldemort.client.protocol.pb.VAdminProto.FetchStoreRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.FetchStoreRequest.newBuilder();
              if (hasFetchStore()) {
                subBuilder.mergeFrom(getFetchStore());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setFetchStore(subBuilder.buildPartial());
              break;
            }
            case 130: {
              voldemort.client.protocol.pb.VAdminProto.SwapStoreRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.SwapStoreRequest.newBuilder();
              if (hasSwapStore()) {
                subBuilder.mergeFrom(getSwapStore());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setSwapStore(subBuilder.buildPartial());
              break;
            }
            case 138: {
              voldemort.client.protocol.pb.VAdminProto.RollbackStoreRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.RollbackStoreRequest.newBuilder();
              if (hasRollbackStore()) {
                subBuilder.mergeFrom(getRollbackStore());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setRollbackStore(subBuilder.buildPartial());
              break;
            }
            case 146: {
              voldemort.client.protocol.pb.VAdminProto.GetROMaxVersionDirRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.GetROMaxVersionDirRequest.newBuilder();
              if (hasGetRoMaxVersionDir()) {
                subBuilder.mergeFrom(getGetRoMaxVersionDir());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setGetRoMaxVersionDir(subBuilder.buildPartial());
              break;
            }
            case 154: {
              voldemort.client.protocol.pb.VAdminProto.GetROCurrentVersionDirRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.GetROCurrentVersionDirRequest.newBuilder();
              if (hasGetRoCurrentVersionDir()) {
                subBuilder.mergeFrom(getGetRoCurrentVersionDir());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setGetRoCurrentVersionDir(subBuilder.buildPartial());
              break;
            }
            case 162: {
              voldemort.client.protocol.pb.VAdminProto.FetchPartitionFilesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.FetchPartitionFilesRequest.newBuilder();
              if (hasFetchPartitionFiles()) {
                subBuilder.mergeFrom(getFetchPartitionFiles());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setFetchPartitionFiles(subBuilder.buildPartial());
              break;
            }
            case 178: {
              voldemort.client.protocol.pb.VAdminProto.UpdateSlopEntriesRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.UpdateSlopEntriesRequest.newBuilder();
              if (hasUpdateSlopEntries()) {
                subBuilder.mergeFrom(getUpdateSlopEntries());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setUpdateSlopEntries(subBuilder.buildPartial());
              break;
            }
            case 194: {
              voldemort.client.protocol.pb.VAdminProto.FailedFetchStoreRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.FailedFetchStoreRequest.newBuilder();
              if (hasFailedFetchStore()) {
                subBuilder.mergeFrom(getFailedFetchStore());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setFailedFetchStore(subBuilder.buildPartial());
              break;
            }
            case 202: {
              voldemort.client.protocol.pb.VAdminProto.GetROStorageFormatRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.GetROStorageFormatRequest.newBuilder();
              if (hasGetRoStorageFormat()) {
                subBuilder.mergeFrom(getGetRoStorageFormat());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setGetRoStorageFormat(subBuilder.buildPartial());
              break;
            }
            case 210: {
              voldemort.client.protocol.pb.VAdminProto.RebalanceStateChangeRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.RebalanceStateChangeRequest.newBuilder();
              if (hasRebalanceStateChange()) {
                subBuilder.mergeFrom(getRebalanceStateChange());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setRebalanceStateChange(subBuilder.buildPartial());
              break;
            }
            case 218: {
              voldemort.client.protocol.pb.VAdminProto.RepairJobRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.RepairJobRequest.newBuilder();
              if (hasRepairJob()) {
                subBuilder.mergeFrom(getRepairJob());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setRepairJob(subBuilder.buildPartial());
              break;
            }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415749413849/fstmerge_var1_1483986232107396263
            case 226: {
              voldemort.client.protocol.pb.VAdminProto.NativeBackupRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.NativeBackupRequest.newBuilder();
              if (hasNativeBackup()) {
                subBuilder.mergeFrom(getNativeBackup());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setNativeBackup(subBuilder.buildPartial());
              break;
            }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415749413849/fstmerge_base_2885911420544777477
=======
            case 226: {
              voldemort.client.protocol.pb.VAdminProto.InitiateRebalanceNodeOnDonorRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.InitiateRebalanceNodeOnDonorRequest.newBuilder();
              if (hasInitiateRebalanceNodeOnDonor()) {
                subBuilder.mergeFrom(getInitiateRebalanceNodeOnDonor());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setInitiateRebalanceNodeOnDonor(subBuilder.buildPartial());
              break;
            }
            case 234: {
              voldemort.client.protocol.pb.VAdminProto.DeleteStoreRebalanceStateRequest.Builder subBuilder = voldemort.client.protocol.pb.VAdminProto.DeleteStoreRebalanceStateRequest.newBuilder();
              if (hasDeleteStoreRebalanceState()) {
                subBuilder.mergeFrom(getDeleteStoreRebalanceState());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setDeleteStoreRebalanceState(subBuilder.buildPartial());
              break;
            }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415749413849/fstmerge_var2_2935015226076079086
          }
        }
      }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_fd5db_aee11/rev_fd5db-aee11/src/java/voldemort/client/protocol/pb/VAdminProto.java
Conflict type: NOPATTERN
Conflict body: 
~~FSTMerge~~ DESCRIPTOR = descriptor.FileDescriptor(  name='voldemort-admin.proto',  package='voldemort',  serialized_pb='\n\x15voldemort-admin.proto\x12\tvoldemort\x1a\x16voldemort-client.proto\"!\n\x12GetMetadataRequest\x12\x0b\n\x03key\x18\x01 \x02(\x0c\"]\n\x13GetMetadataResponse\x12%\n\x07version\x18\x01 \x01(\x0b\x32\x14.voldemort.Versioned\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"M\n\x15UpdateMetadataRequest\x12\x0b\n\x03key\x18\x01 \x02(\x0c\x12\'\n\tversioned\x18\x02 \x02(\x0b\x32\x14.voldemort.Versioned\"9\n\x16UpdateMetadataResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"7\n\tFileEntry\x12\x11\n\tfile_name\x18\x01 \x02(\t\x12\x17\n\x0f\x66ile_size_bytes\x18\x02 \x02(\x03\"F\n\x0ePartitionEntry\x12\x0b\n\x03key\x18\x01 \x02(\x0c\x12\'\n\tversioned\x18\x02 \x02(\x0b\x32\x14.voldemort.Versioned\"\x8e\x01\n\x1dUpdatePartitionEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x32\n\x0fpartition_entry\x18\x02 \x02(\x0b\x32\x19.voldemort.PartitionEntry\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\"A\n\x1eUpdatePartitionEntriesResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"-\n\x0fVoldemortFilter\x12\x0c\n\x04name\x18\x01 \x02(\t\x12\x0c\n\x04\x64\x61ta\x18\x02 \x02(\x0c\"\xaf\x01\n\x18UpdateSlopEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x0b\n\x03key\x18\x02 \x02(\x0c\x12\'\n\x07version\x18\x03 \x02(\x0b\x32\x16.voldemort.VectorClock\x12,\n\x0crequest_type\x18\x04 \x02(\x0e\x32\x16.voldemort.RequestType\x12\r\n\x05value\x18\x05 \x01(\x0c\x12\x11\n\ttransform\x18\x06 \x01(\x0c\"<\n\x19UpdateSlopEntriesResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"d\n\x1a\x46\x65tchPartitionFilesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x37\n\x14replica_to_partition\x18\x02 \x03(\x0b\x32\x19.voldemort.PartitionTuple\"\xd7\x01\n\x1c\x46\x65tchPartitionEntriesRequest\x12\x37\n\x14replica_to_partition\x18\x01 \x03(\x0b\x32\x19.voldemort.PartitionTuple\x12\r\n\x05store\x18\x02 \x02(\t\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\x12\x14\n\x0c\x66\x65tch_values\x18\x04 \x01(\x08\x12\x14\n\x0cskip_records\x18\x05 \x01(\x03\x12\x17\n\x0finitial_cluster\x18\x06 \x01(\t\"\x81\x01\n\x1d\x46\x65tchPartitionEntriesResponse\x12\x32\n\x0fpartition_entry\x18\x01 \x01(\x0b\x32\x19.voldemort.PartitionEntry\x12\x0b\n\x03key\x18\x02 \x01(\x0c\x12\x1f\n\x05\x65rror\x18\x03 \x01(\x0b\x32\x10.voldemort.Error\"\xac\x01\n\x1d\x44\x65letePartitionEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x37\n\x14replica_to_partition\x18\x02 \x03(\x0b\x32\x19.voldemort.PartitionTuple\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\x12\x17\n\x0finitial_cluster\x18\x04 \x01(\t\"P\n\x1e\x44\x65letePartitionEntriesResponse\x12\r\n\x05\x63ount\x18\x01 \x01(\x03\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"\xcf\x01\n\x1dInitiateFetchAndUpdateRequest\x12\x0f\n\x07node_id\x18\x01 \x02(\x05\x12\r\n\x05store\x18\x02 \x02(\t\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\x12\x37\n\x14replica_to_partition\x18\x04 \x03(\x0b\x32\x19.voldemort.PartitionTuple\x12\x17\n\x0finitial_cluster\x18\x05 \x01(\t\x12\x10\n\x08optimize\x18\x06 \x01(\x08\"1\n\x1b\x41syncOperationStatusRequest\x12\x12\n\nrequest_id\x18\x01 \x02(\x05\"/\n\x19\x41syncOperationStopRequest\x12\x12\n\nrequest_id\x18\x01 \x02(\x05\"=\n\x1a\x41syncOperationStopResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"2\n\x19\x41syncOperationListRequest\x12\x15\n\rshow_complete\x18\x02 \x02(\x08\"R\n\x1a\x41syncOperationListResponse\x12\x13\n\x0brequest_ids\x18\x01 \x03(\x05\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\":\n\x0ePartitionTuple\x12\x14\n\x0creplica_type\x18\x01 \x02(\x05\x12\x12\n\npartitions\x18\x02 \x03(\x05\"e\n\x16PerStorePartitionTuple\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x37\n\x14replica_to_partition\x18\x02 \x03(\x0b\x32\x19.voldemort.PartitionTuple\"\xf8\x01\n\x19RebalancePartitionInfoMap\x12\x12\n\nstealer_id\x18\x01 \x02(\x05\x12\x10\n\x08\x64onor_id\x18\x02 \x02(\x05\x12\x0f\n\x07\x61ttempt\x18\x03 \x02(\x05\x12\x43\n\x18replica_to_add_partition\x18\x04 \x03(\x0b\x32!.voldemort.PerStorePartitionTuple\x12\x46\n\x1breplica_to_delete_partition\x18\x05 \x03(\x0b\x32!.voldemort.PerStorePartitionTuple\x12\x17\n\x0finitial_cluster\x18\x06 \x02(\t\"f\n\x1cInitiateRebalanceNodeRequest\x12\x46\n\x18rebalance_partition_info\x18\x01 \x02(\x0b\x32$.voldemort.RebalancePartitionInfoMap\"\x8a\x01\n\x1c\x41syncOperationStatusResponse\x12\x12\n\nrequest_id\x18\x01 \x01(\x05\x12\x13\n\x0b\x64\x65scription\x18\x02 \x01(\t\x12\x0e\n\x06status\x18\x03 \x01(\t\x12\x10\n\x08\x63omplete\x18\x04 \x01(\x08\x12\x1f\n\x05\x65rror\x18\x05 \x01(\x0b\x32\x10.voldemort.Error\"\'\n\x16TruncateEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\":\n\x17TruncateEntriesResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"*\n\x0f\x41\x64\x64StoreRequest\x12\x17\n\x0fstoreDefinition\x18\x01 \x02(\t\"3\n\x10\x41\x64\x64StoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"\'\n\x12\x44\x65leteStoreRequest\x12\x11\n\tstoreName\x18\x01 \x02(\t\"6\n\x13\x44\x65leteStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"P\n\x11\x46\x65tchStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\x12\x14\n\x0cpush_version\x18\x03 \x01(\x03\"9\n\x10SwapStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\"P\n\x11SwapStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\x12\x1a\n\x12previous_store_dir\x18\x02 \x01(\t\"@\n\x14RollbackStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x14\n\x0cpush_version\x18\x02 \x02(\x03\"8\n\x15RollbackStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"&\n\x10RepairJobRequest\x12\x12\n\nstore_name\x18\x01 \x01(\t\"4\n\x11RepairJobResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"=\n\x14ROStoreVersionDirMap\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\"/\n\x19GetROMaxVersionDirRequest\x12\x12\n\nstore_name\x18\x01 \x03(\t\"y\n\x1aGetROMaxVersionDirResponse\x12:\n\x11ro_store_versions\x18\x01 \x03(\x0b\x32\x1f.voldemort.ROStoreVersionDirMap\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"3\n\x1dGetROCurrentVersionDirRequest\x12\x12\n\nstore_name\x18\x01 \x03(\t\"}\n\x1eGetROCurrentVersionDirResponse\x12:\n\x11ro_store_versions\x18\x01 \x03(\x0b\x32\x1f.voldemort.ROStoreVersionDirMap\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"/\n\x19GetROStorageFormatRequest\x12\x12\n\nstore_name\x18\x01 \x03(\t\"y\n\x1aGetROStorageFormatResponse\x12:\n\x11ro_store_versions\x18\x01 \x03(\x0b\x32\x1f.voldemort.ROStoreVersionDirMap\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"@\n\x17\x46\x61iledFetchStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\";\n\x18\x46\x61iledFetchStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"\xe6\x01\n\x1bRebalanceStateChangeRequest\x12K\n\x1drebalance_partition_info_list\x18\x01 \x03(\x0b\x32$.voldemort.RebalancePartitionInfoMap\x12\x16\n\x0e\x63luster_string\x18\x02 \x02(\t\x12\x0f\n\x07swap_ro\x18\x03 \x02(\x08\x12\x1f\n\x17\x63hange_cluster_metadata\x18\x04 \x02(\x08\x12\x1e\n\x16\x63hange_rebalance_state\x18\x05 \x02(\x08\x12\x10\n\x08rollback\x18\x06 \x02(\x08\"?\n\x1cRebalanceStateChangeResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"=\n\x13NativeBackupRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x12\n\nbackup_dir\x18\x02 \x02(\t\"\x8a\r\n\x15VoldemortAdminRequest\x12)\n\x04type\x18\x01 \x02(\x0e\x32\x1b.voldemort.AdminRequestType\x12\x33\n\x0cget_metadata\x18\x02 \x01(\x0b\x32\x1d.voldemort.GetMetadataRequest\x12\x39\n\x0fupdate_metadata\x18\x03 \x01(\x0b\x32 .voldemort.UpdateMetadataRequest\x12J\n\x18update_partition_entries\x18\x04 \x01(\x0b\x32(.voldemort.UpdatePartitionEntriesRequest\x12H\n\x17\x66\x65tch_partition_entries\x18\x05 \x01(\x0b\x32\'.voldemort.FetchPartitionEntriesRequest\x12J\n\x18\x64\x65lete_partition_entries\x18\x06 \x01(\x0b\x32(.voldemort.DeletePartitionEntriesRequest\x12K\n\x19initiate_fetch_and_update\x18\x07 \x01(\x0b\x32(.voldemort.InitiateFetchAndUpdateRequest\x12\x46\n\x16\x61sync_operation_status\x18\x08 \x01(\x0b\x32&.voldemort.AsyncOperationStatusRequest\x12H\n\x17initiate_rebalance_node\x18\t \x01(\x0b\x32\'.voldemort.InitiateRebalanceNodeRequest\x12\x42\n\x14\x61sync_operation_stop\x18\n \x01(\x0b\x32$.voldemort.AsyncOperationStopRequest\x12\x42\n\x14\x61sync_operation_list\x18\x0b \x01(\x0b\x32$.voldemort.AsyncOperationListRequest\x12;\n\x10truncate_entries\x18\x0c \x01(\x0b\x32!.voldemort.TruncateEntriesRequest\x12-\n\tadd_store\x18\r \x01(\x0b\x32\x1a.voldemort.AddStoreRequest\x12\x33\n\x0c\x64\x65lete_store\x18\x0e \x01(\x0b\x32\x1d.voldemort.DeleteStoreRequest\x12\x31\n\x0b\x66\x65tch_store\x18\x0f \x01(\x0b\x32\x1c.voldemort.FetchStoreRequest\x12/\n\nswap_store\x18\x10 \x01(\x0b\x32\x1b.voldemort.SwapStoreRequest\x12\x37\n\x0erollback_store\x18\x11 \x01(\x0b\x32\x1f.voldemort.RollbackStoreRequest\x12\x44\n\x16get_ro_max_version_dir\x18\x12 \x01(\x0b\x32$.voldemort.GetROMaxVersionDirRequest\x12L\n\x1aget_ro_current_version_dir\x18\x13 \x01(\x0b\x32(.voldemort.GetROCurrentVersionDirRequest\x12\x44\n\x15\x66\x65tch_partition_files\x18\x14 \x01(\x0b\x32%.voldemort.FetchPartitionFilesRequest\x12@\n\x13update_slop_entries\x18\x16 \x01(\x0b\x32#.voldemort.UpdateSlopEntriesRequest\x12>\n\x12\x66\x61iled_fetch_store\x18\x18 \x01(\x0b\x32\".voldemort.FailedFetchStoreRequest\x12\x43\n\x15get_ro_storage_format\x18\x19 \x01(\x0b\x32$.voldemort.GetROStorageFormatRequest\x12\x46\n\x16rebalance_state_change\x18\x1a \x01(\x0b\x32&.voldemort.RebalanceStateChangeRequest\x12/\n\nrepair_job\x18\x1b \x01(\x0b\x32\x1b.voldemort.RepairJobRequest\x12\x35\n\rnative_backup\x18\x1c \x01(\x0b\x32\x1e.voldemort.NativeBackupRequest*\xec\x04\n\x10\x41\x64minRequestType\x12\x10\n\x0cGET_METADATA\x10\x00\x12\x13\n\x0fUPDATE_METADATA\x10\x01\x12\x1c\n\x18UPDATE_PARTITION_ENTRIES\x10\x02\x12\x1b\n\x17\x46\x45TCH_PARTITION_ENTRIES\x10\x03\x12\x1c\n\x18\x44\x45LETE_PARTITION_ENTRIES\x10\x04\x12\x1d\n\x19INITIATE_FETCH_AND_UPDATE\x10\x05\x12\x1a\n\x16\x41SYNC_OPERATION_STATUS\x10\x06\x12\x1b\n\x17INITIATE_REBALANCE_NODE\x10\x07\x12\x18\n\x14\x41SYNC_OPERATION_STOP\x10\x08\x12\x18\n\x14\x41SYNC_OPERATION_LIST\x10\t\x12\x14\n\x10TRUNCATE_ENTRIES\x10\n\x12\r\n\tADD_STORE\x10\x0b\x12\x10\n\x0c\x44\x45LETE_STORE\x10\x0c\x12\x0f\n\x0b\x46\x45TCH_STORE\x10\r\x12\x0e\n\nSWAP_STORE\x10\x0e\x12\x12\n\x0eROLLBACK_STORE\x10\x0f\x12\x1a\n\x16GET_RO_MAX_VERSION_DIR\x10\x10\x12\x1e\n\x1aGET_RO_CURRENT_VERSION_DIR\x10\x11\x12\x19\n\x15\x46\x45TCH_PARTITION_FILES\x10\x12\x12\x17\n\x13UPDATE_SLOP_ENTRIES\x10\x14\x12\x16\n\x12\x46\x41ILED_FETCH_STORE\x10\x16\x12\x19\n\x15GET_RO_STORAGE_FORMAT\x10\x17\x12\x1a\n\x16REBALANCE_STATE_CHANGE\x10\x18\x12\x0e\n\nREPAIR_JOB\x10\x19\x12\x11\n\rNATIVE_BACKUP\x10\x1a\x42-\n\x1cvoldemort.client.protocol.pbB\x0bVAdminProtoH\x01') ##FSTMerge## DESCRIPTOR = descriptor.FileDescriptor(  name='voldemort-admin.proto',  package='voldemort',  serialized_pb='\n\x15voldemort-admin.proto\x12\tvoldemort\x1a\x16voldemort-client.proto\"!\n\x12GetMetadataRequest\x12\x0b\n\x03key\x18\x01 \x02(\x0c\"]\n\x13GetMetadataResponse\x12%\n\x07version\x18\x01 \x01(\x0b\x32\x14.voldemort.Versioned\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"M\n\x15UpdateMetadataRequest\x12\x0b\n\x03key\x18\x01 \x02(\x0c\x12\'\n\tversioned\x18\x02 \x02(\x0b\x32\x14.voldemort.Versioned\"9\n\x16UpdateMetadataResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"7\n\tFileEntry\x12\x11\n\tfile_name\x18\x01 \x02(\t\x12\x17\n\x0f\x66ile_size_bytes\x18\x02 \x02(\x03\"F\n\x0ePartitionEntry\x12\x0b\n\x03key\x18\x01 \x02(\x0c\x12\'\n\tversioned\x18\x02 \x02(\x0b\x32\x14.voldemort.Versioned\"\x8e\x01\n\x1dUpdatePartitionEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x32\n\x0fpartition_entry\x18\x02 \x02(\x0b\x32\x19.voldemort.PartitionEntry\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\"A\n\x1eUpdatePartitionEntriesResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"-\n\x0fVoldemortFilter\x12\x0c\n\x04name\x18\x01 \x02(\t\x12\x0c\n\x04\x64\x61ta\x18\x02 \x02(\x0c\"\xaf\x01\n\x18UpdateSlopEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x0b\n\x03key\x18\x02 \x02(\x0c\x12\'\n\x07version\x18\x03 \x02(\x0b\x32\x16.voldemort.VectorClock\x12,\n\x0crequest_type\x18\x04 \x02(\x0e\x32\x16.voldemort.RequestType\x12\r\n\x05value\x18\x05 \x01(\x0c\x12\x11\n\ttransform\x18\x06 \x01(\x0c\"<\n\x19UpdateSlopEntriesResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"d\n\x1a\x46\x65tchPartitionFilesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x37\n\x14replica_to_partition\x18\x02 \x03(\x0b\x32\x19.voldemort.PartitionTuple\"\xd7\x01\n\x1c\x46\x65tchPartitionEntriesRequest\x12\x37\n\x14replica_to_partition\x18\x01 \x03(\x0b\x32\x19.voldemort.PartitionTuple\x12\r\n\x05store\x18\x02 \x02(\t\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\x12\x14\n\x0c\x66\x65tch_values\x18\x04 \x01(\x08\x12\x14\n\x0cskip_records\x18\x05 \x01(\x03\x12\x17\n\x0finitial_cluster\x18\x06 \x01(\t\"\x81\x01\n\x1d\x46\x65tchPartitionEntriesResponse\x12\x32\n\x0fpartition_entry\x18\x01 \x01(\x0b\x32\x19.voldemort.PartitionEntry\x12\x0b\n\x03key\x18\x02 \x01(\x0c\x12\x1f\n\x05\x65rror\x18\x03 \x01(\x0b\x32\x10.voldemort.Error\"\xac\x01\n\x1d\x44\x65letePartitionEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x37\n\x14replica_to_partition\x18\x02 \x03(\x0b\x32\x19.voldemort.PartitionTuple\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\x12\x17\n\x0finitial_cluster\x18\x04 \x01(\t\"P\n\x1e\x44\x65letePartitionEntriesResponse\x12\r\n\x05\x63ount\x18\x01 \x01(\x03\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"\xcf\x01\n\x1dInitiateFetchAndUpdateRequest\x12\x0f\n\x07node_id\x18\x01 \x02(\x05\x12\r\n\x05store\x18\x02 \x02(\t\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\x12\x37\n\x14replica_to_partition\x18\x04 \x03(\x0b\x32\x19.voldemort.PartitionTuple\x12\x17\n\x0finitial_cluster\x18\x05 \x01(\t\x12\x10\n\x08optimize\x18\x06 \x01(\x08\"1\n\x1b\x41syncOperationStatusRequest\x12\x12\n\nrequest_id\x18\x01 \x02(\x05\"/\n\x19\x41syncOperationStopRequest\x12\x12\n\nrequest_id\x18\x01 \x02(\x05\"=\n\x1a\x41syncOperationStopResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"2\n\x19\x41syncOperationListRequest\x12\x15\n\rshow_complete\x18\x02 \x02(\x08\"R\n\x1a\x41syncOperationListResponse\x12\x13\n\x0brequest_ids\x18\x01 \x03(\x05\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\":\n\x0ePartitionTuple\x12\x14\n\x0creplica_type\x18\x01 \x02(\x05\x12\x12\n\npartitions\x18\x02 \x03(\x05\"e\n\x16PerStorePartitionTuple\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x37\n\x14replica_to_partition\x18\x02 \x03(\x0b\x32\x19.voldemort.PartitionTuple\"\xf8\x01\n\x19RebalancePartitionInfoMap\x12\x12\n\nstealer_id\x18\x01 \x02(\x05\x12\x10\n\x08\x64onor_id\x18\x02 \x02(\x05\x12\x0f\n\x07\x61ttempt\x18\x03 \x02(\x05\x12\x43\n\x18replica_to_add_partition\x18\x04 \x03(\x0b\x32!.voldemort.PerStorePartitionTuple\x12\x46\n\x1breplica_to_delete_partition\x18\x05 \x03(\x0b\x32!.voldemort.PerStorePartitionTuple\x12\x17\n\x0finitial_cluster\x18\x06 \x02(\t\"f\n\x1cInitiateRebalanceNodeRequest\x12\x46\n\x18rebalance_partition_info\x18\x01 \x02(\x0b\x32$.voldemort.RebalancePartitionInfoMap\"\x8a\x01\n\x1c\x41syncOperationStatusResponse\x12\x12\n\nrequest_id\x18\x01 \x01(\x05\x12\x13\n\x0b\x64\x65scription\x18\x02 \x01(\t\x12\x0e\n\x06status\x18\x03 \x01(\t\x12\x10\n\x08\x63omplete\x18\x04 \x01(\x08\x12\x1f\n\x05\x65rror\x18\x05 \x01(\x0b\x32\x10.voldemort.Error\"\'\n\x16TruncateEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\":\n\x17TruncateEntriesResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"*\n\x0f\x41\x64\x64StoreRequest\x12\x17\n\x0fstoreDefinition\x18\x01 \x02(\t\"3\n\x10\x41\x64\x64StoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"\'\n\x12\x44\x65leteStoreRequest\x12\x11\n\tstoreName\x18\x01 \x02(\t\"6\n\x13\x44\x65leteStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"P\n\x11\x46\x65tchStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\x12\x14\n\x0cpush_version\x18\x03 \x01(\x03\"9\n\x10SwapStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\"P\n\x11SwapStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\x12\x1a\n\x12previous_store_dir\x18\x02 \x01(\t\"@\n\x14RollbackStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x14\n\x0cpush_version\x18\x02 \x02(\x03\"8\n\x15RollbackStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"&\n\x10RepairJobRequest\x12\x12\n\nstore_name\x18\x01 \x01(\t\"4\n\x11RepairJobResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"=\n\x14ROStoreVersionDirMap\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\"/\n\x19GetROMaxVersionDirRequest\x12\x12\n\nstore_name\x18\x01 \x03(\t\"y\n\x1aGetROMaxVersionDirResponse\x12:\n\x11ro_store_versions\x18\x01 \x03(\x0b\x32\x1f.voldemort.ROStoreVersionDirMap\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"3\n\x1dGetROCurrentVersionDirRequest\x12\x12\n\nstore_name\x18\x01 \x03(\t\"}\n\x1eGetROCurrentVersionDirResponse\x12:\n\x11ro_store_versions\x18\x01 \x03(\x0b\x32\x1f.voldemort.ROStoreVersionDirMap\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"/\n\x19GetROStorageFormatRequest\x12\x12\n\nstore_name\x18\x01 \x03(\t\"y\n\x1aGetROStorageFormatResponse\x12:\n\x11ro_store_versions\x18\x01 \x03(\x0b\x32\x1f.voldemort.ROStoreVersionDirMap\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"@\n\x17\x46\x61iledFetchStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\";\n\x18\x46\x61iledFetchStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"\xe6\x01\n\x1bRebalanceStateChangeRequest\x12K\n\x1drebalance_partition_info_list\x18\x01 \x03(\x0b\x32$.voldemort.RebalancePartitionInfoMap\x12\x16\n\x0e\x63luster_string\x18\x02 \x02(\t\x12\x0f\n\x07swap_ro\x18\x03 \x02(\x08\x12\x1f\n\x17\x63hange_cluster_metadata\x18\x04 \x02(\x08\x12\x1e\n\x16\x63hange_rebalance_state\x18\x05 \x02(\x08\x12\x10\n\x08rollback\x18\x06 \x02(\x08\"?\n\x1cRebalanceStateChangeResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"\xd3\x0c\n\x15VoldemortAdminRequest\x12)\n\x04type\x18\x01 \x02(\x0e\x32\x1b.voldemort.AdminRequestType\x12\x33\n\x0cget_metadata\x18\x02 \x01(\x0b\x32\x1d.voldemort.GetMetadataRequest\x12\x39\n\x0fupdate_metadata\x18\x03 \x01(\x0b\x32 .voldemort.UpdateMetadataRequest\x12J\n\x18update_partition_entries\x18\x04 \x01(\x0b\x32(.voldemort.UpdatePartitionEntriesRequest\x12H\n\x17\x66\x65tch_partition_entries\x18\x05 \x01(\x0b\x32\'.voldemort.FetchPartitionEntriesRequest\x12J\n\x18\x64\x65lete_partition_entries\x18\x06 \x01(\x0b\x32(.voldemort.DeletePartitionEntriesRequest\x12K\n\x19initiate_fetch_and_update\x18\x07 \x01(\x0b\x32(.voldemort.InitiateFetchAndUpdateRequest\x12\x46\n\x16\x61sync_operation_status\x18\x08 \x01(\x0b\x32&.voldemort.AsyncOperationStatusRequest\x12H\n\x17initiate_rebalance_node\x18\t \x01(\x0b\x32\'.voldemort.InitiateRebalanceNodeRequest\x12\x42\n\x14\x61sync_operation_stop\x18\n \x01(\x0b\x32$.voldemort.AsyncOperationStopRequest\x12\x42\n\x14\x61sync_operation_list\x18\x0b \x01(\x0b\x32$.voldemort.AsyncOperationListRequest\x12;\n\x10truncate_entries\x18\x0c \x01(\x0b\x32!.voldemort.TruncateEntriesRequest\x12-\n\tadd_store\x18\r \x01(\x0b\x32\x1a.voldemort.AddStoreRequest\x12\x33\n\x0c\x64\x65lete_store\x18\x0e \x01(\x0b\x32\x1d.voldemort.DeleteStoreRequest\x12\x31\n\x0b\x66\x65tch_store\x18\x0f \x01(\x0b\x32\x1c.voldemort.FetchStoreRequest\x12/\n\nswap_store\x18\x10 \x01(\x0b\x32\x1b.voldemort.SwapStoreRequest\x12\x37\n\x0erollback_store\x18\x11 \x01(\x0b\x32\x1f.voldemort.RollbackStoreRequest\x12\x44\n\x16get_ro_max_version_dir\x18\x12 \x01(\x0b\x32$.voldemort.GetROMaxVersionDirRequest\x12L\n\x1aget_ro_current_version_dir\x18\x13 \x01(\x0b\x32(.voldemort.GetROCurrentVersionDirRequest\x12\x44\n\x15\x66\x65tch_partition_files\x18\x14 \x01(\x0b\x32%.voldemort.FetchPartitionFilesRequest\x12@\n\x13update_slop_entries\x18\x16 \x01(\x0b\x32#.voldemort.UpdateSlopEntriesRequest\x12>\n\x12\x66\x61iled_fetch_store\x18\x18 \x01(\x0b\x32\".voldemort.FailedFetchStoreRequest\x12\x43\n\x15get_ro_storage_format\x18\x19 \x01(\x0b\x32$.voldemort.GetROStorageFormatRequest\x12\x46\n\x16rebalance_state_change\x18\x1a \x01(\x0b\x32&.voldemort.RebalanceStateChangeRequest\x12/\n\nrepair_job\x18\x1b \x01(\x0b\x32\x1b.voldemort.RepairJobRequest*\xd9\x04\n\x10\x41\x64minRequestType\x12\x10\n\x0cGET_METADATA\x10\x00\x12\x13\n\x0fUPDATE_METADATA\x10\x01\x12\x1c\n\x18UPDATE_PARTITION_ENTRIES\x10\x02\x12\x1b\n\x17\x46\x45TCH_PARTITION_ENTRIES\x10\x03\x12\x1c\n\x18\x44\x45LETE_PARTITION_ENTRIES\x10\x04\x12\x1d\n\x19INITIATE_FETCH_AND_UPDATE\x10\x05\x12\x1a\n\x16\x41SYNC_OPERATION_STATUS\x10\x06\x12\x1b\n\x17INITIATE_REBALANCE_NODE\x10\x07\x12\x18\n\x14\x41SYNC_OPERATION_STOP\x10\x08\x12\x18\n\x14\x41SYNC_OPERATION_LIST\x10\t\x12\x14\n\x10TRUNCATE_ENTRIES\x10\n\x12\r\n\tADD_STORE\x10\x0b\x12\x10\n\x0c\x44\x45LETE_STORE\x10\x0c\x12\x0f\n\x0b\x46\x45TCH_STORE\x10\r\x12\x0e\n\nSWAP_STORE\x10\x0e\x12\x12\n\x0eROLLBACK_STORE\x10\x0f\x12\x1a\n\x16GET_RO_MAX_VERSION_DIR\x10\x10\x12\x1e\n\x1aGET_RO_CURRENT_VERSION_DIR\x10\x11\x12\x19\n\x15\x46\x45TCH_PARTITION_FILES\x10\x12\x12\x17\n\x13UPDATE_SLOP_ENTRIES\x10\x14\x12\x16\n\x12\x46\x41ILED_FETCH_STORE\x10\x16\x12\x19\n\x15GET_RO_STORAGE_FORMAT\x10\x17\x12\x1a\n\x16REBALANCE_STATE_CHANGE\x10\x18\x12\x0e\n\nREPAIR_JOB\x10\x19\x42-\n\x1cvoldemort.client.protocol.pbB\x0bVAdminProtoH\x01') ##FSTMerge## DESCRIPTOR = descriptor.FileDescriptor(  name='voldemort-admin.proto',  package='voldemort',  serialized_pb='\n\x15voldemort-admin.proto\x12\tvoldemort\x1a\x16voldemort-client.proto\"!\n\x12GetMetadataRequest\x12\x0b\n\x03key\x18\x01 \x02(\x0c\"]\n\x13GetMetadataResponse\x12%\n\x07version\x18\x01 \x01(\x0b\x32\x14.voldemort.Versioned\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"M\n\x15UpdateMetadataRequest\x12\x0b\n\x03key\x18\x01 \x02(\x0c\x12\'\n\tversioned\x18\x02 \x02(\x0b\x32\x14.voldemort.Versioned\"9\n\x16UpdateMetadataResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"7\n\tFileEntry\x12\x11\n\tfile_name\x18\x01 \x02(\t\x12\x17\n\x0f\x66ile_size_bytes\x18\x02 \x02(\x03\"F\n\x0ePartitionEntry\x12\x0b\n\x03key\x18\x01 \x02(\x0c\x12\'\n\tversioned\x18\x02 \x02(\x0b\x32\x14.voldemort.Versioned\"\x8e\x01\n\x1dUpdatePartitionEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x32\n\x0fpartition_entry\x18\x02 \x02(\x0b\x32\x19.voldemort.PartitionEntry\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\"A\n\x1eUpdatePartitionEntriesResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"-\n\x0fVoldemortFilter\x12\x0c\n\x04name\x18\x01 \x02(\t\x12\x0c\n\x04\x64\x61ta\x18\x02 \x02(\x0c\"\xaf\x01\n\x18UpdateSlopEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x0b\n\x03key\x18\x02 \x02(\x0c\x12\'\n\x07version\x18\x03 \x02(\x0b\x32\x16.voldemort.VectorClock\x12,\n\x0crequest_type\x18\x04 \x02(\x0e\x32\x16.voldemort.RequestType\x12\r\n\x05value\x18\x05 \x01(\x0c\x12\x11\n\ttransform\x18\x06 \x01(\x0c\"<\n\x19UpdateSlopEntriesResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"d\n\x1a\x46\x65tchPartitionFilesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x37\n\x14replica_to_partition\x18\x02 \x03(\x0b\x32\x19.voldemort.PartitionTuple\"\xd7\x01\n\x1c\x46\x65tchPartitionEntriesRequest\x12\x37\n\x14replica_to_partition\x18\x01 \x03(\x0b\x32\x19.voldemort.PartitionTuple\x12\r\n\x05store\x18\x02 \x02(\t\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\x12\x14\n\x0c\x66\x65tch_values\x18\x04 \x01(\x08\x12\x14\n\x0cskip_records\x18\x05 \x01(\x03\x12\x17\n\x0finitial_cluster\x18\x06 \x01(\t\"\x81\x01\n\x1d\x46\x65tchPartitionEntriesResponse\x12\x32\n\x0fpartition_entry\x18\x01 \x01(\x0b\x32\x19.voldemort.PartitionEntry\x12\x0b\n\x03key\x18\x02 \x01(\x0c\x12\x1f\n\x05\x65rror\x18\x03 \x01(\x0b\x32\x10.voldemort.Error\"\xac\x01\n\x1d\x44\x65letePartitionEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\x12\x37\n\x14replica_to_partition\x18\x02 \x03(\x0b\x32\x19.voldemort.PartitionTuple\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\x12\x17\n\x0finitial_cluster\x18\x04 \x01(\t\"P\n\x1e\x44\x65letePartitionEntriesResponse\x12\r\n\x05\x63ount\x18\x01 \x01(\x03\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"\xcf\x01\n\x1dInitiateFetchAndUpdateRequest\x12\x0f\n\x07node_id\x18\x01 \x02(\x05\x12\r\n\x05store\x18\x02 \x02(\t\x12*\n\x06\x66ilter\x18\x03 \x01(\x0b\x32\x1a.voldemort.VoldemortFilter\x12\x37\n\x14replica_to_partition\x18\x04 \x03(\x0b\x32\x19.voldemort.PartitionTuple\x12\x17\n\x0finitial_cluster\x18\x05 \x01(\t\x12\x10\n\x08optimize\x18\x06 \x01(\x08\"1\n\x1b\x41syncOperationStatusRequest\x12\x12\n\nrequest_id\x18\x01 \x02(\x05\"/\n\x19\x41syncOperationStopRequest\x12\x12\n\nrequest_id\x18\x01 \x02(\x05\"=\n\x1a\x41syncOperationStopResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"2\n\x19\x41syncOperationListRequest\x12\x15\n\rshow_complete\x18\x02 \x02(\x08\"R\n\x1a\x41syncOperationListResponse\x12\x13\n\x0brequest_ids\x18\x01 \x03(\x05\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\":\n\x0ePartitionTuple\x12\x14\n\x0creplica_type\x18\x01 \x02(\x05\x12\x12\n\npartitions\x18\x02 \x03(\x05\"e\n\x16PerStorePartitionTuple\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x37\n\x14replica_to_partition\x18\x02 \x03(\x0b\x32\x19.voldemort.PartitionTuple\"\xf8\x01\n\x19RebalancePartitionInfoMap\x12\x12\n\nstealer_id\x18\x01 \x02(\x05\x12\x10\n\x08\x64onor_id\x18\x02 \x02(\x05\x12\x0f\n\x07\x61ttempt\x18\x03 \x02(\x05\x12\x43\n\x18replica_to_add_partition\x18\x04 \x03(\x0b\x32!.voldemort.PerStorePartitionTuple\x12\x46\n\x1breplica_to_delete_partition\x18\x05 \x03(\x0b\x32!.voldemort.PerStorePartitionTuple\x12\x17\n\x0finitial_cluster\x18\x06 \x02(\t\"f\n\x1cInitiateRebalanceNodeRequest\x12\x46\n\x18rebalance_partition_info\x18\x01 \x02(\x0b\x32$.voldemort.RebalancePartitionInfoMap\"m\n#InitiateRebalanceNodeOnDonorRequest\x12\x46\n\x18rebalance_partition_info\x18\x01 \x03(\x0b\x32$.voldemort.RebalancePartitionInfoMap\"\x8a\x01\n\x1c\x41syncOperationStatusResponse\x12\x12\n\nrequest_id\x18\x01 \x01(\x05\x12\x13\n\x0b\x64\x65scription\x18\x02 \x01(\t\x12\x0e\n\x06status\x18\x03 \x01(\t\x12\x10\n\x08\x63omplete\x18\x04 \x01(\x08\x12\x1f\n\x05\x65rror\x18\x05 \x01(\x0b\x32\x10.voldemort.Error\"\'\n\x16TruncateEntriesRequest\x12\r\n\x05store\x18\x01 \x02(\t\":\n\x17TruncateEntriesResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"*\n\x0f\x41\x64\x64StoreRequest\x12\x17\n\x0fstoreDefinition\x18\x01 \x02(\t\"3\n\x10\x41\x64\x64StoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"\'\n\x12\x44\x65leteStoreRequest\x12\x11\n\tstoreName\x18\x01 \x02(\t\"6\n\x13\x44\x65leteStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"P\n\x11\x46\x65tchStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\x12\x14\n\x0cpush_version\x18\x03 \x01(\x03\"9\n\x10SwapStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\"P\n\x11SwapStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\x12\x1a\n\x12previous_store_dir\x18\x02 \x01(\t\"@\n\x14RollbackStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x14\n\x0cpush_version\x18\x02 \x02(\x03\"8\n\x15RollbackStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"&\n\x10RepairJobRequest\x12\x12\n\nstore_name\x18\x01 \x01(\t\"4\n\x11RepairJobResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"=\n\x14ROStoreVersionDirMap\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\"/\n\x19GetROMaxVersionDirRequest\x12\x12\n\nstore_name\x18\x01 \x03(\t\"y\n\x1aGetROMaxVersionDirResponse\x12:\n\x11ro_store_versions\x18\x01 \x03(\x0b\x32\x1f.voldemort.ROStoreVersionDirMap\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"3\n\x1dGetROCurrentVersionDirRequest\x12\x12\n\nstore_name\x18\x01 \x03(\t\"}\n\x1eGetROCurrentVersionDirResponse\x12:\n\x11ro_store_versions\x18\x01 \x03(\x0b\x32\x1f.voldemort.ROStoreVersionDirMap\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"/\n\x19GetROStorageFormatRequest\x12\x12\n\nstore_name\x18\x01 \x03(\t\"y\n\x1aGetROStorageFormatResponse\x12:\n\x11ro_store_versions\x18\x01 \x03(\x0b\x32\x1f.voldemort.ROStoreVersionDirMap\x12\x1f\n\x05\x65rror\x18\x02 \x01(\x0b\x32\x10.voldemort.Error\"@\n\x17\x46\x61iledFetchStoreRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x11\n\tstore_dir\x18\x02 \x02(\t\";\n\x18\x46\x61iledFetchStoreResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"\xe6\x01\n\x1bRebalanceStateChangeRequest\x12K\n\x1drebalance_partition_info_list\x18\x01 \x03(\x0b\x32$.voldemort.RebalancePartitionInfoMap\x12\x16\n\x0e\x63luster_string\x18\x02 \x02(\t\x12\x0f\n\x07swap_ro\x18\x03 \x02(\x08\x12\x1f\n\x17\x63hange_cluster_metadata\x18\x04 \x02(\x08\x12\x1e\n\x16\x63hange_rebalance_state\x18\x05 \x02(\x08\x12\x10\n\x08rollback\x18\x06 \x02(\x08\"?\n\x1cRebalanceStateChangeResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"G\n DeleteStoreRebalanceStateRequest\x12\x12\n\nstore_name\x18\x01 \x02(\t\x12\x0f\n\x07node_id\x18\x02 \x02(\x05\"D\n!DeleteStoreRebalanceStateResponse\x12\x1f\n\x05\x65rror\x18\x01 \x01(\x0b\x32\x10.voldemort.Error\"\x80\x0e\n\x15VoldemortAdminRequest\x12)\n\x04type\x18\x01 \x02(\x0e\x32\x1b.voldemort.AdminRequestType\x12\x33\n\x0cget_metadata\x18\x02 \x01(\x0b\x32\x1d.voldemort.GetMetadataRequest\x12\x39\n\x0fupdate_metadata\x18\x03 \x01(\x0b\x32 .voldemort.UpdateMetadataRequest\x12J\n\x18update_partition_entries\x18\x04 \x01(\x0b\x32(.voldemort.UpdatePartitionEntriesRequest\x12H\n\x17\x66\x65tch_partition_entries\x18\x05 \x01(\x0b\x32\'.voldemort.FetchPartitionEntriesRequest\x12J\n\x18\x64\x65lete_partition_entries\x18\x06 \x01(\x0b\x32(.voldemort.DeletePartitionEntriesRequest\x12K\n\x19initiate_fetch_and_update\x18\x07 \x01(\x0b\x32(.voldemort.InitiateFetchAndUpdateRequest\x12\x46\n\x16\x61sync_operation_status\x18\x08 \x01(\x0b\x32&.voldemort.AsyncOperationStatusRequest\x12H\n\x17initiate_rebalance_node\x18\t \x01(\x0b\x32\'.voldemort.InitiateRebalanceNodeRequest\x12\x42\n\x14\x61sync_operation_stop\x18\n \x01(\x0b\x32$.voldemort.AsyncOperationStopRequest\x12\x42\n\x14\x61sync_operation_list\x18\x0b \x01(\x0b\x32$.voldemort.AsyncOperationListRequest\x12;\n\x10truncate_entries\x18\x0c \x01(\x0b\x32!.voldemort.TruncateEntriesRequest\x12-\n\tadd_store\x18\r \x01(\x0b\x32\x1a.voldemort.AddStoreRequest\x12\x33\n\x0c\x64\x65lete_store\x18\x0e \x01(\x0b\x32\x1d.voldemort.DeleteStoreRequest\x12\x31\n\x0b\x66\x65tch_store\x18\x0f \x01(\x0b\x32\x1c.voldemort.FetchStoreRequest\x12/\n\nswap_store\x18\x10 \x01(\x0b\x32\x1b.voldemort.SwapStoreRequest\x12\x37\n\x0erollback_store\x18\x11 \x01(\x0b\x32\x1f.voldemort.RollbackStoreRequest\x12\x44\n\x16get_ro_max_version_dir\x18\x12 \x01(\x0b\x32$.voldemort.GetROMaxVersionDirRequest\x12L\n\x1aget_ro_current_version_dir\x18\x13 \x01(\x0b\x32(.voldemort.GetROCurrentVersionDirRequest\x12\x44\n\x15\x66\x65tch_partition_files\x18\x14 \x01(\x0b\x32%.voldemort.FetchPartitionFilesRequest\x12@\n\x13update_slop_entries\x18\x16 \x01(\x0b\x32#.voldemort.UpdateSlopEntriesRequest\x12>\n\x12\x66\x61iled_fetch_store\x18\x18 \x01(\x0b\x32\".voldemort.FailedFetchStoreRequest\x12\x43\n\x15get_ro_storage_format\x18\x19 \x01(\x0b\x32$.voldemort.GetROStorageFormatRequest\x12\x46\n\x16rebalance_state_change\x18\x1a \x01(\x0b\x32&.voldemort.RebalanceStateChangeRequest\x12/\n\nrepair_job\x18\x1b \x01(\x0b\x32\x1b.voldemort.RepairJobRequest\x12X\n initiate_rebalance_node_on_donor\x18\x1c \x01(\x0b\x32..voldemort.InitiateRebalanceNodeOnDonorRequest\x12Q\n\x1c\x64\x65lete_store_rebalance_state\x18\x1d \x01(\x0b\x32+.voldemort.DeleteStoreRebalanceStateRequest*\xa1\x05\n\x10\x41\x64minRequestType\x12\x10\n\x0cGET_METADATA\x10\x00\x12\x13\n\x0fUPDATE_METADATA\x10\x01\x12\x1c\n\x18UPDATE_PARTITION_ENTRIES\x10\x02\x12\x1b\n\x17\x46\x45TCH_PARTITION_ENTRIES\x10\x03\x12\x1c\n\x18\x44\x45LETE_PARTITION_ENTRIES\x10\x04\x12\x1d\n\x19INITIATE_FETCH_AND_UPDATE\x10\x05\x12\x1a\n\x16\x41SYNC_OPERATION_STATUS\x10\x06\x12\x1b\n\x17INITIATE_REBALANCE_NODE\x10\x07\x12\x18\n\x14\x41SYNC_OPERATION_STOP\x10\x08\x12\x18\n\x14\x41SYNC_OPERATION_LIST\x10\t\x12\x14\n\x10TRUNCATE_ENTRIES\x10\n\x12\r\n\tADD_STORE\x10\x0b\x12\x10\n\x0c\x44\x45LETE_STORE\x10\x0c\x12\x0f\n\x0b\x46\x45TCH_STORE\x10\r\x12\x0e\n\nSWAP_STORE\x10\x0e\x12\x12\n\x0eROLLBACK_STORE\x10\x0f\x12\x1a\n\x16GET_RO_MAX_VERSION_DIR\x10\x10\x12\x1e\n\x1aGET_RO_CURRENT_VERSION_DIR\x10\x11\x12\x19\n\x15\x46\x45TCH_PARTITION_FILES\x10\x12\x12\x17\n\x13UPDATE_SLOP_ENTRIES\x10\x14\x12\x16\n\x12\x46\x41ILED_FETCH_STORE\x10\x16\x12\x19\n\x15GET_RO_STORAGE_FORMAT\x10\x17\x12\x1a\n\x16REBALANCE_STATE_CHANGE\x10\x18\x12\x0e\n\nREPAIR_JOB\x10\x19\x12$\n INITIATE_REBALANCE_NODE_ON_DONOR\x10\x1a\x12 \n\x1c\x44\x45LETE_STORE_REBALANCE_STATE\x10\x1b\x42-\n\x1cvoldemort.client.protocol.pbB\x0bVAdminProtoH\x01')
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_fd5db_aee11/rev_fd5db-aee11/clients/python/voldemort/protocol
Conflict type: NOPATTERN
Conflict body: 
~~FSTMerge~~ _ADMINREQUESTTYPE = descriptor.EnumDescriptor(  name='AdminRequestType',  full_name='voldemort.AdminRequestType',  filename=None,  file=DESCRIPTOR,  values=[    descriptor.EnumValueDescriptor(      name='GET_METADATA', index=0, number=0,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='UPDATE_METADATA', index=1, number=1,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='UPDATE_PARTITION_ENTRIES', index=2, number=2,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FETCH_PARTITION_ENTRIES', index=3, number=3,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='DELETE_PARTITION_ENTRIES', index=4, number=4,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='INITIATE_FETCH_AND_UPDATE', index=5, number=5,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ASYNC_OPERATION_STATUS', index=6, number=6,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='INITIATE_REBALANCE_NODE', index=7, number=7,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ASYNC_OPERATION_STOP', index=8, number=8,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ASYNC_OPERATION_LIST', index=9, number=9,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='TRUNCATE_ENTRIES', index=10, number=10,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ADD_STORE', index=11, number=11,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='DELETE_STORE', index=12, number=12,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FETCH_STORE', index=13, number=13,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='SWAP_STORE', index=14, number=14,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ROLLBACK_STORE', index=15, number=15,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='GET_RO_MAX_VERSION_DIR', index=16, number=16,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='GET_RO_CURRENT_VERSION_DIR', index=17, number=17,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FETCH_PARTITION_FILES', index=18, number=18,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='UPDATE_SLOP_ENTRIES', index=19, number=20,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FAILED_FETCH_STORE', index=20, number=22,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='GET_RO_STORAGE_FORMAT', index=21, number=23,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='REBALANCE_STATE_CHANGE', index=22, number=24,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='REPAIR_JOB', index=23, number=25,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='NATIVE_BACKUP', index=24, number=26,      options=None,      type=None),  ],  containing_type=None,  options=None,  serialized_start=6322,  serialized_end=6942,) ##FSTMerge## _ADMINREQUESTTYPE = descriptor.EnumDescriptor(  name='AdminRequestType',  full_name='voldemort.AdminRequestType',  filename=None,  file=DESCRIPTOR,  values=[    descriptor.EnumValueDescriptor(      name='GET_METADATA', index=0, number=0,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='UPDATE_METADATA', index=1, number=1,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='UPDATE_PARTITION_ENTRIES', index=2, number=2,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FETCH_PARTITION_ENTRIES', index=3, number=3,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='DELETE_PARTITION_ENTRIES', index=4, number=4,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='INITIATE_FETCH_AND_UPDATE', index=5, number=5,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ASYNC_OPERATION_STATUS', index=6, number=6,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='INITIATE_REBALANCE_NODE', index=7, number=7,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ASYNC_OPERATION_STOP', index=8, number=8,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ASYNC_OPERATION_LIST', index=9, number=9,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='TRUNCATE_ENTRIES', index=10, number=10,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ADD_STORE', index=11, number=11,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='DELETE_STORE', index=12, number=12,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FETCH_STORE', index=13, number=13,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='SWAP_STORE', index=14, number=14,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ROLLBACK_STORE', index=15, number=15,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='GET_RO_MAX_VERSION_DIR', index=16, number=16,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='GET_RO_CURRENT_VERSION_DIR', index=17, number=17,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FETCH_PARTITION_FILES', index=18, number=18,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='UPDATE_SLOP_ENTRIES', index=19, number=20,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FAILED_FETCH_STORE', index=20, number=22,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='GET_RO_STORAGE_FORMAT', index=21, number=23,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='REBALANCE_STATE_CHANGE', index=22, number=24,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='REPAIR_JOB', index=23, number=25,      options=None,      type=None),  ],  containing_type=None,  options=None,  serialized_start=6204,  serialized_end=6805,) ##FSTMerge## _ADMINREQUESTTYPE = descriptor.EnumDescriptor(  name='AdminRequestType',  full_name='voldemort.AdminRequestType',  filename=None,  file=DESCRIPTOR,  values=[    descriptor.EnumValueDescriptor(      name='GET_METADATA', index=0, number=0,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='UPDATE_METADATA', index=1, number=1,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='UPDATE_PARTITION_ENTRIES', index=2, number=2,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FETCH_PARTITION_ENTRIES', index=3, number=3,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='DELETE_PARTITION_ENTRIES', index=4, number=4,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='INITIATE_FETCH_AND_UPDATE', index=5, number=5,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ASYNC_OPERATION_STATUS', index=6, number=6,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='INITIATE_REBALANCE_NODE', index=7, number=7,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ASYNC_OPERATION_STOP', index=8, number=8,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ASYNC_OPERATION_LIST', index=9, number=9,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='TRUNCATE_ENTRIES', index=10, number=10,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ADD_STORE', index=11, number=11,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='DELETE_STORE', index=12, number=12,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FETCH_STORE', index=13, number=13,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='SWAP_STORE', index=14, number=14,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='ROLLBACK_STORE', index=15, number=15,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='GET_RO_MAX_VERSION_DIR', index=16, number=16,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='GET_RO_CURRENT_VERSION_DIR', index=17, number=17,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FETCH_PARTITION_FILES', index=18, number=18,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='UPDATE_SLOP_ENTRIES', index=19, number=20,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='FAILED_FETCH_STORE', index=20, number=22,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='GET_RO_STORAGE_FORMAT', index=21, number=23,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='REBALANCE_STATE_CHANGE', index=22, number=24,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='REPAIR_JOB', index=23, number=25,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='INITIATE_REBALANCE_NODE_ON_DONOR', index=24, number=26,      options=None,      type=None),    descriptor.EnumValueDescriptor(      name='DELETE_STORE_REBALANCE_STATE', index=25, number=27,      options=None,      type=None),  ],  containing_type=None,  options=None,  serialized_start=6631,  serialized_end=7304,)
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_fd5db_aee11/rev_fd5db-aee11/clients/python/voldemort/protocol
Conflict type: NOPATTERN
Conflict body: 
~~FSTMerge~~ _VOLDEMORTADMINREQUEST = descriptor.Descriptor(  name='VoldemortAdminRequest',  full_name='voldemort.VoldemortAdminRequest',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='type', full_name='voldemort.VoldemortAdminRequest.type', index=0,      number=1, type=14, cpp_type=8, label=2,      has_default_value=False, default_value=0,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_metadata', full_name='voldemort.VoldemortAdminRequest.get_metadata', index=1,      number=2, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='update_metadata', full_name='voldemort.VoldemortAdminRequest.update_metadata', index=2,      number=3, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='update_partition_entries', full_name='voldemort.VoldemortAdminRequest.update_partition_entries', index=3,      number=4, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='fetch_partition_entries', full_name='voldemort.VoldemortAdminRequest.fetch_partition_entries', index=4,      number=5, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='delete_partition_entries', full_name='voldemort.VoldemortAdminRequest.delete_partition_entries', index=5,      number=6, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='initiate_fetch_and_update', full_name='voldemort.VoldemortAdminRequest.initiate_fetch_and_update', index=6,      number=7, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='async_operation_status', full_name='voldemort.VoldemortAdminRequest.async_operation_status', index=7,      number=8, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='initiate_rebalance_node', full_name='voldemort.VoldemortAdminRequest.initiate_rebalance_node', index=8,      number=9, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='async_operation_stop', full_name='voldemort.VoldemortAdminRequest.async_operation_stop', index=9,      number=10, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='async_operation_list', full_name='voldemort.VoldemortAdminRequest.async_operation_list', index=10,      number=11, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='truncate_entries', full_name='voldemort.VoldemortAdminRequest.truncate_entries', index=11,      number=12, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='add_store', full_name='voldemort.VoldemortAdminRequest.add_store', index=12,      number=13, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='delete_store', full_name='voldemort.VoldemortAdminRequest.delete_store', index=13,      number=14, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='fetch_store', full_name='voldemort.VoldemortAdminRequest.fetch_store', index=14,      number=15, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='swap_store', full_name='voldemort.VoldemortAdminRequest.swap_store', index=15,      number=16, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='rollback_store', full_name='voldemort.VoldemortAdminRequest.rollback_store', index=16,      number=17, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_ro_max_version_dir', full_name='voldemort.VoldemortAdminRequest.get_ro_max_version_dir', index=17,      number=18, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_ro_current_version_dir', full_name='voldemort.VoldemortAdminRequest.get_ro_current_version_dir', index=18,      number=19, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='fetch_partition_files', full_name='voldemort.VoldemortAdminRequest.fetch_partition_files', index=19,      number=20, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='update_slop_entries', full_name='voldemort.VoldemortAdminRequest.update_slop_entries', index=20,      number=22, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='failed_fetch_store', full_name='voldemort.VoldemortAdminRequest.failed_fetch_store', index=21,      number=24, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_ro_storage_format', full_name='voldemort.VoldemortAdminRequest.get_ro_storage_format', index=22,      number=25, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='rebalance_state_change', full_name='voldemort.VoldemortAdminRequest.rebalance_state_change', index=23,      number=26, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='repair_job', full_name='voldemort.VoldemortAdminRequest.repair_job', index=24,      number=27, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='native_backup', full_name='voldemort.VoldemortAdminRequest.native_backup', index=25,      number=28, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=4645,  serialized_end=6319,) ##FSTMerge## _VOLDEMORTADMINREQUEST = descriptor.Descriptor(  name='VoldemortAdminRequest',  full_name='voldemort.VoldemortAdminRequest',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='type', full_name='voldemort.VoldemortAdminRequest.type', index=0,      number=1, type=14, cpp_type=8, label=2,      has_default_value=False, default_value=0,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_metadata', full_name='voldemort.VoldemortAdminRequest.get_metadata', index=1,      number=2, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='update_metadata', full_name='voldemort.VoldemortAdminRequest.update_metadata', index=2,      number=3, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='update_partition_entries', full_name='voldemort.VoldemortAdminRequest.update_partition_entries', index=3,      number=4, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='fetch_partition_entries', full_name='voldemort.VoldemortAdminRequest.fetch_partition_entries', index=4,      number=5, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='delete_partition_entries', full_name='voldemort.VoldemortAdminRequest.delete_partition_entries', index=5,      number=6, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='initiate_fetch_and_update', full_name='voldemort.VoldemortAdminRequest.initiate_fetch_and_update', index=6,      number=7, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='async_operation_status', full_name='voldemort.VoldemortAdminRequest.async_operation_status', index=7,      number=8, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='initiate_rebalance_node', full_name='voldemort.VoldemortAdminRequest.initiate_rebalance_node', index=8,      number=9, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='async_operation_stop', full_name='voldemort.VoldemortAdminRequest.async_operation_stop', index=9,      number=10, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='async_operation_list', full_name='voldemort.VoldemortAdminRequest.async_operation_list', index=10,      number=11, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='truncate_entries', full_name='voldemort.VoldemortAdminRequest.truncate_entries', index=11,      number=12, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='add_store', full_name='voldemort.VoldemortAdminRequest.add_store', index=12,      number=13, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='delete_store', full_name='voldemort.VoldemortAdminRequest.delete_store', index=13,      number=14, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='fetch_store', full_name='voldemort.VoldemortAdminRequest.fetch_store', index=14,      number=15, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='swap_store', full_name='voldemort.VoldemortAdminRequest.swap_store', index=15,      number=16, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='rollback_store', full_name='voldemort.VoldemortAdminRequest.rollback_store', index=16,      number=17, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_ro_max_version_dir', full_name='voldemort.VoldemortAdminRequest.get_ro_max_version_dir', index=17,      number=18, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_ro_current_version_dir', full_name='voldemort.VoldemortAdminRequest.get_ro_current_version_dir', index=18,      number=19, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='fetch_partition_files', full_name='voldemort.VoldemortAdminRequest.fetch_partition_files', index=19,      number=20, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='update_slop_entries', full_name='voldemort.VoldemortAdminRequest.update_slop_entries', index=20,      number=22, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='failed_fetch_store', full_name='voldemort.VoldemortAdminRequest.failed_fetch_store', index=21,      number=24, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_ro_storage_format', full_name='voldemort.VoldemortAdminRequest.get_ro_storage_format', index=22,      number=25, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='rebalance_state_change', full_name='voldemort.VoldemortAdminRequest.rebalance_state_change', index=23,      number=26, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='repair_job', full_name='voldemort.VoldemortAdminRequest.repair_job', index=24,      number=27, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=4582,  serialized_end=6201,) ##FSTMerge## _VOLDEMORTADMINREQUEST = descriptor.Descriptor(  name='VoldemortAdminRequest',  full_name='voldemort.VoldemortAdminRequest',  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    descriptor.FieldDescriptor(      name='type', full_name='voldemort.VoldemortAdminRequest.type', index=0,      number=1, type=14, cpp_type=8, label=2,      has_default_value=False, default_value=0,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_metadata', full_name='voldemort.VoldemortAdminRequest.get_metadata', index=1,      number=2, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='update_metadata', full_name='voldemort.VoldemortAdminRequest.update_metadata', index=2,      number=3, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='update_partition_entries', full_name='voldemort.VoldemortAdminRequest.update_partition_entries', index=3,      number=4, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='fetch_partition_entries', full_name='voldemort.VoldemortAdminRequest.fetch_partition_entries', index=4,      number=5, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='delete_partition_entries', full_name='voldemort.VoldemortAdminRequest.delete_partition_entries', index=5,      number=6, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='initiate_fetch_and_update', full_name='voldemort.VoldemortAdminRequest.initiate_fetch_and_update', index=6,      number=7, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='async_operation_status', full_name='voldemort.VoldemortAdminRequest.async_operation_status', index=7,      number=8, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='initiate_rebalance_node', full_name='voldemort.VoldemortAdminRequest.initiate_rebalance_node', index=8,      number=9, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='async_operation_stop', full_name='voldemort.VoldemortAdminRequest.async_operation_stop', index=9,      number=10, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='async_operation_list', full_name='voldemort.VoldemortAdminRequest.async_operation_list', index=10,      number=11, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='truncate_entries', full_name='voldemort.VoldemortAdminRequest.truncate_entries', index=11,      number=12, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='add_store', full_name='voldemort.VoldemortAdminRequest.add_store', index=12,      number=13, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='delete_store', full_name='voldemort.VoldemortAdminRequest.delete_store', index=13,      number=14, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='fetch_store', full_name='voldemort.VoldemortAdminRequest.fetch_store', index=14,      number=15, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='swap_store', full_name='voldemort.VoldemortAdminRequest.swap_store', index=15,      number=16, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='rollback_store', full_name='voldemort.VoldemortAdminRequest.rollback_store', index=16,      number=17, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_ro_max_version_dir', full_name='voldemort.VoldemortAdminRequest.get_ro_max_version_dir', index=17,      number=18, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_ro_current_version_dir', full_name='voldemort.VoldemortAdminRequest.get_ro_current_version_dir', index=18,      number=19, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='fetch_partition_files', full_name='voldemort.VoldemortAdminRequest.fetch_partition_files', index=19,      number=20, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='update_slop_entries', full_name='voldemort.VoldemortAdminRequest.update_slop_entries', index=20,      number=22, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='failed_fetch_store', full_name='voldemort.VoldemortAdminRequest.failed_fetch_store', index=21,      number=24, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='get_ro_storage_format', full_name='voldemort.VoldemortAdminRequest.get_ro_storage_format', index=22,      number=25, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='rebalance_state_change', full_name='voldemort.VoldemortAdminRequest.rebalance_state_change', index=23,      number=26, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='repair_job', full_name='voldemort.VoldemortAdminRequest.repair_job', index=24,      number=27, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='initiate_rebalance_node_on_donor', full_name='voldemort.VoldemortAdminRequest.initiate_rebalance_node_on_donor', index=25,      number=28, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),    descriptor.FieldDescriptor(      name='delete_store_rebalance_state', full_name='voldemort.VoldemortAdminRequest.delete_store_rebalance_state', index=26,      number=29, type=11, cpp_type=10, label=1,      has_default_value=False, default_value=None,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      options=None),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  options=None,  is_extendable=False,  extension_ranges=[],  serialized_start=4836,  serialized_end=6628,)
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_fd5db_aee11/rev_fd5db-aee11/clients/python/voldemort/protocol

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_aee11_a0ea6/rev_aee11-a0ea6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_608ad_38b33/rev_608ad-38b33.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2856d_e64bc/rev_2856d-e64bc.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e5e5a_70011/rev_e5e5a-70011.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_9f698_af201/rev_9f698-af201.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_55a5b_fe1b4/rev_55a5b-fe1b4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_9f698_d0bb2/rev_9f698-d0bb2.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public void execute(Pipeline pipeline) {
        List<Node> nodes = pipelineData.getNodes();

        // Now if we had any failures we will be short a few reads. Do serial
        // reads to make up for these.
        while(pipelineData.getSuccesses() < preferred && pipelineData.getNodeIndex() < nodes.size()) {
            Node node = nodes.get(pipelineData.getNodeIndex());
            long start = System.nanoTime();

            try {
                Store<ByteArray, byte[], byte[]> store = stores.get(node.getId());
                V result = storeRequest.request(store);

                Response<ByteArray, V> response = new Response<ByteArray, V>(node,
                                                                             key,
                                                                             result,
                                                                             ((System.nanoTime() - start) / Time.NS_PER_MS));

                pipelineData.incrementSuccesses();
                pipelineData.getResponses().add(response);
                failureDetector.recordSuccess(response.getNode(), response.getRequestTime());
                pipelineData.getZoneResponses().add(node.getZoneId());
            } catch(Exception e) {
                long requestTime = (System.nanoTime() - start) / Time.NS_PER_MS;

                if(handleResponseError(e, node, requestTime, pipeline, failureDetector))
                    return;
            }

            pipelineData.incrementNodeIndex();
        }

        if(pipelineData.getSuccesses() < required) {
            if(insufficientSuccessesEvent != null) {
                pipeline.addEvent(insufficientSuccessesEvent);
            } else {
                pipelineData.setFatalError(new InsufficientOperationalNodesException(required
                                                                                             + " "
                                                                                             + pipeline.getOperation()
                                                                                                       .getSimpleName()
                                                                                             + "s required, but only "
                                                                                             + pipelineData.getSuccesses()
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415756052629/fstmerge_var1_7064144657741044618
                                                                                             + " succeeded",
                                                                                     new ArrayList<Node>(pipelineData.getReplicationSet()),
                                                                                     new ArrayList<Node>(pipelineData.getNodes()),
                                                                                     new ArrayList<Node>(pipelineData.getFailedNodes()),
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415756052629/fstmerge_base_1888103018341427009
                                                                                             + " succeeded",
=======
                                                                                             + " succeeded. Failing nodes : "
                                                                                             + pipelineData.getFailedNodes(),
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415756052629/fstmerge_var2_7242978694980525335
                                                                                     pipelineData.getFailures()));

                pipeline.abort();
            }
        } else {
            if(pipelineData.getZonesRequired() != null) {

                int zonesSatisfied = pipelineData.getZoneResponses().size();
                if(zonesSatisfied >= (pipelineData.getZonesRequired() + 1)) {
                    pipeline.addEvent(completeEvent);
                } else {
                    pipelineData.setFatalError(new InsufficientZoneResponsesException((pipelineData.getZonesRequired() + 1)
                                                                                      + " "
                                                                                      + pipeline.getOperation()
                                                                                                .getSimpleName()
                                                                                      + "s required zone, but only "
                                                                                      + zonesSatisfied
                                                                                      + " succeeded"));

                    pipeline.abort();
                }

            } else {
                pipeline.addEvent(completeEvent);
            }
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_9f698_d0bb2/rev_9f698-d0bb2/src/java/voldemort/store/routed/action/PerformSerialRequests.java
Conflict type: LineBasedMCFd
Conflict body: 
public void execute(final Pipeline pipeline) {
        List<Node> nodes = pipelineData.getNodes();
        int attempts = Math.min(preferred, nodes.size());
        final Map<Integer, Response<ByteArray, Object>> responses = new ConcurrentHashMap<Integer, Response<ByteArray, Object>>();
        final CountDownLatch latch = new CountDownLatch(attempts);

        if(logger.isTraceEnabled())
            logger.trace("Attempting " + attempts + " " + pipeline.getOperation().getSimpleName()
                         + " operations in parallel");

        for(int i = 0; i < attempts; i++) {
            final Node node = nodes.get(i);
            pipelineData.incrementNodeIndex();

            NonblockingStoreCallback callback = new NonblockingStoreCallback() {

                public void requestComplete(Object result, long requestTime) {
                    if(logger.isTraceEnabled())
                        logger.trace(pipeline.getOperation().getSimpleName()
                                     + " response received (" + requestTime + " ms.) from node "
                                     + node.getId());

                    Response<ByteArray, Object> response = new Response<ByteArray, Object>(node,
                                                                                           key,
                                                                                           result,
                                                                                           requestTime);
                    responses.put(node.getId(), response);
                    latch.countDown();

                    // Note errors that come in after the pipeline has finished.
                    // These will *not* get a chance to be called in the loop of
                    // responses below.
                    if(pipeline.isFinished() && response.getValue() instanceof Exception) {
                        if(response.getValue() instanceof InvalidMetadataException) {
                            logger.warn("Received invalid metadata problem after a successful "
                                        + pipeline.getOperation().getSimpleName()
                                        + " call on node " + node.getId() + ", store '"
                                        + pipelineData.getStoreName() + "'");
                        } else {
                            handleResponseError(response, pipeline, failureDetector);
                        }
                    }
                }

            };

            if(logger.isTraceEnabled())
                logger.trace("Submitting " + pipeline.getOperation().getSimpleName()
                             + " request on node " + node.getId());

            NonblockingStore store = nonblockingStores.get(node.getId());

            if(pipeline.getOperation() == Operation.GET)
                store.submitGetRequest(key, transforms, callback, timeoutMs);
            else if(pipeline.getOperation() == Operation.GET_VERSIONS)
                store.submitGetVersionsRequest(key, callback, timeoutMs);
            else
                throw new IllegalStateException(getClass().getName()
                                                + " does not support pipeline operation "
                                                + pipeline.getOperation());
        }

        try {
            latch.await(timeoutMs, TimeUnit.MILLISECONDS);
        } catch(InterruptedException e) {
            if(logger.isEnabledFor(Level.WARN))
                logger.warn(e, e);
        }

        for(Response<ByteArray, Object> response: responses.values()) {
            if(response.getValue() instanceof Exception) {
                if(handleResponseError(response, pipeline, failureDetector))
                    return;
            } else {
                pipelineData.incrementSuccesses();
                Response<ByteArray, V> rCast = Utils.uncheckedCast(response);
                pipelineData.getResponses().add(rCast);
                failureDetector.recordSuccess(response.getNode(), response.getRequestTime());
                pipelineData.getZoneResponses().add(response.getNode().getZoneId());
            }
        }

        if(pipelineData.getSuccesses() < required) {
            if(insufficientSuccessesEvent != null) {
                pipeline.addEvent(insufficientSuccessesEvent);
            } else {
                pipelineData.setFatalError(new InsufficientOperationalNodesException(required
                                                                                             + " "
                                                                                             + pipeline.getOperation()
                                                                                                       .getSimpleName()
                                                                                             + "s required, but only "
                                                                                             + pipelineData.getSuccesses()
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415756052693/fstmerge_var1_6810385146414553237
                                                                                             + " succeeded",
                                                                                     new ArrayList<Node>(pipelineData.getReplicationSet()),
                                                                                     new ArrayList<Node>(pipelineData.getNodes()),
                                                                                     new ArrayList<Node>(pipelineData.getFailedNodes()),
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415756052693/fstmerge_base_5680834332889389549
                                                                                             + " succeeded",
=======
                                                                                             + " succeeded. Failing nodes : "
                                                                                             + pipelineData.getFailedNodes(),
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415756052693/fstmerge_var2_3808553438447232527
                                                                                     pipelineData.getFailures()));

                pipeline.abort();
            }

        } else {

            if(pipelineData.getZonesRequired() != null) {

                int zonesSatisfied = pipelineData.getZoneResponses().size();
                if(zonesSatisfied >= (pipelineData.getZonesRequired() + 1)) {
                    pipeline.addEvent(completeEvent);
                } else {
                    if(logger.isDebugEnabled()) {
                        logger.debug("Operation " + pipeline.getOperation().getSimpleName()
                                     + "failed due to insufficent zone responses, required "
                                     + pipelineData.getZonesRequired() + " obtained "
                                     + zonesSatisfied + " " + pipelineData.getZoneResponses());
                    }
                    if(this.insufficientZonesEvent != null) {
                        pipeline.addEvent(this.insufficientZonesEvent);
                    } else {
                        pipelineData.setFatalError(new InsufficientZoneResponsesException((pipelineData.getZonesRequired() + 1)
                                                                                          + " "
                                                                                          + pipeline.getOperation()
                                                                                                    .getSimpleName()
                                                                                          + "s required zone, but only "
                                                                                          + zonesSatisfied
                                                                                          + " succeeded"));
                    }

                }

            } else {
                pipeline.addEvent(completeEvent);
            }
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_9f698_d0bb2/rev_9f698-d0bb2/src/java/voldemort/store/routed/action/PerformParallelRequests.java
Conflict type: LineBasedMCFd
Conflict body: 
public void execute(Pipeline pipeline) {
        int currentNode = 0;
        List<Node> nodes = pipelineData.getNodes();

        if(logger.isDebugEnabled())
            logger.debug("Performing serial put requests to determine master");

        for(; currentNode < nodes.size(); currentNode++) {
            Node node = nodes.get(currentNode);
            pipelineData.incrementNodeIndex();

            VectorClock versionedClock = (VectorClock) versioned.getVersion();
            final Versioned<byte[]> versionedCopy = new Versioned<byte[]>(versioned.getValue(),
                                                                          versionedClock.incremented(node.getId(),
                                                                                                     time.getMilliseconds()));

            if(logger.isTraceEnabled())
                logger.trace("Attempt #" + (currentNode + 1) + " to perform put (node "
                             + node.getId() + ")");

            long start = System.nanoTime();

            try {
                stores.get(node.getId()).put(key, versionedCopy, transforms);
                long requestTime = (System.nanoTime() - start) / Time.NS_PER_MS;
                pipelineData.incrementSuccesses();
                failureDetector.recordSuccess(node, requestTime);

                if(logger.isTraceEnabled())
                    logger.trace("Put on node " + node.getId() + " succeeded, using as master");

                pipelineData.setMaster(node);
                pipelineData.setVersionedCopy(versionedCopy);
                pipelineData.getZoneResponses().add(node.getZoneId());
                break;
            } catch(Exception e) {
                long requestTime = (System.nanoTime() - start) / Time.NS_PER_MS;

                if(handleResponseError(e, node, requestTime, pipeline, failureDetector))
                    return;
            }
        }

        if(pipelineData.getSuccesses() < 1) {
            List<Exception> failures = pipelineData.getFailures();
            pipelineData.setFatalError(new InsufficientOperationalNodesException("No master node succeeded!",
                                                                                 failures.size() > 0 ? failures.get(0)
                                                                                                    : null));
            pipeline.abort();
            return;
        }

        currentNode++;

        // There aren't any more requests to make...
        if(currentNode == nodes.size()) {
            if(pipelineData.getSuccesses() < required) {
                pipelineData.setFatalError(new InsufficientOperationalNodesException(required
                                                                                             + " "
                                                                                             + pipeline.getOperation()
                                                                                                       .getSimpleName()
                                                                                             + "s required, but only "
                                                                                             + pipelineData.getSuccesses()
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415756052722/fstmerge_var1_5941564091795310565
                                                                                             + " succeeded",
                                                                                     new ArrayList<Node>(pipelineData.getReplicationSet()),
                                                                                     new ArrayList<Node>(pipelineData.getNodes()),
                                                                                     new ArrayList<Node>(pipelineData.getFailedNodes()),
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415756052722/fstmerge_base_8251379929259533470
                                                                                             + " succeeded",
=======
                                                                                             + " succeeded. Failing nodes : "
                                                                                             + pipelineData.getFailedNodes(),
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415756052722/fstmerge_var2_9112077097104393094
                                                                                     pipelineData.getFailures()));
                pipeline.abort();
            } else {
                if(pipelineData.getZonesRequired() != null) {

                    int zonesSatisfied = pipelineData.getZoneResponses().size();
                    if(zonesSatisfied >= (pipelineData.getZonesRequired() + 1)) {
                        pipeline.addEvent(completeEvent);
                    } else {
                        pipelineData.setFatalError(new InsufficientZoneResponsesException((pipelineData.getZonesRequired() + 1)
                                                                                          + " "
                                                                                          + pipeline.getOperation()
                                                                                                    .getSimpleName()
                                                                                          + "s required zone, but only "
                                                                                          + zonesSatisfied
                                                                                          + " succeeded"));
                        pipeline.abort();
                    }

                } else {
                    pipeline.addEvent(completeEvent);
                }
            }
        } else {
            pipeline.addEvent(masterDeterminedEvent);
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_9f698_d0bb2/rev_9f698-d0bb2/src/java/voldemort/store/routed/action/PerformSerialPutRequests.java
Conflict type: LineBasedMCFd
Conflict body: 
public void execute(final Pipeline pipeline) {
        Node master = pipelineData.getMaster();
        final Versioned<byte[]> versionedCopy = pipelineData.getVersionedCopy();

        if(logger.isDebugEnabled())
            logger.debug("Serial put requests determined master node as " + master.getId()
                         + ", submitting remaining requests in parallel");

        List<Node> nodes = pipelineData.getNodes();
        int firstParallelNodeIndex = nodes.indexOf(master) + 1;
        int attempts = nodes.size() - firstParallelNodeIndex;
        int blocks = Math.min(preferred - 1, attempts);

        final Map<Integer, Response<ByteArray, Object>> responses = new ConcurrentHashMap<Integer, Response<ByteArray, Object>>();
        final CountDownLatch attemptsLatch = new CountDownLatch(attempts);
        final CountDownLatch blocksLatch = new CountDownLatch(blocks);

        if(logger.isTraceEnabled())
            logger.trace("Attempting " + attempts + " " + pipeline.getOperation().getSimpleName()
                         + " operations in parallel");

        for(int i = firstParallelNodeIndex; i < (firstParallelNodeIndex + attempts); i++) {
            final Node node = nodes.get(i);
            pipelineData.incrementNodeIndex();

            NonblockingStoreCallback callback = new NonblockingStoreCallback() {

                public void requestComplete(Object result, long requestTime) {
                    if(logger.isTraceEnabled())
                        logger.trace(pipeline.getOperation().getSimpleName()
                                     + " response received (" + requestTime + " ms.) from node "
                                     + node.getId());

                    Response<ByteArray, Object> response = new Response<ByteArray, Object>(node,
                                                                                           key,
                                                                                           result,
                                                                                           requestTime);
                    responses.put(node.getId(), response);

                    if(isHintedHandoffEnabled() && pipeline.isFinished()) {
                        if(response.getValue() instanceof UnreachableStoreException) {
                            Slop slop = new Slop(pipelineData.getStoreName(),
                                                 Slop.Operation.PUT,
                                                 key,
                                                 versionedCopy.getValue(),
                                                 transforms,
                                                 node.getId(),
                                                 new Date());
                            pipelineData.addFailedNode(node);
                            hintedHandoff.sendHintSerial(node, versionedCopy.getVersion(), slop);
                        }
                    }

                    attemptsLatch.countDown();
                    blocksLatch.countDown();

                    if(logger.isTraceEnabled())
                        logger.trace(attemptsLatch.getCount() + " attempts remaining. Will block "
                                     + " for " + blocksLatch.getCount() + " more ");

                    // Note errors that come in after the pipeline has finished.
                    // These will *not* get a chance to be called in the loop of
                    // responses below.
                    if(pipeline.isFinished() && response.getValue() instanceof Exception
                       && !(response.getValue() instanceof ObsoleteVersionException)) {
                        if(response.getValue() instanceof InvalidMetadataException) {
                            logger.warn("Received invalid metadata problem after a successful "
                                        + pipeline.getOperation().getSimpleName()
                                        + " call on node " + node.getId() + ", store '"
                                        + pipelineData.getStoreName() + "'");
                        } else {
                            handleResponseError(response, pipeline, failureDetector);
                        }
                    }
                }

            };

            if(logger.isTraceEnabled())
                logger.trace("Submitting " + pipeline.getOperation().getSimpleName()
                             + " request on node " + node.getId());

            NonblockingStore store = nonblockingStores.get(node.getId());
            store.submitPutRequest(key, versionedCopy, transforms, callback, timeoutMs);
        }

        try {
            long ellapsedNs = System.nanoTime() - pipelineData.getStartTimeNs();
            long remainingNs = (timeoutMs * Time.NS_PER_MS) - ellapsedNs;
            if(remainingNs > 0)
                blocksLatch.await(remainingNs, TimeUnit.NANOSECONDS);
        } catch(InterruptedException e) {
            if(logger.isEnabledFor(Level.WARN))
                logger.warn(e, e);
        }

        for(Entry<Integer, Response<ByteArray, Object>> responseEntry: responses.entrySet()) {
            Response<ByteArray, Object> response = responseEntry.getValue();
            if(response.getValue() instanceof Exception) {
                if(response.getValue() instanceof ObsoleteVersionException) {
                    // ignore this completely here
                    // this means that a higher version was able
                    // to write on this node and should be termed as
                    // clean success.
                    responses.remove(responseEntry.getKey());
                } else if(handleResponseError(response, pipeline, failureDetector))
                    return;
            } else {
                pipelineData.incrementSuccesses();
                failureDetector.recordSuccess(response.getNode(), response.getRequestTime());
                pipelineData.getZoneResponses().add(response.getNode().getZoneId());
                responses.remove(responseEntry.getKey());
            }
        }

        boolean quorumSatisfied = true;
        if(pipelineData.getSuccesses() < required) {
            long ellapsedNs = System.nanoTime() - pipelineData.getStartTimeNs();
            long remainingNs = (timeoutMs * Time.NS_PER_MS) - ellapsedNs;
            if(remainingNs > 0) {
                try {
                    attemptsLatch.await(remainingNs, TimeUnit.NANOSECONDS);
                } catch(InterruptedException e) {
                    if(logger.isEnabledFor(Level.WARN))
                        logger.warn(e, e);
                }

                for(Entry<Integer, Response<ByteArray, Object>> responseEntry: responses.entrySet()) {
                    Response<ByteArray, Object> response = responseEntry.getValue();
                    if(response.getValue() instanceof Exception) {
                        if(response.getValue() instanceof ObsoleteVersionException) {
                            // ignore this completely here
                            // this means that a higher version was able
                            // to write on this node and should be termed as
                            // clean success.
                            responses.remove(responseEntry.getKey());
                        } else if(handleResponseError(response, pipeline, failureDetector))
                            return;
                    } else {
                        pipelineData.incrementSuccesses();
                        failureDetector.recordSuccess(response.getNode(), response.getRequestTime());
                        pipelineData.getZoneResponses().add(response.getNode().getZoneId());
                        responses.remove(responseEntry.getKey());
                    }
                }
            }

            if(pipelineData.getSuccesses() < required) {
                pipelineData.setFatalError(new InsufficientOperationalNodesException(required
                                                                                             + " "
                                                                                             + pipeline.getOperation()
                                                                                                       .getSimpleName()
                                                                                             + "s required, but only "
                                                                                             + pipelineData.getSuccesses()
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415756052806/fstmerge_var1_3582420908995246325
                                                                                             + " succeeded",
                                                                                     new ArrayList<Node>(pipelineData.getReplicationSet()),
                                                                                     new ArrayList<Node>(pipelineData.getNodes()),
                                                                                     new ArrayList<Node>(pipelineData.getFailedNodes()),
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415756052806/fstmerge_base_7808654529946661392
                                                                                             + " succeeded",
=======
                                                                                             + " succeeded. Failing nodes : "
                                                                                             + pipelineData.getFailedNodes(),
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415756052806/fstmerge_var2_6013756704034328671
                                                                                     pipelineData.getFailures()));
                pipeline.abort();
                quorumSatisfied = false;
            }
        }

        if(quorumSatisfied) {
            if(pipelineData.getZonesRequired() != null) {

                int zonesSatisfied = pipelineData.getZoneResponses().size();
                if(zonesSatisfied >= (pipelineData.getZonesRequired() + 1)) {
                    pipeline.addEvent(completeEvent);
                } else {
                    long timeMs = (System.nanoTime() - pipelineData.getStartTimeNs())
                                  / Time.NS_PER_MS;

                    if((timeoutMs - timeMs) > 0) {
                        try {
                            attemptsLatch.await(timeoutMs - timeMs, TimeUnit.MILLISECONDS);
                        } catch(InterruptedException e) {
                            if(logger.isEnabledFor(Level.WARN))
                                logger.warn(e, e);
                        }

                        for(Entry<Integer, Response<ByteArray, Object>> responseEntry: responses.entrySet()) {
                            Response<ByteArray, Object> response = responseEntry.getValue();
                            if(response.getValue() instanceof Exception) {
                                if(handleResponseError(response, pipeline, failureDetector))
                                    return;
                            } else {
                                pipelineData.incrementSuccesses();
                                failureDetector.recordSuccess(response.getNode(),
                                                              response.getRequestTime());
                                pipelineData.getZoneResponses().add(response.getNode().getZoneId());
                                responses.remove(responseEntry.getKey());
                            }
                        }
                    }

                    if(pipelineData.getZoneResponses().size() >= (pipelineData.getZonesRequired() + 1)) {
                        pipeline.addEvent(completeEvent);
                    } else {
                        pipelineData.setFatalError(new InsufficientZoneResponsesException((pipelineData.getZonesRequired() + 1)
                                                                                          + " "
                                                                                          + pipeline.getOperation()
                                                                                                    .getSimpleName()
                                                                                          + "s required zone, but only "
                                                                                          + zonesSatisfied
                                                                                          + " succeeded. Failing nodes : "
                                                                                          + pipelineData.getFailedNodes()));
                        pipeline.abort();
                    }
                }

            } else {
                pipeline.addEvent(completeEvent);
            }
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_9f698_d0bb2/rev_9f698-d0bb2/src/java/voldemort/store/routed/action/PerformParallelPutRequests.java
Conflict type: LineBasedMCFd
Conflict body: 
public void execute(final Pipeline pipeline) {
        List<Node> nodes = pipelineData.getNodes();
        final Map<Integer, Response<ByteArray, Object>> responses = new ConcurrentHashMap<Integer, Response<ByteArray, Object>>();
        int attempts = nodes.size();
        int blocks = Math.min(preferred, attempts);
        final CountDownLatch attemptsLatch = new CountDownLatch(attempts);
        final CountDownLatch blocksLatch = new CountDownLatch(blocks);

        if(logger.isTraceEnabled())
            logger.trace("Attempting " + attempts + " " + pipeline.getOperation().getSimpleName()
                         + " operations in parallel");

        long beginTime = System.nanoTime();

        for(int i = 0; i < attempts; i++) {
            final Node node = nodes.get(i);
            pipelineData.incrementNodeIndex();

            NonblockingStoreCallback callback = new NonblockingStoreCallback() {

                public void requestComplete(Object result, long requestTime) {
                    if(logger.isTraceEnabled())
                        logger.info(pipeline.getOperation().getSimpleName()
                                    + " response received (" + requestTime + " ms.) from node "
                                    + node.getId());

                    Response<ByteArray, Object> response = new Response<ByteArray, Object>(node,
                                                                                           key,
                                                                                           result,
                                                                                           requestTime);
                    responses.put(node.getId(), response);
                    if(enableHintedHandoff && pipeline.isFinished()
                       && response.getValue() instanceof UnreachableStoreException) {
                        Slop slop = new Slop(pipelineData.getStoreName(),
                                             Slop.Operation.DELETE,
                                             key,
                                             null,
                                             null,
                                             node.getId(),
                                             new Date());
                        pipelineData.addFailedNode(node);
                        hintedHandoff.sendHintSerial(node, version, slop);
                    }

                    attemptsLatch.countDown();
                    blocksLatch.countDown();

                    if(logger.isTraceEnabled())
                        logger.trace(attemptsLatch.getCount() + " attempts remaining. Will block "
                                     + " for " + blocksLatch.getCount() + " more ");

                    // Note errors that come in after the pipeline has finished.
                    // These will *not* get a chance to be called in the loop of
                    // responses below.
                    if(pipeline.isFinished() && response.getValue() instanceof Exception
                       && !(response.getValue() instanceof ObsoleteVersionException)) {
                        if(response.getValue() instanceof InvalidMetadataException) {
                            logger.warn("Received invalid metadata problem after a successful "
                                        + pipeline.getOperation().getSimpleName()
                                        + " call on node " + node.getId() + ", store '"
                                        + pipelineData.getStoreName() + "'");
                        } else {
                            handleResponseError(response, pipeline, failureDetector);
                        }
                    }
                }
            };

            if(logger.isTraceEnabled())
                logger.info("Submitting " + pipeline.getOperation().getSimpleName()
                            + " request on node " + node.getId());

            NonblockingStore store = nonblockingStores.get(node.getId());
            store.submitDeleteRequest(key, version, callback, timeoutMs);
        }

        try {
            long ellapsedNs = System.nanoTime() - beginTime;
            long remainingNs = (timeoutMs * Time.NS_PER_MS) - ellapsedNs;
            if(remainingNs > 0) {
                blocksLatch.await(remainingNs, TimeUnit.NANOSECONDS);
            }
        } catch(InterruptedException e) {
            if(logger.isEnabledFor(Level.WARN))
                logger.warn(e, e);
        }

        for(Entry<Integer, Response<ByteArray, Object>> responseEntry: responses.entrySet()) {
            Response<ByteArray, Object> response = responseEntry.getValue();
            if(response.getValue() instanceof Exception) {
                if(response.getValue() instanceof ObsoleteVersionException) {
                    // ignore this completely here
                    // this means that a higher version was able
                    // to write on this node and should be termed as
                    // clean success.
                    responses.remove(responseEntry.getKey());
                } else if(handleResponseError(response, pipeline, failureDetector)) {
                    return;
                }
            } else {
                pipelineData.incrementSuccesses();
                failureDetector.recordSuccess(response.getNode(), response.getRequestTime());
                pipelineData.getZoneResponses().add(response.getNode().getZoneId());
                Response<ByteArray, V> rCast = Utils.uncheckedCast(response);
                pipelineData.getResponses().add(rCast);
                responses.remove(responseEntry.getKey());
            }
        }

        // wait for more responses in case we did not have enough successful
        // response to achieve the required count
        boolean quorumSatisfied = true;
        if(pipelineData.getSuccesses() < required) {
            long ellapsedNs = System.nanoTime() - beginTime;
            long remainingNs = (timeoutMs * Time.NS_PER_MS) - ellapsedNs;
            if(remainingNs > 0) {
                try {
                    attemptsLatch.await(remainingNs, TimeUnit.NANOSECONDS);
                } catch(InterruptedException e) {
                    if(logger.isEnabledFor(Level.WARN))
                        logger.warn(e, e);
                }

                for(Entry<Integer, Response<ByteArray, Object>> responseEntry: responses.entrySet()) {
                    Response<ByteArray, Object> response = responseEntry.getValue();
                    if(response.getValue() instanceof Exception) {
                        if(response.getValue() instanceof ObsoleteVersionException) {
                            // ignore this completely here
                            // this means that a higher version was able
                            // to write on this node and should be termed as
                            // clean success.
                            responses.remove(responseEntry.getKey());
                        } else if(handleResponseError(response, pipeline, failureDetector))
                            return;
                    } else {
                        pipelineData.incrementSuccesses();
                        failureDetector.recordSuccess(response.getNode(), response.getRequestTime());
                        pipelineData.getZoneResponses().add(response.getNode().getZoneId());
                        Response<ByteArray, V> rCast = Utils.uncheckedCast(response);
                        pipelineData.getResponses().add(rCast);
                        responses.remove(responseEntry.getKey());
                    }
                }
            }

            if(pipelineData.getSuccesses() < required) {
                pipelineData.setFatalError(new InsufficientOperationalNodesException(required
                                                                                             + " "
                                                                                             + pipeline.getOperation()
                                                                                                       .getSimpleName()
                                                                                             + "s required, but only "
                                                                                             + pipelineData.getSuccesses()
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415756052828/fstmerge_var1_2933089441077882711
                                                                                             + " succeeded",
                                                                                     new ArrayList<Node>(pipelineData.getReplicationSet()),
                                                                                     new ArrayList<Node>(pipelineData.getNodes()),
                                                                                     new ArrayList<Node>(pipelineData.getFailedNodes()),
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415756052828/fstmerge_base_134299685569440358
                                                                                             + " succeeded",
=======
                                                                                             + " succeeded. Failing nodes : "
                                                                                             + pipelineData.getFailedNodes(),
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415756052828/fstmerge_var2_5649966273633096104
                                                                                     pipelineData.getFailures()));
                pipeline.abort();
                quorumSatisfied = false;
            }
        }

        if(quorumSatisfied) {
            if(pipelineData.getZonesRequired() != null) {
                int zonesSatisfied = pipelineData.getZoneResponses().size();
                if(zonesSatisfied >= (pipelineData.getZonesRequired() + 1)) {
                    pipeline.addEvent(completeEvent);
                } else {
                    long timeMs = (System.nanoTime() - beginTime) / Time.NS_PER_MS;

                    if((timeoutMs - timeMs) > 0) {
                        try {
                            attemptsLatch.await(timeoutMs - timeMs, TimeUnit.MILLISECONDS);
                        } catch(InterruptedException e) {
                            if(logger.isEnabledFor(Level.WARN))
                                logger.warn(e, e);
                        }

                        for(Entry<Integer, Response<ByteArray, Object>> responseEntry: responses.entrySet()) {
                            Response<ByteArray, Object> response = responseEntry.getValue();
                            if(response.getValue() instanceof Exception) {
                                if(handleResponseError(response, pipeline, failureDetector))
                                    return;
                            } else {
                                pipelineData.incrementSuccesses();
                                failureDetector.recordSuccess(response.getNode(),
                                                              response.getRequestTime());
                                pipelineData.getZoneResponses().add(response.getNode().getZoneId());
                                Response<ByteArray, V> rCast = Utils.uncheckedCast(response);
                                pipelineData.getResponses().add(rCast);
                                responses.remove(responseEntry.getKey());
                            }
                        }
                    }

                    if(pipelineData.getZoneResponses().size() >= (pipelineData.getZonesRequired() + 1)) {
                        pipeline.addEvent(completeEvent);
                    } else {
                        pipelineData.setFatalError(new InsufficientZoneResponsesException((pipelineData.getZonesRequired() + 1)
                                                                                          + " "
                                                                                          + pipeline.getOperation()
                                                                                                    .getSimpleName()
                                                                                          + "s required zone, but only "
                                                                                          + zonesSatisfied
                                                                                          + " succeeded"));
                        pipeline.abort();
                    }
                }

            } else {
                pipeline.addEvent(completeEvent);
            }
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_9f698_d0bb2/rev_9f698-d0bb2/src/java/voldemort/store/routed/action/PerformParallelDeleteRequests.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_ed45d_de2f9/rev_ed45d-de2f9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_40ef1_31178/rev_40ef1-31178.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_ea2c4_ddded/rev_ea2c4-ddded.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_ea2c4_7c65a/rev_ea2c4-7c65a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d2fae_a8718/rev_d2fae-a8718.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3d8ec_3481e/rev_3d8ec-3481e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_4957e_b4707/rev_4957e-b4707.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_34c9c_1f057/rev_34c9c-1f057.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f2698_9b93e/rev_f2698-9b93e.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public <K, V, T> Store<K, V, T> getRawStore(String storeName,
                                                InconsistencyResolver<Versioned<V>> resolver) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415764605712/fstmerge_var1_6197880822938011064
        return getRawStore(storeName, resolver, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415764605712/fstmerge_base_8931440060026060747

        logger.info("Client zone-id [" + clientZoneId
                    + "] Attempting to obtain metadata for store [" + storeName + "] ");
        if(logger.isDebugEnabled()) {
            for(URI uri: bootstrapUrls) {
                logger.debug("Client Bootstrap url [" + uri + "]");
            }
        }
        // Get cluster and store metadata
        String clusterXml = bootstrapMetadataWithRetries(MetadataStore.CLUSTER_KEY, bootstrapUrls);
        Cluster cluster = clusterMapper.readCluster(new StringReader(clusterXml), false);
        String storesXml = bootstrapMetadataWithRetries(MetadataStore.STORES_KEY, bootstrapUrls);

        if(logger.isDebugEnabled()) {
            logger.debug("Obtained cluster metadata xml" + clusterXml);
            logger.debug("Obtained stores  metadata xml" + storesXml);
        }

        List<StoreDefinition> storeDefs = storeMapper.readStoreList(new StringReader(storesXml),
                                                                    false);
        StoreDefinition storeDef = null;
        for(StoreDefinition d: storeDefs)
            if(d.getName().equals(storeName))
                storeDef = d;
        if(storeDef == null)
            throw new BootstrapFailureException("Unknown store '" + storeName + "'.");

        if(logger.isDebugEnabled()) {
            logger.debug(cluster.toString(true));
            logger.debug(storeDef.toString());
        }
        boolean repairReads = !storeDef.isView();

        // construct mapping
        Map<Integer, Store<ByteArray, byte[], byte[]>> clientMapping = Maps.newHashMap();
        Map<Integer, NonblockingStore> nonblockingStores = Maps.newHashMap();
        Map<Integer, NonblockingStore> nonblockingSlopStores = Maps.newHashMap();

        Map<Integer, Store<ByteArray, Slop, byte[]>> slopStores = null;
        if(storeDef.hasHintedHandoffStrategyType())
            slopStores = Maps.newHashMap();

        for(Node node: cluster.getNodes()) {
            Store<ByteArray, byte[], byte[]> store = getStore(storeDef.getName(),
                                                              node.getHost(),
                                                              getPort(node),
                                                              this.requestFormatType);
            clientMapping.put(node.getId(), store);

            NonblockingStore nonblockingStore = routedStoreFactory.toNonblockingStore(store);
            nonblockingStores.put(node.getId(), nonblockingStore);

            if(slopStores != null) {
                Store<ByteArray, byte[], byte[]> rawSlopStore = getStore("slop",
                                                                         node.getHost(),
                                                                         getPort(node),
                                                                         this.requestFormatType);
                Store<ByteArray, Slop, byte[]> slopStore = SerializingStore.wrap(rawSlopStore,
                                                                                 slopKeySerializer,
                                                                                 slopValueSerializer,
                                                                                 new IdentitySerializer());
                slopStores.put(node.getId(), slopStore);
                nonblockingSlopStores.put(node.getId(),
                                          routedStoreFactory.toNonblockingStore(rawSlopStore));
            }
        }

        Store<ByteArray, byte[], byte[]> store = routedStoreFactory.create(cluster,
                                                                           storeDef,
                                                                           clientMapping,
                                                                           nonblockingStores,
                                                                           slopStores,
                                                                           nonblockingSlopStores,
                                                                           repairReads,
                                                                           clientZoneId,
                                                                           getFailureDetector());
        store = new LoggingStore(store);

        if(isJmxEnabled) {
            StatTrackingStore statStore = new StatTrackingStore(store, this.stats);
            store = statStore;
            JmxUtils.registerMbean(new StoreStatsJmx(statStore.getStats()),
                                   JmxUtils.createObjectName(JmxUtils.getPackageName(store.getClass()),
                                                             store.getName() + jmxId()));
        }

        if(storeDef.getKeySerializer().hasCompression()
           || storeDef.getValueSerializer().hasCompression()) {
            store = new CompressingStore(store,
                                         getCompressionStrategy(storeDef.getKeySerializer()),
                                         getCompressionStrategy(storeDef.getValueSerializer()));
        }

        Serializer<K> keySerializer = (Serializer<K>) serializerFactory.getSerializer(storeDef.getKeySerializer());
        Serializer<V> valueSerializer = (Serializer<V>) serializerFactory.getSerializer(storeDef.getValueSerializer());

        if(storeDef.isView() && (storeDef.getTransformsSerializer() == null))
            throw new SerializationException("Transforms serializer must be specified with a view ");

        Serializer<T> transformsSerializer = (Serializer<T>) serializerFactory.getSerializer(storeDef.getTransformsSerializer() != null ? storeDef.getTransformsSerializer()
                                                                                                                                       : new SerializerDefinition("identity"));

        Store<K, V, T> serializedStore = SerializingStore.wrap(store,
                                                               keySerializer,
                                                               valueSerializer,
                                                               transformsSerializer);

        // Add inconsistency resolving decorator, using their inconsistency
        // resolver (if they gave us one)
        InconsistencyResolver<Versioned<V>> secondaryResolver = resolver == null ? new TimeBasedInconsistencyResolver()
                                                                                : resolver;
        serializedStore = new InconsistencyResolvingStore<K, V, T>(serializedStore,
                                                                   new ChainedResolver<Versioned<V>>(new VectorClockInconsistencyResolver(),
                                                                                                     secondaryResolver));
        return serializedStore;
=======

        logger.info("Client zone-id [" + clientZoneId
                    + "] Attempting to obtain metadata for store [" + storeName + "] ");
        if(logger.isDebugEnabled()) {
            for(URI uri: bootstrapUrls) {
                logger.debug("Client Bootstrap url [" + uri + "]");
            }
        }
        // Get cluster and store metadata
        String clusterXml = bootstrapMetadataWithRetries(MetadataStore.CLUSTER_KEY, bootstrapUrls);
        Cluster cluster = clusterMapper.readCluster(new StringReader(clusterXml), false);
        String storesXml = bootstrapMetadataWithRetries(MetadataStore.STORES_KEY, bootstrapUrls);

        if(logger.isDebugEnabled()) {
            logger.debug("Obtained cluster metadata xml" + clusterXml);
            logger.debug("Obtained stores  metadata xml" + storesXml);
        }

        List<StoreDefinition> storeDefs = storeMapper.readStoreList(new StringReader(storesXml),
                                                                    false);
        StoreDefinition storeDef = null;
        for(StoreDefinition d: storeDefs)
            if(d.getName().equals(storeName))
                storeDef = d;
        if(storeDef == null)
            throw new BootstrapFailureException("Unknown store '" + storeName + "'.");

        if(logger.isDebugEnabled()) {
            logger.debug(cluster.toString(true));
            logger.debug(storeDef.toString());
        }
        boolean repairReads = !storeDef.isView();

        // construct mapping
        Map<Integer, Store<ByteArray, byte[], byte[]>> clientMapping = Maps.newHashMap();
        Map<Integer, NonblockingStore> nonblockingStores = Maps.newHashMap();
        Map<Integer, NonblockingStore> nonblockingSlopStores = Maps.newHashMap();

        Map<Integer, Store<ByteArray, Slop, byte[]>> slopStores = null;
        if(storeDef.hasHintedHandoffStrategyType())
            slopStores = Maps.newHashMap();

        for(Node node: cluster.getNodes()) {
            Store<ByteArray, byte[], byte[]> store = getStore(storeDef.getName(),
                                                              node.getHost(),
                                                              getPort(node),
                                                              this.requestFormatType);
            clientMapping.put(node.getId(), store);

            NonblockingStore nonblockingStore = routedStoreFactory.toNonblockingStore(store);
            nonblockingStores.put(node.getId(), nonblockingStore);

            if(slopStores != null) {
                Store<ByteArray, byte[], byte[]> rawSlopStore = getStore("slop",
                                                                         node.getHost(),
                                                                         getPort(node),
                                                                         this.requestFormatType);
                Store<ByteArray, Slop, byte[]> slopStore = SerializingStore.wrap(rawSlopStore,
                                                                                 slopKeySerializer,
                                                                                 slopValueSerializer,
                                                                                 new IdentitySerializer());
                slopStores.put(node.getId(), slopStore);
                nonblockingSlopStores.put(node.getId(),
                                          routedStoreFactory.toNonblockingStore(rawSlopStore));
            }
        }

        Store<ByteArray, byte[], byte[]> store = routedStoreFactory.create(cluster,
                                                                           storeDef,
                                                                           clientMapping,
                                                                           nonblockingStores,
                                                                           slopStores,
                                                                           nonblockingSlopStores,
                                                                           repairReads,
                                                                           clientZoneId,
                                                                           getFailureDetector(),
                                                                           isJmxEnabled);
        store = new LoggingStore(store);

        if(isJmxEnabled) {
            StatTrackingStore statStore = new StatTrackingStore(store, this.stats);
            store = statStore;
            JmxUtils.registerMbean(new StoreStatsJmx(statStore.getStats()),
                                   JmxUtils.createObjectName(JmxUtils.getPackageName(store.getClass()),
                                                             store.getName() + jmxId()));
        }

        if(storeDef.getKeySerializer().hasCompression()
           || storeDef.getValueSerializer().hasCompression()) {
            store = new CompressingStore(store,
                                         getCompressionStrategy(storeDef.getKeySerializer()),
                                         getCompressionStrategy(storeDef.getValueSerializer()));
        }

        Serializer<K> keySerializer = (Serializer<K>) serializerFactory.getSerializer(storeDef.getKeySerializer());
        Serializer<V> valueSerializer = (Serializer<V>) serializerFactory.getSerializer(storeDef.getValueSerializer());

        if(storeDef.isView() && (storeDef.getTransformsSerializer() == null))
            throw new SerializationException("Transforms serializer must be specified with a view ");

        Serializer<T> transformsSerializer = (Serializer<T>) serializerFactory.getSerializer(storeDef.getTransformsSerializer() != null ? storeDef.getTransformsSerializer()
                                                                                                                                       : new SerializerDefinition("identity"));

        Store<K, V, T> serializedStore = SerializingStore.wrap(store,
                                                               keySerializer,
                                                               valueSerializer,
                                                               transformsSerializer);

        // Add inconsistency resolving decorator, using their inconsistency
        // resolver (if they gave us one)
        InconsistencyResolver<Versioned<V>> secondaryResolver = resolver == null ? new TimeBasedInconsistencyResolver()
                                                                                : resolver;
        serializedStore = new InconsistencyResolvingStore<K, V, T>(serializedStore,
                                                                   new ChainedResolver<Versioned<V>>(new VectorClockInconsistencyResolver(),
                                                                                                     secondaryResolver));
        return serializedStore;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415764605712/fstmerge_var2_1845984621445761026
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f2698_9b93e/rev_f2698-9b93e/src/java/voldemort/client/AbstractStoreClientFactory.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_24dbf_c8ab4/rev_24dbf-c8ab4.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@SuppressWarnings("unchecked")
    public static void main(String[] args) throws Exception {
        OptionParser parser = new OptionParser();
        parser.accepts("help", "print help information");
        parser.accepts("url", "[REQUIRED] bootstrap URL")
              .withRequiredArg()
              .describedAs("bootstrap-url")
              .ofType(String.class);
        parser.accepts("node", "node id")
              .withRequiredArg()
              .describedAs("node-id")
              .ofType(Integer.class);
        parser.accepts("delete-partitions", "Delete partitions")
              .withRequiredArg()
              .describedAs("partition-ids")
              .withValuesSeparatedBy(',')
              .ofType(Integer.class);
        parser.accepts("restore",
                       "Restore from replication [ Optional parallelism param - Default - 5 ]")
              .withOptionalArg()
              .describedAs("parallelism")
              .ofType(Integer.class);
        parser.accepts("ascii", "Fetch keys as ASCII");
        parser.accepts("fetch-keys", "Fetch keys")
              .withOptionalArg()
              .describedAs("partition-ids")
              .withValuesSeparatedBy(',')
              .ofType(Integer.class);
        parser.accepts("fetch-entries", "Fetch full entries")
              .withOptionalArg()
              .describedAs("partition-ids")
              .withValuesSeparatedBy(',')
              .ofType(Integer.class);
        parser.accepts("outdir", "Output directory")
              .withRequiredArg()
              .describedAs("output-directory")
              .ofType(String.class);
        parser.accepts("stores", "Store names")
              .withRequiredArg()
              .describedAs("store-names")
              .withValuesSeparatedBy(',')
              .ofType(String.class);
        parser.accepts("add-stores", "Add stores in this stores.xml")
              .withRequiredArg()
              .describedAs("stores.xml containing just the new stores")
              .ofType(String.class);
        parser.accepts("delete-store", "Delete store")
              .withRequiredArg()
              .describedAs("store-name")
              .ofType(String.class);
        parser.accepts("update-entries", "Insert or update entries")
              .withRequiredArg()
              .describedAs("input-directory")
              .ofType(String.class);
        parser.accepts("get-metadata",
                       "retreive metadata information " + MetadataStore.METADATA_KEYS)
              .withOptionalArg()
              .describedAs("metadata-key")
              .ofType(String.class);
        parser.accepts("check-metadata",
                       "retreive metadata information from all nodes and checks if they are consistent across [ "
                               + MetadataStore.CLUSTER_KEY + " | " + MetadataStore.STORES_KEY
                               + " | " + MetadataStore.SERVER_STATE_KEY + " ]")
              .withRequiredArg()
              .describedAs("metadata-key")
              .ofType(String.class);
        parser.accepts("ro-metadata",
                       "retrieve version information [current | max | storage-format]")
              .withRequiredArg()
              .describedAs("type")
              .ofType(String.class);
        parser.accepts("truncate", "truncate a store")
              .withRequiredArg()
              .describedAs("store-name")
              .ofType(String.class);
        parser.accepts("set-metadata",
                       "Forceful setting of metadata [ " + MetadataStore.CLUSTER_KEY + " | "
                               + MetadataStore.STORES_KEY + " | " + MetadataStore.SERVER_STATE_KEY
                               + " | " + MetadataStore.REBALANCING_STEAL_INFO + " ]")
              .withRequiredArg()
              .describedAs("metadata-key")
              .ofType(String.class);
        parser.accepts("set-metadata-value",
                       "The value for the set-metadata [ " + MetadataStore.CLUSTER_KEY + " | "
                               + MetadataStore.STORES_KEY + ", "
                               + MetadataStore.REBALANCING_STEAL_INFO
                               + " ] - xml file location, [ " + MetadataStore.SERVER_STATE_KEY
                               + " ] - " + MetadataStore.VoldemortState.NORMAL_SERVER + ","
                               + MetadataStore.VoldemortState.REBALANCING_MASTER_SERVER)
              .withRequiredArg()
              .describedAs("metadata-value")
              .ofType(String.class);
        parser.accepts("key-distribution", "Prints the current key distribution of the cluster");
        parser.accepts("clear-rebalancing-metadata", "Remove the metadata related to rebalancing");
        parser.accepts("async",
                       "a) Get a list of async job ids [get] b) Stop async job ids [stop] ")
              .withRequiredArg()
              .describedAs("op-type")
              .ofType(String.class);
        parser.accepts("async-id", "Comma separated list of async ids to stop")
              .withOptionalArg()
              .describedAs("job-ids")
              .withValuesSeparatedBy(',')
              .ofType(Integer.class);
        parser.accepts("repair-job", "Clean after rebalancing is done");
        parser.accepts("native-backup", "Perform a native backup")
              .withRequiredArg()
              .describedAs("store-name")
              .ofType(String.class);
        parser.accepts("backup-dir")
              .withRequiredArg()
              .describedAs("backup-directory")
              .ofType(String.class);
        parser.accepts("backup-timeout")
              .withRequiredArg()
              .describedAs("minutes to wait for backup completion, default 30 mins")
              .ofType(Integer.class);
        parser.accepts("backup-verify",
                       "If provided, backup will also verify checksum (with extra overhead)");
        parser.accepts("backup-incremental",
                       "Perform an incremental backup for point-in-time recovery."
                               + " By default backup has latest consistent snapshot.");
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415765553843/fstmerge_var1_1328383753361548708
        parser.accepts("rollback", "rollback a store")
              .withRequiredArg()
              .describedAs("store-name")
              .ofType(String.class);
        parser.accepts("version", "Push version of store to rollback to")
              .withRequiredArg()
              .describedAs("version")
              .ofType(Long.class);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415765553843/fstmerge_base_2976962709700688152
=======
        parser.accepts("zone", "zone id")
              .withRequiredArg()
              .describedAs("zone-id")
              .ofType(Integer.class);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415765553843/fstmerge_var2_3919766496350605282

        OptionSet options = parser.parse(args);

        if(options.has("help")) {
            printHelp(System.out, parser);
            System.exit(0);
        }

        Set<String> missing = CmdUtils.missing(options, "url", "node");
        if(missing.size() > 0) {
            // Not the most elegant way to do this
            if(!(missing.equals(ImmutableSet.of("node"))
                 && (options.has("add-stores") || options.has("delete-store")
                     || options.has("ro-metadata") || options.has("set-metadata")
                     || options.has("get-metadata") || options.has("check-metadata") || options.has("key-distribution"))
                 || options.has("truncate") || options.has("clear-rebalancing-metadata")
                 || options.has("async") || options.has("native-backup") || options.has("rollback"))) {
                System.err.println("Missing required arguments: " + Joiner.on(", ").join(missing));
                printHelp(System.err, parser);
                System.exit(1);
            }
        }

        String url = (String) options.valueOf("url");
        Integer nodeId = CmdUtils.valueOf(options, "node", -1);
        int parallelism = CmdUtils.valueOf(options, "restore", 5);
        Integer zoneId = CmdUtils.valueOf(options, "zone", -1);

        AdminClient adminClient = new AdminClient(url, new AdminClientConfig());

        String ops = "";
        if(options.has("delete-partitions")) {
            ops += "d";
        }
        if(options.has("fetch-keys")) {
            ops += "k";
        }
        if(options.has("fetch-entries")) {
            ops += "v";
        }
        if(options.has("restore")) {
            ops += "r";
        }
        if(options.has("add-stores")) {
            ops += "a";
        }
        if(options.has("update-entries")) {
            ops += "u";
        }
        if(options.has("delete-store")) {
            ops += "s";
        }
        if(options.has("get-metadata")) {
            ops += "g";
        }
        if(options.has("ro-metadata")) {
            ops += "e";
        }
        if(options.has("truncate")) {
            ops += "t";
        }
        if(options.has("set-metadata")) {
            ops += "m";
        }
        if(options.has("check-metadata")) {
            ops += "c";
        }
        if(options.has("key-distribution")) {
            ops += "y";
        }
        if(options.has("clear-rebalancing-metadata")) {
            ops += "i";
        }
        if(options.has("async")) {
            ops += "b";
        }
        if(options.has("repair-job")) {
            ops += "l";
        }
        if(options.has("native-backup")) {
            if(!options.has("backup-dir")) {
                Utils.croak("A backup directory must be specified with backup-dir option");
            }
            ops += "n";
        }
        if(options.has("rollback")) {
            if(!options.has("version")) {
                Utils.croak("A read-only push version must be specified with rollback option");
            }
            ops += "o";
        }
        if(ops.length() < 1) {
            Utils.croak("At least one of (delete-partitions, restore, add-node, fetch-entries, "
                        + "fetch-keys, add-stores, delete-store, update-entries, get-metadata, ro-metadata, "
                        + "set-metadata, check-metadata, key-distribution, clear-rebalancing-metadata, async, "
                        + "repair-job, native-backup) must be specified");
        }

        List<String> storeNames = null;

        if(options.has("stores")) {
            List<String> temp = (List<String>) options.valuesOf("stores");
            storeNames = temp;
        }

        String outputDir = null;
        if(options.has("outdir")) {
            outputDir = (String) options.valueOf("outdir");
        }

        try {
            if(ops.contains("d")) {
                System.out.println("Starting delete-partitions");
                List<Integer> partitionIdList = (List<Integer>) options.valuesOf("delete-partitions");
                executeDeletePartitions(nodeId, adminClient, partitionIdList, storeNames);
                System.out.println("Finished delete-partitions");
            }
            if(ops.contains("r")) {
                if(nodeId == -1) {
                    System.err.println("Cannot run restore without node id");
                    System.exit(1);
                }
                System.out.println("Starting restore");
                adminClient.restoreDataFromReplications(nodeId, parallelism, zoneId);
                System.out.println("Finished restore");
            }
            if(ops.contains("k")) {
                boolean useAscii = options.has("ascii");
                System.out.println("Starting fetch keys");
                List<Integer> partitionIdList = null;
                if(options.hasArgument("fetch-keys"))
                    partitionIdList = (List<Integer>) options.valuesOf("fetch-keys");
                executeFetchKeys(nodeId,
                                 adminClient,
                                 partitionIdList,
                                 outputDir,
                                 storeNames,
                                 useAscii);
            }
            if(ops.contains("v")) {
                boolean useAscii = options.has("ascii");
                System.out.println("Starting fetch entries");
                List<Integer> partitionIdList = null;
                if(options.hasArgument("fetch-entries"))
                    partitionIdList = (List<Integer>) options.valuesOf("fetch-entries");
                executeFetchEntries(nodeId,
                                    adminClient,
                                    partitionIdList,
                                    outputDir,
                                    storeNames,
                                    useAscii);
            }
            if(ops.contains("a")) {
                String storesXml = (String) options.valueOf("add-stores");
                executeAddStores(adminClient, storesXml, nodeId);
            }
            if(ops.contains("u")) {
                String inputDir = (String) options.valueOf("update-entries");
                executeUpdateEntries(nodeId, adminClient, storeNames, inputDir);
            }
            if(ops.contains("s")) {
                String storeName = (String) options.valueOf("delete-store");
                executeDeleteStore(adminClient, storeName, nodeId);
            }
            if(ops.contains("g")) {
                String metadataKey = ALL_METADATA;
                if(options.hasArgument("get-metadata")) {
                    metadataKey = (String) options.valueOf("get-metadata");
                }
                executeGetMetadata(nodeId, adminClient, metadataKey, outputDir);
            }
            if(ops.contains("e")) {
                String type = (String) options.valueOf("ro-metadata");
                executeROMetadata(nodeId, adminClient, storeNames, type);
            }
            if(ops.contains("t")) {
                String storeName = (String) options.valueOf("truncate");
                executeTruncateStore(nodeId, adminClient, storeName);
            }
            if(ops.contains("c")) {
                String metadataKey = (String) options.valueOf("check-metadata");
                executeCheckMetadata(adminClient, metadataKey);
            }
            if(ops.contains("m")) {
                String metadataKey = (String) options.valueOf("set-metadata");
                if(!options.has("set-metadata-value")) {
                    throw new VoldemortException("Missing set-metadata-value");
                } else {
                    String metadataValue = (String) options.valueOf("set-metadata-value");
                    if(metadataKey.compareTo(MetadataStore.CLUSTER_KEY) == 0) {
                        if(!Utils.isReadableFile(metadataValue))
                            throw new VoldemortException("Cluster xml file path incorrect");
                        ClusterMapper mapper = new ClusterMapper();
                        Cluster newCluster = mapper.readCluster(new File(metadataValue));
                        executeSetMetadata(nodeId,
                                           adminClient,
                                           MetadataStore.CLUSTER_KEY,
                                           mapper.writeCluster(newCluster));
                    } else if(metadataKey.compareTo(MetadataStore.SERVER_STATE_KEY) == 0) {
                        VoldemortState newState = VoldemortState.valueOf(metadataValue);
                        executeSetMetadata(nodeId,
                                           adminClient,
                                           MetadataStore.SERVER_STATE_KEY,
                                           newState.toString());
                    } else if(metadataKey.compareTo(MetadataStore.STORES_KEY) == 0) {
                        if(!Utils.isReadableFile(metadataValue))
                            throw new VoldemortException("Stores definition xml file path incorrect");
                        StoreDefinitionsMapper mapper = new StoreDefinitionsMapper();
                        List<StoreDefinition> storeDefs = mapper.readStoreList(new File(metadataValue));
                        executeSetMetadata(nodeId,
                                           adminClient,
                                           MetadataStore.STORES_KEY,
                                           mapper.writeStoreList(storeDefs));
                    } else if(metadataKey.compareTo(MetadataStore.REBALANCING_STEAL_INFO) == 0) {
                        if(!Utils.isReadableFile(metadataValue))
                            throw new VoldemortException("Rebalancing steal info file path incorrect");
                        String rebalancingStealInfoJsonString = FileUtils.readFileToString(new File(metadataValue));
                        RebalancerState state = RebalancerState.create(rebalancingStealInfoJsonString);
                        executeSetMetadata(nodeId,
                                           adminClient,
                                           MetadataStore.REBALANCING_STEAL_INFO,
                                           state.toJsonString());
                    } else {
                        throw new VoldemortException("Incorrect metadata key");
                    }
                }

            }
            if(ops.contains("y")) {
                executeKeyDistribution(adminClient);
            }
            if(ops.contains("i")) {
                executeClearRebalancing(nodeId, adminClient);
            }
            if(ops.contains("b")) {
                String asyncKey = (String) options.valueOf("async");
                List<Integer> asyncIds = null;
                if(options.hasArgument("async-id"))
                    asyncIds = (List<Integer>) options.valuesOf("async-id");
                executeAsync(nodeId, adminClient, asyncKey, asyncIds);
            }
            if(ops.contains("l")) {
                executeRepairJob(nodeId, adminClient);
            }
            if(ops.contains("n")) {
                String backupDir = (String) options.valueOf("backup-dir");
                String storeName = (String) options.valueOf("native-backup");
                int timeout = CmdUtils.valueOf(options, "backup-timeout", 30);
                adminClient.nativeBackup(nodeId,
                                         storeName,
                                         backupDir,
                                         timeout,
                                         options.has("backup-verify"),
                                         options.has("backup-incremental"));
            }
            if(ops.contains("o")) {
                String storeName = (String) options.valueOf("rollback");
                long pushVersion = (Long) options.valueOf("version");
                executeRollback(nodeId, storeName, pushVersion, adminClient);
            }
        } catch(Exception e) {
            e.printStackTrace();
            Utils.croak(e.getMessage());
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_24dbf_c8ab4/rev_24dbf-c8ab4/src/java/voldemort/VoldemortAdminTool.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d59d3_056d9/rev_d59d3-056d9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_1d2bc_cccb8/rev_1d2bc-cccb8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e7c7b_c4196/rev_e7c7b-c4196.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e7c7b_d37df/rev_e7c7b-d37df.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c709b_b3e72/rev_c709b-b3e72.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_be89c_e7c7b/rev_be89c-e7c7b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bcf42_9bb17/rev_bcf42-9bb17.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_fbae4_f23e6/rev_fbae4-f23e6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_20dfa_8b0a7/rev_20dfa-8b0a7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d1b9b_f70b3/rev_d1b9b-f70b3.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public SocketStoreClientFactory(ClientConfig config) {
        super(config);
        this.requestRoutingType = RequestRoutingType.getRequestRoutingType(RoutingTier.SERVER.equals(config.getRoutingTier()),
                                                                           false);
        this.storeFactory = new ClientRequestExecutorPool(config.getSelectors(),
                                                          config.getMaxConnectionsPerNode(),
                                                          config.getConnectionTimeout(TimeUnit.MILLISECONDS),
                                                          config.getSocketTimeout(TimeUnit.MILLISECONDS),
                                                          config.getSocketBufferSize(),
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415775152327/fstmerge_var1_1903506284686818088
                                                          config.getSocketKeepAlive());
        if(config.isJmxEnabled())
            JmxUtils.registerMbean(storeFactory,
                                   JmxUtils.createObjectName(JmxUtils.getPackageName(storeFactory.getClass()),
                                                             JmxUtils.getClassName(storeFactory.getClass())
                                                                     + jmxId()));
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415775152327/fstmerge_base_5411383639563049620
                                                          config.getSocketKeepAlive());
        if(config.isJmxEnabled())
            JmxUtils.registerMbean(storeFactory, JmxUtils.createObjectName(storeFactory.getClass()));
=======
                                                          config.getSocketKeepAlive(),
                                                          config.isJmxEnabled());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415775152327/fstmerge_var2_5858279720067578852
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d1b9b_f70b3/rev_d1b9b-f70b3/src/java/voldemort/client/SocketStoreClientFactory.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_366cd_ba412/rev_366cd-ba412.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public AbstractStoreClientFactory(ClientConfig config) {
        this.config = config;
        this.threadPool = new ClientThreadPool(config.getMaxThreads(),
                                               config.getThreadIdleTime(TimeUnit.MILLISECONDS),
                                               config.getMaxQueuedRequests());
        this.serializerFactory = config.getSerializerFactory();
        this.bootstrapUrls = validateUrls(config.getBootstrapUrls());
        this.isJmxEnabled = config.isJmxEnabled();
        this.requestFormatType = config.getRequestFormatType();
        this.jmxId = jmxIdCounter.getAndIncrement();
        this.maxBootstrapRetries = config.getMaxBootstrapRetries();
        this.stats = new StoreStats();
        this.clientZoneId = config.getClientZoneId();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146019/fstmerge_base_7659948318813931386
=======
        this.clientContextName = (null == config.getClientContextName() ? ""
                                                                       : config.getClientContextName());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146019/fstmerge_var2_8546429971670653929
        this.routedStoreFactory = new RoutedStoreFactory(config.isPipelineRoutedStoreEnabled(),
                                                         threadPool,
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146019/fstmerge_var1_2267860433598076657
                                                         config.getRoutingTimeout(TimeUnit.MILLISECONDS));
        this.sequencer = new AtomicInteger(0);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146019/fstmerge_base_7659948318813931386
                                                         config.getRoutingTimeout(TimeUnit.MILLISECONDS));
=======
                                                         config.getTimeoutConfig());

        this.sequencer = new AtomicInteger(0);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146019/fstmerge_var2_8546429971670653929

        if(this.isJmxEnabled) {
            JmxUtils.registerMbean(threadPool,
                                   JmxUtils.createObjectName(JmxUtils.getPackageName(threadPool.getClass()),
                                                             JmxUtils.getClassName(threadPool.getClass())
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146019/fstmerge_base_7659948318813931386
=======
                                                                     + "."
                                                                     + clientContextName
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146019/fstmerge_var2_8546429971670653929
                                                                     + jmxId()));
            JmxUtils.registerMbean(new StoreStatsJmx(stats),
                                   JmxUtils.createObjectName("voldemort.store.stats.aggregate",
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146019/fstmerge_base_7659948318813931386
                                                             "aggregate-perf" + jmxId()));
=======
                                                             clientContextName + ".aggregate-perf"
                                                                     + jmxId()));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146019/fstmerge_var2_8546429971670653929
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_366cd_ba412/rev_366cd-ba412/src/java/voldemort/client/AbstractStoreClientFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146092/fstmerge_var1_7516233749431084662
private String jmxId() {
        return jmxId == 0 ? "" : "." + Integer.toString(jmxId);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146092/fstmerge_base_9196237148340267844
private String jmxId() {
        return jmxId == 0 ? "" : Integer.toString(jmxId);
=======
public String jmxId() {
        return jmxId == 0 ? "" : Integer.toString(jmxId);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146092/fstmerge_var2_331250842792563928
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_366cd_ba412/rev_366cd-ba412/src/java/voldemort/client/AbstractStoreClientFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
public SocketStoreClientFactory(ClientConfig config) {
        super(config);
        this.requestRoutingType = RequestRoutingType.getRequestRoutingType(RoutingTier.SERVER.equals(config.getRoutingTier()),
                                                                           false);
        this.storeFactory = new ClientRequestExecutorPool(config.getSelectors(),
                                                          config.getMaxConnectionsPerNode(),
                                                          config.getConnectionTimeout(TimeUnit.MILLISECONDS),
                                                          config.getSocketTimeout(TimeUnit.MILLISECONDS),
                                                          config.getSocketBufferSize(),
                                                          config.getSocketKeepAlive(),
                                                          config.isJmxEnabled());
        if(config.isJmxEnabled())
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146100/fstmerge_var1_7230602113537434865
            JmxUtils.registerMbean(storeFactory, JmxUtils.createObjectName(storeFactory.getClass()));
        _config = config;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146100/fstmerge_base_1273453011335801757
            JmxUtils.registerMbean(storeFactory, JmxUtils.createObjectName(storeFactory.getClass()));
=======
            JmxUtils.registerMbean(storeFactory,
                                   JmxUtils.createObjectName(JmxUtils.getPackageName(storeFactory.getClass()),
                                                             JmxUtils.getClassName(storeFactory.getClass())
                                                                     + jmxId()));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146100/fstmerge_var2_5610467176674019829
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_366cd_ba412/rev_366cd-ba412/src/java/voldemort/client/SocketStoreClientFactory.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146537/fstmerge_var1_4350401848953439922
public void setAsyncCheckMetadataInterval(long asyncCheckMetadataInterval) {
        this.asyncCheckMetadataInterval = asyncCheckMetadataInterval;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146537/fstmerge_base_8765028504947288844
=======
public ClientConfig setAsyncCheckMetadataInterval(long asyncCheckMetadataInterval) {
        this.asyncCheckMetadataInterval = asyncCheckMetadataInterval;
        return this;
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146537/fstmerge_var2_4448491213753678691

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_366cd_ba412/rev_366cd-ba412/src/java/voldemort/client/ClientConfig.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146600/fstmerge_var1_4193713371808114826
@SuppressWarnings("unchecked")
    public DefaultStoreClient(String storeName,
                              InconsistencyResolver<Versioned<V>> resolver,
                              StoreClientFactory storeFactory,
                              int maxMetadataRefreshAttempts,
                              String clientContext,
                              int clientSequence,
                              ClientConfig config) {

        this.storeName = Utils.notNull(storeName);
        this.resolver = resolver;
        this.storeFactory = Utils.notNull(storeFactory);
        this.metadataRefreshAttempts = maxMetadataRefreshAttempts;
        this.clientInfo = new ClientInfo(storeName,
                                         clientContext,
                                         clientSequence,
                                         System.currentTimeMillis());
        this.clientId = AbstractStoreClientFactory.generateClientId(clientInfo);
        this.config = config;

        // Registering self to be able to bootstrap client dynamically via JMX
        JmxUtils.registerMbean(this,
                               JmxUtils.createObjectName(JmxUtils.getPackageName(this.getClass()),
                                                         JmxUtils.getClassName(this.getClass())
                                                                 + "." + clientContext + "."
                                                                 + storeName + "."
                                                                 + clientId.toString()));
        bootStrap();

        // Initialize all the system stores
        sysStoreMap = createSystemStores();

        // Initialize the background thread for checking metadata version
        if(config != null) {
            asyncCheckMetadata = createMetadataChecker();
        }

        registerClient();
        logger.info("Voldemort client created: clientContext=" + clientContext + " clientSequence="
                    + clientSequence + " clientId=" + clientId.toString());
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146600/fstmerge_base_7122090700392335484
=======
@SuppressWarnings("unchecked")
    public DefaultStoreClient(String storeName,
                              InconsistencyResolver<Versioned<V>> resolver,
                              StoreClientFactory storeFactory,
                              int maxMetadataRefreshAttempts,
                              String clientContext,
                              int clientSequence,
                              ClientConfig config) {

        this.storeName = Utils.notNull(storeName);
        this.resolver = resolver;
        this.storeFactory = Utils.notNull(storeFactory);
        this.metadataRefreshAttempts = maxMetadataRefreshAttempts;
        this.clientInfo = new ClientInfo(storeName,
                                         clientContext,
                                         clientSequence,
                                         System.currentTimeMillis(),
                                         ManifestFileReader.getReleaseVersion());
        this.clientId = AbstractStoreClientFactory.generateClientId(clientInfo);
        this.config = config;

        // Registering self to be able to bootstrap client dynamically via JMX
        JmxUtils.registerMbean(this,
                               JmxUtils.createObjectName(JmxUtils.getPackageName(this.getClass()),
                                                         JmxUtils.getClassName(this.getClass())
                                                                 + "." + clientContext + "."
                                                                 + storeName + "."
                                                                 + clientId.toString()));
        bootStrap();

        // Initialize all the system stores
        sysStoreMap = createSystemStores();

        // Initialize the background thread for checking metadata version
        if(config != null) {
            asyncCheckMetadata = createMetadataChecker();
        }

        registerClient();
        logger.info("Voldemort client created: " + clientId.toString() + "\n" + clientInfo);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146600/fstmerge_var2_7040534833890195027

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_366cd_ba412/rev_366cd-ba412/src/java/voldemort/client/DefaultStoreClient.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146781/fstmerge_var1_7698848260374646924
public SystemStore(String storeName, String[] bootstrapUrls, int clientZoneID) {
        String prefix = storeName.substring(0, SystemStoreConstants.NAME_PREFIX.length());
        if(!SystemStoreConstants.NAME_PREFIX.equals(prefix))
            throw new VoldemortException("Illegal system store : " + storeName);

        ClientConfig config = new ClientConfig();
        config.setSelectors(1)
              .setBootstrapUrls(bootstrapUrls)
              .setMaxConnectionsPerNode(2)
              .setConnectionTimeout(1500, TimeUnit.MILLISECONDS)
              .setSocketTimeout(5000, TimeUnit.MILLISECONDS)
              .setRoutingTimeout(5000, TimeUnit.MILLISECONDS)
              .setEnableJmx(false)
              .setEnablePipelineRoutedStore(true)
              .setClientZoneId(clientZoneID);
        this.systemStoreFactory = new SocketStoreClientFactory(config);
        this.storeName = storeName;
        this.sysStore = this.systemStoreFactory.getSystemStore(this.storeName);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146781/fstmerge_base_4971987450842827412
=======
public SystemStore(String storeName, String[] bootstrapUrls, int clientZoneID) {
        String prefix = storeName.substring(0, SystemStoreConstants.NAME_PREFIX.length());
        if(!SystemStoreConstants.NAME_PREFIX.equals(prefix))
            throw new VoldemortException("Illegal system store : " + storeName);

        ClientConfig config = new ClientConfig();
        config.setSelectors(1)
              .setBootstrapUrls(config.getBootstrapUrls())
              .setMaxConnectionsPerNode(2)
              .setConnectionTimeout(1500, TimeUnit.MILLISECONDS)
              .setSocketTimeout(5000, TimeUnit.MILLISECONDS)
              .setRoutingTimeout(5000, TimeUnit.MILLISECONDS)
              .setEnableJmx(false)
              .setEnablePipelineRoutedStore(true)
              .setClientZoneId(config.getClientZoneId());
        this.systemStoreFactory = new SocketStoreClientFactory(config);
        this.storeName = storeName;
        this.sysStore = this.systemStoreFactory.getSystemStore(this.storeName);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776146781/fstmerge_var2_6353790629695866245

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_366cd_ba412/rev_366cd-ba412/src/java/voldemort/client/SystemStore.java
Conflict type: SameIdFd
Conflict body: 
~~FSTMerge~~ public static final String SYSTEM_STORE_SCHEMA = "<stores>"
                                                     + "  <store>"
                                                     + "    <name>voldsys$_client_registry</name>"
                                                     + "    <routing-strategy>zone-routing</routing-strategy>"
                                                     + "    <hinted-handoff-strategy>proximity-handoff</hinted-handoff-strategy>"
                                                     + "    <persistence>memory</persistence>"
                                                     + "    <routing>client</routing>"
                                                     + "    <replication-factor>4</replication-factor>"
                                                     + "    <zone-replication-factor>"
                                                     + "      <replication-factor zone-id=\"0\">2</replication-factor>"
                                                     + "      <replication-factor zone-id=\"1\">2</replication-factor>"
                                                     + "    </zone-replication-factor>"
                                                     + "    <required-reads>1</required-reads>"
                                                     + "    <required-writes>1</required-writes>"
                                                     + "    <key-serializer>"
                                                     + "      <type>string</type>"
                                                     + "     <schema-info version=\"0\">utf8</schema-info>"
                                                     + "    </key-serializer>"
                                                     + "    <value-serializer>"
                                                     // +
                                                     // "      <type>avro-specific</type>"
                                                     // +
                                                     // "      <schema-info version=\"0\">java=voldemort.client.ClientInfo</schema-info>"
                                                     + "      <type>java-serialization</type>"
                                                     + "    </value-serializer>"
                                                     + "    <retention-days>7</retention-days>"
                                                     + "  </store>"

                                                     + "  <store>"
                                                     + "    <name>voldsys$_client_store_definition</name>"
                                                     + "    <routing-strategy>zone-routing</routing-strategy>"
                                                     + "    <hinted-handoff-strategy>proximity-handoff</hinted-handoff-strategy>"
                                                     + "    <persistence>memory</persistence>"
                                                     + "    <routing>client</routing>"
                                                     + "    <replication-factor>1</replication-factor>"
                                                     + "    <required-reads>1</required-reads>"
                                                     + "    <required-writes>1</required-writes>"
                                                     + "    <key-serializer>"
                                                     + "      <type>string</type>"
                                                     + "    </key-serializer>"
                                                     + "    <value-serializer>"
                                                     + "      <type>string</type>"
                                                     + "    </value-serializer>"
                                                     + "    <retention-days>7</retention-days>"
                                                     + "  </store>"

                                                     + "  <store>"
                                                     + "    <name>voldsys$_metadata_version</name>"
                                                     + "    <routing-strategy>local-pref-all-routing</routing-strategy>"
                                                     + "    <hinted-handoff-strategy>proximity-handoff</hinted-handoff-strategy>"
                                                     + "    <persistence>memory</persistence>"
                                                     + "    <routing>client</routing>"
                                                     + "    <replication-factor>1</replication-factor>"
                                                     + "    <required-reads>1</required-reads>"
                                                     + "    <required-writes>1</required-writes>"
                                                     + "    <key-serializer>"
                                                     + "      <type>string</type>"
                                                     + "    </key-serializer>"
                                                     + "    <value-serializer>"
                                                     + "      <type>java-serialization</type>"
                                                     + "    </value-serializer>" + "  </store>"

                                                     + "</stores>"; ##FSTMerge## ##FSTMerge## public static final String SYSTEM_STORE_SCHEMA = "<stores>"
                                                     + "  <store>"
                                                     + "    <name>voldsys$_client_registry</name>"
                                                     + "    <routing-strategy>all-routing</routing-strategy>"
                                                     + "    <hinted-handoff-strategy>proximity-handoff</hinted-handoff-strategy>"
                                                     + "    <persistence>memory</persistence>"
                                                     + "    <routing>client</routing>"
                                                     + "    <replication-factor>4</replication-factor>"
                                                     + "    <zone-replication-factor>"
                                                     + "      <replication-factor zone-id=\"0\">2</replication-factor>"
                                                     + "      <replication-factor zone-id=\"1\">2</replication-factor>"
                                                     + "    </zone-replication-factor>"
                                                     + "    <required-reads>1</required-reads>"
                                                     + "    <required-writes>1</required-writes>"
                                                     + "    <key-serializer>"
                                                     + "      <type>string</type>"
                                                     + "     <schema-info version=\"0\">utf8</schema-info>"
                                                     + "    </key-serializer>"
                                                     + "    <value-serializer>"
                                                     // +
                                                     // "      <type>avro-specific</type>"
                                                     // +
                                                     // "      <schema-info version=\"0\">java=voldemort.client.ClientInfo</schema-info>"
                                                     + "      <type>java-serialization</type>"
                                                     + "    </value-serializer>"
                                                     + "    <retention-days>7</retention-days>"
                                                     + "  </store>"

                                                     + "  <store>"
                                                     + "    <name>voldsys$_client_store_definition</name>"
                                                     + "    <routing-strategy>zone-routing</routing-strategy>"
                                                     + "    <hinted-handoff-strategy>proximity-handoff</hinted-handoff-strategy>"
                                                     + "    <persistence>memory</persistence>"
                                                     + "    <routing>client</routing>"
                                                     + "    <replication-factor>1</replication-factor>"
                                                     + "    <required-reads>1</required-reads>"
                                                     + "    <required-writes>1</required-writes>"
                                                     + "    <key-serializer>"
                                                     + "      <type>string</type>"
                                                     + "    </key-serializer>"
                                                     + "    <value-serializer>"
                                                     + "      <type>string</type>"
                                                     + "    </value-serializer>"
                                                     + "    <retention-days>7</retention-days>"
                                                     + "  </store>"

                                                     + "  <store>"
                                                     + "    <name>voldsys$_metadata_version</name>"
                                                     + "    <routing-strategy>local-pref-all-routing</routing-strategy>"
                                                     + "    <hinted-handoff-strategy>proximity-handoff</hinted-handoff-strategy>"
                                                     + "    <persistence>memory</persistence>"
                                                     + "    <routing>client</routing>"
                                                     + "    <replication-factor>1</replication-factor>"
                                                     + "    <required-reads>1</required-reads>"
                                                     + "    <required-writes>1</required-writes>"
                                                     + "    <key-serializer>"
                                                     + "      <type>string</type>"
                                                     + "    </key-serializer>"
                                                     + "    <value-serializer>"
                                                     + "      <type>java-serialization</type>"
                                                     + "    </value-serializer>" + "  </store>"

                                                     + "</stores>";
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_366cd_ba412/rev_366cd-ba412/src/java/voldemort/store/system/SystemStoreConstants.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776176131/fstmerge_var1_284316637625637599
public static StoreDefinition getSystemStoreDef(String name) {
        StoreDefinition storeDef = null;
        List<StoreDefinition> allDefs = getAllSystemStoreDefs();
        for(StoreDefinition def: allDefs) {
            if(name.equals(def.getName())) {
                storeDef = def;
            }
        }
        return storeDef;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776176131/fstmerge_base_1993991569391204287
=======
public static StoreDefinition getSystemStoreDef(String name) {
        List<StoreDefinition> allDefs = getAllSystemStoreDefs();
        return RebalanceUtils.getStoreDefinitionWithName(allDefs, name);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415776176131/fstmerge_var2_4956362900217591939

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_366cd_ba412/rev_366cd-ba412/src/java/voldemort/store/system/SystemStoreConstants.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e90fa_05f23/rev_e90fa-05f23.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_fa3d6_70718/rev_fa3d6-70718.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_ab979_4e628/rev_ab979-4e628.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_40a3d_0aa7f/rev_40a3d-0aa7f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_581d9_1b895/rev_581d9-1b895.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_2c6b6_d15b6/rev_2c6b6-d15b6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_21ff9_b8f0b/rev_21ff9-b8f0b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_98643_4f8c9/rev_98643-4f8c9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_89ded_210a2/rev_89ded-210a2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@Test
    public void testHappyPath() {
        List<Integer> emptyPartitionList = Lists.newArrayList();
        ClientConfig clientConfig = new ClientConfig().setMaxThreads(4)
                                                      .setMaxTotalConnections(4)
                                                      .setMaxConnectionsPerNode(4)
                                                      .setBootstrapUrls(SERVER_LOCAL_URL
                                                                        + serverPorts[0])
                                                      .setClientContextName(CLIENT_CONTEXT_NAME)
                                                      .setClientRegistryUpdateInSecs(CLIENT_REGISTRY_REFRSH_INTERVAL)
                                                      .setEnableLazy(false);
        SocketStoreClientFactory socketFactory = new SocketStoreClientFactory(clientConfig);
        StoreClient<String, String> client1 = socketFactory.getStoreClient(TEST_STORE_NAME);
        client1.put("k", "v");
        Iterator<Pair<ByteArray, Versioned<byte[]>>> it = adminClient.fetchEntries(0,
                                                                                   SystemStoreConstants.SystemStoreName.voldsys$_client_registry.name(),
                                                                                   emptyPartitionList,
                                                                                   null,
                                                                                   false);
        ArrayList<ClientInfo> infoList = getClientRegistryContent(it);
        assertEquals(TEST_STORE_NAME, infoList.get(0).getStoreName());
        assertEquals(CLIENT_CONTEXT_NAME, infoList.get(0).getContext());
        assertEquals(0, infoList.get(0).getClientSequence());
        assertTrue("Client registry bootstrap time incorrect",
                   startTime <= infoList.get(0).getBootstrapTime());

        assertNotNull("Client version is null", infoList.get(0).getReleaseVersion());
        assertEquals(1, infoList.size());

        it = adminClient.fetchEntries(1,
                                      SystemStoreConstants.SystemStoreName.voldsys$_client_registry.name(),
                                      emptyPartitionList,
                                      null,
                                      false);
        infoList = getClientRegistryContent(it);
        assertEquals(TEST_STORE_NAME, infoList.get(0).getStoreName());
        assertEquals(CLIENT_CONTEXT_NAME, infoList.get(0).getContext());
        assertEquals(0, infoList.get(0).getClientSequence());
        assertTrue("Client registry bootstrap time incorrect",
                   startTime <= infoList.get(0).getBootstrapTime());
        assertNotNull("Client version is null", infoList.get(0).getReleaseVersion());
        assertEquals(1, infoList.size());

        try {
            Thread.sleep(CLIENT_REGISTRY_REFRSH_INTERVAL * 1000 * 5);
        } catch(InterruptedException e) {}
        // now the periodical update has gone through, it shall be higher than
        // the bootstrap time
        it = adminClient.fetchEntries(1,
                                      SystemStoreConstants.SystemStoreName.voldsys$_client_registry.name(),
                                      emptyPartitionList,
                                      null,
                                      false);
        infoList = getClientRegistryContent(it);
        assertTrue("Client registry not updated.",
                   infoList.get(0).getBootstrapTime() < infoList.get(0).getUpdateTime());
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155037/fstmerge_var1_4739605149067289241
        socketFactory.close();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155037/fstmerge_base_8890913386506091301
        ((DefaultStoreClient<String, String>) client1).close();
=======
        ((ZenStoreClient<String, String>) client1).close();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155037/fstmerge_var2_1758538897458609178
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/test/unit/voldemort/client/ClientRegistryTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Test
    public void testTwoClients() {
        List<Integer> emptyPartitionList = Lists.newArrayList();
        ClientConfig clientConfig = new ClientConfig().setMaxThreads(4)
                                                      .setMaxTotalConnections(4)
                                                      .setMaxConnectionsPerNode(4)
                                                      .setBootstrapUrls(SERVER_LOCAL_URL
                                                                        + serverPorts[0])
                                                      .setClientContextName(CLIENT_CONTEXT_NAME)
                                                      .setClientRegistryUpdateInSecs(CLIENT_REGISTRY_REFRSH_INTERVAL)
                                                      .setEnableLazy(false);
        SocketStoreClientFactory socketFactory = new SocketStoreClientFactory(clientConfig);
        StoreClient<String, String> client1 = socketFactory.getStoreClient(TEST_STORE_NAME);
        StoreClient<String, String> client2 = socketFactory.getStoreClient(TEST_STORE_NAME);

        client1.put("k1", "v1");
        client2.put("k2", "v2");

        Iterator<Pair<ByteArray, Versioned<byte[]>>> it = adminClient.fetchEntries(0,
                                                                                   SystemStoreConstants.SystemStoreName.voldsys$_client_registry.name(),
                                                                                   emptyPartitionList,
                                                                                   null,
                                                                                   false);
        ArrayList<ClientInfo> infoList = getClientRegistryContent(it);
        assertEquals(TEST_STORE_NAME, infoList.get(0).getStoreName());
        assertEquals(CLIENT_CONTEXT_NAME, infoList.get(0).getContext());
        assertTrue("Client registry sequence number incorrect", 1 >= infoList.get(0)
                                                                             .getClientSequence());
        assertTrue("Client registry bootstrap time incorrect",
                   startTime <= infoList.get(0).getBootstrapTime());
        assertNotNull("Client version is null", infoList.get(0).getReleaseVersion());

        assertEquals(TEST_STORE_NAME, infoList.get(1).getStoreName());
        assertEquals(CLIENT_CONTEXT_NAME, infoList.get(1).getContext());
        assertTrue("Client registry sequence number incorrect", 1 >= infoList.get(1)
                                                                             .getClientSequence());
        assertTrue("Client registry bootstrap time incorrect",
                   startTime <= infoList.get(1).getBootstrapTime());
        assertNotNull("Client version is null", infoList.get(1).getReleaseVersion());
        assertEquals(infoList.size(), 2);

        it = adminClient.fetchEntries(1,
                                      SystemStoreConstants.SystemStoreName.voldsys$_client_registry.name(),
                                      emptyPartitionList,
                                      null,
                                      false);
        infoList = getClientRegistryContent(it);
        assertEquals(TEST_STORE_NAME, infoList.get(0).getStoreName());
        assertEquals(CLIENT_CONTEXT_NAME, infoList.get(0).getContext());
        assertTrue("Client registry sequence number incorrect", 1 >= infoList.get(0)
                                                                             .getClientSequence());
        assertTrue("Client registry bootstrap time incorrect",
                   startTime <= infoList.get(0).getBootstrapTime());
        assertNotNull("Client version is null", infoList.get(0).getReleaseVersion());

        assertEquals(TEST_STORE_NAME, infoList.get(1).getStoreName());
        assertEquals(CLIENT_CONTEXT_NAME, infoList.get(1).getContext());
        assertTrue("Client registry sequence number incorrect", 1 >= infoList.get(1)
                                                                             .getClientSequence());
        assertTrue("Client registry bootstrap time incorrect",
                   startTime <= infoList.get(1).getBootstrapTime());
        assertNotNull("Client version is null", infoList.get(1).getReleaseVersion());

        assertEquals(infoList.size(), 2);

        try {
            Thread.sleep(CLIENT_REGISTRY_REFRSH_INTERVAL * 1000 * 5);
        } catch(InterruptedException e) {}
        // now the periodical update has gone through, it shall be higher than
        // the bootstrap time
        it = adminClient.fetchEntries(1,
                                      SystemStoreConstants.SystemStoreName.voldsys$_client_registry.name(),
                                      emptyPartitionList,
                                      null,
                                      false);
        infoList = getClientRegistryContent(it);
        assertTrue("Client registry not updated.",
                   infoList.get(0).getBootstrapTime() < infoList.get(0).getUpdateTime());
        assertTrue("Client registry not updated.",
                   infoList.get(1).getBootstrapTime() < infoList.get(1).getUpdateTime());

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155042/fstmerge_var1_7425405424848824247
        socketFactory.close();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155042/fstmerge_base_6349897912751427818
        ((DefaultStoreClient<String, String>) client1).close();
        ((DefaultStoreClient<String, String>) client2).close();
=======
        ((ZenStoreClient<String, String>) client1).close();
        ((ZenStoreClient<String, String>) client2).close();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155042/fstmerge_var2_2860464687398180852
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/test/unit/voldemort/client/ClientRegistryTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Test
    public void testTwoStores() {
        List<Integer> emptyPartitionList = Lists.newArrayList();
        ClientConfig clientConfig = new ClientConfig().setMaxThreads(4)
                                                      .setMaxTotalConnections(4)
                                                      .setMaxConnectionsPerNode(4)
                                                      .setBootstrapUrls(SERVER_LOCAL_URL
                                                                        + serverPorts[0])
                                                      .setClientContextName(CLIENT_CONTEXT_NAME)
                                                      .setClientRegistryUpdateInSecs(CLIENT_REGISTRY_REFRSH_INTERVAL)
                                                      .setEnableLazy(false);
        SocketStoreClientFactory socketFactory = new SocketStoreClientFactory(clientConfig);
        StoreClient<String, String> client1 = socketFactory.getStoreClient(TEST_STORE_NAME);
        StoreClient<String, String> client2 = socketFactory.getStoreClient(TEST_STORE_NAME2);

        client1.put("k1", "v1");
        client2.put("k2", "v2");

        Iterator<Pair<ByteArray, Versioned<byte[]>>> it = adminClient.fetchEntries(0,
                                                                                   SystemStoreConstants.SystemStoreName.voldsys$_client_registry.name(),
                                                                                   emptyPartitionList,
                                                                                   null,
                                                                                   false);
        ArrayList<ClientInfo> infoList = getClientRegistryContent(it);

        assertEquals(CLIENT_CONTEXT_NAME, infoList.get(0).getContext());
        assertTrue("Client registry bootstrap time incorrect",
                   startTime <= infoList.get(0).getBootstrapTime());
        assertNotNull("Client version is null", infoList.get(0).getReleaseVersion());

        assertEquals(CLIENT_CONTEXT_NAME, infoList.get(1).getContext());
        assertTrue("Client registry bootstrap time incorrect",
                   startTime <= infoList.get(1).getBootstrapTime());
        assertNotNull("Client version is null", infoList.get(1).getReleaseVersion());

        if(infoList.get(0).getStoreName().equals(TEST_STORE_NAME)) {
            assertEquals(0, infoList.get(0).getClientSequence());
            assertEquals(TEST_STORE_NAME2, infoList.get(1).getStoreName());
            assertEquals(1, infoList.get(1).getClientSequence());
            assertTrue("Client registry bootstrap time incorrect",
                       infoList.get(1).getBootstrapTime() >= infoList.get(0).getBootstrapTime());
        } else {
            assertEquals(TEST_STORE_NAME2, infoList.get(0).getStoreName());
            assertEquals(1, infoList.get(0).getClientSequence());
            assertEquals(TEST_STORE_NAME, infoList.get(1).getStoreName());
            assertEquals(0, infoList.get(1).getClientSequence());
            assertTrue("Client registry bootstrap time incorrect",
                       infoList.get(0).getBootstrapTime() >= infoList.get(1).getBootstrapTime());
        }

        it = adminClient.fetchEntries(1,
                                      SystemStoreConstants.SystemStoreName.voldsys$_client_registry.name(),
                                      emptyPartitionList,
                                      null,
                                      false);
        infoList = getClientRegistryContent(it);

        assertEquals(CLIENT_CONTEXT_NAME, infoList.get(0).getContext());
        assertTrue("Client registry bootstrap time incorrect",
                   startTime <= infoList.get(0).getBootstrapTime());
        assertNotNull("Client version is null", infoList.get(0).getReleaseVersion());

        assertEquals(CLIENT_CONTEXT_NAME, infoList.get(1).getContext());
        assertTrue("Client registry bootstrap time incorrect",
                   startTime <= infoList.get(1).getBootstrapTime());
        assertNotNull("Client version is null", infoList.get(1).getReleaseVersion());

        if(infoList.get(0).getStoreName().equals(TEST_STORE_NAME)) {
            assertEquals(0, infoList.get(0).getClientSequence());
            assertEquals(TEST_STORE_NAME2, infoList.get(1).getStoreName());
            assertEquals(1, infoList.get(1).getClientSequence());
            assertTrue("Client registry bootstrap time incorrect",
                       infoList.get(1).getBootstrapTime() >= infoList.get(0).getBootstrapTime());
        } else {
            assertEquals(TEST_STORE_NAME2, infoList.get(0).getStoreName());
            assertEquals(1, infoList.get(0).getClientSequence());
            assertEquals(TEST_STORE_NAME, infoList.get(1).getStoreName());
            assertEquals(0, infoList.get(1).getClientSequence());
            assertTrue("Client registry bootstrap time incorrect",
                       infoList.get(0).getBootstrapTime() >= infoList.get(1).getBootstrapTime());
        }

        try {
            Thread.sleep(CLIENT_REGISTRY_REFRSH_INTERVAL * 1000 * 5);
        } catch(InterruptedException e) {}
        // now the periodical update has gone through, it shall be higher than
        // the bootstrap time
        it = adminClient.fetchEntries(1,
                                      SystemStoreConstants.SystemStoreName.voldsys$_client_registry.name(),
                                      emptyPartitionList,
                                      null,
                                      false);
        infoList = getClientRegistryContent(it);
        assertTrue("Client registry not updated.",
                   infoList.get(0).getBootstrapTime() < infoList.get(0).getUpdateTime());
        assertTrue("Client registry not updated.",
                   infoList.get(1).getBootstrapTime() < infoList.get(1).getUpdateTime());

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155047/fstmerge_var1_876779811202885067
        socketFactory.close();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155047/fstmerge_base_4006813227772302757
        ((DefaultStoreClient<String, String>) client1).close();
        ((DefaultStoreClient<String, String>) client2).close();
=======
        ((ZenStoreClient<String, String>) client1).close();
        ((ZenStoreClient<String, String>) client2).close();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155047/fstmerge_var2_5613882822376472115
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/test/unit/voldemort/client/ClientRegistryTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Test
    public void testTwoFactories() {
        List<Integer> emptyPartitionList = Lists.newArrayList();
        ClientConfig clientConfig = new ClientConfig().setMaxThreads(4)
                                                      .setMaxTotalConnections(4)
                                                      .setMaxConnectionsPerNode(4)
                                                      .setBootstrapUrls(SERVER_LOCAL_URL
                                                                        + serverPorts[0])
                                                      .setClientContextName(CLIENT_CONTEXT_NAME)
                                                      .setClientRegistryUpdateInSecs(CLIENT_REGISTRY_REFRSH_INTERVAL)
                                                      .setEnableLazy(false);
        SocketStoreClientFactory socketFactory1 = new SocketStoreClientFactory(clientConfig);

        ClientConfig clientConfig2 = new ClientConfig().setMaxThreads(4)
                                                       .setMaxTotalConnections(4)
                                                       .setMaxConnectionsPerNode(4)
                                                       .setBootstrapUrls(SERVER_LOCAL_URL
                                                                         + serverPorts[0])
                                                       .setClientContextName(CLIENT_CONTEXT_NAME2)
                                                       .setClientRegistryUpdateInSecs(CLIENT_REGISTRY_REFRSH_INTERVAL)
                                                       .setEnableLazy(false);
        SocketStoreClientFactory socketFactory2 = new SocketStoreClientFactory(clientConfig2);

        StoreClient<String, String> client1 = socketFactory1.getStoreClient(TEST_STORE_NAME);
        StoreClient<String, String> client2 = socketFactory2.getStoreClient(TEST_STORE_NAME2);

        client1.put("k1", "v1");
        client2.put("k2", "v2");

        Iterator<Pair<ByteArray, Versioned<byte[]>>> it = adminClient.fetchEntries(0,
                                                                                   SystemStoreConstants.SystemStoreName.voldsys$_client_registry.name(),
                                                                                   emptyPartitionList,
                                                                                   null,
                                                                                   false);
        ArrayList<ClientInfo> infoList = getClientRegistryContent(it);

        assertNotNull("Client version is null", infoList.get(0).getReleaseVersion());
        assertNotNull("Client version is null", infoList.get(1).getReleaseVersion());

        if(infoList.get(0).getStoreName().equals(TEST_STORE_NAME)) {
            assertEquals(CLIENT_CONTEXT_NAME, infoList.get(0).getContext());
            assertEquals(0, infoList.get(0).getClientSequence());
            assertTrue("Client registry bootstrap time incorrect",
                       startTime <= infoList.get(0).getBootstrapTime());

            assertEquals(TEST_STORE_NAME2, infoList.get(1).getStoreName());
            assertEquals(CLIENT_CONTEXT_NAME2, infoList.get(1).getContext());
            assertEquals(0, infoList.get(1).getClientSequence());
            assertTrue("Client registry bootstrap time incorrect",
                       startTime <= infoList.get(1).getBootstrapTime());

            assertTrue("Client registry bootstrap time incorrect",
                       infoList.get(1).getBootstrapTime() >= infoList.get(0).getBootstrapTime());

        } else {
            assertEquals(TEST_STORE_NAME2, infoList.get(0).getStoreName());
            assertEquals(CLIENT_CONTEXT_NAME2, infoList.get(0).getContext());
            assertEquals(0, infoList.get(0).getClientSequence());
            assertTrue("Client registry bootstrap time incorrect",
                       startTime <= infoList.get(0).getBootstrapTime());

            assertEquals(TEST_STORE_NAME, infoList.get(1).getStoreName());
            assertEquals(CLIENT_CONTEXT_NAME, infoList.get(1).getContext());
            assertEquals(0, infoList.get(1).getClientSequence());
            assertTrue("Client registry bootstrap time incorrect",
                       startTime <= infoList.get(1).getBootstrapTime());

            assertTrue("Client registry bootstrap time incorrect",
                       infoList.get(0).getBootstrapTime() >= infoList.get(1).getBootstrapTime());
        }

        it = adminClient.fetchEntries(1,
                                      SystemStoreConstants.SystemStoreName.voldsys$_client_registry.name(),
                                      emptyPartitionList,
                                      null,
                                      false);
        infoList = getClientRegistryContent(it);

        assertNotNull("Client version is null", infoList.get(0).getReleaseVersion());
        assertNotNull("Client version is null", infoList.get(1).getReleaseVersion());

        if(infoList.get(0).getStoreName().equals(TEST_STORE_NAME)) {
            assertEquals(CLIENT_CONTEXT_NAME, infoList.get(0).getContext());
            assertEquals(0, infoList.get(0).getClientSequence());
            assertTrue("Client registry bootstrap time incorrect",
                       startTime <= infoList.get(0).getBootstrapTime());

            assertEquals(TEST_STORE_NAME2, infoList.get(1).getStoreName());
            assertEquals(CLIENT_CONTEXT_NAME2, infoList.get(1).getContext());
            assertEquals(0, infoList.get(1).getClientSequence());
            assertTrue("Client registry bootstrap time incorrect",
                       startTime <= infoList.get(1).getBootstrapTime());

            assertTrue("Client registry bootstrap time incorrect",
                       infoList.get(1).getBootstrapTime() >= infoList.get(0).getBootstrapTime());

        } else {
            assertEquals(TEST_STORE_NAME2, infoList.get(0).getStoreName());
            assertEquals(CLIENT_CONTEXT_NAME2, infoList.get(0).getContext());
            assertEquals(0, infoList.get(0).getClientSequence());
            assertTrue("Client registry bootstrap time incorrect",
                       startTime <= infoList.get(0).getBootstrapTime());

            assertEquals(TEST_STORE_NAME, infoList.get(1).getStoreName());
            assertEquals(CLIENT_CONTEXT_NAME, infoList.get(1).getContext());
            assertEquals(0, infoList.get(1).getClientSequence());
            assertTrue("Client registry bootstrap time incorrect",
                       startTime <= infoList.get(1).getBootstrapTime());

            assertTrue("Client registry bootstrap time incorrect",
                       infoList.get(0).getBootstrapTime() >= infoList.get(1).getBootstrapTime());
        }

        try {
            Thread.sleep(CLIENT_REGISTRY_REFRSH_INTERVAL * 1000 * 5);
        } catch(InterruptedException e) {}
        // now the periodical update has gone through, it shall be higher than
        // the bootstrap time
        it = adminClient.fetchEntries(1,
                                      SystemStoreConstants.SystemStoreName.voldsys$_client_registry.name(),
                                      emptyPartitionList,
                                      null,
                                      false);
        infoList = getClientRegistryContent(it);
        assertTrue("Client registry not updated.",
                   infoList.get(0).getBootstrapTime() < infoList.get(0).getUpdateTime());
        assertTrue("Client registry not updated.",
                   infoList.get(1).getBootstrapTime() < infoList.get(1).getUpdateTime());

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155053/fstmerge_var1_7146721728198329705
        socketFactory1.close();
        socketFactory2.close();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155053/fstmerge_base_2098771958402964864
        ((DefaultStoreClient<String, String>) client1).close();
        ((DefaultStoreClient<String, String>) client2).close();
=======
        ((ZenStoreClient<String, String>) client1).close();
        ((ZenStoreClient<String, String>) client2).close();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155053/fstmerge_var2_5052495483474110109
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/test/unit/voldemort/client/ClientRegistryTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Test
    public void testOneServerFailre() {
        // bring down one server before starting up the clients
        servers[0].stop();

        List<Integer> emptyPartitionList = Lists.newArrayList();
        ClientConfig clientConfig = new ClientConfig().setMaxThreads(4)
                                                      .setMaxTotalConnections(4)
                                                      .setMaxConnectionsPerNode(4)
                                                      .setBootstrapUrls(SERVER_LOCAL_URL
                                                                        + serverPorts[1])
                                                      .setClientContextName(CLIENT_CONTEXT_NAME)
                                                      .setClientRegistryUpdateInSecs(CLIENT_REGISTRY_REFRSH_INTERVAL)
                                                      .setEnableLazy(false);
        SocketStoreClientFactory socketFactory1 = new SocketStoreClientFactory(clientConfig);

        ClientConfig clientConfig2 = new ClientConfig().setMaxThreads(4)
                                                       .setMaxTotalConnections(4)
                                                       .setMaxConnectionsPerNode(4)
                                                       .setBootstrapUrls(SERVER_LOCAL_URL
                                                                         + serverPorts[1])
                                                       .setClientContextName(CLIENT_CONTEXT_NAME2)
                                                       .setClientRegistryUpdateInSecs(CLIENT_REGISTRY_REFRSH_INTERVAL)
                                                       .setEnableLazy(false);
        SocketStoreClientFactory socketFactory2 = new SocketStoreClientFactory(clientConfig2);

        StoreClient<String, String> client1 = socketFactory1.getStoreClient(TEST_STORE_NAME);
        StoreClient<String, String> client2 = socketFactory2.getStoreClient(TEST_STORE_NAME2);

        client1.put("k1", "v1");
        client2.put("k2", "v2");

        Iterator<Pair<ByteArray, Versioned<byte[]>>> it = adminClient.fetchEntries(1,
                                                                                   SystemStoreConstants.SystemStoreName.voldsys$_client_registry.name(),
                                                                                   emptyPartitionList,
                                                                                   null,
                                                                                   false);
        ArrayList<ClientInfo> infoList = getClientRegistryContent(it);

        assertNotNull("Client version is null", infoList.get(0).getReleaseVersion());
        assertNotNull("Client version is null", infoList.get(1).getReleaseVersion());

        if(infoList.get(0).getStoreName().equals(TEST_STORE_NAME)) {
            assertEquals(CLIENT_CONTEXT_NAME, infoList.get(0).getContext());
            assertEquals(0, infoList.get(0).getClientSequence());
            assertTrue("Client registry bootstrap time incorrect",
                       startTime <= infoList.get(0).getBootstrapTime());

            assertEquals(TEST_STORE_NAME2, infoList.get(1).getStoreName());
            assertEquals(CLIENT_CONTEXT_NAME2, infoList.get(1).getContext());
            assertEquals(0, infoList.get(1).getClientSequence());
            assertTrue("Client registry bootstrap time incorrect",
                       startTime <= infoList.get(1).getBootstrapTime());

            assertTrue("Client registry bootstrap time incorrect",
                       infoList.get(1).getBootstrapTime() >= infoList.get(0).getBootstrapTime());

        } else {
            assertEquals(TEST_STORE_NAME2, infoList.get(0).getStoreName());
            assertEquals(CLIENT_CONTEXT_NAME2, infoList.get(0).getContext());
            assertEquals(0, infoList.get(0).getClientSequence());
            assertTrue("Client registry bootstrap time incorrect",
                       startTime <= infoList.get(0).getBootstrapTime());

            assertEquals(TEST_STORE_NAME, infoList.get(1).getStoreName());
            assertEquals(CLIENT_CONTEXT_NAME, infoList.get(1).getContext());
            assertEquals(0, infoList.get(1).getClientSequence());
            assertTrue("Client registry bootstrap time incorrect",
                       startTime <= infoList.get(1).getBootstrapTime());

            assertTrue("Client registry bootstrap time incorrect",
                       infoList.get(0).getBootstrapTime() >= infoList.get(1).getBootstrapTime());
        }

        try {
            Thread.sleep(CLIENT_REGISTRY_REFRSH_INTERVAL * 1000 * 5);
        } catch(InterruptedException e) {}
        // now the periodical update has gone through, it shall be higher than
        // the bootstrap time
        it = adminClient.fetchEntries(1,
                                      SystemStoreConstants.SystemStoreName.voldsys$_client_registry.name(),
                                      emptyPartitionList,
                                      null,
                                      false);
        infoList = getClientRegistryContent(it);
        assertTrue("Client registry not updated.",
                   infoList.get(0).getBootstrapTime() < infoList.get(0).getUpdateTime());
        assertTrue("Client registry not updated.",
                   infoList.get(1).getBootstrapTime() < infoList.get(1).getUpdateTime());

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155059/fstmerge_var1_3732831780675150632
        socketFactory1.close();
        socketFactory2.close();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155059/fstmerge_base_7780102680038095807
        ((DefaultStoreClient<String, String>) client1).close();
        ((DefaultStoreClient<String, String>) client2).close();
=======
        ((ZenStoreClient<String, String>) client1).close();
        ((ZenStoreClient<String, String>) client2).close();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155059/fstmerge_var2_7843561185435740813
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/test/unit/voldemort/client/ClientRegistryTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Test
    public void testRepeatRegistrationSameFactory() {

        List<Integer> emptyPartitionList = Lists.newArrayList();
        ClientConfig clientConfig = new ClientConfig().setMaxThreads(4)
                                                      .setMaxTotalConnections(4)
                                                      .setMaxConnectionsPerNode(4)
                                                      .setBootstrapUrls(SERVER_LOCAL_URL
                                                                        + serverPorts[1])
                                                      .setClientContextName(CLIENT_CONTEXT_NAME)
                                                      .setClientRegistryUpdateInSecs(CLIENT_REGISTRY_REFRSH_INTERVAL)
                                                      .setEnableLazy(false);
        SocketStoreClientFactory socketFactory1 = new SocketStoreClientFactory(clientConfig);

        ClientConfig clientConfig2 = new ClientConfig().setMaxThreads(4)
                                                       .setMaxTotalConnections(4)
                                                       .setMaxConnectionsPerNode(4)
                                                       .setBootstrapUrls(SERVER_LOCAL_URL
                                                                         + serverPorts[1])
                                                       .setClientContextName(CLIENT_CONTEXT_NAME2)
                                                       .setClientRegistryUpdateInSecs(CLIENT_REGISTRY_REFRSH_INTERVAL)
                                                       .setEnableLazy(false);
        SocketStoreClientFactory socketFactory2 = new SocketStoreClientFactory(clientConfig2);

        for(int i = 0; i < 3; i++) {

            StoreClient<String, String> client1 = socketFactory1.getStoreClient(TEST_STORE_NAME);
            StoreClient<String, String> client2 = socketFactory2.getStoreClient(TEST_STORE_NAME2);

            client1.put("k1", "v1");
            client2.put("k2", "v2");

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155065/fstmerge_var1_5695009573908829815
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155065/fstmerge_base_8118221501937773298
            ((DefaultStoreClient<String, String>) client1).close();
            ((DefaultStoreClient<String, String>) client2).close();
=======
            ((ZenStoreClient<String, String>) client1).close();
            ((ZenStoreClient<String, String>) client2).close();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155065/fstmerge_var2_7427089281103611300
        }

        Iterator<Pair<ByteArray, Versioned<byte[]>>> it = adminClient.fetchEntries(1,
                                                                                   SystemStoreConstants.SystemStoreName.voldsys$_client_registry.name(),
                                                                                   emptyPartitionList,
                                                                                   null,
                                                                                   false);
        ArrayList<ClientInfo> infoList = getClientRegistryContent(it);
        assertEquals("Incrrect # of entries created in client registry", 6, infoList.size());

        socketFactory1.close();
        socketFactory2.close();
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/test/unit/voldemort/client/ClientRegistryTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Test
    public void testRepeatRegistrationDifferentFactories() {
        long client1LastBootstrapTime = 0;
        long client2LastBootstrapTime = 0;
        for(int i = 0; i < 3; i++) {

            List<Integer> emptyPartitionList = Lists.newArrayList();
            ClientConfig clientConfig = new ClientConfig().setMaxThreads(4)
                                                          .setMaxTotalConnections(4)
                                                          .setMaxConnectionsPerNode(4)
                                                          .setBootstrapUrls(SERVER_LOCAL_URL
                                                                            + serverPorts[1])
                                                          .setClientContextName(CLIENT_CONTEXT_NAME)
                                                          .setClientRegistryUpdateInSecs(CLIENT_REGISTRY_REFRSH_INTERVAL)
                                                          .setEnableLazy(false);
            SocketStoreClientFactory socketFactory1 = new SocketStoreClientFactory(clientConfig);

            ClientConfig clientConfig2 = new ClientConfig().setMaxThreads(4)
                                                           .setMaxTotalConnections(4)
                                                           .setMaxConnectionsPerNode(4)
                                                           .setBootstrapUrls(SERVER_LOCAL_URL
                                                                             + serverPorts[1])
                                                           .setClientContextName(CLIENT_CONTEXT_NAME2)
                                                           .setClientRegistryUpdateInSecs(CLIENT_REGISTRY_REFRSH_INTERVAL)
                                                           .setEnableLazy(false);
            SocketStoreClientFactory socketFactory2 = new SocketStoreClientFactory(clientConfig2);

            StoreClient<String, String> client1 = socketFactory1.getStoreClient(TEST_STORE_NAME);
            StoreClient<String, String> client2 = socketFactory2.getStoreClient(TEST_STORE_NAME2);

            client1.put("k1", "v1");
            client2.put("k2", "v2");

            Iterator<Pair<ByteArray, Versioned<byte[]>>> it = adminClient.fetchEntries(1,
                                                                                       SystemStoreConstants.SystemStoreName.voldsys$_client_registry.name(),
                                                                                       emptyPartitionList,
                                                                                       null,
                                                                                       false);
            ArrayList<ClientInfo> infoList = getClientRegistryContent(it);

            assertEquals("Incrrect # of entries created in client registry", 2, infoList.size());

            assertNotNull("Client version is null", infoList.get(0).getReleaseVersion());
            assertNotNull("Client version is null", infoList.get(1).getReleaseVersion());

            if(infoList.get(0).getStoreName().equals(TEST_STORE_NAME)) {
                assertEquals(CLIENT_CONTEXT_NAME, infoList.get(0).getContext());
                assertEquals(0, infoList.get(0).getClientSequence());
                assertTrue("Client registry bootstrap time incorrect",
                           startTime <= infoList.get(0).getBootstrapTime());

                assertEquals(TEST_STORE_NAME2, infoList.get(1).getStoreName());
                assertEquals(CLIENT_CONTEXT_NAME2, infoList.get(1).getContext());
                assertEquals(0, infoList.get(1).getClientSequence());
                assertTrue("Client registry bootstrap time incorrect",
                           startTime <= infoList.get(1).getBootstrapTime());

                assertTrue("Client registry bootstrap time incorrect",
                           infoList.get(1).getBootstrapTime() >= infoList.get(0).getBootstrapTime());

            } else {
                assertEquals(TEST_STORE_NAME2, infoList.get(0).getStoreName());
                assertEquals(CLIENT_CONTEXT_NAME2, infoList.get(0).getContext());
                assertEquals(0, infoList.get(0).getClientSequence());
                assertTrue("Client registry bootstrap time incorrect",
                           startTime <= infoList.get(0).getBootstrapTime());

                assertEquals(TEST_STORE_NAME, infoList.get(1).getStoreName());
                assertEquals(CLIENT_CONTEXT_NAME, infoList.get(1).getContext());
                assertEquals(0, infoList.get(1).getClientSequence());
                assertTrue("Client registry bootstrap time incorrect",
                           startTime <= infoList.get(1).getBootstrapTime());

                assertTrue("Client registry bootstrap time incorrect",
                           infoList.get(0).getBootstrapTime() >= infoList.get(1).getBootstrapTime());
            }

            try {
                Thread.sleep(CLIENT_REGISTRY_REFRSH_INTERVAL * 1000 * 5);
            } catch(InterruptedException e) {}
            // now the periodical update has gone through, it shall be higher
            // than
            // the bootstrap time
            it = adminClient.fetchEntries(1,
                                          SystemStoreConstants.SystemStoreName.voldsys$_client_registry.name(),
                                          emptyPartitionList,
                                          null,
                                          false);
            infoList = getClientRegistryContent(it);

            assertTrue("Client registry not updated.",
                       infoList.get(0).getBootstrapTime() < infoList.get(0).getUpdateTime());
            assertTrue("Client registry not updated.",
                       infoList.get(1).getBootstrapTime() < infoList.get(1).getUpdateTime());

            assertTrue("Bootstrap time does not increase client bounces",
                       infoList.get(0).getBootstrapTime() > client1LastBootstrapTime);
            assertTrue("Bootstrap time does not increase client bounces",
                       infoList.get(1).getBootstrapTime() > client2LastBootstrapTime);

            client1LastBootstrapTime = infoList.get(0).getBootstrapTime();
            client2LastBootstrapTime = infoList.get(0).getBootstrapTime();

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155070/fstmerge_var1_8898277094704469731
            socketFactory1.close();
            socketFactory2.close();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155070/fstmerge_base_3438748303367019678
            ((DefaultStoreClient<String, String>) client1).close();
            ((DefaultStoreClient<String, String>) client2).close();
=======
            ((ZenStoreClient<String, String>) client1).close();
            ((ZenStoreClient<String, String>) client2).close();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155070/fstmerge_var2_105307288324352538
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/test/unit/voldemort/client/ClientRegistryTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Test
    public void testTwoClientContextOnJmx() throws Exception {
        String clientContext1 = "clientA";
        String clientContext2 = "clientB";
        String jmxId1 = getAndIncrementJmxId();
        String jmxId2 = getAndIncrementJmxId();

        StoreClient<Object, Object> c1 = getFactoryWithClientContext(clientContext1,
                                                                     getValidBootstrapUrl()).getStoreClient(getValidStoreName());
        StoreClient<Object, Object> c2 = getFactoryWithClientContext(clientContext2,
                                                                     getValidBootstrapUrl()).getStoreClient(getValidStoreName());

        // checking for aggregate stats
        ObjectName c1Name = JmxUtils.createObjectName(AGGREGATE_STATS_DOMAIN, "aggregate-perf"
                                                                              + jmxId1);
        ObjectName c2Name = JmxUtils.createObjectName(AGGREGATE_STATS_DOMAIN, "aggregate-perf"
                                                                              + jmxId2);
        checkForMbeanFound(c1Name);
        checkForMbeanFound(c2Name);
        mbServer.unregisterMBean(c1Name);
        mbServer.unregisterMBean(c2Name);

        // checking for per store stats
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155385/fstmerge_var1_9108004001934239948
        String c1type = "test" + jmxId1;
        String c2type = "test" + jmxId2;
        c1Name = JmxUtils.createObjectName(STATS_DOMAIN, c1type);

        c2Name = JmxUtils.createObjectName(STATS_DOMAIN, c2type);

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155385/fstmerge_base_2540590923964594923
        String c1type = clientContext1 + ".test" + jmxId1;
        String c2type = clientContext2 + ".test" + jmxId2;
        c1Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                           c1type
                                                   + "."
                                                   + ((DefaultStoreClient<Object, Object>) c1).getClientId()
                                                                                              .toString());
        c2Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                           c2type
                                                   + "."
                                                   + ((DefaultStoreClient<Object, Object>) c2).getClientId()
                                                                                              .toString());
=======
        String c1type = clientContext1 + ".test" + jmxId1;
        String c2type = clientContext2 + ".test" + jmxId2;
        c1Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                           c1type
                                                   + "."
                                                   + ((ZenStoreClient<Object, Object>) c1).getClientId()
                                                                                               .toString());
        c2Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                           c2type
                                                   + "."
                                                   + ((ZenStoreClient<Object, Object>) c2).getClientId()
                                                                                               .toString());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155385/fstmerge_var2_4899019799578288619
        checkForMbeanFound(c1Name);
        checkForMbeanFound(c2Name);
        mbServer.unregisterMBean(c1Name);
        mbServer.unregisterMBean(c2Name);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/test/unit/voldemort/client/ClientJmxTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Test
    public void testSameContextOnJmx() throws Exception {
        String clientContext = "clientContext";
        String jmxId1 = getAndIncrementJmxId();
        String jmxId2 = getAndIncrementJmxId();

        StoreClient<Object, Object>[] clients = new StoreClient[2];
        for(int i = 0; i < 2; i++) {
            clients[i] = getFactoryWithClientContext(clientContext, getValidBootstrapUrl()).getStoreClient(getValidStoreName());
        }

        // checking for aggregate stats
        ObjectName c1Name = JmxUtils.createObjectName(AGGREGATE_STATS_DOMAIN, "aggregate-perf"
                                                                              + jmxId1);
        ObjectName c2Name = JmxUtils.createObjectName(AGGREGATE_STATS_DOMAIN, "aggregate-perf"
                                                                              + jmxId2);
        checkForMbeanFound(c1Name);
        checkForMbeanFound(c2Name);
        mbServer.unregisterMBean(c1Name);
        mbServer.unregisterMBean(c2Name);

        // checking for per store stats
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155390/fstmerge_var1_7459348261203874157
        String c1type = "test" + jmxId1;
        String c2type = "test" + jmxId2;
        c1Name = JmxUtils.createObjectName(STATS_DOMAIN, c1type);
        c2Name = JmxUtils.createObjectName(STATS_DOMAIN, c2type);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155390/fstmerge_base_5001999439383438433
        String c1type = clientContext + ".test" + jmxId1;
        String c2type = clientContext + ".test" + jmxId2;
        c1Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                           c1type
                                                   + "."
                                                   + ((DefaultStoreClient<Object, Object>) clients[0]).getClientId()
                                                                                                      .toString());
        c2Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                           c2type
                                                   + "."
                                                   + ((DefaultStoreClient<Object, Object>) clients[1]).getClientId()
                                                                                                      .toString());
=======
        String c1type = clientContext + ".test" + jmxId1;
        String c2type = clientContext + ".test" + jmxId2;
        c1Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                           c1type
                                                   + "."
                                                   + ((ZenStoreClient<Object, Object>) clients[0]).getClientId()
                                                                                                       .toString());
        c2Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                           c2type
                                                   + "."
                                                   + ((ZenStoreClient<Object, Object>) clients[1]).getClientId()
                                                                                                       .toString());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155390/fstmerge_var2_8977029709749978914
        checkForMbeanFound(c1Name);
        checkForMbeanFound(c2Name);
        mbServer.unregisterMBean(c1Name);
        mbServer.unregisterMBean(c2Name);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/test/unit/voldemort/client/ClientJmxTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Test
    public void testTwoClientNoContextOnJmx() throws Exception {
        String clientContextCompare = "";
        String jmxId1 = getAndIncrementJmxId();
        String jmxId2 = getAndIncrementJmxId();

        StoreClient<Object, Object> c1 = getFactory(getValidBootstrapUrl()).getStoreClient(getValidStoreName());
        StoreClient<Object, Object> c2 = getFactory(getValidBootstrapUrl()).getStoreClient(getValidStoreName());

        // checking for aggregate stats
        ObjectName c1Name = JmxUtils.createObjectName(AGGREGATE_STATS_DOMAIN, "aggregate-perf"
                                                                              + jmxId1);
        ObjectName c2Name = JmxUtils.createObjectName(AGGREGATE_STATS_DOMAIN, "aggregate-perf"
                                                                              + jmxId2);
        checkForMbeanFound(c1Name);
        checkForMbeanFound(c2Name);
        mbServer.unregisterMBean(c1Name);
        mbServer.unregisterMBean(c2Name);

        // checking for per store stats
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155395/fstmerge_var1_5033621528304433883
        String c1type = clientContextCompare + "test" + jmxId1;
        String c2type = clientContextCompare + "test" + jmxId2;
        c1Name = JmxUtils.createObjectName(STATS_DOMAIN, c1type);
        c2Name = JmxUtils.createObjectName(STATS_DOMAIN, c2type);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155395/fstmerge_base_8812254626427644355
        String c1type = clientContextCompare + ".test" + jmxId1;
        String c2type = clientContextCompare + ".test" + jmxId2;
        c1Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                           c1type
                                                   + "."
                                                   + ((DefaultStoreClient<Object, Object>) c1).getClientId()
                                                                                              .toString());
        c2Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                           c2type
                                                   + "."
                                                   + ((DefaultStoreClient<Object, Object>) c2).getClientId()
                                                                                              .toString());
=======
        String c1type = clientContextCompare + ".test" + jmxId1;
        String c2type = clientContextCompare + ".test" + jmxId2;
        c1Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                           c1type
                                                   + "."
                                                   + ((ZenStoreClient<Object, Object>) c1).getClientId()
                                                                                               .toString());
        c2Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                           c2type
                                                   + "."
                                                   + ((ZenStoreClient<Object, Object>) c2).getClientId()
                                                                                               .toString());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155395/fstmerge_var2_7581628714136736893
        checkForMbeanFound(c1Name);
        checkForMbeanFound(c2Name);
        mbServer.unregisterMBean(c1Name);
        mbServer.unregisterMBean(c2Name);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/test/unit/voldemort/client/ClientJmxTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Test
    public void testTwoClientNullContextOnJmx() throws Exception {
        String clientContextCompare = "";
        String jmxId1 = getAndIncrementJmxId();
        String jmxId2 = getAndIncrementJmxId();

        StoreClient<Object, Object> c1 = getFactoryWithClientContext(null, getValidBootstrapUrl()).getStoreClient(getValidStoreName());
        StoreClient<Object, Object> c2 = getFactoryWithClientContext(null, getValidBootstrapUrl()).getStoreClient(getValidStoreName());

        // checking for aggregate stats
        ObjectName c1Name = JmxUtils.createObjectName(AGGREGATE_STATS_DOMAIN, "aggregate-perf"
                                                                              + jmxId1);
        ObjectName c2Name = JmxUtils.createObjectName(AGGREGATE_STATS_DOMAIN, "aggregate-perf"
                                                                              + jmxId2);
        checkForMbeanFound(c1Name);
        checkForMbeanFound(c2Name);
        mbServer.unregisterMBean(c1Name);
        mbServer.unregisterMBean(c2Name);

        // checking for per store stats
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155400/fstmerge_var1_886509964466890690
        String c1type = clientContextCompare + "test" + jmxId1;
        String c2type = clientContextCompare + "test" + jmxId2;
        c1Name = JmxUtils.createObjectName(STATS_DOMAIN, c1type);
        c2Name = JmxUtils.createObjectName(STATS_DOMAIN, c2type);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155400/fstmerge_base_5947223508296306846
        String c1type = clientContextCompare + ".test" + jmxId1;
        String c2type = clientContextCompare + ".test" + jmxId2;
        c1Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                           c1type
                                                   + "."
                                                   + ((DefaultStoreClient<Object, Object>) c1).getClientId()
                                                                                              .toString());
        c2Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                           c2type
                                                   + "."
                                                   + ((DefaultStoreClient<Object, Object>) c2).getClientId()
                                                                                              .toString());
=======
        String c1type = clientContextCompare + ".test" + jmxId1;
        String c2type = clientContextCompare + ".test" + jmxId2;
        c1Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                           c1type
                                                   + "."
                                                   + ((ZenStoreClient<Object, Object>) c1).getClientId()
                                                                                               .toString());
        c2Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                           c2type
                                                   + "."
                                                   + ((ZenStoreClient<Object, Object>) c2).getClientId()
                                                                                               .toString());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155400/fstmerge_var2_3443309361033709788
        checkForMbeanFound(c1Name);
        checkForMbeanFound(c2Name);
        mbServer.unregisterMBean(c1Name);
        mbServer.unregisterMBean(c2Name);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/test/unit/voldemort/client/ClientJmxTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Test
    public void testSameContextAndFactory() throws Exception {
        String clientContext = "clientContext";
        String jmxId = getAndIncrementJmxId();
        StoreClientFactory factory = getFactoryWithClientContext(clientContext,
                                                                 getValidBootstrapUrl());

        StoreClient<Object, Object>[] clients = new StoreClient[2];
        for(int i = 0; i < 2; i++) {
            clients[i] = factory.getStoreClient(getValidStoreName());
        }

        ObjectName cName = JmxUtils.createObjectName(AGGREGATE_STATS_DOMAIN, "aggregate-perf"
                                                                             + jmxId);
        checkForMbeanFound(cName);
        mbServer.unregisterMBean(cName);

        // checking for per store stats
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155404/fstmerge_var1_1290436725292922516
        String ctype = "test" + jmxId;
        ObjectName c1Name = JmxUtils.createObjectName(STATS_DOMAIN, ctype);
        ObjectName c2Name = JmxUtils.createObjectName(STATS_DOMAIN, ctype);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155404/fstmerge_base_3574844008582975746
        String ctype = clientContext + ".test" + jmxId;
        ObjectName c1Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                                      ctype
                                                              + "."
                                                              + ((DefaultStoreClient<Object, Object>) clients[0]).getClientId()
                                                                                                                 .toString());
        ObjectName c2Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                                      ctype
                                                              + "."
                                                              + ((DefaultStoreClient<Object, Object>) clients[1]).getClientId()
                                                                                                                 .toString());
=======
        String ctype = clientContext + ".test" + jmxId;
        ObjectName c1Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                                      ctype
                                                              + "."
                                                              + ((ZenStoreClient<Object, Object>) clients[0]).getClientId()
                                                                                                                  .toString());
        ObjectName c2Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                                      ctype
                                                              + "."
                                                              + ((ZenStoreClient<Object, Object>) clients[1]).getClientId()
                                                                                                                  .toString());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155404/fstmerge_var2_6866988158004827659
        checkForMbeanFound(c1Name);
        checkForMbeanFound(c2Name);
        mbServer.unregisterMBean(c1Name);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/test/unit/voldemort/client/ClientJmxTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Test
    public void testDifferentId() throws Exception {
        String clientContext = "clientContext";
        String jmxId = getAndIncrementJmxId();
        StoreClientFactory factory = getFactoryWithClientContext(clientContext,
                                                                 getValidBootstrapUrl());

        StoreClient<Object, Object>[] clients = new StoreClient[2];
        clients[0] = factory.getStoreClient(getValidStoreName());
        clients[1] = factory.getStoreClient(getValidStoreName());

        ObjectName cName = JmxUtils.createObjectName(AGGREGATE_STATS_DOMAIN, "aggregate-perf"
                                                                             + jmxId);
        checkForMbeanFound(cName);
        mbServer.unregisterMBean(cName);

        // checking for per store stats
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155409/fstmerge_var1_7974654346501857712
        String ctype = "test" + jmxId;
        ObjectName c1Name = JmxUtils.createObjectName(STATS_DOMAIN, ctype);
        ObjectName c2Name = JmxUtils.createObjectName(STATS_DOMAIN, ctype);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155409/fstmerge_base_2222406511681433437
        String ctype = clientContext + ".test" + jmxId;
        ObjectName c1Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                                      ctype
                                                              + "."
                                                              + ((DefaultStoreClient<Object, Object>) clients[0]).getClientId()
                                                                                                                 .toString());
        ObjectName c2Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                                      ctype
                                                              + "."
                                                              + ((DefaultStoreClient<Object, Object>) clients[1]).getClientId()
                                                                                                                 .toString());
=======
        String ctype = clientContext + ".test" + jmxId;
        ObjectName c1Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                                      ctype
                                                              + "."
                                                              + ((ZenStoreClient<Object, Object>) clients[0]).getClientId()
                                                                                                                  .toString());
        ObjectName c2Name = JmxUtils.createObjectName(STATS_DOMAIN,
                                                      ctype
                                                              + "."
                                                              + ((ZenStoreClient<Object, Object>) clients[1]).getClientId()
                                                                                                                  .toString());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786155409/fstmerge_var2_8073365733694775493
        checkForMbeanFound(c1Name);
        checkForMbeanFound(c2Name);
        // assertTrue(!c1Name.equals(c2Name));
        mbServer.unregisterMBean(c1Name);
        // mbServer.unregisterMBean(c2Name);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/test/unit/voldemort/client/ClientJmxTest.java
Conflict type: LineBasedMCFd
Conflict body: 
public <K, V> StoreClient<K, V> getStoreClient(String storeName,
                                                   InconsistencyResolver<Versioned<V>> resolver) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786159511/fstmerge_var1_3553663639241012974
        SchedulerService service = new SchedulerService(config.getAsyncJobThreadPoolSize(),
                                                        SystemTime.INSTANCE,
                                                        true);
        clientAsyncServiceRepo.add(service);

        return new DefaultStoreClient<K, V>(storeName,
                                            resolver,
                                            this,
                                            3,
                                            clientContextName,
                                            clientSequencer.getAndIncrement(),
                                            config,
                                            service);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786159511/fstmerge_base_8578373653693477675
        return new DefaultStoreClient<K, V>(storeName,
                                            resolver,
                                            this,
                                            3,
                                            clientContextName,
                                            sequencer.getAndIncrement(),
                                            config);
=======
        if(this.config.isDefaultClientEnabled()) {
            return new DefaultStoreClient<K, V>(storeName, resolver, this, 3);
        }

        return new ZenStoreClient<K, V>(storeName,
                                             resolver,
                                             this,
                                             3,
                                             clientContextName,
                                             sequencer.getAndIncrement(),
                                             config);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786159511/fstmerge_var2_643948627980866667
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/src/java/voldemort/client/AbstractStoreClientFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
private void setProperties(Properties properties) {
        Props props = new Props(properties);
        if(props.containsKey(MAX_CONNECTIONS_PER_NODE_PROPERTY))
            this.setMaxConnectionsPerNode(props.getInt(MAX_CONNECTIONS_PER_NODE_PROPERTY));

        if(props.containsKey(MAX_TOTAL_CONNECTIONS_PROPERTY))
            this.setMaxTotalConnections(props.getInt(MAX_TOTAL_CONNECTIONS_PROPERTY));

        if(props.containsKey(MAX_THREADS_PROPERTY))
            this.setMaxThreads(props.getInt(MAX_THREADS_PROPERTY));

        if(props.containsKey(MAX_QUEUED_REQUESTS_PROPERTY))
            this.setMaxQueuedRequests(props.getInt(MAX_QUEUED_REQUESTS_PROPERTY));

        if(props.containsKey(THREAD_IDLE_MS_PROPERTY))
            this.setThreadIdleTime(props.getLong(THREAD_IDLE_MS_PROPERTY), TimeUnit.MILLISECONDS);

        if(props.containsKey(CONNECTION_TIMEOUT_MS_PROPERTY))
            this.setConnectionTimeout(props.getInt(CONNECTION_TIMEOUT_MS_PROPERTY),
                                      TimeUnit.MILLISECONDS);

        if(props.containsKey(SOCKET_TIMEOUT_MS_PROPERTY))
            this.setSocketTimeout(props.getInt(SOCKET_TIMEOUT_MS_PROPERTY), TimeUnit.MILLISECONDS);

        if(props.containsKey(SOCKET_KEEPALIVE_PROPERTY))
            this.setSocketKeepAlive(props.getBoolean(SOCKET_KEEPALIVE_PROPERTY));

        if(props.containsKey(SELECTORS_PROPERTY))
            this.setSelectors(props.getInt(SELECTORS_PROPERTY));

        if(props.containsKey(ROUTING_TIMEOUT_MS_PROPERTY))
            this.setRoutingTimeout(props.getInt(ROUTING_TIMEOUT_MS_PROPERTY), TimeUnit.MILLISECONDS);

        // By default, make all the timeouts equal to routing timeout
        timeoutConfig = new TimeoutConfig(routingTimeoutMs, false);

        if(props.containsKey(GETALL_ROUTING_TIMEOUT_MS_PROPERTY))
            timeoutConfig.setOperationTimeout(VoldemortOpCode.GET_ALL_OP_CODE,
                                              props.getInt(GETALL_ROUTING_TIMEOUT_MS_PROPERTY));

        if(props.containsKey(GET_ROUTING_TIMEOUT_MS_PROPERTY))
            timeoutConfig.setOperationTimeout(VoldemortOpCode.GET_OP_CODE,
                                              props.getInt(GET_ROUTING_TIMEOUT_MS_PROPERTY));

        if(props.containsKey(PUT_ROUTING_TIMEOUT_MS_PROPERTY)) {
            long putTimeoutMs = props.getInt(PUT_ROUTING_TIMEOUT_MS_PROPERTY);
            timeoutConfig.setOperationTimeout(VoldemortOpCode.PUT_OP_CODE, putTimeoutMs);
            // By default, use the same thing for getVersions() also
            timeoutConfig.setOperationTimeout(VoldemortOpCode.GET_VERSION_OP_CODE, putTimeoutMs);
        }

        // of course, if someone overrides it, we will respect that
        if(props.containsKey(GET_VERSIONS_ROUTING_TIMEOUT_MS_PROPERTY))
            timeoutConfig.setOperationTimeout(VoldemortOpCode.GET_VERSION_OP_CODE,
                                              props.getInt(GET_VERSIONS_ROUTING_TIMEOUT_MS_PROPERTY));

        if(props.containsKey(DELETE_ROUTING_TIMEOUT_MS_PROPERTY))
            timeoutConfig.setOperationTimeout(VoldemortOpCode.DELETE_OP_CODE,
                                              props.getInt(DELETE_ROUTING_TIMEOUT_MS_PROPERTY));

        if(props.containsKey(ALLOW_PARTIAL_GETALLS_PROPERTY))
            timeoutConfig.setPartialGetAllAllowed(props.getBoolean(ALLOW_PARTIAL_GETALLS_PROPERTY));

        if(props.containsKey(SOCKET_BUFFER_SIZE_PROPERTY))
            this.setSocketBufferSize(props.getInt(SOCKET_BUFFER_SIZE_PROPERTY));

        if(props.containsKey(SERIALIZER_FACTORY_CLASS_PROPERTY)) {
            Class<?> factoryClass = ReflectUtils.loadClass(props.getString(SERIALIZER_FACTORY_CLASS_PROPERTY));
            SerializerFactory factory = (SerializerFactory) ReflectUtils.callConstructor(factoryClass,
                                                                                         new Object[] {});
            this.setSerializerFactory(factory);
        }

        if(props.containsKey(BOOTSTRAP_URLS_PROPERTY))
            this.setBootstrapUrls(props.getList(BOOTSTRAP_URLS_PROPERTY));

        if(props.containsKey(REQUEST_FORMAT_PROPERTY))
            this.setRequestFormatType(RequestFormatType.fromCode(props.getString(REQUEST_FORMAT_PROPERTY)));

        if(props.containsKey(ENABLE_JMX_PROPERTY))
            this.setEnableJmx(props.getBoolean(ENABLE_JMX_PROPERTY));

        if(props.containsKey(ENABLE_LAZY_PROPERTY))
            this.setEnableLazy(props.getBoolean(ENABLE_LAZY_PROPERTY));

        if(props.containsKey(ENABLE_PIPELINE_ROUTED_STORE_PROPERTY))
            this.setEnablePipelineRoutedStore(props.getBoolean(ENABLE_PIPELINE_ROUTED_STORE_PROPERTY));

        if(props.containsKey(CLIENT_ZONE_ID))
            this.setClientZoneId(props.getInt(CLIENT_ZONE_ID));

        if(props.containsKey(USE_DEFAULT_CLIENT))
            this.enableDefaultClient(props.getBoolean(USE_DEFAULT_CLIENT));

        if(props.containsKey(FAILUREDETECTOR_IMPLEMENTATION_PROPERTY))
            this.setFailureDetectorImplementation(props.getString(FAILUREDETECTOR_IMPLEMENTATION_PROPERTY));

        // We're changing the property from "node_bannage_ms" to
        // "failuredetector_bannage_period" so if we have the old one, migrate
        // it over.
        if(props.containsKey(NODE_BANNAGE_MS_PROPERTY)
           && !props.containsKey(FAILUREDETECTOR_BANNAGE_PERIOD_PROPERTY)) {
            props.put(FAILUREDETECTOR_BANNAGE_PERIOD_PROPERTY, props.get(NODE_BANNAGE_MS_PROPERTY));
        }

        if(props.containsKey(FAILUREDETECTOR_BANNAGE_PERIOD_PROPERTY))
            this.setFailureDetectorBannagePeriod(props.getLong(FAILUREDETECTOR_BANNAGE_PERIOD_PROPERTY));

        if(props.containsKey(FAILUREDETECTOR_THRESHOLD_PROPERTY))
            this.setFailureDetectorThreshold(props.getInt(FAILUREDETECTOR_THRESHOLD_PROPERTY));

        if(props.containsKey(FAILUREDETECTOR_THRESHOLD_COUNTMINIMUM_PROPERTY))
            this.setFailureDetectorThresholdCountMinimum(props.getInt(FAILUREDETECTOR_THRESHOLD_COUNTMINIMUM_PROPERTY));

        if(props.containsKey(FAILUREDETECTOR_THRESHOLD_INTERVAL_PROPERTY))
            this.setFailureDetectorThresholdInterval(props.getLong(FAILUREDETECTOR_THRESHOLD_INTERVAL_PROPERTY));

        if(props.containsKey(FAILUREDETECTOR_ASYNCRECOVERY_INTERVAL_PROPERTY))
            this.setFailureDetectorAsyncRecoveryInterval(props.getLong(FAILUREDETECTOR_ASYNCRECOVERY_INTERVAL_PROPERTY));

        if(props.containsKey(FAILUREDETECTOR_CATASTROPHIC_ERROR_TYPES_PROPERTY))
            this.setFailureDetectorCatastrophicErrorTypes(props.getList(FAILUREDETECTOR_CATASTROPHIC_ERROR_TYPES_PROPERTY));

        if(props.containsKey(FAILUREDETECTOR_REQUEST_LENGTH_THRESHOLD_PROPERTY))
            this.setFailureDetectorRequestLengthThreshold(props.getLong(FAILUREDETECTOR_REQUEST_LENGTH_THRESHOLD_PROPERTY));
        else
            this.setFailureDetectorRequestLengthThreshold(getSocketTimeout(TimeUnit.MILLISECONDS));

        if(props.containsKey(MAX_BOOTSTRAP_RETRIES))
            this.setMaxBootstrapRetries(props.getInt(MAX_BOOTSTRAP_RETRIES));

        if(props.containsKey(CLIENT_CONTEXT_NAME)) {
            this.setClientContextName(props.getString(CLIENT_CONTEXT_NAME));
        }

        if(props.containsKey(ASYNC_CHECK_METADATA_INTERVAL)) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786159821/fstmerge_var1_3443607326620649718
            this.setAsyncCheckMetadataInterval(props.getLong(ASYNC_CHECK_METADATA_INTERVAL));
        }

        if(props.containsKey(CLIENT_REGISTRY_REFRESH_INTERVAL)) {
            this.setClientRegistryRefreshInterval(props.getInt(CLIENT_REGISTRY_REFRESH_INTERVAL));
        }

        if(props.containsKey(ASYNC_JOB_THREAD_POOL_SIZE)) {
            this.setClientRegistryRefreshInterval(props.getInt(ASYNC_JOB_THREAD_POOL_SIZE));
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786159821/fstmerge_base_9129489164082406708
            this.setAsyncCheckMetadataInterval(props.getLong(ASYNC_CHECK_METADATA_INTERVAL, 5000));
=======
            this.setAsyncMetadataRefreshInMs(props.getLong(ASYNC_CHECK_METADATA_INTERVAL, 5000));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786159821/fstmerge_var2_4927904615382631345
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/src/java/voldemort/client/ClientConfig.java
Conflict type: LineBasedMCFd
Conflict body: 
public DefaultStoreClient(String storeName,
                              InconsistencyResolver<Versioned<V>> resolver,
                              StoreClientFactory storeFactory,
                              int maxMetadataRefreshAttempts) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786160207/fstmerge_var1_6256935120789469139
        this(storeName, resolver, storeFactory, maxMetadataRefreshAttempts, null, 0, null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786160207/fstmerge_base_2739490087091363216
        this(storeName, resolver, storeFactory, maxMetadataRefreshAttempts, null, 0, null);
=======
        this.storeName = Utils.notNull(storeName);
        this.resolver = resolver;
        this.storeFactory = Utils.notNull(storeFactory);
        this.metadataRefreshAttempts = maxMetadataRefreshAttempts;

        // Registering self to be able to bootstrap client dynamically via JMX
        JmxUtils.registerMbean(this,
                               JmxUtils.createObjectName(JmxUtils.getPackageName(this.getClass()),
                                                         JmxUtils.getClassName(this.getClass())
                                                                 + "." + storeName));

        bootStrap();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786160207/fstmerge_var2_6895129948962981360
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/src/java/voldemort/client/DefaultStoreClient.java
Conflict type: LineBasedMCFd
Conflict body: 
@JmxOperation(description = "bootstrap metadata from the cluster.")
    public void bootStrap() {
        logger.info("Bootstrapping metadata for store " + this.storeName);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786160212/fstmerge_var1_4580228165322236389

        /*
         * Since we need cluster.xml for bootstrapping this client as well as
         * all the System stores, just fetch it once and pass it around.
         * 
         * Seems hackish since bootstrapMetadataWithRetries only exists for
         * AbstractStoreClientFactory. TODO: Think about making this part of the
         * generic interface ?
         */
        clusterXml = ((AbstractStoreClientFactory) storeFactory).bootstrapMetadataWithRetries(MetadataStore.CLUSTER_KEY);

        this.store = storeFactory.getRawStore(storeName, resolver, null, clusterXml);

        // Create system stores
        logger.info("Creating system stores for store " + this.storeName);
        this.sysRepository.createSystemStores(this.config, this.clusterXml);

        /*
         * Update to the new metadata versions (in case we got here from Invalid
         * Metadata exception). This will prevent another bootstrap via the
         * Async metadata checker
         */
        if(asyncCheckMetadata != null) {
            asyncCheckMetadata.updateMetadataVersions();
        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786160212/fstmerge_base_8039723264131904135

        /*
         * Since we need cluster.xml for bootstrapping this client as well as
         * all the System stores, just fetch it once and pass it around.
         * 
         * Seems hackish since bootstrapMetadataWithRetries only exists for
         * AbstractStoreClientFactory. TODO: Think about making this part of the
         * generic interface ?
         */
        clusterXml = ((AbstractStoreClientFactory) storeFactory).bootstrapMetadataWithRetries(MetadataStore.CLUSTER_KEY);

        this.store = storeFactory.getRawStore(storeName, resolver, clientId, null, clusterXml);

        // Create system stores
        logger.info("Creating system stores for store " + this.storeName);
        this.sysRepository.createSystemStores(this.config, this.clusterXml);

        /*
         * Update to the new metadata versions (in case we got here from Invalid
         * Metadata exception). This will prevent another bootstrap via the
         * Async metadata checker
         */
        if(asyncCheckMetadata != null) {
            asyncCheckMetadata.updateMetadataVersions();
        }
=======
        this.store = storeFactory.getRawStore(storeName, resolver);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786160212/fstmerge_var2_1539946223965272906
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/src/java/voldemort/client/DefaultStoreClient.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ private final String clientId; ##FSTMerge## private final UUID clientId; ##FSTMerge##
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/src/java/voldemort/client/DefaultStoreClient.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786160287/fstmerge_var1_2653365854588811114
private void registerClient(String jobId, int interval) {
        SystemStore<String, ClientInfo> clientRegistry = this.sysRepository.getClientRegistryStore();
        if(null != clientRegistry) {
            try {
                Version version = clientRegistry.putSysStore(clientId, clientInfo);
                ClientRegistryRefresher refresher = new ClientRegistryRefresher(clientRegistry,
                                                                                clientId,
                                                                                clientInfo,
                                                                                version);
                GregorianCalendar cal = new GregorianCalendar();
                cal.add(Calendar.SECOND, interval);

                if(scheduler != null) {
                    scheduler.schedule(jobId + refresher.getClass().getName(),
                                       refresher,
                                       cal.getTime(),
                                       TimeUnit.MILLISECONDS.convert(interval, TimeUnit.SECONDS));
                    logger.info("Client registry refresher thread started, refresh interval: "
                                + interval + " seconds");
                } else {
                    logger.warn("Client registry won't run because scheduler service is not configured");
                }
            } catch(Exception e) {
                logger.warn("Unable to register with the cluster due to the following error:", e);
            }
        } else {
            logger.warn(SystemStoreConstants.SystemStoreName.voldsys$_client_registry.name()
                        + " not found. Unable to registry with voldemort cluster.");
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786160287/fstmerge_base_994715529618630222
private void registerClient(String jobId, int interval) {
        SystemStore<String, ClientInfo> clientRegistry = this.sysRepository.getClientRegistryStore();
        if(null != clientRegistry) {
            try {
                Version version = clientRegistry.putSysStore(clientId.toString(), clientInfo);
                ClientRegistryRefresher refresher = new ClientRegistryRefresher(clientRegistry,
                                                                                clientId.toString(),
                                                                                clientInfo,
                                                                                version);
                GregorianCalendar cal = new GregorianCalendar();
                cal.add(Calendar.SECOND, interval);
                scheduler.schedule(jobId + refresher.getClass().getName(),
                                   refresher,
                                   cal.getTime(),
                                   interval * 1000);
                logger.info("Client registry refresher thread started, refresh frequency: "
                            + interval + " seconds");
            } catch(Exception e) {
                logger.warn("Unable to register with the cluster due to the following error:", e);
            }
        } else {
            logger.warn(SystemStoreConstants.SystemStoreName.voldsys$_client_registry.name()
                        + "not found. Unable to registry with voldemort cluster.");
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786160287/fstmerge_var2_8934965987218349521

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/src/java/voldemort/client/DefaultStoreClient.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786160292/fstmerge_var1_1662452083869567591
private AsyncMetadataVersionManager scheduleMetadataChecker(String jobId, long interval) {
        AsyncMetadataVersionManager asyncCheckMetadata = null;
        SystemStore<String, Long> versionStore = this.sysRepository.getVersionStore();
        if(versionStore == null)
            logger.warn("Metadata version system store not found. Cannot run Metadata version check thread.");
        else {

            // Create a callback for re-bootstrapping the client
            Callable<Void> rebootstrapCallback = new Callable<Void>() {

                public Void call() throws Exception {
                    bootStrap();
                    return null;
                }
            };

            asyncCheckMetadata = new AsyncMetadataVersionManager(this.sysRepository,
                                                                 rebootstrapCallback);

            // schedule the job to run every 'checkInterval' period, starting
            // now
            if(scheduler != null) {
                scheduler.schedule(jobId + asyncCheckMetadata.getClass().getName(),
                                   asyncCheckMetadata,
                                   new Date(),
                                   interval);
                logger.info("Metadata version check thread started. Frequency = Every " + interval
                            + " ms");
            } else {
                logger.warn("Metadata version check thread won't start because the scheduler service is not configured.");
            }
        }
        return asyncCheckMetadata;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786160292/fstmerge_base_6908869326879014699
private AsyncMetadataVersionManager scheduleMetadataChecker(String jobId, long interval) {
        AsyncMetadataVersionManager asyncCheckMetadata = null;
        SystemStore<String, Long> versionStore = this.sysRepository.getVersionStore();
        if(versionStore == null)
            logger.warn("Metadata version system store not found. Cannot run Metadata version check thread.");
        else {

            // Create a callback for re-bootstrapping the client
            Callable<Void> rebootstrapCallback = new Callable<Void>() {

                public Void call() throws Exception {
                    bootStrap();
                    return null;
                }
            };

            asyncCheckMetadata = new AsyncMetadataVersionManager(this.sysRepository,
                                                                 rebootstrapCallback);

            // schedule the job to run every 'checkInterval' period, starting
            // now
            scheduler.schedule(jobId + asyncCheckMetadata.getClass().getName(),
                               asyncCheckMetadata,
                               new Date(),
                               interval);
            logger.info("Metadata version check thread started. Frequency = Every " + interval
                        + " ms");

        }
        return asyncCheckMetadata;
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786160292/fstmerge_var2_1182821126433293526

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/src/java/voldemort/client/DefaultStoreClient.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786160297/fstmerge_var1_7640634460006548843
public String getClientId() {
        return clientId;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786160297/fstmerge_base_1007843750318114161
public UUID getClientId() {
        return clientId;
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786160297/fstmerge_var2_7594018031795581111

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/src/java/voldemort/client/DefaultStoreClient.java
Conflict type: LineBasedMCFd
Conflict body: 
public void run() {

        if(hadConflict) {
            // if we previously had a conflict during update, we will try to get
            // a newer version before update this time. This case shall not
            // happen under regular circumstances. But it is just avoid update
            // keeping failing when strange situations occur.
            lastVersion = clientRegistry.getSysStore(clientId).getVersion();
            hadConflict = false;
        }
        clientInfo.setUpdateTime(System.currentTimeMillis());
        logger.info("updating client registry with the following info for client: " + clientId
                    + "\n" + clientInfo);
        try {
            lastVersion = clientRegistry.putSysStore(clientId,
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786179406/fstmerge_var1_421736969692384822
                                                     new Versioned<ClientInfo>(clientInfo,
                                                                               lastVersion));
        } catch(ObsoleteVersionException e) {
            Versioned<ClientInfo> existingValue = clientRegistry.getSysStore(clientId);
            logger.warn("Multiple clients are updating the same client registry entry");
            logger.warn("  current value: " + clientInfo + " " + lastVersion);
            logger.warn("  existing value: " + existingValue.getValue() + " "
                        + existingValue.getVersion());
            hadConflict = true;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786179406/fstmerge_base_7409375618847808964
                                                     new Versioned<ClientInfo>(clientInfo,
                                                                               lastVersion));
=======
                                                     new Versioned<String>(clientInfo.toString(),
                                                                           lastVersion));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786179406/fstmerge_var2_4984269253948032899
        } catch(Exception e) {
            logger.warn("encountered the following error while trying to update client registry: "
                        + e);
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/src/java/voldemort/client/scheduler/ClientRegistryRefresher.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786179411/fstmerge_var1_7751796308856554615
public ClientRegistryRefresher(SystemStore<String, ClientInfo> clientRegistry,
                                   String clientId,
                                   ClientInfo clientInfo,
                                   Version version) {
        this.clientRegistry = clientRegistry;
        this.clientInfo = clientInfo;
        this.clientId = clientId;
        this.lastVersion = version;
        this.hadConflict = false;
        logger.info("Initial version obtained from client registry: " + version);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786179411/fstmerge_base_2540273198853147638
public ClientRegistryRefresher(SystemStore<String, ClientInfo> clientRegistry,
                                   String clientId,
                                   ClientInfo clientInfo,
                                   Version version) {
        this.clientRegistry = clientRegistry;
        this.clientInfo = clientInfo;
        this.clientId = clientId;
        this.lastVersion = version;
        logger.info("Initial version obtained from client registry: " + version);
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415786179411/fstmerge_var2_4894712784837643709

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/src/java/voldemort/client/scheduler/ClientRegistryRefresher.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ public static final String SYSTEM_STORE_SCHEMA = "<stores>"
                                                     + "  <store>"
                                                     + "    <name>voldsys$_client_registry</name>"
                                                     + "    <routing-strategy>all-routing</routing-strategy>"
                                                     + "    <hinted-handoff-strategy>proximity-handoff</hinted-handoff-strategy>"
                                                     + "    <persistence>memory</persistence>"
                                                     + "    <routing>client</routing>"
                                                     + "    <replication-factor>4</replication-factor>"
                                                     + "    <zone-replication-factor>"
                                                     + "      <replication-factor zone-id=\"0\">2</replication-factor>"
                                                     + "      <replication-factor zone-id=\"1\">2</replication-factor>"
                                                     + "    </zone-replication-factor>"
                                                     + "    <required-reads>1</required-reads>"
                                                     + "    <required-writes>1</required-writes>"
                                                     + "    <key-serializer>"
                                                     + "      <type>string</type>"
                                                     + "     <schema-info version=\"0\">utf8</schema-info>"
                                                     + "    </key-serializer>"
                                                     + "    <value-serializer>"
                                                     + "      <type>java-serialization</type>"
                                                     + "    </value-serializer>"
                                                     + "    <retention-days>7</retention-days>"
                                                     + "  </store>"

                                                     + "  <store>"
                                                     + "    <name>voldsys$_client_store_definition</name>"
                                                     + "    <routing-strategy>zone-routing</routing-strategy>"
                                                     + "    <hinted-handoff-strategy>proximity-handoff</hinted-handoff-strategy>"
                                                     + "    <persistence>memory</persistence>"
                                                     + "    <routing>client</routing>"
                                                     + "    <replication-factor>1</replication-factor>"
                                                     + "    <required-reads>1</required-reads>"
                                                     + "    <required-writes>1</required-writes>"
                                                     + "    <key-serializer>"
                                                     + "      <type>string</type>"
                                                     + "    </key-serializer>"
                                                     + "    <value-serializer>"
                                                     + "      <type>string</type>"
                                                     + "    </value-serializer>"
                                                     + "    <retention-days>7</retention-days>"
                                                     + "  </store>"

                                                     + "  <store>"
                                                     + "    <name>voldsys$_metadata_version</name>"
                                                     + "    <routing-strategy>local-pref-all-routing</routing-strategy>"
                                                     + "    <hinted-handoff-strategy>proximity-handoff</hinted-handoff-strategy>"
                                                     + "    <persistence>memory</persistence>"
                                                     + "    <routing>client</routing>"
                                                     + "    <replication-factor>1</replication-factor>"
                                                     + "    <required-reads>1</required-reads>"
                                                     + "    <required-writes>1</required-writes>"
                                                     + "    <key-serializer>"
                                                     + "      <type>string</type>"
                                                     + "    </key-serializer>"
                                                     + "    <value-serializer>"
                                                     + "      <type>java-serialization</type>"
                                                     + "    </value-serializer>" + "  </store>"

                                                     + "</stores>"; ##FSTMerge## public static final String SYSTEM_STORE_SCHEMA = "<stores>"
                                                     + "  <store>"
                                                     + "    <name>voldsys$_client_registry</name>"
                                                     + "    <routing-strategy>all-routing</routing-strategy>"
                                                     + "    <hinted-handoff-strategy>proximity-handoff</hinted-handoff-strategy>"
                                                     + "    <persistence>memory</persistence>"
                                                     + "    <routing>client</routing>"
                                                     + "    <replication-factor>4</replication-factor>"
                                                     + "    <zone-replication-factor>"
                                                     + "      <replication-factor zone-id=\"0\">2</replication-factor>"
                                                     + "      <replication-factor zone-id=\"1\">2</replication-factor>"
                                                     + "    </zone-replication-factor>"
                                                     + "    <required-reads>1</required-reads>"
                                                     + "    <required-writes>1</required-writes>"
                                                     + "    <key-serializer>"
                                                     + "      <type>string</type>"
                                                     + "     <schema-info version=\"0\">utf8</schema-info>"
                                                     + "    </key-serializer>"
                                                     + "    <value-serializer>"
                                                     // +
                                                     // "      <type>avro-specific</type>"
                                                     // +
                                                     // "      <schema-info version=\"0\">java=voldemort.client.ClientInfo</schema-info>"
                                                     + "      <type>java-serialization</type>"
                                                     + "    </value-serializer>"
                                                     + "    <retention-days>7</retention-days>"
                                                     + "  </store>"

                                                     + "  <store>"
                                                     + "    <name>voldsys$_client_store_definition</name>"
                                                     + "    <routing-strategy>zone-routing</routing-strategy>"
                                                     + "    <hinted-handoff-strategy>proximity-handoff</hinted-handoff-strategy>"
                                                     + "    <persistence>memory</persistence>"
                                                     + "    <routing>client</routing>"
                                                     + "    <replication-factor>1</replication-factor>"
                                                     + "    <required-reads>1</required-reads>"
                                                     + "    <required-writes>1</required-writes>"
                                                     + "    <key-serializer>"
                                                     + "      <type>string</type>"
                                                     + "    </key-serializer>"
                                                     + "    <value-serializer>"
                                                     + "      <type>string</type>"
                                                     + "    </value-serializer>"
                                                     + "    <retention-days>7</retention-days>"
                                                     + "  </store>"

                                                     + "  <store>"
                                                     + "    <name>voldsys$_metadata_version</name>"
                                                     + "    <routing-strategy>local-pref-all-routing</routing-strategy>"
                                                     + "    <hinted-handoff-strategy>proximity-handoff</hinted-handoff-strategy>"
                                                     + "    <persistence>memory</persistence>"
                                                     + "    <routing>client</routing>"
                                                     + "    <replication-factor>1</replication-factor>"
                                                     + "    <required-reads>1</required-reads>"
                                                     + "    <required-writes>1</required-writes>"
                                                     + "    <key-serializer>"
                                                     + "      <type>string</type>"
                                                     + "    </key-serializer>"
                                                     + "    <value-serializer>"
                                                     + "      <type>java-serialization</type>"
                                                     + "    </value-serializer>" + "  </store>"

                                                     + "</stores>"; ##FSTMerge## public static final String SYSTEM_STORE_SCHEMA = "<stores>"
                                                     + "  <store>"
                                                     + "    <name>voldsys$_client_registry</name>"
                                                     + "    <routing-strategy>all-routing</routing-strategy>"
                                                     + "    <hinted-handoff-strategy>proximity-handoff</hinted-handoff-strategy>"
                                                     + "    <persistence>memory</persistence>"
                                                     + "    <routing>client</routing>"
                                                     + "    <replication-factor>4</replication-factor>"
                                                     + "    <zone-replication-factor>"
                                                     + "      <replication-factor zone-id=\"0\">2</replication-factor>"
                                                     + "      <replication-factor zone-id=\"1\">2</replication-factor>"
                                                     + "    </zone-replication-factor>"
                                                     + "    <required-reads>1</required-reads>"
                                                     + "    <required-writes>1</required-writes>"
                                                     + "    <key-serializer>"
                                                     + "      <type>string</type>"
                                                     + "     <schema-info version=\"0\">utf8</schema-info>"
                                                     + "    </key-serializer>"
                                                     + "    <value-serializer>"
                                                     + "      <type>string</type>"
                                                     + "    </value-serializer>"
                                                     + "    <retention-days>7</retention-days>"
                                                     + "  </store>"

                                                     + "  <store>"
                                                     + "    <name>voldsys$_metadata_version</name>"
                                                     + "    <routing-strategy>local-pref-all-routing</routing-strategy>"
                                                     + "    <hinted-handoff-strategy>proximity-handoff</hinted-handoff-strategy>"
                                                     + "    <persistence>memory</persistence>"
                                                     + "    <routing>client</routing>"
                                                     + "    <replication-factor>1</replication-factor>"
                                                     + "    <required-reads>1</required-reads>"
                                                     + "    <required-writes>1</required-writes>"
                                                     + "    <key-serializer>"
                                                     + "      <type>string</type>"
                                                     + "    </key-serializer>"
                                                     + "    <value-serializer>"
                                                     + "      <type>string</type>"
                                                     + "    </value-serializer>"
                                                     + "  </store>"

                                                     + "  <store>"
                                                     + "    <name>voldsys$_metadata_version_persistence</name>"
                                                     + "    <routing-strategy>local-pref-all-routing</routing-strategy>"
                                                     + "    <hinted-handoff-strategy>proximity-handoff</hinted-handoff-strategy>"
                                                     + "    <persistence>file</persistence>"
                                                     + "    <routing>client</routing>"
                                                     + "    <replication-factor>1</replication-factor>"
                                                     + "    <required-reads>1</required-reads>"
                                                     + "    <required-writes>1</required-writes>"
                                                     + "    <key-serializer>"
                                                     + "      <type>string</type>"
                                                     + "    </key-serializer>"
                                                     + "    <value-serializer>"
                                                     + "      <type>string</type>"
                                                     + "    </value-serializer>" + "  </store>"

                                                     + "</stores>";
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e77ee_fcffe/rev_e77ee-fcffe/src/java/voldemort/store/system/SystemStoreConstants.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5410_78ae5/rev_c5410-78ae5.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@SuppressWarnings("unchecked")
    public static void main(String[] args) throws Exception {
        OptionParser parser = new OptionParser();
        parser.accepts("help", "print help information");
        parser.accepts("url", "[REQUIRED] bootstrap URL")
              .withRequiredArg()
              .describedAs("bootstrap-url")
              .ofType(String.class);
        parser.accepts("node", "node id")
              .withRequiredArg()
              .describedAs("node-id")
              .ofType(Integer.class);
        parser.accepts("delete-partitions", "Delete partitions")
              .withRequiredArg()
              .describedAs("partition-ids")
              .withValuesSeparatedBy(',')
              .ofType(Integer.class);
        parser.accepts("restore",
                       "Restore from replication [ Optional parallelism param - Default - 5 ]")
              .withOptionalArg()
              .describedAs("parallelism")
              .ofType(Integer.class);
        parser.accepts("ascii", "Fetch keys as ASCII");
        parser.accepts("fetch-keys", "Fetch keys")
              .withOptionalArg()
              .describedAs("partition-ids")
              .withValuesSeparatedBy(',')
              .ofType(Integer.class);
        parser.accepts("fetch-entries", "Fetch full entries")
              .withOptionalArg()
              .describedAs("partition-ids")
              .withValuesSeparatedBy(',')
              .ofType(Integer.class);
        parser.accepts("outdir", "Output directory")
              .withRequiredArg()
              .describedAs("output-directory")
              .ofType(String.class);
        parser.accepts("stores", "Store names")
              .withRequiredArg()
              .describedAs("store-names")
              .withValuesSeparatedBy(',')
              .ofType(String.class);
        parser.accepts("store", "Store name for querying keys")
              .withRequiredArg()
              .describedAs("store-name")
              .ofType(String.class);
        parser.accepts("add-stores", "Add stores in this stores.xml")
              .withRequiredArg()
              .describedAs("stores.xml containing just the new stores")
              .ofType(String.class);
        parser.accepts("delete-store", "Delete store")
              .withRequiredArg()
              .describedAs("store-name")
              .ofType(String.class);
        parser.accepts("update-entries", "Insert or update entries")
              .withRequiredArg()
              .describedAs("input-directory")
              .ofType(String.class);
        parser.accepts("get-metadata",
                       "retreive metadata information " + MetadataStore.METADATA_KEYS)
              .withOptionalArg()
              .describedAs("metadata-key")
              .ofType(String.class);
        parser.accepts("check-metadata",
                       "retreive metadata information from all nodes and checks if they are consistent across [ "
                               + MetadataStore.CLUSTER_KEY + " | " + MetadataStore.STORES_KEY
                               + " | " + MetadataStore.SERVER_STATE_KEY + " ]")
              .withRequiredArg()
              .describedAs("metadata-key")
              .ofType(String.class);
        parser.accepts("ro-metadata",
                       "retrieve version information [current | max | storage-format]")
              .withRequiredArg()
              .describedAs("type")
              .ofType(String.class);
        parser.accepts("truncate", "truncate a store")
              .withRequiredArg()
              .describedAs("store-name")
              .ofType(String.class);
        parser.accepts("set-metadata",
                       "Forceful setting of metadata [ " + MetadataStore.CLUSTER_KEY + " | "
                               + MetadataStore.STORES_KEY + " | " + MetadataStore.SERVER_STATE_KEY
                               + " | " + MetadataStore.REBALANCING_STEAL_INFO + " ]")
              .withRequiredArg()
              .describedAs("metadata-key")
              .ofType(String.class);
        parser.accepts("set-metadata-value",
                       "The value for the set-metadata [ " + MetadataStore.CLUSTER_KEY + " | "
                               + MetadataStore.STORES_KEY + ", "
                               + MetadataStore.REBALANCING_STEAL_INFO
                               + " ] - xml file location, [ " + MetadataStore.SERVER_STATE_KEY
                               + " ] - " + MetadataStore.VoldemortState.NORMAL_SERVER + ","
                               + MetadataStore.VoldemortState.REBALANCING_MASTER_SERVER)
              .withRequiredArg()
              .describedAs("metadata-value")
              .ofType(String.class);
        parser.accepts("key-distribution", "Prints the current key distribution of the cluster");
        parser.accepts("clear-rebalancing-metadata", "Remove the metadata related to rebalancing");
        parser.accepts("async",
                       "a) Get a list of async job ids [get] b) Stop async job ids [stop] ")
              .withRequiredArg()
              .describedAs("op-type")
              .ofType(String.class);
        parser.accepts("async-id", "Comma separated list of async ids to stop")
              .withOptionalArg()
              .describedAs("job-ids")
              .withValuesSeparatedBy(',')
              .ofType(Integer.class);
        parser.accepts("repair-job", "Clean after rebalancing is done");
        parser.accepts("native-backup", "Perform a native backup")
              .withRequiredArg()
              .describedAs("store-name")
              .ofType(String.class);
        parser.accepts("backup-dir")
              .withRequiredArg()
              .describedAs("backup-directory")
              .ofType(String.class);
        parser.accepts("backup-timeout")
              .withRequiredArg()
              .describedAs("minutes to wait for backup completion, default 30 mins")
              .ofType(Integer.class);
        parser.accepts("backup-verify",
                       "If provided, backup will also verify checksum (with extra overhead)");
        parser.accepts("backup-incremental",
                       "Perform an incremental backup for point-in-time recovery."
                               + " By default backup has latest consistent snapshot.");
        parser.accepts("zone", "zone id")
              .withRequiredArg()
              .describedAs("zone-id")
              .ofType(Integer.class);
        parser.accepts("rollback", "rollback a store")
              .withRequiredArg()
              .describedAs("store-name")
              .ofType(String.class);
        parser.accepts("version", "Push version of store to rollback to")
              .withRequiredArg()
              .describedAs("version")
              .ofType(Long.class);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787151884/fstmerge_var1_3880453383214879563
        parser.accepts("reserve-memory", "Memory in MB to reserve for the store")
              .withRequiredArg()
              .describedAs("size-in-mb")
              .ofType(Long.class);
        parser.accepts("query-keys", "Get values of keys on specific nodes")
              .withRequiredArg()
              .describedAs("query-keys")
              .withValuesSeparatedBy(',')
              .ofType(String.class);

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787151884/fstmerge_base_5106025042499841391

=======
        parser.accepts("verify-metadata-version",
                       "Verify the version of Metadata on all the cluster nodes");
        parser.accepts("synchronize-metadata-version",
                       "Synchronize the metadata versions across all the nodes.");
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787151884/fstmerge_var2_6733799024449803267
        OptionSet options = parser.parse(args);

        if(options.has("help")) {
            printHelp(System.out, parser);
            System.exit(0);
        }

        Set<String> missing = CmdUtils.missing(options, "url", "node");
        if(missing.size() > 0) {
            // Not the most elegant way to do this
            if(!(missing.equals(ImmutableSet.of("node"))
                 && (options.has("add-stores") || options.has("delete-store")
                     || options.has("ro-metadata") || options.has("set-metadata")
                     || options.has("get-metadata") || options.has("check-metadata") || options.has("key-distribution"))
                 || options.has("truncate") || options.has("clear-rebalancing-metadata")
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787151884/fstmerge_var1_3880453383214879563
                 || options.has("async") || options.has("native-backup") || options.has("rollback") || options.has("reserve-memory"))) {
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787151884/fstmerge_base_5106025042499841391
                 || options.has("async") || options.has("native-backup") || options.has("rollback"))) {
=======
                 || options.has("async") || options.has("native-backup") || options.has("rollback") || options.has("verify-metadata-version"))) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787151884/fstmerge_var2_6733799024449803267
                System.err.println("Missing required arguments: " + Joiner.on(", ").join(missing));
                printHelp(System.err, parser);
                System.exit(1);
            }
        }

        String url = (String) options.valueOf("url");
        Integer nodeId = CmdUtils.valueOf(options, "node", -1);
        int parallelism = CmdUtils.valueOf(options, "restore", 5);
        Integer zoneId = CmdUtils.valueOf(options, "zone", -1);

        int zone = zoneId == -1 ? 0 : zoneId;
        AdminClient adminClient = new AdminClient(url, new AdminClientConfig(), zone);

        if(options.has("verify-metadata-version")) {
            checkMetadataVersion(adminClient);
            return;
        }

        String ops = "";
        if(options.has("delete-partitions")) {
            ops += "d";
        }
        if(options.has("fetch-keys")) {
            ops += "k";
        }
        if(options.has("fetch-entries")) {
            ops += "v";
        }
        if(options.has("restore")) {
            ops += "r";
        }
        if(options.has("add-stores")) {
            ops += "a";
        }
        if(options.has("update-entries")) {
            ops += "u";
        }
        if(options.has("delete-store")) {
            ops += "s";
        }
        if(options.has("get-metadata")) {
            ops += "g";
        }
        if(options.has("ro-metadata")) {
            ops += "e";
        }
        if(options.has("truncate")) {
            ops += "t";
        }
        if(options.has("set-metadata")) {
            ops += "m";
        }
        if(options.has("check-metadata")) {
            ops += "c";
        }
        if(options.has("key-distribution")) {
            ops += "y";
        }
        if(options.has("clear-rebalancing-metadata")) {
            ops += "i";
        }
        if(options.has("async")) {
            ops += "b";
        }
        if(options.has("repair-job")) {
            ops += "l";
        }
        if(options.has("native-backup")) {
            if(!options.has("backup-dir")) {
                Utils.croak("A backup directory must be specified with backup-dir option");
            }
            ops += "n";
        }
        if(options.has("rollback")) {
            if(!options.has("version")) {
                Utils.croak("A read-only push version must be specified with rollback option");
            }
            ops += "o";
        }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787151884/fstmerge_var1_3880453383214879563
        if(options.has("reserve-memory")) {
            if(!options.has("stores")) {
                Utils.croak("Specify the list of stores to reserve memory");
            }
            ops += "f";
        }
        if(options.has("query-keys")) {
            ops += "q";
        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787151884/fstmerge_base_5106025042499841391
=======
        if(options.has("synchronize-metadata-version")) {
            ops += "z";
        }

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787151884/fstmerge_var2_6733799024449803267
        if(ops.length() < 1) {
            Utils.croak("At least one of (delete-partitions, restore, add-node, fetch-entries, "
                        + "fetch-keys, add-stores, delete-store, update-entries, get-metadata, ro-metadata, "
                        + "set-metadata, check-metadata, key-distribution, clear-rebalancing-metadata, async, "
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787151884/fstmerge_var1_3880453383214879563
                        + "repair-job, native-backup, rollback, reserve-memory) must be specified");
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787151884/fstmerge_base_5106025042499841391
                        + "repair-job, native-backup) must be specified");
=======
                        + "repair-job, native-backup, verify-metadata-version) must be specified");
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787151884/fstmerge_var2_6733799024449803267
        }

        List<String> storeNames = null;

        if(options.has("stores")) {
            List<String> temp = (List<String>) options.valuesOf("stores");
            storeNames = temp;
        }

        String outputDir = null;
        if(options.has("outdir")) {
            outputDir = (String) options.valueOf("outdir");
        }

        try {
            if(ops.contains("d")) {
                System.out.println("Starting delete-partitions");
                List<Integer> partitionIdList = (List<Integer>) options.valuesOf("delete-partitions");
                executeDeletePartitions(nodeId, adminClient, partitionIdList, storeNames);
                System.out.println("Finished delete-partitions");
            }
            if(ops.contains("r")) {
                if(nodeId == -1) {
                    System.err.println("Cannot run restore without node id");
                    System.exit(1);
                }
                System.out.println("Starting restore");
                adminClient.restoreDataFromReplications(nodeId, parallelism, zoneId);
                System.out.println("Finished restore");
            }
            if(ops.contains("k")) {
                boolean useAscii = options.has("ascii");
                System.out.println("Starting fetch keys");
                List<Integer> partitionIdList = null;
                if(options.hasArgument("fetch-keys"))
                    partitionIdList = (List<Integer>) options.valuesOf("fetch-keys");
                executeFetchKeys(nodeId,
                                 adminClient,
                                 partitionIdList,
                                 outputDir,
                                 storeNames,
                                 useAscii);
            }
            if(ops.contains("v")) {
                boolean useAscii = options.has("ascii");
                System.out.println("Starting fetch entries");
                List<Integer> partitionIdList = null;
                if(options.hasArgument("fetch-entries"))
                    partitionIdList = (List<Integer>) options.valuesOf("fetch-entries");
                executeFetchEntries(nodeId,
                                    adminClient,
                                    partitionIdList,
                                    outputDir,
                                    storeNames,
                                    useAscii);
            }
            if(ops.contains("a")) {
                String storesXml = (String) options.valueOf("add-stores");
                executeAddStores(adminClient, storesXml, nodeId);
            }
            if(ops.contains("u")) {
                String inputDir = (String) options.valueOf("update-entries");
                executeUpdateEntries(nodeId, adminClient, storeNames, inputDir);
            }
            if(ops.contains("s")) {
                String storeName = (String) options.valueOf("delete-store");
                executeDeleteStore(adminClient, storeName, nodeId);
            }
            if(ops.contains("g")) {
                String metadataKey = ALL_METADATA;
                if(options.hasArgument("get-metadata")) {
                    metadataKey = (String) options.valueOf("get-metadata");
                }
                executeGetMetadata(nodeId, adminClient, metadataKey, outputDir);
            }
            if(ops.contains("e")) {
                String type = (String) options.valueOf("ro-metadata");
                executeROMetadata(nodeId, adminClient, storeNames, type);
            }
            if(ops.contains("t")) {
                String storeName = (String) options.valueOf("truncate");
                executeTruncateStore(nodeId, adminClient, storeName);
            }
            if(ops.contains("c")) {
                String metadataKey = (String) options.valueOf("check-metadata");
                executeCheckMetadata(adminClient, metadataKey);
            }
            if(ops.contains("m")) {
                String metadataKey = (String) options.valueOf("set-metadata");
                if(!options.has("set-metadata-value")) {
                    throw new VoldemortException("Missing set-metadata-value");
                } else {
                    String metadataValue = (String) options.valueOf("set-metadata-value");
                    if(metadataKey.compareTo(MetadataStore.CLUSTER_KEY) == 0) {
                        if(!Utils.isReadableFile(metadataValue))
                            throw new VoldemortException("Cluster xml file path incorrect");
                        ClusterMapper mapper = new ClusterMapper();
                        Cluster newCluster = mapper.readCluster(new File(metadataValue));
                        executeSetMetadata(nodeId,
                                           adminClient,
                                           MetadataStore.CLUSTER_KEY,
                                           mapper.writeCluster(newCluster));
                    } else if(metadataKey.compareTo(MetadataStore.SERVER_STATE_KEY) == 0) {
                        VoldemortState newState = VoldemortState.valueOf(metadataValue);
                        executeSetMetadata(nodeId,
                                           adminClient,
                                           MetadataStore.SERVER_STATE_KEY,
                                           newState.toString());
                    } else if(metadataKey.compareTo(MetadataStore.STORES_KEY) == 0) {
                        if(!Utils.isReadableFile(metadataValue))
                            throw new VoldemortException("Stores definition xml file path incorrect");
                        StoreDefinitionsMapper mapper = new StoreDefinitionsMapper();
                        List<StoreDefinition> storeDefs = mapper.readStoreList(new File(metadataValue));
                        executeSetMetadata(nodeId,
                                           adminClient,
                                           MetadataStore.STORES_KEY,
                                           mapper.writeStoreList(storeDefs));
                    } else if(metadataKey.compareTo(MetadataStore.REBALANCING_STEAL_INFO) == 0) {
                        if(!Utils.isReadableFile(metadataValue))
                            throw new VoldemortException("Rebalancing steal info file path incorrect");
                        String rebalancingStealInfoJsonString = FileUtils.readFileToString(new File(metadataValue));
                        RebalancerState state = RebalancerState.create(rebalancingStealInfoJsonString);
                        executeSetMetadata(nodeId,
                                           adminClient,
                                           MetadataStore.REBALANCING_STEAL_INFO,
                                           state.toJsonString());
                    } else {
                        throw new VoldemortException("Incorrect metadata key");
                    }
                }

            }
            if(ops.contains("y")) {
                executeKeyDistribution(adminClient);
            }
            if(ops.contains("i")) {
                executeClearRebalancing(nodeId, adminClient);
            }
            if(ops.contains("b")) {
                String asyncKey = (String) options.valueOf("async");
                List<Integer> asyncIds = null;
                if(options.hasArgument("async-id"))
                    asyncIds = (List<Integer>) options.valuesOf("async-id");
                executeAsync(nodeId, adminClient, asyncKey, asyncIds);
            }
            if(ops.contains("l")) {
                executeRepairJob(nodeId, adminClient);
            }
            if(ops.contains("n")) {
                String backupDir = (String) options.valueOf("backup-dir");
                String storeName = (String) options.valueOf("native-backup");
                int timeout = CmdUtils.valueOf(options, "backup-timeout", 30);
                adminClient.nativeBackup(nodeId,
                                         storeName,
                                         backupDir,
                                         timeout,
                                         options.has("backup-verify"),
                                         options.has("backup-incremental"));
            }
            if(ops.contains("o")) {
                String storeName = (String) options.valueOf("rollback");
                long pushVersion = (Long) options.valueOf("version");
                executeRollback(nodeId, storeName, pushVersion, adminClient);
            }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787151884/fstmerge_var1_3880453383214879563
            if(ops.contains("f")) {
                long reserveMB = (Long) options.valueOf("reserve-memory");
                adminClient.reserveMemory(nodeId, storeNames, reserveMB);
            }
            if(ops.contains("q")) {
                List<String> keyList = (List<String>) options.valuesOf("query-keys");
                if(storeNames == null || storeNames.size() == 0) {
                    throw new VoldemortException("Must specify store name using --stores option");
                }
                executeQueryKeys(nodeId, adminClient, storeNames, keyList);
            }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787151884/fstmerge_base_5106025042499841391
=======
            if(ops.contains("z")) {
                synchronizeMetadataVersion(adminClient, nodeId);
            }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787151884/fstmerge_var2_6733799024449803267
        } catch(Exception e) {
            e.printStackTrace();
            Utils.croak(e.getMessage());
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5410_78ae5/rev_c5410-78ae5/src/java/voldemort/VoldemortAdminTool.java
Conflict type: LineBasedMCFd
Conflict body: 
@SuppressWarnings("unchecked")
    public <K, V, T> Store<K, V, T> getRawStore(String storeName,
                                                InconsistencyResolver<Versioned<V>> resolver) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787152167/fstmerge_var1_7605045332952594462

        logger.info("Client zone-id [" + clientZoneId
                    + "] Attempting to obtain metadata for store [" + storeName + "] ");
        if(logger.isDebugEnabled()) {
            for(URI uri: bootstrapUrls) {
                logger.debug("Client Bootstrap url [" + uri + "]");
            }
        }
        // Get cluster and store metadata
        String clusterXml = bootstrapMetadataWithRetries(MetadataStore.CLUSTER_KEY, bootstrapUrls);
        Cluster cluster = clusterMapper.readCluster(new StringReader(clusterXml), false);
        String storesXml = bootstrapMetadataWithRetries(MetadataStore.STORES_KEY, bootstrapUrls);

        if(logger.isDebugEnabled()) {
            logger.debug("Obtained cluster metadata xml" + clusterXml);
            logger.debug("Obtained stores  metadata xml" + storesXml);
        }

        List<StoreDefinition> storeDefs = storeMapper.readStoreList(new StringReader(storesXml),
                                                                    false);
        StoreDefinition storeDef = null;
        for(StoreDefinition d: storeDefs)
            if(d.getName().equals(storeName))
                storeDef = d;
        if(storeDef == null)
            throw new BootstrapFailureException("Unknown store '" + storeName + "'.");

        if(logger.isDebugEnabled()) {
            logger.debug(cluster.toString(true));
            logger.debug(storeDef.toString());
        }
        boolean repairReads = !storeDef.isView();

        // construct mapping
        Map<Integer, Store<ByteArray, byte[], byte[]>> clientMapping = Maps.newHashMap();
        Map<Integer, NonblockingStore> nonblockingStores = Maps.newHashMap();
        Map<Integer, NonblockingStore> nonblockingSlopStores = Maps.newHashMap();

        Map<Integer, Store<ByteArray, Slop, byte[]>> slopStores = null;
        if(storeDef.hasHintedHandoffStrategyType())
            slopStores = Maps.newHashMap();

        for(Node node: cluster.getNodes()) {
            Store<ByteArray, byte[], byte[]> store = getStore(storeDef.getName(),
                                                              node.getHost(),
                                                              getPort(node),
                                                              this.requestFormatType);
            clientMapping.put(node.getId(), store);

            NonblockingStore nonblockingStore = routedStoreFactory.toNonblockingStore(store);
            nonblockingStores.put(node.getId(), nonblockingStore);

            if(slopStores != null) {
                Store<ByteArray, byte[], byte[]> rawSlopStore = getStore("slop",
                                                                         node.getHost(),
                                                                         getPort(node),
                                                                         this.requestFormatType);
                Store<ByteArray, Slop, byte[]> slopStore = SerializingStore.wrap(rawSlopStore,
                                                                                 slopKeySerializer,
                                                                                 slopValueSerializer,
                                                                                 new IdentitySerializer());
                slopStores.put(node.getId(), slopStore);
                nonblockingSlopStores.put(node.getId(),
                                          routedStoreFactory.toNonblockingStore(rawSlopStore));
            }
        }

        Store<ByteArray, byte[], byte[]> store = routedStoreFactory.create(cluster,
                                                                           storeDef,
                                                                           clientMapping,
                                                                           nonblockingStores,
                                                                           slopStores,
                                                                           nonblockingSlopStores,
                                                                           repairReads,
                                                                           clientZoneId,
                                                                           getFailureDetector(),
                                                                           isJmxEnabled,
                                                                           jmxId);
        store = new LoggingStore(store);

        if(isJmxEnabled) {
            StatTrackingStore statStore = new StatTrackingStore(store, this.stats);
            store = statStore;
            JmxUtils.registerMbean(new StoreStatsJmx(statStore.getStats()),
                                   JmxUtils.createObjectName(JmxUtils.getPackageName(store.getClass()),
                                                             store.getName()
                                                                     + JmxUtils.getJmxId(jmxId)));
        }

        if(storeDef.getKeySerializer().hasCompression()
           || storeDef.getValueSerializer().hasCompression()) {
            store = new CompressingStore(store,
                                         getCompressionStrategy(storeDef.getKeySerializer()),
                                         getCompressionStrategy(storeDef.getValueSerializer()));
        }

        Serializer<K> keySerializer = (Serializer<K>) serializerFactory.getSerializer(storeDef.getKeySerializer());
        Serializer<V> valueSerializer = (Serializer<V>) serializerFactory.getSerializer(storeDef.getValueSerializer());

        if(storeDef.isView() && (storeDef.getTransformsSerializer() == null))
            throw new SerializationException("Transforms serializer must be specified with a view ");

        Serializer<T> transformsSerializer = (Serializer<T>) serializerFactory.getSerializer(storeDef.getTransformsSerializer() != null ? storeDef.getTransformsSerializer()
                                                                                                                                       : new SerializerDefinition("identity"));

        Store<K, V, T> serializedStore = SerializingStore.wrap(store,
                                                               keySerializer,
                                                               valueSerializer,
                                                               transformsSerializer);

        // Add inconsistency resolving decorator, using their inconsistency
        // resolver (if they gave us one)
        InconsistencyResolver<Versioned<V>> secondaryResolver = resolver == null ? new TimeBasedInconsistencyResolver()
                                                                                : resolver;
        serializedStore = new InconsistencyResolvingStore<K, V, T>(serializedStore,
                                                                   new ChainedResolver<Versioned<V>>(new VectorClockInconsistencyResolver(),
                                                                                                     secondaryResolver));
        return serializedStore;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787152167/fstmerge_base_2155386044890216406

        logger.info("Client zone-id [" + clientZoneId
                    + "] Attempting to obtain metadata for store [" + storeName + "] ");
        if(logger.isDebugEnabled()) {
            for(URI uri: bootstrapUrls) {
                logger.debug("Client Bootstrap url [" + uri + "]");
            }
        }
        // Get cluster and store metadata
        String clusterXml = bootstrapMetadataWithRetries(MetadataStore.CLUSTER_KEY, bootstrapUrls);
        Cluster cluster = clusterMapper.readCluster(new StringReader(clusterXml), false);
        String storesXml = bootstrapMetadataWithRetries(MetadataStore.STORES_KEY, bootstrapUrls);

        if(logger.isDebugEnabled()) {
            logger.debug("Obtained cluster metadata xml" + clusterXml);
            logger.debug("Obtained stores  metadata xml" + storesXml);
        }

        List<StoreDefinition> storeDefs = storeMapper.readStoreList(new StringReader(storesXml),
                                                                    false);
        StoreDefinition storeDef = null;
        for(StoreDefinition d: storeDefs)
            if(d.getName().equals(storeName))
                storeDef = d;
        if(storeDef == null)
            throw new BootstrapFailureException("Unknown store '" + storeName + "'.");

        if(logger.isDebugEnabled()) {
            logger.debug(cluster.toString(true));
            logger.debug(storeDef.toString());
        }
        boolean repairReads = !storeDef.isView();

        // construct mapping
        Map<Integer, Store<ByteArray, byte[], byte[]>> clientMapping = Maps.newHashMap();
        Map<Integer, NonblockingStore> nonblockingStores = Maps.newHashMap();
        Map<Integer, NonblockingStore> nonblockingSlopStores = Maps.newHashMap();

        Map<Integer, Store<ByteArray, Slop, byte[]>> slopStores = null;
        if(storeDef.hasHintedHandoffStrategyType())
            slopStores = Maps.newHashMap();

        for(Node node: cluster.getNodes()) {
            Store<ByteArray, byte[], byte[]> store = getStore(storeDef.getName(),
                                                              node.getHost(),
                                                              getPort(node),
                                                              this.requestFormatType);
            clientMapping.put(node.getId(), store);

            NonblockingStore nonblockingStore = routedStoreFactory.toNonblockingStore(store);
            nonblockingStores.put(node.getId(), nonblockingStore);

            if(slopStores != null) {
                Store<ByteArray, byte[], byte[]> rawSlopStore = getStore("slop",
                                                                         node.getHost(),
                                                                         getPort(node),
                                                                         this.requestFormatType);
                Store<ByteArray, Slop, byte[]> slopStore = SerializingStore.wrap(rawSlopStore,
                                                                                 slopKeySerializer,
                                                                                 slopValueSerializer,
                                                                                 new IdentitySerializer());
                slopStores.put(node.getId(), slopStore);
                nonblockingSlopStores.put(node.getId(),
                                          routedStoreFactory.toNonblockingStore(rawSlopStore));
            }
        }

        Store<ByteArray, byte[], byte[]> store = routedStoreFactory.create(cluster,
                                                                           storeDef,
                                                                           clientMapping,
                                                                           nonblockingStores,
                                                                           slopStores,
                                                                           nonblockingSlopStores,
                                                                           repairReads,
                                                                           clientZoneId,
                                                                           getFailureDetector(),
                                                                           isJmxEnabled);
        store = new LoggingStore(store);

        if(isJmxEnabled) {
            StatTrackingStore statStore = new StatTrackingStore(store, this.stats);
            store = statStore;
            JmxUtils.registerMbean(new StoreStatsJmx(statStore.getStats()),
                                   JmxUtils.createObjectName(JmxUtils.getPackageName(store.getClass()),
                                                             store.getName() + jmxId()));
        }

        if(storeDef.getKeySerializer().hasCompression()
           || storeDef.getValueSerializer().hasCompression()) {
            store = new CompressingStore(store,
                                         getCompressionStrategy(storeDef.getKeySerializer()),
                                         getCompressionStrategy(storeDef.getValueSerializer()));
        }

        Serializer<K> keySerializer = (Serializer<K>) serializerFactory.getSerializer(storeDef.getKeySerializer());
        Serializer<V> valueSerializer = (Serializer<V>) serializerFactory.getSerializer(storeDef.getValueSerializer());

        if(storeDef.isView() && (storeDef.getTransformsSerializer() == null))
            throw new SerializationException("Transforms serializer must be specified with a view ");

        Serializer<T> transformsSerializer = (Serializer<T>) serializerFactory.getSerializer(storeDef.getTransformsSerializer() != null ? storeDef.getTransformsSerializer()
                                                                                                                                       : new SerializerDefinition("identity"));

        Store<K, V, T> serializedStore = SerializingStore.wrap(store,
                                                               keySerializer,
                                                               valueSerializer,
                                                               transformsSerializer);

        // Add inconsistency resolving decorator, using their inconsistency
        // resolver (if they gave us one)
        InconsistencyResolver<Versioned<V>> secondaryResolver = resolver == null ? new TimeBasedInconsistencyResolver()
                                                                                : resolver;
        serializedStore = new InconsistencyResolvingStore<K, V, T>(serializedStore,
                                                                   new ChainedResolver<Versioned<V>>(new VectorClockInconsistencyResolver(),
                                                                                                     secondaryResolver));
        return serializedStore;
=======
        return getRawStore(storeName, resolver, null, null, null);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787152167/fstmerge_var2_76286951827845631
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5410_78ae5/rev_c5410-78ae5/src/java/voldemort/client/AbstractStoreClientFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
public FailureDetector getFailureDetector() {
        if(this.cluster == null) {
            String clusterXml = bootstrapMetadataWithRetries(MetadataStore.CLUSTER_KEY,
                                                             bootstrapUrls);
            this.cluster = clusterMapper.readCluster(new StringReader(clusterXml), false);
        }

        // first check: avoids locking as the field is volatile
        FailureDetector result = failureDetector;

        if(result == null) {
            logger.debug("Failure detector is null. Creating a new FD.");
            synchronized(this) {
                // second check: avoids double initialization
                result = failureDetector;
                if(result == null) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787152208/fstmerge_var1_5787673667507761597
                    failureDetector = result = initFailureDetector(config, cluster.getNodes());
                    if(isJmxEnabled) {
                        JmxUtils.registerMbean(failureDetector,
                                               JmxUtils.createObjectName(JmxUtils.getPackageName(failureDetector.getClass()),
                                                                         JmxUtils.getClassName(failureDetector.getClass())
                                                                                 + JmxUtils.getJmxId(jmxId)));
                    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787152208/fstmerge_base_1718877612245785602
                    failureDetector = result = initFailureDetector(config, cluster.getNodes());
                    JmxUtils.registerMbean(failureDetector,
                                           JmxUtils.createObjectName(JmxUtils.getPackageName(failureDetector.getClass()),
                                                                     JmxUtils.getClassName(failureDetector.getClass())
                                                                             + jmxId()));
=======
                    failureDetector = result = initFailureDetector(config, this.cluster);
                    JmxUtils.registerMbean(failureDetector,
                                           JmxUtils.createObjectName(JmxUtils.getPackageName(failureDetector.getClass()),
                                                                     JmxUtils.getClassName(failureDetector.getClass())
                                                                             + jmxId()));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787152208/fstmerge_var2_5104268533770818155
                }
            }
        } else {

            /*
             * The existing failure detector might have an old state
             */
            logger.debug("Failure detector already exists. Updating the state and flushing cached verifier stores.");
            synchronized(this) {
                failureDetector.getConfig().setCluster(this.cluster);
                failureDetector.getConfig().getStoreVerifier().flushCachedStores();
            }
        }

        return result;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5410_78ae5/rev_c5410-78ae5/src/java/voldemort/client/AbstractStoreClientFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
public void close() {
        this.threadPool.shutdown();

        try {
            if(!this.threadPool.awaitTermination(10, TimeUnit.SECONDS))
                this.threadPool.shutdownNow();
        } catch(InterruptedException e) {
            // okay, fine, playing nice didn't work
            this.threadPool.shutdownNow();
        }

        if(failureDetector != null) {
            failureDetector.destroy();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787152235/fstmerge_var1_2829709588321577635
            if(isJmxEnabled) {
                JmxUtils.unregisterMbean(JmxUtils.createObjectName(JmxUtils.getPackageName(failureDetector.getClass()),
                                                                   JmxUtils.getClassName(failureDetector.getClass())
                                                                           + JmxUtils.getJmxId(jmxId)));
                JmxUtils.unregisterMbean(JmxUtils.createObjectName(JmxUtils.getPackageName(threadPool.getClass()),
                                                                   JmxUtils.getClassName(threadPool.getClass())
                                                                           + JmxUtils.getJmxId(jmxId)));
                JmxUtils.unregisterMbean(JmxUtils.createObjectName("voldemort.store.stats.aggregate",
                                                                   "aggregate-perf"
                                                                           + JmxUtils.getJmxId(jmxId)));
            }
        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787152235/fstmerge_base_4092652611328103912
=======

        stopClientAsyncSchedulers();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787152235/fstmerge_var2_875892363286196785
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5410_78ae5/rev_c5410-78ae5/src/java/voldemort/client/AbstractStoreClientFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
public SocketStoreClientFactory(ClientConfig config) {
        super(config);
        this.requestRoutingType = RequestRoutingType.getRequestRoutingType(RoutingTier.SERVER.equals(config.getRoutingTier()),
                                                                           false);
        this.storeFactory = new ClientRequestExecutorPool(config.getSelectors(),
                                                          config.getMaxConnectionsPerNode(),
                                                          config.getConnectionTimeout(TimeUnit.MILLISECONDS),
                                                          config.getSocketTimeout(TimeUnit.MILLISECONDS),
                                                          config.getSocketBufferSize(),
                                                          config.getSocketKeepAlive(),
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787152253/fstmerge_var1_3455121684755960632
                                                          config.isJmxEnabled(),
                                                          jmxId);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787152253/fstmerge_base_6835779208644368570
                                                          config.isJmxEnabled());
        if(config.isJmxEnabled())
            JmxUtils.registerMbean(storeFactory,
                                   JmxUtils.createObjectName(JmxUtils.getPackageName(storeFactory.getClass()),
                                                             JmxUtils.getClassName(storeFactory.getClass())
                                                                     + jmxId()));
=======
                                                          config.isJmxEnabled());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787152253/fstmerge_var2_6201626028948876940
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5410_78ae5/rev_c5410-78ae5/src/java/voldemort/client/SocketStoreClientFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787152280/fstmerge_var1_8772517628995461190
@Override
    protected FailureDetector initFailureDetector(final ClientConfig config,
                                                  final Collection<Node> nodes) {
        failureDetectorListener = new FailureDetectorListener() {

            public void nodeAvailable(Node node) {

            }

            public void nodeUnavailable(Node node) {
                if(logger.isInfoEnabled())
                    logger.info(node + " has been marked as unavailable, destroying socket pool");

                // Kill the socket pool for this node...
                SocketDestination destination = new SocketDestination(node.getHost(),
                                                                      node.getSocketPort(),
                                                                      config.getRequestFormatType());
                storeFactory.close(destination);
            }

        };

        ClientStoreVerifier storeVerifier = new ClientStoreVerifier() {

            @Override
            protected Store<ByteArray, byte[], byte[]> getStoreInternal(Node node) {
                return SocketStoreClientFactory.this.getStore(MetadataStore.METADATA_STORE_NAME,
                                                              node.getHost(),
                                                              node.getSocketPort(),
                                                              config.getRequestFormatType());
            }

        };

        FailureDetectorConfig failureDetectorConfig = new FailureDetectorConfig(config).setNodes(nodes)
                                                                                       .setStoreVerifier(storeVerifier);

        return create(failureDetectorConfig, false, failureDetectorListener);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787152280/fstmerge_base_6930427494312041571
@Override
    protected FailureDetector initFailureDetector(final ClientConfig config,
                                                  final Collection<Node> nodes) {
        failureDetectorListener = new FailureDetectorListener() {

            public void nodeAvailable(Node node) {

            }

            public void nodeUnavailable(Node node) {
                if(logger.isInfoEnabled())
                    logger.info(node + " has been marked as unavailable, destroying socket pool");

                // Kill the socket pool for this node...
                SocketDestination destination = new SocketDestination(node.getHost(),
                                                                      node.getSocketPort(),
                                                                      config.getRequestFormatType());
                storeFactory.close(destination);
            }

        };

        ClientStoreVerifier storeVerifier = new ClientStoreVerifier() {

            @Override
            protected Store<ByteArray, byte[], byte[]> getStoreInternal(Node node) {
                return SocketStoreClientFactory.this.getStore(MetadataStore.METADATA_STORE_NAME,
                                                              node.getHost(),
                                                              node.getSocketPort(),
                                                              config.getRequestFormatType());
            }

        };

        FailureDetectorConfig failureDetectorConfig = new FailureDetectorConfig(config).setNodes(nodes)
                                                                                       .setStoreVerifier(storeVerifier);

        return create(failureDetectorConfig, true, failureDetectorListener);
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415787152280/fstmerge_var2_4481085095359159226

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5410_78ae5/rev_c5410-78ae5/src/java/voldemort/client/SocketStoreClientFactory.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c2637_6889d/rev_c2637-6889d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_5b70b_fbdb0/rev_5b70b-fbdb0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_87914_5b70b/rev_87914-5b70b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_922ec_8b961/rev_922ec-8b961.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c6118_8dcc8/rev_c6118-8dcc8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_0d9a4_c94b8/rev_0d9a4-c94b8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_22860_8b309/rev_22860-8b309.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b08ad_88516/rev_b08ad-88516.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_3cfcd_eb5d5/rev_3cfcd-eb5d5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_4964e_a2359/rev_4964e-a2359.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_db6ac_90c0b/rev_db6ac-90c0b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_797b7_26622/rev_797b7-26622.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_113d2_797b7/rev_113d2-797b7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e79f9_81788/rev_e79f9-81788.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6cb44_78993/rev_6cb44-78993.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_38297_ea2ee/rev_38297-ea2ee.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_e0f18_d44ca/rev_e0f18-d44ca.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_55d9b_18fb7/rev_55d9b-18fb7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_649cd_7ed0b/rev_649cd-7ed0b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d9ab0_251f2/rev_d9ab0-251f2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_44b9b_84ced/rev_44b9b-84ced.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_5747a_2df99/rev_5747a-2df99.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d007b_f410f/rev_d007b-f410f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b56cc_784e7/rev_b56cc-784e7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f29cf_9f793/rev_f29cf-9f793.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_0b5e2_ca8d6/rev_0b5e2-ca8d6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a7622_b5fcb/rev_a7622-b5fcb.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_30bbd_a11c4/rev_30bbd-a11c4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d4cc0_5f7df/rev_d4cc0-5f7df.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_da027_62a58/rev_da027-62a58.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f87fb_a368b/rev_f87fb-a368b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d4cbd_0b154/rev_d4cbd-0b154.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b453b_7a7c8/rev_b453b-7a7c8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_8b8f1_3fd7e/rev_8b8f1-3fd7e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c8b64_f1f57/rev_c8b64-f1f57.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_9d0a3_cbc5e/rev_9d0a3-cbc5e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d5409_7ee12/rev_d5409-7ee12.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_a2adb_1b31a/rev_a2adb-1b31a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6b4c1_25800/rev_6b4c1-25800.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_96032_e6390/rev_96032-e6390.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_cf92e_3d639/rev_cf92e-3d639.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7c9af_11c86/rev_7c9af-11c86.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_f29a9_56e19/rev_f29a9-56e19.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_6d8c0_044e9/rev_6d8c0-044e9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_7e774_265b4/rev_7e774-265b4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_de1ab_c07b7/rev_de1ab-c07b7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c451e_9bda8/rev_c451e-9bda8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c51a5_f7370/rev_c51a5-f7370.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_10591_c07b7/rev_10591-c07b7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_53073_d8c93/rev_53073-d8c93.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_62aa5_9bbe1/rev_62aa5-9bbe1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_b1b68_90cd6/rev_b1b68-90cd6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_03717_3f0fc/rev_03717-3f0fc.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_453dd_8724f/rev_453dd-8724f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d7d73_c080c/rev_d7d73-c080c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5995_5aabf/rev_c5995-5aabf.revisions
Conflict type: ModifierList
Conflict body: 
~~FSTMerge~~ @JmxManaged(description = "Coordinator Service for proxying Voldemort requests from the thin client")
public ##FSTMerge## ##FSTMerge## @JmxManaged(description = "Coordinator Service for proxying Voldemort requests from the thin client")

public
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5995_5aabf/rev_c5995-5aabf/src/java/voldemort/rest/coordinator/CoordinatorProxyService.java
Conflict type: SameIdFd
Conflict body: 
~~FSTMerge~~ public final static Schema CLIENT_CONFIGS_AVRO_SCHEMA = Schema.parse(CLIENT_CONFIGS_AVRO_SCHEMA_STRING); ##FSTMerge## ##FSTMerge## public final static Schema CLIENT_CONFIGS_AVRO_SCHEMA = Schema.parse("{ \"name\": \"clientConfigs\",  \"type\":\"array\","
                                                                         + "\"items\": { \"name\": \"clientConfig\", \"type\": \"map\", \"values\":\"string\" }}}");
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5995_5aabf/rev_c5995-5aabf/src/java/voldemort/rest/coordinator/CoordinatorProxyService.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632710/fstmerge_var1_7820001047614669317
private void initializeFatClients() {

        StoreDefinitionsMapper storeMapper = new StoreDefinitionsMapper();
        // Fetch the state once and use this to initialize all the Fat clients
        String storesXml = storeClientFactory.bootstrapMetadataWithRetries(MetadataStore.STORES_KEY);
        String clusterXml = storeClientFactory.bootstrapMetadataWithRetries(MetadataStore.CLUSTER_KEY);
        List<StoreDefinition> storeDefList = storeMapper.readStoreList(new StringReader(storesXml),
                                                                       false);

        // Update the Coordinator Metadata
        this.coordinatorMetadata.setMetadata(clusterXml, storeDefList);

        Map<String, SocketStoreClientFactory> fatClientFactoryMap = readClientConfig(this.coordinatorConfig.getFatClientConfigPath(),
                                                                                     this.coordinatorConfig.getBootstrapURLs());

        // Do not recreate map if it already exists. This function might be
        // called by the AsyncMetadataVersionManager
        // if there is a metadata update on the server side

        if(this.fatClientMap == null) {
            this.fatClientMap = new HashMap<String, DynamicTimeoutStoreClient<ByteArray, byte[]>>();
        }

        for(StoreDefinition storeDef: storeDefList) {
            String storeName = storeDef.getName();

            // Initialize only those stores defined in the client configs file
            if(fatClientFactoryMap.get(storeName) != null) {
                DynamicTimeoutStoreClient<ByteArray, byte[]> storeClient = new DynamicTimeoutStoreClient<ByteArray, byte[]>(storeName,
                                                                                                                            fatClientFactoryMap.get(storeName),
                                                                                                                            1,
                                                                                                                            storesXml,
                                                                                                                            clusterXml);

                fatClientMap.put(storeName, storeClient);
            }
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632710/fstmerge_base_9142876659836401682
=======
private void initializeFatClients() {

        StoreDefinitionsMapper storeMapper = new StoreDefinitionsMapper();
        // Fetch the state once and use this to initialize all the Fat clients
        String storesXml = storeClientFactory.bootstrapMetadataWithRetries(MetadataStore.STORES_KEY);
        String clusterXml = storeClientFactory.bootstrapMetadataWithRetries(MetadataStore.CLUSTER_KEY);
        List<StoreDefinition> storeDefList = storeMapper.readStoreList(new StringReader(storesXml), false);

        // Update the Coordinator Metadata
        this.coordinatorMetadata.setMetadata(clusterXml, storeDefList);

        Map<String, SocketStoreClientFactory> fatClientFactoryMap = readClientConfig(this.coordinatorConfig.getFatClientConfigPath(),
                                                                                     this.coordinatorConfig.getBootstrapURLs());

        // Do not recreate map if it already exists. This function might be called by the AsyncMetadataVersionManager
        // if there is a metadata update on the server side

        if (this.fatClientMap == null) {
            this.fatClientMap = new HashMap<String, DynamicTimeoutStoreClient<ByteArray, byte[]>>();
        }

        for (StoreDefinition storeDef: storeDefList) {
            String storeName = storeDef.getName();

            // Initialize only those stores defined in the client configs file
            if (fatClientFactoryMap.get(storeName) != null) {
                DynamicTimeoutStoreClient<ByteArray, byte[]> storeClient = new DynamicTimeoutStoreClient<ByteArray, byte[]>(storeName,
                                                                                                                            fatClientFactoryMap.get(storeName),
                                                                                                                            1,
                                                                                                                            storesXml,
                                                                                                                            clusterXml);

                fatClientMap.put(storeName, storeClient);
            }
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632710/fstmerge_var2_5650176770984441517

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5995_5aabf/rev_c5995-5aabf/src/java/voldemort/rest/coordinator/CoordinatorProxyService.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632716/fstmerge_var1_7750233884769331027
@Override
    protected void initialize() {
        // Initialize the Voldemort Metadata
        ClientConfig clientConfig = new ClientConfig();
        clientConfig.setBootstrapUrls(this.coordinatorConfig.getBootstrapURLs());
        storeClientFactory = new SocketStoreClientFactory(clientConfig);
        try {
            initializeFatClients();
            // Setup the Async Metadata checker
            SystemStoreRepository sysRepository = new SystemStoreRepository(clientConfig);
            String clusterXml = storeClientFactory.bootstrapMetadataWithRetries(MetadataStore.CLUSTER_KEY);

            sysRepository.createSystemStores(clientConfig,
                                             clusterXml,
                                             storeClientFactory.getFailureDetector());

            // Create a callback for re-bootstrapping the client
            Callable<Void> rebootstrapCallback = new Callable<Void>() {

                @Override
                public Void call() throws Exception {
                    initializeFatClients();
                    return null;
                }

            };
            asyncMetadataManager = new AsyncMetadataVersionManager(sysRepository,
                                                                   rebootstrapCallback,
                                                                   null);

            schedulerService = new SchedulerService(1, SystemTime.INSTANCE, true);
            schedulerService.schedule(asyncMetadataManager.getClass().getName(),
                                      asyncMetadataManager,
                                      new Date(),
                                      this.coordinatorConfig.getMetadataCheckIntervalInMs());
        } catch(BootstrapFailureException be) {
            /*
             * While testing, the cluster may not be up, but we may still need
             * to verify if the service deploys. Hence, catch a
             * BootstrapFailureException if any, but continue to register the
             * Netty service (and listener).
             * 
             * TODO: Modify the coordinator service to be more lazy. If it
             * cannot initialize the fat clients during initialization, do this
             * when we get an actual request.
             */
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632716/fstmerge_base_3402452104478003774
=======
@Override
    protected void initialize() {
        // Initialize the Voldemort Metadata
        ClientConfig clientConfig = new ClientConfig();
        clientConfig.setBootstrapUrls(this.coordinatorConfig.getBootstrapURLs());
        storeClientFactory = new SocketStoreClientFactory(clientConfig);
        try {
            initializeFatClients();
            // Setup the Async Metadata checker
            SystemStoreRepository sysRepository = new SystemStoreRepository(clientConfig);
            String clusterXml = storeClientFactory.bootstrapMetadataWithRetries(MetadataStore.CLUSTER_KEY);

            sysRepository.createSystemStores(clientConfig,
                                             clusterXml,
                                             storeClientFactory.getFailureDetector());

            // Create a callback for re-bootstrapping the client
            Callable<Void> rebootstrapCallback = new Callable<Void>() {

                @Override
                public Void call() throws Exception {
                    initializeFatClients();
                    return null;
                }

            };
            asyncMetadataManager = new AsyncMetadataVersionManager(sysRepository,
                                                                   rebootstrapCallback,
                                                                   null);

            schedulerService = new SchedulerService(1, SystemTime.INSTANCE, true);
            schedulerService.schedule(asyncMetadataManager.getClass().getName(),
                                      asyncMetadataManager,
                                      new Date(),
                                      this.coordinatorConfig.getMetadataCheckIntervalInMs());
        } catch(BootstrapFailureException be) {
            /*
             * While testing, the cluster may not be up, but we may still need to verify if the service deploys.
             * Hence, catch a BootstrapFailureException if any, but continue to register the Netty service (and
             * listener).
             *
             * TODO: Modify the coordinator service to be more lazy. If it cannot initialize the fat clients during
             * initialization, do this when we get an actual request.
             */
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632716/fstmerge_var2_2692908564101874535

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5995_5aabf/rev_c5995-5aabf/src/java/voldemort/rest/coordinator/CoordinatorProxyService.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632722/fstmerge_var1_965240183406847849
private static Map<String, SocketStoreClientFactory> readClientConfig(String configFilePath,
                                                                          String[] bootstrapURLs) {
        String line;
        Map<String, SocketStoreClientFactory> storeFactoryMap = new HashMap<String, SocketStoreClientFactory>();
        try {
            line = Joiner.on(" ")
                         .join(IOUtils.readLines(new FileReader(new File(configFilePath))))
                         .trim();

            Map<String, Properties> mapStoreToProps = readClientConfigAvro(line);

            for(String storeName: mapStoreToProps.keySet()) {
                Properties props = mapStoreToProps.get(storeName);

                ClientConfig fatClientConfig = new ClientConfig(props);

                fatClientConfig.setBootstrapUrls(bootstrapURLs)
                               .setEnableCompressionLayer(false)
                               .setEnableSerializationLayer(false)
                               .enableDefaultClient(true)
                               .setEnableLazy(false)
                               .setIdentifierString(props.getProperty(IDENTIFIER_STRING_KEY, null));

                logger.info("Creating a Fat client for store: " + storeName);
                logger.info("Using config: " + fatClientConfig);

                storeFactoryMap.put(storeName, new SocketStoreClientFactory(fatClientConfig));
            }

        } catch(FileNotFoundException e) {
            e.printStackTrace();
        } catch(IOException e) {
            e.printStackTrace();
        } catch(Exception e) {
            e.printStackTrace();
        }
        return storeFactoryMap;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632722/fstmerge_base_11454622298370380
=======
@SuppressWarnings("unchecked")
    private static Map<String, SocketStoreClientFactory> readClientConfig(String configFilePath,
                                                                          String[] bootstrapURLs) {
        String line;
        Map<String, SocketStoreClientFactory> storeFactoryMap = new HashMap<String, SocketStoreClientFactory>();
        try {
            line = Joiner.on(" ")
                         .join(IOUtils.readLines(new FileReader(new File(configFilePath))))
                         .trim();

            JsonDecoder decoder = new JsonDecoder(CLIENT_CONFIGS_AVRO_SCHEMA, line);
            GenericDatumReader<Object> datumReader = new GenericDatumReader<Object>(CLIENT_CONFIGS_AVRO_SCHEMA);
            GenericData.Array<Map<Utf8, Utf8>> flowMaps = (GenericData.Array<Map<Utf8, Utf8>>) datumReader.read(null,
                                                                                                                decoder);

            // Flows to return back
            if (flowMaps != null && flowMaps.size() > 0) {
                for (Map<Utf8, Utf8> flowMap: flowMaps) {
                    Properties props = new Properties();
                    for (Utf8 key: flowMap.keySet()) {
                        props.put(key.toString(), flowMap.get(key).toString());
                    }

                    String storeName = flowMap.get(new Utf8(STORE_NAME_KEY)).toString();

                    storeName = props.getProperty(STORE_NAME_KEY);
                    if (storeName == null || storeName.length() == 0) {
                        throw new Exception("Illegal Store Name !!!");
                    }

                    ClientConfig fatClientConfig = new ClientConfig(props);
                    fatClientConfig.setBootstrapUrls(bootstrapURLs)
                                   .setEnableCompressionLayer(false)
                                   .setEnableSerializationLayer(false)
                                   .enableDefaultClient(true)
                                   .setEnableLazy(false)
                                   .setIdentifierString(props.getProperty(IDENTIFIER_STRING_KEY,
                                                                          null));

                    logger.info("Creating a Fat client for store: " + storeName);
                    logger.info("Using config: " + fatClientConfig);
                    storeFactoryMap.put(storeName, new SocketStoreClientFactory(fatClientConfig));
                }
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return storeFactoryMap;
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632722/fstmerge_var2_8986839466814038488

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5995_5aabf/rev_c5995-5aabf/src/java/voldemort/rest/coordinator/CoordinatorProxyService.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632747/fstmerge_var1_637514202416427290
@JmxGetter(name = "numberOfActiveThreads", description = "The number of active Netty worker threads.")
    public int getNumberOfActiveThreads() {
        return this.workerPool.getActiveCount();
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632747/fstmerge_base_1696382975145845018
=======
@JmxGetter(name = "numberOfActiveThreads",
            description = "The number of active Netty worker threads.")
    public int getNumberOfActiveThreads() {
        return this.workerPool.getActiveCount();
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632747/fstmerge_var2_9107456748980068200

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5995_5aabf/rev_c5995-5aabf/src/java/voldemort/rest/coordinator/CoordinatorProxyService.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632752/fstmerge_var1_7771754198784894969
@JmxGetter(name = "numberOfThreads", description = "The total number of Netty worker threads, active and idle.")
    public int getNumberOfThreads() {
        return this.workerPool.getPoolSize();
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632752/fstmerge_base_3483906433343477881
=======
@JmxGetter(name = "numberOfThreads",
            description = "The total number of Netty worker threads, active and idle.")
    public int getNumberOfThreads() {
        return this.workerPool.getPoolSize();
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632752/fstmerge_var2_2449385301677005152

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5995_5aabf/rev_c5995-5aabf/src/java/voldemort/rest/coordinator/CoordinatorProxyService.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632757/fstmerge_var1_2866806528948280044
@JmxGetter(name = "queuedRequests", description = "Number of requests in the Netty worker queue waiting to execute.")
    public int getQueuedRequests() {
        return this.workerPool.getQueue().size();
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632757/fstmerge_base_8081439787488276357
=======
@JmxGetter(name = "queuedRequests",
            description = "Number of requests in the Netty worker queue waiting to execute.")
    public int getQueuedRequests() {
        return this.workerPool.getQueue().size();
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632757/fstmerge_var2_8032167765854883132

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5995_5aabf/rev_c5995-5aabf/src/java/voldemort/rest/coordinator/CoordinatorProxyService.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632761/fstmerge_var1_7555473337892076349
@JmxGetter(name = "averageGetCompletionTimeInMs", description = "The avg. time in ms for GET calls to complete.")
    public double getAverageGetCompletionTimeInMs() {
        return this.coordinatorPerfStats.getAvgTimeInMs(Tracked.GET);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632761/fstmerge_base_8135926525019335714
=======
@JmxGetter(name = "averageGetCompletionTimeInMs",
            description = "The avg. time in ms for GET calls to complete.")
    public double getAverageGetCompletionTimeInMs() {
        return this.coordinatorPerfStats.getAvgTimeInMs(Tracked.GET);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632761/fstmerge_var2_7798921407010153372

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5995_5aabf/rev_c5995-5aabf/src/java/voldemort/rest/coordinator/CoordinatorProxyService.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632769/fstmerge_var1_2739138542066566596
@JmxGetter(name = "averagePutCompletionTimeInMs", description = "The avg. time in ms for GET calls to complete.")
    public double getAveragePutCompletionTimeInMs() {
        return this.coordinatorPerfStats.getAvgTimeInMs(Tracked.PUT);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632769/fstmerge_base_6794186740633189944
=======
@JmxGetter(name = "averagePutCompletionTimeInMs",
            description = "The avg. time in ms for GET calls to complete.")
    public double getAveragePutCompletionTimeInMs() {
        return this.coordinatorPerfStats.getAvgTimeInMs(Tracked.PUT);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632769/fstmerge_var2_7935371045107834105

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5995_5aabf/rev_c5995-5aabf/src/java/voldemort/rest/coordinator/CoordinatorProxyService.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632774/fstmerge_var1_1372402359153375725
@JmxGetter(name = "averageGetAllCompletionTimeInMs", description = "The avg. time in ms for GET calls to complete.")
    public double getAverageGetAllCompletionTimeInMs() {
        return this.coordinatorPerfStats.getAvgTimeInMs(Tracked.GET_ALL);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632774/fstmerge_base_6929333423370323960
=======
@JmxGetter(name = "averageGetAllCompletionTimeInMs",
            description = "The avg. time in ms for GET calls to complete.")
    public double getAverageGetAllCompletionTimeInMs() {
        return this.coordinatorPerfStats.getAvgTimeInMs(Tracked.GET_ALL);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632774/fstmerge_var2_3426348301801224667

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5995_5aabf/rev_c5995-5aabf/src/java/voldemort/rest/coordinator/CoordinatorProxyService.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632776/fstmerge_var1_3027119022235105127
@JmxGetter(name = "averageDeleteCompletionTimeInMs", description = "The avg. time in ms for GET calls to complete.")
    public double getAverageDeleteCompletionTimeInMs() {
        return this.coordinatorPerfStats.getAvgTimeInMs(Tracked.DELETE);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632776/fstmerge_base_8945240375895622596
=======
@JmxGetter(name = "averageDeleteCompletionTimeInMs",
            description = "The avg. time in ms for GET calls to complete.")
    public double getAverageDeleteCompletionTimeInMs() {
        return this.coordinatorPerfStats.getAvgTimeInMs(Tracked.DELETE);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863632776/fstmerge_var2_8212639476778947352

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5995_5aabf/rev_c5995-5aabf/src/java/voldemort/rest/coordinator/CoordinatorProxyService.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863633111/fstmerge_var1_7796570183787160255
@Override
    public void messageReceived(ChannelHandlerContext ctx, MessageEvent messageEvent) throws Exception {
        // TODO handle message here. Depending on the type of request, different handlers will be called.
        // This is just for testing purposes.
        sendResponse(messageEvent);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863633111/fstmerge_base_8286775877564982601
=======
@Override
    public void messageReceived(ChannelHandlerContext ctx, MessageEvent messageEvent) throws Exception {
        logger.info("messageReceived!! (omg)");
        sendResponse(messageEvent);
//        if (!readingChunks) {
//            HttpRequest request = this.request = (HttpRequest) messageEvent.getMessage();
//            String requestURI = this.request.getUri();
//            if (logger.isDebugEnabled()) {
//                logger.debug("Request URI: " + requestURI);
//            }
//
//            if (request.isChunked()) {
//                readingChunks = true;
//            } else {
//                // Instantiate the appropriate error handler
//                HttpMethod httpMethod = request.getMethod();
//                if (httpMethod.equals(HttpMethod.GET)) {
//                    if(logger.isDebugEnabled()) {
//                        logger.debug("Received a Http GET request at " + System.currentTimeMillis() + " ms");
//                    }
//                    // handleGet()
//                } else if (httpMethod.equals(HttpMethod.POST)) {
//                    if (logger.isDebugEnabled()) {
//                        logger.debug("Recieved a Http POST request at " + System.currentTimeMillis() + " ms");
//                    }
//                    // handlePut
//                } else if (httpMethod.equals(HttpMethod.DELETE)) {
//                    if (logger.isDebugEnabled()) {
//                        logger.debug("Received a Http DELETE request at " + System.currentTimeMillis() + " ms");
//                    }
//                    // handleDelete
//                } else {
//                    String errorMessage = "Illegal Http request received at " + System.currentTimeMillis() + " ms";
//                    logger.error(errorMessage);
//                    RestErrorHandler.writeErrorResponse(messageEvent, BAD_REQUEST, errorMessage);
//                    return;
//                }
//            }
//        } else {
//            HttpChunk chunk = (HttpChunk) messageEvent.getMessage();
//            if (chunk.isLast()) {
//                readingChunks = false;
//            }
//        }
        //sendResponse(messageEvent);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863633111/fstmerge_var2_4806655773394479594

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5995_5aabf/rev_c5995-5aabf/src/java/voldemort/rest/coordinator/admin/CoordinatorAdminRequestHandler.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863633116/fstmerge_var1_3249839054336435319
public void sendResponse(MessageEvent messageEvent) {
        // TODO Remove the code below with actual code for the response. This was for testing purposes.
        // Fill in the actual response that you want to send.
        HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);
        response.setHeader(CONTENT_LENGTH, "4");
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        try {
            outputStream.write("allo".getBytes());
        } catch (IOException e) {
        e.printStackTrace(); //To change body of catch statement use File | Settings | File Templates.
        }
        ChannelBuffer responseContent = ChannelBuffers.dynamicBuffer();
        responseContent.writeBytes(outputStream.toByteArray());
        response.setContent(responseContent);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863633116/fstmerge_base_7604145721190693737
=======
public void sendResponse(MessageEvent messageEvent) {
        HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);
        response.setHeader(CONTENT_LENGTH, "4");
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        try {
            outputStream.write("allo".getBytes());
        } catch (IOException e) {
            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
        }
        ChannelBuffer responseContent = ChannelBuffers.dynamicBuffer();
        responseContent.writeBytes(outputStream.toByteArray());
        response.setContent(responseContent);
        messageEvent.getChannel().write(response);
        logger.info("Sent");
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1415863633116/fstmerge_var2_6061016257774662690

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c5995_5aabf/rev_c5995-5aabf/src/java/voldemort/rest/coordinator/admin/CoordinatorAdminRequestHandler.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_912e2_fc8a3/rev_912e2-fc8a3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d43d7_1992a/rev_d43d7-1992a.revisions
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ public static final String IDENTIFIER_STRING_KEY = "identifier_string"; ##FSTMerge## static final String IDENTIFIER_STRING_KEY = "identifier_string"; ##FSTMerge##
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_d43d7_1992a/rev_d43d7-1992a/src/java/voldemort/rest/coordinator/config/ClientConfigUtil.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_c81ab_130e8/rev_c81ab-130e8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_ec23b_0d5dd/rev_ec23b-0d5dd.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_5c4a4_a3f45/rev_5c4a4-a3f45.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_babfd_b6d6f/rev_babfd-b6d6f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_bf230_5d604/rev_bf230-5d604.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/voldemort/revisions/rev_0d5a9_0da29/rev_0d5a9-0da29.revisions

=========================================================