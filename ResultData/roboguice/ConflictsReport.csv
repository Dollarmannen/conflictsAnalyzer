==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b9906_ed222/rev_b9906-ed222.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_60b94_0220e/rev_60b94-0220e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_6757e_54a59/rev_6757e-54a59.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_00787_43882/rev_00787-43882.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_fe92f_3f3f9/rev_fe92f-3f3f9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_ab989_e880b/rev_ab989-e880b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_8d072_e4bb2/rev_8d072-e4bb2.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public void configure(Binder b) {

        // Sundry Android Classes
        b.bind(SharedPreferences.class).toProvider(SharedPreferencesProvider.class);
        b.bind(Resources.class).toProvider(ResourcesProvider.class);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743267064/fstmerge_var1_3870903671387925901
        b.bind(GuiceApplication.class).toProvider( Key.get(new TypeLiteral<GuiceApplicationProvider<GuiceApplication>>() {}));
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743267064/fstmerge_base_1909322439139842718
        b.bind(GuiceApplication.class).toProvider(
                Key.get(new TypeLiteral<GuiceApplicationProvider<GuiceApplication>>() {
                }));
=======

        for (Class<?> c = getClass(); c != null && Application.class.isAssignableFrom(c); c = c
        .getSuperclass()) {
            b.bind((Class<Object>) c).toInstance(this);
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743267064/fstmerge_var2_1248413726792036808

        // System Services
        b.bind(LocationManager.class).toProvider(new SystemServiceProvider<LocationManager>(Context.LOCATION_SERVICE));
        b.bind(WindowManager.class).toProvider(new SystemServiceProvider<WindowManager>(Context.WINDOW_SERVICE));
        b.bind(LayoutInflater.class).toProvider( new SystemServiceProvider<LayoutInflater>(Context.LAYOUT_INFLATER_SERVICE));
        b.bind(ActivityManager.class).toProvider(new SystemServiceProvider<ActivityManager>(Context.ACTIVITY_SERVICE));
        b.bind(PowerManager.class).toProvider(new SystemServiceProvider<PowerManager>(Context.POWER_SERVICE));
        b.bind(AlarmManager.class).toProvider(new SystemServiceProvider<AlarmManager>(Context.ALARM_SERVICE));
        b.bind(NotificationManager.class).toProvider( new SystemServiceProvider<NotificationManager>(Context.NOTIFICATION_SERVICE));
        b.bind(KeyguardManager.class).toProvider(new SystemServiceProvider<KeyguardManager>(Context.KEYGUARD_SERVICE));
        b.bind(SearchManager.class).toProvider(new SystemServiceProvider<SearchManager>(Context.SEARCH_SERVICE));
        b.bind(Vibrator.class).toProvider(new SystemServiceProvider<Vibrator>(Context.VIBRATOR_SERVICE));
        b.bind(ConnectivityManager.class).toProvider( new SystemServiceProvider<ConnectivityManager>(Context.CONNECTIVITY_SERVICE));
        b.bind(WifiManager.class).toProvider(new SystemServiceProvider<WifiManager>(Context.WIFI_SERVICE));
        b.bind(InputMethodManager.class).toProvider( new SystemServiceProvider<InputMethodManager>(Context.INPUT_METHOD_SERVICE));

        // Context Scope bindings
        b.bindScope(ContextScoped.class, contextScope);
        b.bind(ContextScope.class).toInstance(contextScope);
        b.bind(Context.class).toProvider(throwingContextProvider).in(ContextScoped.class);
        b.bind(Activity.class).toProvider(ActivityProvider.class);

        // Android Resources, Views and extras require special handling
        b.bindListener(Matchers.any(), resourceListener);
        b.bindListener(Matchers.any(), extrasListener);
        b.bindListener(Matchers.any(), viewListener);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_8d072_e4bb2/rev_8d072-e4bb2/robo-guice/src/main/java/roboguice/application/GuiceApplication.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_42ba0_17bf8/rev_42ba0-17bf8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_be981_c9bc7/rev_be981-c9bc7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_4dba7_a8e8a/rev_4dba7-a8e8a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_3e08a_ff5e9/rev_3e08a-ff5e9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_96f02_ef3a3/rev_96f02-ef3a3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282101/fstmerge_var1_4905928436227051834
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282101/fstmerge_base_829377070326811342
public <I> void hear(TypeLiteral<I> iTypeLiteral, TypeEncounter<I> iTypeEncounter) {
        for (Method method : iTypeLiteral.getRawType().getMethods()) {
            //ContextObserver scan
            if (method.isAnnotationPresent(ContextObserver.class)) {
                final ContextObserver annotation = method.getAnnotation(ContextObserver.class);
                registerContextObserver(iTypeEncounter, method, annotation.value());
            }
            //ContextObservers scan
            if (method.isAnnotationPresent(ContextObservers.class)) {
                final ContextObservers annotation = method.getAnnotation(ContextObservers.class);
                for(ContextObserver observerAnnotation : annotation.value()){
                    registerContextObserver(iTypeEncounter, method, observerAnnotation.value());
                }
            }
            //ContextObserves scan
            for(int i = 0; i < method.getParameterAnnotations().length; i++){
                Annotation[] annotationArray = method.getParameterAnnotations()[i];
                Class<?>[] parameterTypes = method.getParameterTypes();
                Class parameterType = parameterTypes[i];
                for(Annotation annotation : annotationArray){
                    if(annotation.annotationType().equals(ContextObserves.class)){
                        registerContextObserver(iTypeEncounter, method, parameterType);
                    }
                }
            }
        }
    }
=======
public <I> void hear(TypeLiteral<I> iTypeLiteral, TypeEncounter<I> iTypeEncounter) {
        for (Method method : iTypeLiteral.getRawType().getMethods()) {
            for(int i = 0; i < method.getParameterAnnotations().length; i++){
                Annotation[] annotationArray = method.getParameterAnnotations()[i];
                Class<?>[] parameterTypes = method.getParameterTypes();
                Class parameterType = parameterTypes[i];
                for(Annotation annotation : annotationArray){
                    if(annotation.annotationType().equals(ContextObserves.class)){
                        registerContextObserver(iTypeEncounter, method, parameterType);
                    }
                }
            }
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282101/fstmerge_var2_2411258156556062253

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/inject/ContextObserverTypeListener.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282105/fstmerge_var1_3263412265254013705
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282105/fstmerge_base_8246371329869293520
private <I> void registerContextObserver(TypeEncounter<I> iTypeEncounter, Method method, Class parameterType) {
        checkMethodParameters(method, parameterType);
        iTypeEncounter.register(new ContextObserverMethodInjector<I>(mContextProvider, mObservationManager, method, parameterType));
    }
=======
protected <I> void registerContextObserver(TypeEncounter<I> iTypeEncounter, Method method, Class parameterType) {
        checkMethodParameters(method, parameterType);
        iTypeEncounter.register(new ContextObserverMethodInjector<I>(mObservationManager, method, parameterType));
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282105/fstmerge_var2_4134398601354486193

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/inject/ContextObserverTypeListener.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282107/fstmerge_var1_6815915535955458096
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282107/fstmerge_base_1747319863991216677
private void checkMethodParameters(Method method, Class parameterType) {
        if(method.getParameterTypes().length > 1){
            throw new RuntimeException("Annotation @ContextObserves must only annotate one parameter," +
                    " which must be the only parameter in the listener method.");
        }
        if(method.getParameterTypes().length == 1 && !method.getParameterTypes()[0].equals(parameterType)){
            throw new RuntimeException("Value injected by ContextObserver or ContextObserves in method " +
                    method.getDeclaringClass().getCanonicalName() + "." + method.getName() +
                    " must match annotated type " + parameterType.getName() + " or have no parameters.");
        }
    }
=======
protected void checkMethodParameters(Method method, Class parameterType) {
        if(method.getParameterTypes().length != 1)
            throw new RuntimeException("Annotation @ContextObserves must only annotate one parameter, which must be the only parameter in the listener method.");

        if( !method.getParameterTypes()[0].equals(parameterType) )
            throw new RuntimeException("Value injected by ContextObserves in method " +
                    method.getDeclaringClass().getCanonicalName() + "." + method.getName() +
                    " must match annotated type " + parameterType.getName() + " .");
        
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282107/fstmerge_var2_21076546864786379

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/inject/ContextObserverTypeListener.java
Conflict type: ModifierList
Conflict body: 
~~FSTMerge~~ ##FSTMerge## private static ##FSTMerge## protected static
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/inject/ContextObserverTypeListener.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ ##FSTMerge## private final ContextObservationManager mObservationManager; ##FSTMerge## protected final ContextObservationManager mObservationManager;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/inject/ContextObserverTypeListener.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ ##FSTMerge## private final Method mMethod; ##FSTMerge## protected final Method mMethod;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/inject/ContextObserverTypeListener.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ ##FSTMerge## private final Class event; ##FSTMerge## protected final Class event;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/inject/ContextObserverTypeListener.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282112/fstmerge_var1_3948627668904579562
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282112/fstmerge_base_6217901000222475332
public void afterInjection(I i) {
            mObservationManager.registerObserver(mContextProvider.get(), i, mMethod, event);
        }
=======
public void afterInjection(I i) {
            mObservationManager.registerObserver(i, mMethod, event);
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282112/fstmerge_var2_6701646871628359564

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/inject/ContextObserverTypeListener.java
Conflict type: ModifierList
Conflict body: 
~~FSTMerge~~ ##FSTMerge## @Singleton
public ##FSTMerge## @ContextScoped
public
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/inject/ContextObservationManager.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282215/fstmerge_var1_4450949447694870302
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282215/fstmerge_base_9067676297101896441
public void unregisterObserver(Context context, Object instance, Class event) {
        if (!isEnabled()) return;

        final Map<Class, Set<ContextObserverReference>> methods = mRegistrations.get(context);
        if (methods == null) return;

        final Set<ContextObserverReference> observers = methods.get(event);
        if (observers == null) return;

        for (Iterator<ContextObserverReference> iterator = observers.iterator(); iterator.hasNext();) {
            ContextObserverReference observer = iterator.next();
            if (observer != null) {
                final Object registeredInstance = observer.instanceReference.get();
                if (registeredInstance == instance) {
                    iterator.remove();
                    break;
                }
            }
        }
    }
=======
public void unregisterObserver(Context context, Object instance, Class event) {
        if (!isEnabled()) return;

        final Set<ContextObserverReference> observers = methods.get(event);
        if (observers == null) return;

        for (Iterator<ContextObserverReference> iterator = observers.iterator(); iterator.hasNext();) {
            ContextObserverReference observer = iterator.next();
            if (observer != null) {
                final Object registeredInstance = observer.instanceReference.get();
                if (registeredInstance == instance) {
                    iterator.remove();
                    break;
                }
            }
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282215/fstmerge_var2_2402194385739634274

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/inject/ContextObservationManager.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    protected void onCreate(Bundle savedInstanceState) {
        final Injector injector = getInjector();
        scope = injector.getInstance(ContextScope.class);
        scope.enter(this);
        injector.injectMembers(this);
        super.onCreate(savedInstanceState);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282770/fstmerge_var1_5936738880721247302
        eventManager.notify(this, roboActivityEventFactory.buildOnCreateEvent(savedInstanceState));
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282770/fstmerge_base_6387134491235583019
        contextObservationManager.notify(this, roboActivityEventFactory.buildOnCreateEvent(savedInstanceState));
=======
        contextObservationManager.notify(new OnCreateEvent(savedInstanceState));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282770/fstmerge_var2_6151117578264296735
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/RoboActivity.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    protected void onRestart() {
        scope.enter(this);
        super.onRestart();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282793/fstmerge_var1_1146198743848321653
        eventManager.notify(this, roboActivityEventFactory.buildOnRestartEvent());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282793/fstmerge_base_8151336874255208886
        contextObservationManager.notify(this, roboActivityEventFactory.buildOnRestartEvent());
=======
        contextObservationManager.notify(new OnRestartEvent());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282793/fstmerge_var2_5440252557532807286
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/RoboActivity.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    protected void onStart() {
        scope.enter(this);
        super.onStart();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282797/fstmerge_var1_5052112707081067130
        eventManager.notify(this, roboActivityEventFactory.buildOnStartEvent());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282797/fstmerge_base_1940749615233459686
        contextObservationManager.notify(this, roboActivityEventFactory.buildOnStartEvent());
=======
        contextObservationManager.notify(new OnStartEvent());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282797/fstmerge_var2_3112769875277081933
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/RoboActivity.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    protected void onResume() {
        scope.enter(this);
        super.onResume();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282802/fstmerge_var1_8329579608479080021
        eventManager.notify(this, roboActivityEventFactory.buildOnResumeEvent());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282802/fstmerge_base_2422520206420658460
        contextObservationManager.notify(this, roboActivityEventFactory.buildOnResumeEvent());
=======
        contextObservationManager.notify(new OnResumeEvent());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282802/fstmerge_var2_1078706808798502300
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/RoboActivity.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    protected void onPause() {
        super.onPause();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282807/fstmerge_var1_2232100958739979685
        eventManager.notify(this, roboActivityEventFactory.buildOnPauseEvent());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282807/fstmerge_base_9045794060286047942
        contextObservationManager.notify(this, roboActivityEventFactory.buildOnPauseEvent());
=======
        contextObservationManager.notify(new OnPauseEvent());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282807/fstmerge_var2_1991651109711321179
        scope.exit(this);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/RoboActivity.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    protected void onNewIntent( Intent intent ) {
        super.onNewIntent(intent);
        scope.enter(this);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282811/fstmerge_var1_3667289118134526521
        eventManager.notify(this, roboActivityEventFactory.buildOnNewIntentEvent());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282811/fstmerge_base_4438828975290070928
        contextObservationManager.notify(this, roboActivityEventFactory.buildOnNewIntentEvent());
=======
        contextObservationManager.notify(new OnNewIntentEvent());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282811/fstmerge_var2_2055586514388256990
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/RoboActivity.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    protected void onStop() {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282816/fstmerge_var1_3174864162432767393
        eventManager.notify(this, roboActivityEventFactory.buildOnStopEvent());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282816/fstmerge_base_6025354168101154947
        contextObservationManager.notify(this, roboActivityEventFactory.buildOnStopEvent());
=======
        contextObservationManager.notify(new OnStopEvent());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282816/fstmerge_var2_1525852629424542967
        super.onStop();
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/RoboActivity.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    protected void onDestroy() {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282820/fstmerge_var1_8126272148146439724
        eventManager.notify(this, roboActivityEventFactory.buildOnDestroyEvent());
        eventManager.clear(this);
        eventManager.clear(this);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282820/fstmerge_base_6692622236829165715
        contextObservationManager.notify(this, roboActivityEventFactory.buildOnDestroyEvent());
        contextObservationManager.clear(this);
        contextObservationManager.clear(this);
=======
        contextObservationManager.notify(new OnDestroyEvent());
        contextObservationManager.clear();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282820/fstmerge_var2_3740960449638597789
        super.onDestroy();
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/RoboActivity.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282825/fstmerge_var1_3778172325758399540
        eventManager.notify(this, roboActivityEventFactory.buildOnConfigurationChangedEvent(newConfig));
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282825/fstmerge_base_3554989171883516409
        contextObservationManager.notify(this, roboActivityEventFactory.buildOnConfigurationChangedEvent(newConfig));
=======
        contextObservationManager.notify(new OnConfigurationChangedEvent(newConfig));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282825/fstmerge_var2_8445106873573352854
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/RoboActivity.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282829/fstmerge_var1_8466258347807031113
        eventManager.notify(this, roboActivityEventFactory.buildOnKeyDownEvent(keyCode, event));
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282829/fstmerge_base_1683832291656918587
        contextObservationManager.notify(this, roboActivityEventFactory.buildOnKeyDownEvent(keyCode, event));
=======
        contextObservationManager.notify(new OnKeyDownEvent(keyCode, event));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282829/fstmerge_var2_3616190489867931602
        return super.onKeyDown(keyCode, event);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/RoboActivity.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public boolean onKeyUp(int keyCode, KeyEvent event) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282834/fstmerge_var1_4213727563298771609
        eventManager.notify(this, roboActivityEventFactory.buildOnKeyUpEvent(keyCode, event));
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282834/fstmerge_base_3692283805164357687
        contextObservationManager.notify(this, roboActivityEventFactory.buildOnKeyUpEvent(keyCode, event));
=======
        contextObservationManager.notify(new OnKeyUpEvent(keyCode, event));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282834/fstmerge_var2_2270349640389397771
        return super.onKeyUp(keyCode, event);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/RoboActivity.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public void onContentChanged() {
        super.onContentChanged();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282839/fstmerge_var1_947047495635481194
        eventManager.notify(this, roboActivityEventFactory.buildOnContentChangedEvent());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282839/fstmerge_base_6030923749313336603
        contextObservationManager.notify(this, roboActivityEventFactory.buildOnContentChangedEvent());
=======
        contextObservationManager.notify(new OnContentChangedEvent());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282839/fstmerge_var2_2494701942106980352
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/RoboActivity.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282843/fstmerge_var1_1247794187549072860
        eventManager.notify(this, roboActivityEventFactory.buildOnActivityResultEvent(requestCode, resultCode, data));
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282843/fstmerge_base_9191395571717297902
        contextObservationManager.notify(this, roboActivityEventFactory.buildOnActivityResultEvent(requestCode, resultCode, data));
=======
        contextObservationManager.notify(new OnActivityResultEvent(requestCode, resultCode, data));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743282843/fstmerge_var2_8024220577001605077
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/RoboActivity.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ @Inject
    protected RoboActivityEventFactory roboActivityEventFactory; ##FSTMerge## @Inject protected RoboActivityEventFactory roboActivityEventFactory; ##FSTMerge##
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/RoboActivity.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ protected static final OnRestartEvent ON_RESTART_INSTANCE = new OnRestartEvent(); ##FSTMerge## private static final OnRestartEvent ON_RESTART_INSTANCE = new OnRestartEvent(); ##FSTMerge##
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/event/RoboActivityEventFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ protected static final OnStartEvent ON_START_INSTANCE = new OnStartEvent(); ##FSTMerge## private static final OnStartEvent ON_START_INSTANCE = new OnStartEvent(); ##FSTMerge##
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/event/RoboActivityEventFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ protected static final OnResumeEvent ON_RESUME_INSTANCE = new OnResumeEvent(); ##FSTMerge## private static final OnResumeEvent ON_RESUME_INSTANCE = new OnResumeEvent(); ##FSTMerge##
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/event/RoboActivityEventFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ protected static final OnPauseEvent ON_PAUSE_INSTANCE = new OnPauseEvent(); ##FSTMerge## private static final OnPauseEvent ON_PAUSE_INSTANCE = new OnPauseEvent(); ##FSTMerge##
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/event/RoboActivityEventFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ protected static final OnNewIntentEvent ON_NEW_INTENT_INSTANCE = new OnNewIntentEvent(); ##FSTMerge## private static final OnNewIntentEvent ON_NEW_INTENT_INSTANCE = new OnNewIntentEvent(); ##FSTMerge##
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/event/RoboActivityEventFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ protected static final OnStopEvent ON_STOP_INSTANCE = new OnStopEvent(); ##FSTMerge## private static final OnStopEvent ON_STOP_INSTANCE = new OnStopEvent(); ##FSTMerge##
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/event/RoboActivityEventFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ protected static final OnDestroyEvent ON_DESTROY_INSTANCE = new OnDestroyEvent(); ##FSTMerge## private static final OnDestroyEvent ON_DESTROY_INSTANCE = new OnDestroyEvent(); ##FSTMerge##
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/event/RoboActivityEventFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ protected static final OnContentChangedEvent ON_CONTENT_CHANGED_INSTANCE = new OnContentChangedEvent(); ##FSTMerge## private static final OnContentChangedEvent ON_CONTENT_CHANGED_INSTANCE = new OnContentChangedEvent(); ##FSTMerge##
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/activity/event/RoboActivityEventFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
@SuppressWarnings("unchecked")
    @Override
    protected void configure() {
        // Context Scope bindings
        bindScope(ContextScoped.class, contextScope);
        bind(ContextScope.class).toInstance(contextScope);
        bind(Context.class).toProvider(throwingContextProvider).in(ContextScoped.class);
        bind(Activity.class).toProvider(ActivityProvider.class);
        bind(AssetManager.class).toProvider( AssetManagerProvider.class );

        // Sundry Android Classes
        bind(SharedPreferences.class).toProvider(SharedPreferencesProvider.class);
        bind(Resources.class).toProvider(ResourcesProvider.class);
        bind(ContentResolver.class).toProvider(ContentResolverProvider.class);

        // Context observers
        bind(EventManager.class).toInstance(observationManager);

        for (Class<?> c = application.getClass(); c != null && Application.class.isAssignableFrom(c); c = c.getSuperclass())
            bind((Class<Object>) c).toInstance(application);


        // System Services
        bind(LocationManager.class).toProvider(new SystemServiceProvider<LocationManager>(Context.LOCATION_SERVICE));
        bind(WindowManager.class).toProvider(new SystemServiceProvider<WindowManager>(Context.WINDOW_SERVICE));
        bind(LayoutInflater.class).toProvider(new SystemServiceProvider<LayoutInflater>(Context.LAYOUT_INFLATER_SERVICE));
        bind(ActivityManager.class).toProvider(new SystemServiceProvider<ActivityManager>(Context.ACTIVITY_SERVICE));
        bind(PowerManager.class).toProvider(new SystemServiceProvider<PowerManager>(Context.POWER_SERVICE));
        bind(AlarmManager.class).toProvider(new SystemServiceProvider<AlarmManager>(Context.ALARM_SERVICE));
        bind(NotificationManager.class).toProvider(new SystemServiceProvider<NotificationManager>(Context.NOTIFICATION_SERVICE));
        bind(KeyguardManager.class).toProvider(new SystemServiceProvider<KeyguardManager>(Context.KEYGUARD_SERVICE));
        bind(SearchManager.class).toProvider(new SystemServiceProvider<SearchManager>(Context.SEARCH_SERVICE));
        bind(Vibrator.class).toProvider(new SystemServiceProvider<Vibrator>(Context.VIBRATOR_SERVICE));
        bind(ConnectivityManager.class).toProvider(new SystemServiceProvider<ConnectivityManager>(Context.CONNECTIVITY_SERVICE));
        bind(WifiManager.class).toProvider(new SystemServiceProvider<WifiManager>(Context.WIFI_SERVICE));
        bind(InputMethodManager.class).toProvider(new SystemServiceProvider<InputMethodManager>(Context.INPUT_METHOD_SERVICE));
        bind(SensorManager.class).toProvider( new SystemServiceProvider<SensorManager>(Context.SENSOR_SERVICE));


        // Android Resources, Views and extras require special handling
        bindListener(Matchers.any(), resourceListener);
        bindListener(Matchers.any(), extrasListener);
        bindListener(Matchers.any(), viewListener);

        if (preferenceListener != null)
          bindListener(Matchers.any(), preferenceListener);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283382/fstmerge_var1_2869492811307631133
        if (observationManager.isEnabled()) {
            bindListener(Matchers.any(), new ObserverTypeListener(contextProvider, observationManager));
        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283382/fstmerge_base_8166380845692832752
        if (observationManager.isEnabled()) {
            bindListener(Matchers.any(), new ContextObserverTypeListener(contextProvider, observationManager));
        }
=======

        if (observationManager.isEnabled())
            bindListener(Matchers.any(), new ContextObserverTypeListener(observationManager));

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283382/fstmerge_var2_6809150419246964100

        requestStaticInjection( Ln.class );
        requestStaticInjection( RoboThread.class );
        requestStaticInjection( RoboAsyncTask.class );
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/roboguice/src/main/java/roboguice/config/RoboModule.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ @Inject ExtendedContextObservingService contextObservingClassEventService; ##FSTMerge## @Inject ContextObservingClassEventService contextObservingClassEventService; ##FSTMerge## @Inject protected ContextObservingClassEventService contextObservingClassEventService;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/samples/src/roboguice/astroboy/activity/DoctorTenma.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main); // Injection doesn't happen until you
        // call setContentView()

        helloView.setText(hello + ", " + this.getClass().getSimpleName());
        helloView.setOnClickListener(new OnClickListener() {
            public void onClick(View arg0) {
                startActivity(new Intent(DoctorTenma.this, AstroPrefActivity.class));
            }
        });

        assertEquals(prefs.getString("dummyPref", "la la la"), "la la la");
        assertNull(nullInjectedMember);
        assertEquals(myDateExtra, new Date(0));
        assertEquals(nameExtra, "Atom");
        assertEquals(personFromExtra.getName(), "Atom");
        assertEquals(personFromExtra.getAge().getTime(), 3000L);
        assertEquals(personFromConvertedExtra.getName(), "Atom");
        assertEquals(dateFromTimestampExtra.getTime(), 1000L);
        assertEquals(dateFromTimestampTwiceExtra.getTime(), 2000L);

        Log.d("DoctorTenma", talker.talk());

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283526/fstmerge_var1_1553327706227052427
        backgroundJunkProvider.get().execute();


||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283526/fstmerge_base_4141308414479745527
=======

        for( int i=0; i<10; ++i ) {
            final RoboAsyncTask<Void> t = new RoboAsyncTask<Void>() {

                public Void call() throws Exception {
                    Ln.d("Doing some junk in background thread %s", this);
                    Thread.sleep(10*1000);
                    return null;
                }

                protected void onActivityDestroy( @ContextObserves OnDestroyEvent ignored ) {
                    Ln.d("Killing background thread %s", this);
                    cancel(true);
                }

            };
            getInjector().injectMembers(t);
            t.execute();
        }

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283526/fstmerge_var2_1068832074235701004
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/samples/src/roboguice/astroboy/activity/DoctorTenma.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        final BooleanResultHandler booleanReturnHandler = new BooleanResultHandler();

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283530/fstmerge_var1_5608343547654072819
        eventManager.notifyWithResult(this, roboActivityEventFactory.buildOnKeyDownEvent(keyCode, event), booleanReturnHandler);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283530/fstmerge_base_7729254022091362469
        contextObservationManager.notifyWithResult(this, roboActivityEventFactory.buildOnKeyDownEvent(keyCode, event), booleanReturnHandler);
=======
        contextObservationManager.notifyWithResult(new OnKeyDownEvent(keyCode, event), booleanReturnHandler);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283530/fstmerge_var2_5633493213201190012

        if(booleanReturnHandler.isSuccess()){
            return true;
        }
        return super.onKeyDown(keyCode, event);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/samples/src/roboguice/astroboy/activity/DoctorTenma.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ @Inject
    protected EventManager contextObserverManager; ##FSTMerge## @Inject
    private ContextObservationManager contextObserverManager; ##FSTMerge## @Inject protected ContextObservationManager contextObserverManager;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/samples/src/roboguice/astroboy/service/PreferenceChangeEventToastListener.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ @Inject
    protected ToastContextObserverService toastService; ##FSTMerge## @Inject
    private ToastContextObserverService toastService; ##FSTMerge## @Inject protected ToastContextObserverService toastService;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/samples/src/roboguice/astroboy/service/PreferenceChangeEventToastListener.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ @Inject
    protected RoboActivityEventFactory roboActivityEventFactory; ##FSTMerge## @Inject
    private RoboActivityEventFactory roboActivityEventFactory; ##FSTMerge##
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/samples/src/roboguice/astroboy/service/PreferenceChangeEventToastListener.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ @Inject
    protected Context context; ##FSTMerge## @Inject
    private Context context; ##FSTMerge##
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/samples/src/roboguice/astroboy/service/PreferenceChangeEventToastListener.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ @Inject
    protected Context context; ##FSTMerge## @Inject
    private Context context; ##FSTMerge## @Inject protected Context context;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/samples/src/roboguice/astroboy/service/ContextObservingClassEventService.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ @Inject
    protected Context context; ##FSTMerge## @Inject
    Context context; ##FSTMerge##
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/samples/src/roboguice/astroboy/service/HybridObservingService.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283594/fstmerge_var1_8633521901955316666
@Observer(OnCreateEvent.class)
    public void onCreate() {
        Ln.v("onCreate");
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283594/fstmerge_base_2306001722884740718
@ContextObserver(OnCreateEvent.class)
    public void onCreate() {
        Ln.v("onCreate");
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283594/fstmerge_var2_4023204942205435919

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/samples/src/roboguice/astroboy/service/HybridObservingService.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283598/fstmerge_var1_6666746086382047601
@Observers({
            @Observer(OnPauseEvent.class),
            @Observer(OnStopEvent.class),
            @Observer(OnDestroyEvent.class)
    })
    public void onOutOfScopeLogger() {
        Ln.v("onOutOfScope; No idea which method was called");
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283598/fstmerge_base_5885224857829791505
@ContextObservers({
            @ContextObserver(OnPauseEvent.class),
            @ContextObserver(OnStopEvent.class),
            @ContextObserver(OnDestroyEvent.class)
    })
    public void onOutOfScopeLogger() {
        Ln.v("onOutOfScope; No idea which method was called");
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283598/fstmerge_var2_8536468128037048101

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/samples/src/roboguice/astroboy/service/HybridObservingService.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283603/fstmerge_var1_5916761012158490287
public void onKeyDown(@Observes OnKeyDownEvent onKeyDownEvent) {
        Ln.v("onKeyDown %1$s", onKeyDownEvent.getEvent());
        if (onKeyDownEvent.getKeyCode() == KeyEvent.KEYCODE_SEARCH) {
            Toast.makeText(context, "You pressed the search button", Toast.LENGTH_SHORT).show();
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283603/fstmerge_base_1216002579689860933
public void onKeyDown(@ContextObserves OnKeyDownEvent onKeyDownEvent) {
        Ln.v("onKeyDown %1$s", onKeyDownEvent.getEvent());
        if (onKeyDownEvent.getKeyCode() == KeyEvent.KEYCODE_SEARCH) {
            Toast.makeText(context, "You pressed the search button", Toast.LENGTH_SHORT).show();
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283603/fstmerge_var2_1085717686333336558

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/samples/src/roboguice/astroboy/service/HybridObservingService.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ @Inject
    protected Context context; ##FSTMerge## @Inject Context context; ##FSTMerge##
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/samples/src/roboguice/astroboy/service/ContextObservingService.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283607/fstmerge_var1_3682596144063669473
@Observer(OnCreateEvent.class)
    public void onCreate() {
        Ln.v("onCreate");
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283607/fstmerge_base_5253915648417474067
@ContextObserver(OnCreateEvent.class)
    public void onCreate() {
        Ln.v("onCreate");
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283607/fstmerge_var2_6412151184594783471

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/samples/src/roboguice/astroboy/service/ContextObservingService.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283611/fstmerge_var1_8850584416194249109
@Observers({
            @Observer(OnPauseEvent.class),
            @Observer(OnStopEvent.class),
            @Observer(OnDestroyEvent.class)
    })
    public void onOutOfScopeLogger() {
        Ln.v("onOutOfScope; No idea which method was called");
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283611/fstmerge_base_1009981286172055161
@ContextObservers({
            @ContextObserver(OnPauseEvent.class),
            @ContextObserver(OnStopEvent.class),
            @ContextObserver(OnDestroyEvent.class)
    })
    public void onOutOfScopeLogger() {
        Ln.v("onOutOfScope; No idea which method was called");
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283611/fstmerge_var2_2762293505750638475

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/samples/src/roboguice/astroboy/service/ContextObservingService.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283615/fstmerge_var1_5516986718706175031
@Observer(OnKeyDownEvent.class)
    public void onKeyDown(){
         Ln.v("onKeyDownCalled");
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283615/fstmerge_base_5061072405611476199
@ContextObserver(OnKeyDownEvent.class)
    public void onKeyDown(){
         Ln.v("onKeyDownCalled");
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283615/fstmerge_var2_3905469436998846376

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/samples/src/roboguice/astroboy/service/ContextObservingService.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283619/fstmerge_var1_145526808396983391
@Observer(OnKeyDownEvent.class)
    public boolean onKeyDown(OnKeyDownEvent onKeyDownEvent) {
        Ln.v("onKeyDown %1$s", onKeyDownEvent.getEvent());
        if (onKeyDownEvent.getKeyCode() == KeyEvent.KEYCODE_SEARCH) {
            Toast.makeText(context, "You pressed the search button", Toast.LENGTH_SHORT).show();
            return true;
        }
        return false;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283619/fstmerge_base_6192128314441918717
@ContextObserver(OnKeyDownEvent.class)
    public boolean onKeyDown(OnKeyDownEvent onKeyDownEvent) {
        Ln.v("onKeyDown %1$s", onKeyDownEvent.getEvent());
        if (onKeyDownEvent.getKeyCode() == KeyEvent.KEYCODE_SEARCH) {
            Toast.makeText(context, "You pressed the search button", Toast.LENGTH_SHORT).show();
            return true;
        }
        return false;
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743283619/fstmerge_var2_8781780121153409776

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b5a29_7d707/rev_b5a29-7d707/samples/src/roboguice/astroboy/service/ContextObservingService.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_20364_9a05c/rev_20364-9a05c.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743286986/fstmerge_var1_5912983083321798810
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743286986/fstmerge_base_1514577554031500988
public <I> void hear(TypeLiteral<I> iTypeLiteral, TypeEncounter<I> iTypeEncounter) {
        for (Method method : iTypeLiteral.getRawType().getMethods()) {
            if (method.isAnnotationPresent(ContextObserver.class)) {
                final ContextObserver annotation = method.getAnnotation(ContextObserver.class);
                iTypeEncounter.register(new ContextObserverMethodInjector<I>(mContextProvider, mObservationManager, method, annotation.value()));
            }

            if (method.isAnnotationPresent(ContextObservers.class)) {
                final ContextObservers annotation = method.getAnnotation(ContextObservers.class);
                for(ContextObserver observerAnnotation : annotation.value()){
                    iTypeEncounter.register(new ContextObserverMethodInjector<I>(mContextProvider, mObservationManager, method, observerAnnotation.value()));
                }
            }
        }
    }
=======
public <I> void hear(TypeLiteral<I> iTypeLiteral, TypeEncounter<I> iTypeEncounter) {
        for (Method method : iTypeLiteral.getRawType().getMethods()) {
            if (method.isAnnotationPresent(ContextObserver.class)) {

                final Class<?>[] parameterTypes = method.getParameterTypes();                
                if( parameterTypes.length != 1 )
                    throw new InvalidParameterException("Methods annotated with @ContextObserver must take a single parameter subtype of roboguice.event.Event");

                iTypeEncounter.register(new ContextObserverMethodInjector<I>(mContextProvider, mObservationManager, method, method.getParameterTypes()[0] ));
            }
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743286986/fstmerge_var2_7994110795368874909

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_20364_9a05c/rev_20364-9a05c/roboguice/src/main/java/roboguice/inject/ContextObserverTypeListener.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ ##FSTMerge## private final Provider<Context> mContextProvider; ##FSTMerge## protected final Provider<Context> mContextProvider;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_20364_9a05c/rev_20364-9a05c/roboguice/src/main/java/roboguice/inject/ContextObserverTypeListener.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ ##FSTMerge## private final ContextObservationManager mObservationManager; ##FSTMerge## protected final ContextObservationManager mObservationManager;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_20364_9a05c/rev_20364-9a05c/roboguice/src/main/java/roboguice/inject/ContextObserverTypeListener.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ ##FSTMerge## private final Method mMethod; ##FSTMerge## protected final Method mMethod;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_20364_9a05c/rev_20364-9a05c/roboguice/src/main/java/roboguice/inject/ContextObserverTypeListener.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743286988/fstmerge_var1_2988647511484702684
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743286988/fstmerge_base_9049894685920077092
public void afterInjection(I i) {
            mObservationManager.registerObserver(mContextProvider.get(), i, mMethod, event);
        }
=======
@Override
        public void afterInjection(I i) {
            mObservationManager.registerObserver(mContextProvider.get(), i, mMethod, eventType);
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743286988/fstmerge_var2_6848889576294150111

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_20364_9a05c/rev_20364-9a05c/roboguice/src/main/java/roboguice/inject/ContextObserverTypeListener.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ ##FSTMerge## private final Field field; ##FSTMerge## protected final Field field;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_20364_9a05c/rev_20364-9a05c/roboguice/src/main/java/roboguice/inject/PreferenceListener.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ ##FSTMerge## private final Provider<Context> contextProvider; ##FSTMerge## protected final Provider<Context> contextProvider;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_20364_9a05c/rev_20364-9a05c/roboguice/src/main/java/roboguice/inject/PreferenceListener.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ ##FSTMerge## private final InjectPreference annotation; ##FSTMerge## protected final InjectPreference annotation;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_20364_9a05c/rev_20364-9a05c/roboguice/src/main/java/roboguice/inject/PreferenceListener.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ ##FSTMerge## private final Map<Context, Map<String, Set<ContextObserverMethod>>> mRegistrations; ##FSTMerge## protected final Map<Context, Map<Class<?>, Set<ContextObserverMethod>>> mRegistrations;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_20364_9a05c/rev_20364-9a05c/roboguice/src/main/java/roboguice/inject/ContextObservationManager.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743287084/fstmerge_var1_3309263455958249374
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743287084/fstmerge_base_9010979788545851371
public ContextObservationManager() {
        mRegistrations  = new WeakHashMap<Context, Map<String, Set<ContextObserverMethod>>>();
    }
=======
public ContextObservationManager() {
        mRegistrations  = new WeakHashMap<Context, Map<Class<?>, Set<ContextObserverMethod>>>();
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743287084/fstmerge_var2_509416370318365278

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_20364_9a05c/rev_20364-9a05c/roboguice/src/main/java/roboguice/inject/ContextObservationManager.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743287086/fstmerge_var1_4216213729820591184
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743287086/fstmerge_base_8380694802005740615
public void unregisterObserver(Context context, Object instance, String event) {
        if (!isEnabled()) return;

        final Map<String, Set<ContextObserverMethod>> methods = mRegistrations.get(context);
        if (methods == null) return;

        final Set<ContextObserverMethod> observers = methods.get(event);
        if (observers == null) return;

        for (Iterator<ContextObserverMethod> iterator = observers.iterator(); iterator.hasNext();) {
            ContextObserverMethod observer = iterator.next();
            if (observer != null) {
                final Object registeredInstance = observer.instanceReference.get();
                if (registeredInstance == instance) {
                    iterator.remove();
                    break;
                }
            }
        }
    }
=======
public void unregisterObserver(Context context, Object instance, String event) {
        if (!isEnabled()) return;

        final Map<Class<?>, Set<ContextObserverMethod>> methods = mRegistrations.get(context);
        if (methods == null) return;

        final Set<ContextObserverMethod> observers = methods.get(event);
        if (observers == null) return;

        for (Iterator<ContextObserverMethod> iterator = observers.iterator(); iterator.hasNext();) {
            ContextObserverMethod observer = iterator.next();
            if (observer != null) {
                final Object registeredInstance = observer.instanceReference.get();
                if (registeredInstance == instance) {
                    iterator.remove();
                    break;
                }
            }
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743287086/fstmerge_var2_5900353261029645124

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_20364_9a05c/rev_20364-9a05c/roboguice/src/main/java/roboguice/inject/ContextObservationManager.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743287088/fstmerge_var1_5013825602810970093
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743287088/fstmerge_base_4355200679867544617
public void clear(Context context) {
        if (!isEnabled()) return;

        final Map<String, Set<ContextObserverMethod>> methods = mRegistrations.get(context);
        if (methods == null) return;

        mRegistrations.remove(context);
        methods.clear();
    }
=======
public void clear(Context context) {
        if (!isEnabled()) return;

        final Map<Class<?>, Set<ContextObserverMethod>> methods = mRegistrations.get(context);
        if (methods == null) return;

        mRegistrations.remove(context);
        methods.clear();
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743287088/fstmerge_var2_536829437870571646

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_20364_9a05c/rev_20364-9a05c/roboguice/src/main/java/roboguice/inject/ContextObservationManager.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743287091/fstmerge_var1_1442927022901503198
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743287091/fstmerge_base_7101105436477669469
public void notify(Context context, String event, Object... args) {
        if (!isEnabled()) return;

        final Map<String, Set<ContextObserverMethod>> methods = mRegistrations.get(context);
        if (methods == null) return;

        final Set<ContextObserverMethod> observers = methods.get(event);
        if (observers == null) return;

        for (ContextObserverMethod observerMethod : observers) {
            try {
                observerMethod.invoke(null, args);
            } catch (InvocationTargetException e) {
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }
    }
=======
public void notify(Context context, String event, Object... args) {
        if (!isEnabled()) return;

        final Map<Class<?>, Set<ContextObserverMethod>> methods = mRegistrations.get(context);
        if (methods == null) return;

        final Set<ContextObserverMethod> observers = methods.get(event);
        if (observers == null) return;

        for (ContextObserverMethod observerMethod : observers) {
            try {
                observerMethod.invoke(null, args);
            } catch (InvocationTargetException e) {
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743287091/fstmerge_var2_8608113944202915906

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_20364_9a05c/rev_20364-9a05c/roboguice/src/main/java/roboguice/inject/ContextObservationManager.java
Conflict type: ModifierList
Conflict body: 
~~FSTMerge~~ ##FSTMerge## static ##FSTMerge## protected static
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_20364_9a05c/rev_20364-9a05c/roboguice/src/main/java/roboguice/inject/ContextObservationManager.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ ##FSTMerge## Method method; ##FSTMerge## protected Method method;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_20364_9a05c/rev_20364-9a05c/roboguice/src/main/java/roboguice/inject/ContextObservationManager.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ ##FSTMerge## WeakReference<Object> instanceReference; ##FSTMerge## protected WeakReference<Object> instanceReference;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_20364_9a05c/rev_20364-9a05c/roboguice/src/main/java/roboguice/inject/ContextObservationManager.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743287100/fstmerge_var1_6885750567910864306
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743287100/fstmerge_base_4228224147547455667
public Object invoke(Object defaultReturn, Object... args) throws InvocationTargetException, IllegalAccessException {
            final Object instance = instanceReference.get();
            if (instance != null) {
                return method.invoke(instance, args);
            }
            return defaultReturn;
        }
=======
public Object invoke(Object defaultReturn, Object... args) throws InvocationTargetException, IllegalAccessException {
            final Object instance = instanceReference.get();
            return instance!=null ? method.invoke(instance,args) : defaultReturn;
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743287100/fstmerge_var2_5663857569238411411

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_20364_9a05c/rev_20364-9a05c/roboguice/src/main/java/roboguice/inject/ContextObservationManager.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743287670/fstmerge_var1_7589327433225814155
@Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        eventManager.notify(new OnKeyDownEvent(keyCode, event));
        return super.onKeyDown(keyCode, event);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743287670/fstmerge_base_3543863233639270799
@Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        Object result = contextObservationManager.notifyWithResult(this,  ActivityEvent.ON_KEY_DOWN, false, keyCode, event);
        if (result != null && Boolean.TRUE.equals(result)) return true;
        return super.onKeyDown(keyCode, event);
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743287670/fstmerge_var2_8382615502731380511

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_20364_9a05c/rev_20364-9a05c/roboguice/src/main/java/roboguice/activity/RoboActivity.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743287673/fstmerge_var1_3074028016222731338
@Override
    public boolean onKeyUp(int keyCode, KeyEvent event) {
        eventManager.notify(new OnKeyUpEvent(keyCode, event));
        return super.onKeyUp(keyCode, event);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743287673/fstmerge_base_8963405742428778851
@Override
    public boolean onKeyUp(int keyCode, KeyEvent event) {
        Object result = contextObservationManager.notifyWithResult(this,  ActivityEvent.ON_KEY_UP, false, keyCode, event);
        if (result != null && Boolean.TRUE.equals(result)) return true;
        return super.onKeyUp(keyCode, event);

    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743287673/fstmerge_var2_1540146487823194079

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_20364_9a05c/rev_20364-9a05c/roboguice/src/main/java/roboguice/activity/RoboActivity.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_013dc_9653e/rev_013dc-9653e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_163e3_4c8c7/rev_163e3-4c8c7.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743299947/fstmerge_var1_2324685575202062475
public void injectMembers(T instance) {

        Object value = null;

        try {

            final int id = annotation.value();
            final Class<?> t = field.getType();
            final Resources resources = application.getResources();

            if (String.class.isAssignableFrom(t)) {
                value = resources.getString(id);
            } else if (boolean.class.isAssignableFrom(t) || Boolean.class.isAssignableFrom(t)) {
                value = resources.getBoolean(id);
            } else if (ColorStateList.class.isAssignableFrom(t)  ) {
                value = resources.getColorStateList(id);
            } else if (int.class.isAssignableFrom(t) || Integer.class.isAssignableFrom(t)) {
                value = resources.getInteger(id);
            } else if (Drawable.class.isAssignableFrom(t)) {
                value = resources.getDrawable(id);
            } else if (String[].class.isAssignableFrom(t)) {
                value = resources.getStringArray(id);
            } else if (int[].class.isAssignableFrom(t) || Integer[].class.isAssignableFrom(t)) {
                value = resources.getIntArray(id);
            } else if (Animation.class.isAssignableFrom(t)) {
                value = AnimationUtils.loadAnimation(application, id);
            } else if (Movie.class.isAssignableFrom(t)  ) {
                value = resources.getMovie(id);
            }

            if (value == null && field.getAnnotation(Nullable.class) == null) {
                throw new NullPointerException(String.format("Can't inject null value into %s.%s when field is not @Nullable", field.getDeclaringClass(), field
                        .getName()));
            }

            field.setAccessible(true);
            field.set(instance, value);

        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);

        } catch (IllegalArgumentException f) {
            throw new IllegalArgumentException(String.format("Can't assign %s value %s to %s field %s", value != null ? value.getClass() : "(null)", value,
                    field.getType(), field.getName()));
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743299947/fstmerge_base_9126698119215669100
public void injectMembers(T instance) {

        Object value = null;

        try {

            final int id = annotation.value();
            final Class<?> t = field.getType();
            final Resources resources = application.getResources();

            if (String.class.isAssignableFrom(t)) {
                value = resources.getString(id);
            } else if (Drawable.class.isAssignableFrom(t)) {
                value = resources.getDrawable(id);
            } else if (String[].class.isAssignableFrom(t)) {
                value = resources.getStringArray(id);
            } else if (int[].class.isAssignableFrom(t) || Integer[].class.isAssignableFrom(t)) {
                value = resources.getIntArray(id);
            }

            if (value == null && field.getAnnotation(Nullable.class) == null) {
                throw new NullPointerException(String.format("Can't inject null value into %s.%s when field is not @Nullable", field.getDeclaringClass(), field
                        .getName()));
            }

            field.setAccessible(true);
            field.set(instance, value);

        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);

        } catch (IllegalArgumentException f) {
            throw new IllegalArgumentException(String.format("Can't assign %s value %s to %s field %s", value != null ? value.getClass() : "(null)", value,
                    field.getType(), field.getName()));
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743299947/fstmerge_var2_1334524101124356786

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_163e3_4c8c7/rev_163e3-4c8c7/roboguice/src/main/java/roboguice/inject/ResourceListener.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_ce3aa_d4fce/rev_ce3aa-d4fce.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_e7fb2_6c0e7/rev_e7fb2-6c0e7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    protected void onCreate(Bundle savedInstanceState) {
        final Injector injector = getInjector();
        eventManager = injector.getInstance(EventManager.class);
        scope = injector.getInstance(ContextScope.class);
        scope.enter(this);
        injector.injectMembers(this);
        super.onCreate(savedInstanceState);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743316174/fstmerge_var1_3042234356882543313
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743316174/fstmerge_base_7011939528944474015

        // Injecting the preferences requires that they've been loaded, so load them
        onCreatePreferences();

        // Only then inject everything
        injector.injectMembers(this);

        assertNotNull(listView);


=======

        // Injecting the preferences requires that they've been loaded, so load them
        onCreatePreferences();

        // Only then inject everything
        injector.injectMembers(this);

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743316174/fstmerge_var2_5007740800819584596
        eventManager.fire(new OnCreateEvent(savedInstanceState));
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/roboguice/src/main/java/roboguice/activity/RoboPreferenceActivity.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317099/fstmerge_var1_2277691987181959039
@Before
    public void setup() throws NoSuchMethodException {
        eventManager = new EventManager();
        context = EasyMock.createMock(Context.class);
        tester = new ContextObserverTesterImpl();
        eventOneMethods = ContextObserverTesterImpl.getMethods(EventOne.class);
        eventTwoMethods = ContextObserverTesterImpl.getMethods(EventTwo.class);
        methods = new ArrayList<Method>();
        methods.addAll(eventOneMethods);
        methods.addAll(eventTwoMethods);

        event = new EventOne();
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317099/fstmerge_base_8787269625959625584
=======
@BeforeClass(groups = "roboguice")
    public void setup() throws NoSuchMethodException {
        eventManager = new EventManager();
        context = EasyMock.createMock(Context.class);
        tester = new ContextObserverTesterImpl();
        eventOneMethods = ContextObserverTesterImpl.getMethods(EventOne.class);
        eventTwoMethods = ContextObserverTesterImpl.getMethods(EventTwo.class);
        methods = new ArrayList<Method>();
        methods.addAll(eventOneMethods);
        methods.addAll(eventTwoMethods);

        event = new EventOne();
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317099/fstmerge_var2_2275050600809246660

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/roboguice/src/test/java/roboguice/event/EventManagerTest.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317103/fstmerge_var1_7478892619737271317
@Test
    public void testRegistrationLifeCycle(){
        for(Method method : eventOneMethods){
            eventManager.registerObserver(context, tester, method, EventOne.class);
        }
        for(Method method : eventTwoMethods){
            eventManager.registerObserver(context, tester, method, EventTwo.class);
        }

        eventManager.fire(context, event);

        tester.verifyCallCount(eventOneMethods, EventOne.class, 1);
        tester.verifyCallCount(eventTwoMethods, EventTwo.class, 0);

        //reset
        tester.reset();

        eventManager.unregisterObserver(context, tester, EventOne.class);
        eventManager.unregisterObserver(context, tester, EventTwo.class);

        eventManager.fire(context, event);

        tester.verifyCallCount(eventOneMethods, EventOne.class, 0);
        tester.verifyCallCount(eventTwoMethods, EventTwo.class, 0);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317103/fstmerge_base_729485893922588194
=======
@Test(groups = "roboguice")
    public void testRegistrationLifeCycle(){
        for(Method method : eventOneMethods){
            eventManager.registerObserver(context, tester, method, EventOne.class);
        }
        for(Method method : eventTwoMethods){
            eventManager.registerObserver(context, tester, method, EventTwo.class);
        }

        eventManager.fire(context, event);

        tester.verifyCallCount(eventOneMethods, EventOne.class, 1);
        tester.verifyCallCount(eventTwoMethods, EventTwo.class, 0);

        //reset
        tester.reset();

        eventManager.unregisterObserver(context, tester, EventOne.class);
        eventManager.unregisterObserver(context, tester, EventTwo.class);

        eventManager.fire(context, event);

        tester.verifyCallCount(eventOneMethods, EventOne.class, 0);
        tester.verifyCallCount(eventTwoMethods, EventTwo.class, 0);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317103/fstmerge_var2_2539330764317882237

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/roboguice/src/test/java/roboguice/event/EventManagerTest.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317107/fstmerge_var1_1960974902860896208
@Test
    public void testRegistrationClear(){
        Context contextTwo = EasyMock.createMock(Context.class);

        for(Method method : eventOneMethods){
            eventManager.registerObserver(context, tester, method, EventOne.class);
        }
        for(Method method : eventOneMethods){
            eventManager.registerObserver(contextTwo, tester, method, EventOne.class);
        }

        eventManager.clear(context);

        eventManager.fire(context, event);
        tester.verifyCallCount(eventOneMethods, EventOne.class, 0);

        eventManager.fire(contextTwo, event);
        tester.verifyCallCount(eventOneMethods, EventOne.class, 1);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317107/fstmerge_base_2729458522259468965
=======
@Test(groups = "roboguice")
    public void testRegistrationClear(){
        Context contextTwo = EasyMock.createMock(Context.class);

        for(Method method : eventOneMethods){
            eventManager.registerObserver(context, tester, method, EventOne.class);
        }
        for(Method method : eventOneMethods){
            eventManager.registerObserver(contextTwo, tester, method, EventOne.class);
        }

        eventManager.clear(context);

        eventManager.fire(context, event);
        tester.verifyCallCount(eventOneMethods, EventOne.class, 0);

        eventManager.fire(contextTwo, event);
        tester.verifyCallCount(eventOneMethods, EventOne.class, 1);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317107/fstmerge_var2_2841287826882221736

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/roboguice/src/test/java/roboguice/event/EventManagerTest.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317112/fstmerge_var1_2502501207383486003
@Test(expected = RuntimeException.class)
    public void testApplicationContextEvent(){
        Context applicationContext = EasyMock.createMock(Application.class);

        for(Method method : eventOneMethods){
            eventManager.registerObserver(applicationContext, tester, method, EventOne.class);
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317112/fstmerge_base_5804548695619640409
=======
@Test(groups = "roboguice", expectedExceptions = RuntimeException.class)
    public void testApplicationContextEvent(){
        Context applicationContext = EasyMock.createMock(Application.class);

        for(Method method : eventOneMethods){
            eventManager.registerObserver(applicationContext, tester, method, EventOne.class);
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317112/fstmerge_var2_5754135740876006419

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/roboguice/src/test/java/roboguice/event/EventManagerTest.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317116/fstmerge_var1_6672317448585843230
@Test
    public void testEquality() {

        EventManager.ObserverMethodListener<EqualityTestClass> observerRefOne = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOne);
        EventManager.ObserverMethodListener<EqualityTestClass> observerRefTwo = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOneBase);

        assertEquals(observerRefOne, observerRefTwo);
        assertEquals(observerRefOne.hashCode(), observerRefTwo.hashCode());
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317116/fstmerge_base_2450590227603999667
=======
@Test(groups = "roboguice")
    public void testEquality() throws NoSuchMethodException {

        EqualityTestClass test = new EqualityTestClass();
        Method methodOne = EqualityTestClass.class.getDeclaredMethod("one", null);
        Method methodTwo = EqualityTestOverrideClass.class.getDeclaredMethod("one", null);

        EventManager.ObserverReference<EqualityTestClass> observerRefOne = new EventManager.ObserverReference<EqualityTestClass>(test, methodOne);
        EventManager.ObserverReference<EqualityTestClass> observerRefTwo = new EventManager.ObserverReference<EqualityTestClass>(test, methodTwo);

        assertEquals(observerRefOne, observerRefTwo);
        assertEquals(observerRefOne.hashCode(), observerRefTwo.hashCode());
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317116/fstmerge_var2_981838736971148299

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/roboguice/src/test/java/roboguice/event/ObserverReferenceTest.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317120/fstmerge_var1_8244279479479874497
@Test
    public void testEqualityOfSameGuts() {

        EventManager.ObserverMethodListener<EqualityTestClass> observerRefOne = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOne);
        EventManager.ObserverMethodListener<EqualityTestClass> observerRefTwo = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOne);

        assertEquals(observerRefOne, observerRefTwo);
        assertEquals(observerRefOne.hashCode(), observerRefTwo.hashCode());
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317120/fstmerge_base_8435243990717237222
=======
@Test(groups = "roboguice")
    public void testEqualityOfSameGuts() throws NoSuchMethodException {

        EqualityTestClass test = new EqualityTestClass();
        Method methodOne = EqualityTestClass.class.getDeclaredMethod("one", null);

        EventManager.ObserverReference<EqualityTestClass> observerRefOne = new EventManager.ObserverReference<EqualityTestClass>(test, methodOne);
        EventManager.ObserverReference<EqualityTestClass> observerRefTwo = new EventManager.ObserverReference<EqualityTestClass>(test, methodOne);

        assertEquals(observerRefOne, observerRefTwo);
        assertEquals(observerRefOne.hashCode(), observerRefTwo.hashCode());
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317120/fstmerge_var2_8747247997968244932

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/roboguice/src/test/java/roboguice/event/ObserverReferenceTest.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317125/fstmerge_var1_3324577342906303141
@Test
    public void testInequalityBetweenSameClass() {

        EventManager.ObserverMethodListener<EqualityTestClass> observerRefOne = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOne);
        EventManager.ObserverMethodListener<EqualityTestClass> observerRefTwo = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodTwo);

        assert !observerRefOne.equals(observerRefTwo) ;
        assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317125/fstmerge_base_705187815404360333
=======
@Test(groups = "roboguice")
    public void testInequalityBetweenSameClass() throws NoSuchMethodException {

        EqualityTestClass test = new EqualityTestClass();
        Method methodOne = EqualityTestClass.class.getDeclaredMethod("one", null);
        Method methodTwo = EqualityTestClass.class.getDeclaredMethod("two", null);

        EventManager.ObserverReference<EqualityTestClass> observerRefOne = new EventManager.ObserverReference<EqualityTestClass>(test, methodOne);
        EventManager.ObserverReference<EqualityTestClass> observerRefTwo = new EventManager.ObserverReference<EqualityTestClass>(test, methodTwo);

        assert !observerRefOne.equals(observerRefTwo) ;
        assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317125/fstmerge_var2_1905218089024842982

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/roboguice/src/test/java/roboguice/event/ObserverReferenceTest.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317129/fstmerge_var1_4494439901777988274
@Test
    public void testInequalityBetweenDifferentClass() {

        EventManager.ObserverMethodListener<EqualityTestClass> observerRefOne = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOne);
        EventManager.ObserverMethodListener<EqualityTestClass> observerRefTwo = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodTwoBase);

        assert !observerRefOne.equals(observerRefTwo) ;
        assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317129/fstmerge_base_3100664979149632742
=======
@Test(groups = "roboguice")
    public void testInequalityBetweenDifferentClass() throws NoSuchMethodException {

        EqualityTestClass test = new EqualityTestClass();
        Method methodOne = EqualityTestClass.class.getDeclaredMethod("one", null);
        Method methodTwo = EqualityTestOverrideClass.class.getDeclaredMethod("two", null);

        EventManager.ObserverReference<EqualityTestClass> observerRefOne = new EventManager.ObserverReference<EqualityTestClass>(test, methodOne);
        EventManager.ObserverReference<EqualityTestClass> observerRefTwo = new EventManager.ObserverReference<EqualityTestClass>(test, methodTwo);

        assert !observerRefOne.equals(observerRefTwo) ;
        assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317129/fstmerge_var2_8908004572376172717

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/roboguice/src/test/java/roboguice/event/ObserverReferenceTest.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317134/fstmerge_var1_1733204252443066133
@Test
    public void testInequalityBetweenDifferentInstances() {

        EventManager.ObserverMethodListener<EqualityTestClass> observerRefOne = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOne);
        EventManager.ObserverMethodListener<EqualityTestClass> observerRefTwo = new EventManager.ObserverMethodListener<EqualityTestClass>(test2, methodOne);

        assert !observerRefOne.equals(observerRefTwo) ;
        assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317134/fstmerge_base_9207216985814765950
=======
@Test(groups = "roboguice")
    public void testInequalityBetweenDifferentInstances() throws NoSuchMethodException {

        EqualityTestClass test = new EqualityTestClass();
        EqualityTestClass test2 = new EqualityTestClass();
        Method methodOne = EqualityTestClass.class.getDeclaredMethod("one", null);

        EventManager.ObserverReference<EqualityTestClass> observerRefOne = new EventManager.ObserverReference<EqualityTestClass>(test, methodOne);
        EventManager.ObserverReference<EqualityTestClass> observerRefTwo = new EventManager.ObserverReference<EqualityTestClass>(test2, methodOne);

        assert !observerRefOne.equals(observerRefTwo) ;
        assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317134/fstmerge_var2_8438645288974504190

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/roboguice/src/test/java/roboguice/event/ObserverReferenceTest.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317138/fstmerge_var1_411197000022440125
@Test
    public void testInequalityBetweenDifferentInstancesAndDifferentMethods() {

        EventManager.ObserverMethodListener<EqualityTestClass> observerRefOne = new EventManager.ObserverMethodListener<EqualityTestClass>(test, methodOne);
        EventManager.ObserverMethodListener<EqualityTestClass> observerRefTwo = new EventManager.ObserverMethodListener<EqualityTestClass>(test2, methodTwoBase);

        assert !observerRefOne.equals(observerRefTwo) ;
        assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317138/fstmerge_base_242683223517799404
=======
@Test(groups = "roboguice")
    public void testInequalityBetweenDifferentInstancesAndDifferentMethods() throws NoSuchMethodException {

        EqualityTestClass test = new EqualityTestClass();
        EqualityTestClass test2 = new EqualityTestClass();
        Method methodOne = EqualityTestClass.class.getDeclaredMethod("one", null);
        Method methodTwo = EqualityTestOverrideClass.class.getDeclaredMethod("one", null);

        EventManager.ObserverReference<EqualityTestClass> observerRefOne = new EventManager.ObserverReference<EqualityTestClass>(test, methodOne);
        EventManager.ObserverReference<EqualityTestClass> observerRefTwo = new EventManager.ObserverReference<EqualityTestClass>(test2, methodTwo);

        assert !observerRefOne.equals(observerRefTwo) ;
         assert !Integer.valueOf(observerRefOne.hashCode()).equals(observerRefTwo.hashCode());
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317138/fstmerge_var2_8710019598923659806

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/roboguice/src/test/java/roboguice/event/ObserverReferenceTest.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317143/fstmerge_var1_8035989203651800916
public void verifyCallCount(List<Method> methods, Class<?> event, int expectedCount){
        for(Method method : methods){

            assertTrue("Method: " + method.getName() + " was not called.",
                    callCount.containsKey(method.getName()) || expectedCount == 0);

            if(callCount.containsKey(method.getName())){

            Map<Class<?>, Integer> callCountClass = callCount.get(method.getName());

                if(expectedCount > 0){

                    assertTrue("Event: " + event.getName() + " was not observed.",
                            callCountClass.containsKey(event) || expectedCount == 0);

                    if(callCountClass.containsKey(event)){
                        assertEquals(
                                "Call count was not expected",
                                callCountClass.get(event).intValue(), expectedCount);
                    }
                }
            }
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317143/fstmerge_base_5943280035223534288
=======
public void verifyCallCount(List<Method> methods, Class<?> event, int expectedCount){
        for(Method method : methods){
            assertTrue(callCount.containsKey(method.getName()) || expectedCount == 0);
            if(callCount.containsKey(method.getName())){
            Map<Class<?>, Integer> callCountClass = callCount.get(method.getName());
                if(expectedCount > 0){
                    assertTrue(callCountClass.containsKey(event) || expectedCount == 0);
                    if(callCountClass.containsKey(event)){
                        assertEquals(callCountClass.get(event).intValue(), expectedCount);
                    }
                }
            }
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317143/fstmerge_var2_609423606332711727

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/roboguice/src/test/java/roboguice/event/ContextObserverBase.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317214/fstmerge_var1_9132665290808064429
@Before
    public void setup() throws NoSuchMethodException {
        context = EasyMock.createMock(Context.class);
        
        contextProvider = new Provider<Context>() {
            public Context get() {
                return context;
            }
        };

        Module eventManagerModule = new EventManagerModule(new EventManager(), contextProvider);

        Module contextProviderModule = new AbstractModule() {
            public void configure() {
                bind(Context.class).toProvider(contextProvider);
            }
        };

        injector = Guice.createInjector(eventManagerModule, contextProviderModule);

        eventManager = injector.getInstance(EventManager.class);

        eventOneMethods = ContextObserverTesterImpl.getMethods(EventOne.class);
        eventTwoMethods = ContextObserverTesterImpl.getMethods(EventTwo.class);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317214/fstmerge_base_5529012164623254368
=======
@BeforeClass(groups = "roboguice")
    public void setup() throws NoSuchMethodException {
        context = EasyMock.createMock(Context.class);

        contextAwareEventManager = new EventManager();

        contextProvider = new Provider<Context>() {
            public Context get() {
                return context;
            }
        };

        Module eventManagerModule = new EventManagerModule(new EventManager(), contextProvider);

        Module contextProviderModule = new AbstractModule() {
            public void configure() {
                bind(Context.class).toProvider(contextProvider);
            }
        };

        injector = Guice.createInjector(eventManagerModule, contextProviderModule);
        injector.injectMembers(contextAwareEventManager);

        eventOneMethods = ContextObserverTesterImpl.getMethods(EventOne.class);
        eventTwoMethods = ContextObserverTesterImpl.getMethods(EventTwo.class);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317214/fstmerge_var2_480066571591993761

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/roboguice/src/test/java/roboguice/event/ObservesTypeListenerTest.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317219/fstmerge_var1_8925457951276091129
@Test
    public void simulateInjection() {
        InjectedTestClass testClass = new InjectedTestClass();
        injector.injectMembers(testClass);

        eventManager.fire(new EventOne());

        testClass.getTester().verifyCallCount(eventOneMethods, EventOne.class, 1);
        testClass.getTester().verifyCallCount(eventTwoMethods, EventTwo.class, 0);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317219/fstmerge_base_8854047555073603760
=======
@Test(groups = "roboguice")
    public void simulateInjection() {
        InjectedTestClass testClass = new InjectedTestClass();
        injector.injectMembers(testClass);

        contextAwareEventManager.fire(new EventOne());

        testClass.getTester().verifyCallCount(eventOneMethods, EventOne.class, 1);
        testClass.getTester().verifyCallCount(eventTwoMethods, EventTwo.class, 0);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317219/fstmerge_var2_3269532180872195386

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/roboguice/src/test/java/roboguice/event/ObservesTypeListenerTest.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317224/fstmerge_var1_7443160836922374257
@Test(expected = RuntimeException.class)
    public void invalidObservesMethodSignature(){
        injector.getInstance(MalformedObserves.class);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317224/fstmerge_base_7182515507329771922
=======
@Test(groups = "roboguice", expectedExceptions = RuntimeException.class)
    public void invalidObservesMethodSignature(){
        MalformedObserves testClass = new MalformedObserves();

        injector.injectMembers(testClass);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317224/fstmerge_var2_6005028662365237699

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/roboguice/src/test/java/roboguice/event/ObservesTypeListenerTest.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ ##FSTMerge## @InjectPreference("bool_pref")
  CheckBoxPreference boolPref; ##FSTMerge## @InjectPreference("bool_pref") protected CheckBoxPreference boolPref;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/samples/src/roboguice/astroboy/activity/AstroPrefActivity.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ ##FSTMerge## @Inject
  PreferenceChangeEventToastListener preferenceChangeEventListener; ##FSTMerge## @Inject protected PreferenceChangeEventToastListener preferenceChangeEventListener;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/samples/src/roboguice/astroboy/activity/AstroPrefActivity.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317361/fstmerge_var1_4906484527032634350
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317361/fstmerge_base_514273492901192631
@Override
  protected void onCreatePreferences() {
    addPreferencesFromResource(R.xml.preference);
  }
=======
@Override
    protected void onCreatePreferences() {
        addPreferencesFromResource(R.xml.preference);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317361/fstmerge_var2_8274818879314536846

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/samples/src/roboguice/astroboy/activity/AstroPrefActivity.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317365/fstmerge_var1_6667640445201184895
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317365/fstmerge_base_4747867777376636192
@Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

      //example of binding a event listener through a preference change listener
    boolPref.setOnPreferenceChangeListener(preferenceChangeEventListener);
  }
=======
@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        //example of binding a event listener through a preference change listener
        boolPref.setOnPreferenceChangeListener(preferenceChangeEventListener);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743317365/fstmerge_var2_5776839530226689544

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_56fbe_532fa/rev_56fbe-532fa/samples/src/roboguice/astroboy/activity/AstroPrefActivity.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_bee33_b6d1a/rev_bee33-b6d1a.revisions
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ ##FSTMerge## protected RoboApplication app; ##FSTMerge## protected Application app;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_bee33_b6d1a/rev_bee33-b6d1a/roboguice/src/main/java/roboguice/inject/ContextScope.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743321940/fstmerge_var1_3672128528626841820
public void exit(Context context) {
        ensureContextStack();
        contextStack.get().remove(context);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743321940/fstmerge_base_7579790276953437769
@SuppressWarnings({"UnusedParameters"})
    public void exit(Context ignored) {
        values.remove();
=======
public void exit(Context ignored) {
        values.remove();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743321940/fstmerge_var2_3177762663264798912
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_bee33_b6d1a/rev_bee33-b6d1a/roboguice/src/main/java/roboguice/inject/ContextScope.java
Conflict type: LineBasedMCFd
Conflict body: 
@SuppressWarnings({"SuspiciousMethodCalls","unchecked"})
    public <T> Provider<T> scope(final Key<T> key, final Provider<T> unscoped) {
        return new Provider<T>() {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743321949/fstmerge_base_2335307421572297679
            @SuppressWarnings({"SuspiciousMethodCalls", "unchecked"})
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743321949/fstmerge_var2_4310339303760048003
            public T get() {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743321949/fstmerge_var1_2626862395600548152
                Map<Key<?>, Object> scopedObjects = getScopedObjectMap(key);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743321949/fstmerge_base_2335307421572297679
                final Map<Key<Context>, Object> scopedObjects = getScopedObjectMap(key);
=======
                final Map<Key<Context>,Object> map = values.get();
                final Map<Key<Context>, Object> scopedObjects = map != null ? map : initialScopedObjectMap();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743321949/fstmerge_var2_4310339303760048003

                T current = (T) scopedObjects.get(key);
                if (current == null && !scopedObjects.containsKey(key)) {
                    current = unscoped.get();
                    scopedObjects.put(key, current);
                }
                return current;
            }
        };
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_bee33_b6d1a/rev_bee33-b6d1a/roboguice/src/main/java/roboguice/inject/ContextScope.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743321955/fstmerge_var1_6469222776713065694
public ContextScope(RoboApplication app) {
        enter(app);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743321955/fstmerge_base_5605210963122241308
public ContextScope( RoboApplication app ) {
        this.app = app;
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743321955/fstmerge_var2_4292803865881310332

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_bee33_b6d1a/rev_bee33-b6d1a/roboguice/src/main/java/roboguice/inject/ContextScope.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743321958/fstmerge_var1_4152168960000985597
protected <T> Map<Key<?>, Object> getScopedObjectMap(Key<T> key) {
        final Context context = contextStack.get().peek();

        Map<Key<?>,Object> scopedObjects = values.get(context);
        if (scopedObjects == null) {
            scopedObjects = Maps.newHashMap();
            values.put(context, scopedObjects);
        }

        return scopedObjects;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743321958/fstmerge_base_3827460705881609562
@SuppressWarnings({"UnusedParameters"})
    protected <T> Map<Key<Context>, Object> getScopedObjectMap(Key<T> key) {
        final Map<Key<Context>,Object> map = values.get();
        return map!=null ? map : initialScopedObjectMap();
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743321958/fstmerge_var2_4507328757367299077

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_bee33_b6d1a/rev_bee33-b6d1a/roboguice/src/main/java/roboguice/inject/ContextScope.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323127/fstmerge_var1_7349118478206724860
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323127/fstmerge_base_3258712684322165550
public void registerObserver(Context context, Object instance, Method method, Class event) {
        if (!isEnabled()) return;

        if( context instanceof Application )
            throw new RuntimeException("You may not register event handlers on the Application context");

        Map<Class<?>, Set<ObserverReference<?>>> methods = registrations.get(context);
        if (methods == null) {
            methods = new HashMap<Class<?>, Set<ObserverReference<?>>>();
            registrations.put(context, methods);
        }

        Set<ObserverReference<?>> observers = methods.get(event);
        if (observers == null) {
            observers = new HashSet<ObserverReference<?>>();
            methods.put(event, observers);
        }

        /*
        final Returns returns = (Returns) event.getAnnotation(Returns.class);
        if( returns!=null ) {
            if( !returns.value().isAssignableFrom(method.getReturnType()) )
                throw new RuntimeException( String.format("Method %s.%s does not return a value that is assignable to %s",method.getDeclaringClass().getName(),method.getName(),returns.value().getName()) );

            if( !observers.isEmpty() ) {
                final ObserverReference observer = observers.iterator().next();
                throw new RuntimeException( String.format("Only one observer allowed for event types that return a value annotation.  Previously registered observer is %s.%s", observer.method.getDeclaringClass().getName(), observer.method.getName()));
            }
        }
        */

        observers.add(new ObserverReference(instance, method));
    }
=======
public void registerObserver(Context context, Object instance, Method method, Class event) {
        if( context instanceof Application )
            throw new RuntimeException("You may not register event handlers on the Application context");

        Map<Class<?>, Set<ObserverReference<?>>> methods = registrations.get(context);
        if (methods == null) {
            methods = new HashMap<Class<?>, Set<ObserverReference<?>>>();
            registrations.put(context, methods);
        }

        Set<ObserverReference<?>> observers = methods.get(event);
        if (observers == null) {
            observers = new HashSet<ObserverReference<?>>();
            methods.put(event, observers);
        }

        /*
        final Returns returns = (Returns) event.getAnnotation(Returns.class);
        if( returns!=null ) {
            if( !returns.value().isAssignableFrom(method.getReturnType()) )
                throw new RuntimeException( String.format("Method %s.%s does not return a value that is assignable to %s",method.getDeclaringClass().getName(),method.getName(),returns.value().getName()) );

            if( !observers.isEmpty() ) {
                final ObserverReference observer = observers.iterator().next();
                throw new RuntimeException( String.format("Only one observer allowed for event types that return a value annotation.  Previously registered observer is %s.%s", observer.method.getDeclaringClass().getName(), observer.method.getName()));
            }
        }
        */

        observers.add(new ObserverReference(instance, method));
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323127/fstmerge_var2_1901582987204820418

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_bee33_b6d1a/rev_bee33-b6d1a/roboguice/src/main/java/roboguice/event/EventManager.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323131/fstmerge_var1_2342801868095055134
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323131/fstmerge_base_2605724892203245186
public void unregisterObserver(Context context, Object instance, Class event) {
        if (!isEnabled()) return;

        final Map<Class<?>, Set<ObserverReference<?>>> methods = registrations.get(context);
        if (methods == null) return;

        final Set<ObserverReference<?>> observers = methods.get(event);
        if (observers == null) return;

        for (Iterator<ObserverReference<?>> iterator = observers.iterator(); iterator.hasNext();) {
            ObserverReference observer = iterator.next();
            if (observer != null) {
                final Object registeredInstance = observer.instanceReference.get();
                if (registeredInstance == instance) {
                    iterator.remove();
                    break;
                }
            }
        }
    }
=======
public void unregisterObserver(Context context, Object instance, Class event) {
        final Map<Class<?>, Set<ObserverReference<?>>> methods = registrations.get(context);
        if (methods == null) return;

        final Set<ObserverReference<?>> observers = methods.get(event);
        if (observers == null) return;

        for (Iterator<ObserverReference<?>> iterator = observers.iterator(); iterator.hasNext();) {
            ObserverReference observer = iterator.next();
            if (observer != null) {
                final Object registeredInstance = observer.instanceReference.get();
                if (registeredInstance == instance) {
                    iterator.remove();
                    break;
                }
            }
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323131/fstmerge_var2_1845608859452779619

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_bee33_b6d1a/rev_bee33-b6d1a/roboguice/src/main/java/roboguice/event/EventManager.java
Conflict type: LineBasedMCFd
Conflict body: 
public void fire(Context context, Object event) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323145/fstmerge_var1_4864222101467010551
        if (!isEnabled()) return;
        
        final Map<Class<?>, Set<EventListener<?>>> methods = registrations.get(context);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323145/fstmerge_base_5121325438961932714
        if (!isEnabled()) return;

        /*
        if( event.getClass().getAnnotation(Returns.class)!=null )
            throw new RuntimeException("You must use notifyWithResult for events that expect return values");
        */

        final Map<Class<?>, Set<ObserverReference<?>>> methods = registrations.get(context);
=======
        /*
        if( event.getClass().getAnnotation(Returns.class)!=null )
            throw new RuntimeException("You must use notifyWithResult for events that expect return values");
        */

        final Map<Class<?>, Set<ObserverReference<?>>> methods = registrations.get(context);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323145/fstmerge_var2_3476806655455458068
        if (methods == null) return;


        final Set<EventListener<?>> observers = methods.get(event.getClass());
        if (observers == null) return;

        for (EventListener observer : observers)
            observer.onEvent(event);

    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_bee33_b6d1a/rev_bee33-b6d1a/roboguice/src/main/java/roboguice/event/EventManager.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323258/fstmerge_var1_6243048758152956918
    public final void onReceive(Context context, Intent intent) {
        final Injector injector = ((RoboApplication) context.getApplicationContext()).getInjector();
        final Context current = injector.getInstance(Context.class);

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323258/fstmerge_base_1272325413989607316
    public void onReceive(Context context, Intent intent) {
        final Injector injector = ((RoboApplication) context.getApplicationContext()).getInjector();
=======
    public void onReceive(Context context, Intent intent) {
        final Injector injector = RoboGuice.getInjector((Application)context.getApplicationContext());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323258/fstmerge_var2_3649970523016636778
        scope = injector.getInstance(ContextScope.class);
        scope.enter(context);
        try {
            injector.injectMembers(this);
            handleReceive(context, intent);
        } finally {
            scope.exit(context);
            scope.enter(current);
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_bee33_b6d1a/rev_bee33-b6d1a/roboguice/src/main/java/roboguice/receiver/RoboBroadcastReceiver.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    protected void configure() {
        
        final ExtrasListener extrasListener = new ExtrasListener(contextProvider);
        final EventManager eventManager = new EventManager();
        final PreferenceListener preferenceListener = new PreferenceListener(contextProvider);


        // Context Scope bindings
        bindScope(ContextScoped.class, contextScope);
        bind(ContextScope.class).toInstance(contextScope);
        bind(Context.class).toProvider(contextProvider).in(ContextScoped.class);
        bind(Activity.class).toProvider(ActivityProvider.class);
        bind(AssetManager.class).toProvider(AssetManagerProvider.class);

        
        // Sundry Android Classes
        bind(SharedPreferences.class).toProvider(SharedPreferencesProvider.class);
        bind(Resources.class).toProvider(ResourcesProvider.class);
        bind(ContentResolver.class).toProvider(ContentResolverProvider.class);
        bind(Application.class).toInstance(application);


        // Package Info
        try {
            final PackageInfo info = application.getPackageManager().getPackageInfo(application.getPackageName(),0);
            bind(PackageInfo.class).toInstance(info);
        } catch( PackageManager.NameNotFoundException e ) {
            throw new RuntimeException(e);
        }


<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323263/fstmerge_var1_2128799133942794739
        for (Class<?> c = application.getClass(); c != null && Application.class.isAssignableFrom(c); c = c.getSuperclass())
            bind((Class<Object>) c).toInstance(application);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323263/fstmerge_base_7043321366047059638
        // Context observers
        bind(EventManager.class).toInstance(eventManager);

        for (Class<?> c = application.getClass(); c != null && Application.class.isAssignableFrom(c); c = c.getSuperclass())
            bind((Class<Object>) c).toInstance(application);
=======
        bind(EventManager.class).toInstance(eventManager);

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323263/fstmerge_var2_2264328039313376599


        // System Services
        bind(LocationManager.class).toProvider(new SystemServiceProvider<LocationManager>(Context.LOCATION_SERVICE));
        bind(WindowManager.class).toProvider(new SystemServiceProvider<WindowManager>(Context.WINDOW_SERVICE));
        bind(LayoutInflater.class).toProvider(new SystemServiceProvider<LayoutInflater>(Context.LAYOUT_INFLATER_SERVICE));
        bind(ActivityManager.class).toProvider(new SystemServiceProvider<ActivityManager>(Context.ACTIVITY_SERVICE));
        bind(PowerManager.class).toProvider(new SystemServiceProvider<PowerManager>(Context.POWER_SERVICE));
        bind(AlarmManager.class).toProvider(new SystemServiceProvider<AlarmManager>(Context.ALARM_SERVICE));
        bind(NotificationManager.class).toProvider(new SystemServiceProvider<NotificationManager>(Context.NOTIFICATION_SERVICE));
        bind(KeyguardManager.class).toProvider(new SystemServiceProvider<KeyguardManager>(Context.KEYGUARD_SERVICE));
        bind(SearchManager.class).toProvider(new SystemServiceProvider<SearchManager>(Context.SEARCH_SERVICE));
        bind(Vibrator.class).toProvider(new SystemServiceProvider<Vibrator>(Context.VIBRATOR_SERVICE));
        bind(ConnectivityManager.class).toProvider(new SystemServiceProvider<ConnectivityManager>(Context.CONNECTIVITY_SERVICE));
        bind(WifiManager.class).toProvider(new SystemServiceProvider<WifiManager>(Context.WIFI_SERVICE));
        bind(InputMethodManager.class).toProvider(new SystemServiceProvider<InputMethodManager>(Context.INPUT_METHOD_SERVICE));
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323263/fstmerge_var1_2128799133942794739
        bind(SensorManager.class).toProvider( new SystemServiceProvider<SensorManager>(Context.SENSOR_SERVICE));
        bind(TelephonyManager.class).toProvider( new SystemServiceProvider<TelephonyManager>(Context.TELEPHONY_SERVICE));
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323263/fstmerge_base_7043321366047059638
        bind(SensorManager.class).toProvider( new SystemServiceProvider<SensorManager>(Context.SENSOR_SERVICE));
=======
        bind(SensorManager.class).toProvider(new SystemServiceProvider<SensorManager>(Context.SENSOR_SERVICE));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323263/fstmerge_var2_2264328039313376599


        // Android Resources, Views and extras require special handling
        bindListener(Matchers.any(), resourceListener);
        bindListener(Matchers.any(), extrasListener);
        bindListener(Matchers.any(), viewListener);
        bindListener(Matchers.any(), preferenceListener);
        bindListener(Matchers.any(), new ObservesTypeListener(contextProvider, eventManager));

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323263/fstmerge_var1_2128799133942794739
        if (preferenceListener != null)
          bindListener(Matchers.any(), preferenceListener);
        
        requestStaticInjection( Ln.class );
        requestStaticInjection( RoboThread.class );
        requestStaticInjection( RoboAsyncTask.class );
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323263/fstmerge_base_7043321366047059638
        if (preferenceListener != null)
          bindListener(Matchers.any(), preferenceListener);

        if (eventManager.isEnabled())
            bindListener(Matchers.any(), new ObservesTypeListener(contextProvider, eventManager));

        requestInjection(eventManager);
        
        requestStaticInjection( Ln.class );
        requestStaticInjection( RoboThread.class );
        requestStaticInjection( RoboAsyncTask.class );
=======
        requestInjection(eventManager);

        requestStaticInjection(Ln.class);
        requestStaticInjection(RoboThread.class);
        requestStaticInjection(RoboAsyncTask.class);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323263/fstmerge_var2_2264328039313376599
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_bee33_b6d1a/rev_bee33-b6d1a/roboguice/src/main/java/roboguice/config/RoboModule.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323308/fstmerge_var1_1013850063940778506
protected void initInstanceMembers() {
        contextScope = new ContextScope(this);
        throwingContextProvider = new Provider<Context>() {
            public Context get() {
                return RoboApplication.this;
            }
        };
        
        contextProvider = contextScope.scope(Key.get(Context.class), throwingContextProvider);
        resourceListener = new ResourceListener(this);
        viewListener = new ViewListener(contextProvider, this, contextScope);
        extrasListener = new ExtrasListener(contextProvider);
        eventManager = allowContextObservers() ? new EventManager() : new EventManager.NullEventManager();

        if (allowPreferenceInjection())
          preferenceListener = new PreferenceListener(contextProvider, this, contextScope);


        staticTypeListeners = new ArrayList<StaticTypeListener>();
        staticTypeListeners.add(resourceListener);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323308/fstmerge_base_5352219007786838520
protected void initInstanceMembers() {
        contextScope = new ContextScope(this);
        throwingContextProvider = new Provider<Context>() {
            public Context get() {
                return RoboApplication.this;
            }
        };
        
        contextProvider = contextScope.scope(Key.get(Context.class), throwingContextProvider);
        resourceListener = new ResourceListener(this);
        viewListener = new ViewListener(contextProvider, this, contextScope);
        extrasListener = new ExtrasListener(contextProvider);
        eventManager = allowContextObservers() ? new EventManager() : new NullEventManager();
                
        if (allowPreferenceInjection())
          preferenceListener = new PreferenceListener(contextProvider);


        staticTypeListeners = new ArrayList<StaticTypeListener>();
        staticTypeListeners.add(resourceListener);
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323308/fstmerge_var2_8663213404776354065

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_bee33_b6d1a/rev_bee33-b6d1a/roboguice/src/main/java/roboguice/application/RoboApplication.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323312/fstmerge_var1_297746833221477848
protected Injector createInjector() {
        final ArrayList<Module> modules = new ArrayList<Module>();
        final Module roboguiceModule = new RoboModule(contextScope, throwingContextProvider,
                contextProvider, resourceListener, viewListener, extrasListener, preferenceListener, this);
        modules.add(roboguiceModule);

        // Separate module required for testing eventmanager
        final Module eventManagerModule = new EventManagerModule(eventManager, contextProvider);
        modules.add(eventManagerModule);
        
        //context observer manager module
        addApplicationModules(modules);
        for (Module m : modules)
            if (m instanceof AbstractAndroidModule)
                ((AbstractAndroidModule) m).setStaticTypeListeners(staticTypeListeners);
                    
        return Guice.createInjector(Stage.PRODUCTION, modules);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323312/fstmerge_base_8913652715022172665
protected Injector createInjector() {
        ArrayList<Module> modules = new ArrayList<Module>();
        Module roboguiceModule = new RoboModule(contextScope, throwingContextProvider,
                contextProvider, resourceListener, viewListener, extrasListener, preferenceListener,
                eventManager, this);
        modules.add(roboguiceModule);
        //context observer manager module
        addApplicationModules(modules);
        for (Module m : modules) {
            if (m instanceof AbstractAndroidModule) {
                ((AbstractAndroidModule) m).setStaticTypeListeners(staticTypeListeners);
            }
        }
        return Guice.createInjector(Stage.PRODUCTION, modules);
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323312/fstmerge_var2_4992830802739397931

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_bee33_b6d1a/rev_bee33-b6d1a/roboguice/src/main/java/roboguice/application/RoboApplication.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323672/fstmerge_var1_982539783487095243
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323672/fstmerge_base_7796559157756526234
@Override
    protected void configure() {

        // Context observers
        bind(EventManager.class).toInstance(eventManager);

        if (eventManager.isEnabled())
            bindListener(Matchers.any(), new ObservesTypeListener(contextProvider, eventManager));

        requestInjection(eventManager);
    }
=======
@Override
    protected void configure() {

        // Context observers
        bind(EventManager.class).toInstance(eventManager);
        bindListener(Matchers.any(), new ObservesTypeListener(contextProvider, eventManager));

        requestInjection(eventManager);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323672/fstmerge_var2_6773751655326007904

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_bee33_b6d1a/rev_bee33-b6d1a/roboguice/src/test/java/roboguice/event/ObservesTypeListenerTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323777/fstmerge_var1_4023217094429457196
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323777/fstmerge_base_7772372763471508527
@Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main); // Injection doesn't happen until you call setContentView()

        helloView.setText(hello + ", " + this.getClass().getSimpleName());
        helloView.setOnClickListener(new OnClickListener() {
            public void onClick(View arg0) {
                startActivity(new Intent(DoctorTenma.this, AstroPrefActivity.class));
            }
        });

        assertEquals(prefs.getString("dummyPref", "la la la"), "la la la");
        assertNull(nullInjectedMember);
        assertEquals(myDateExtra, new Date(0));
        assertEquals(nameExtra, "Atom");
        assertEquals(personFromExtra.getName(), "Atom");
        assertEquals(personFromExtra.getAge().getTime(), 3000L);
        assertEquals(personFromConvertedExtra.getName(), "Atom");
        assertEquals(dateFromTimestampExtra.getTime(), 1000L);
        assertEquals(dateFromTimestampTwiceExtra.getTime(), 2000L);

        Ln.d(talker.talk());

        backgroundTaskProvider.execute();

    }
=======
@Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main); // Injection doesn't happen until you call setContentView()

        helloView.setText(hello + ", " + this.getClass().getSimpleName());
        helloView.setOnClickListener(new OnClickListener() {
            public void onClick(View arg0) {
                startActivity(new Intent(DoctorTenma.this, AstroPrefActivity.class));
            }
        });

        assertEquals(prefs.getString("dummyPref", "la la la"), "la la la");
        assertNull(nullInjectedMember);
        assertEquals(myDateExtra, new Date(0));
        assertEquals(nameExtra, "Atom");
        assertEquals(personFromExtra.getName(), "Atom");
        assertEquals(personFromExtra.getAge().getTime(), 3000L);
        assertEquals(personFromConvertedExtra.getName(), "Atom");
        assertEquals(dateFromTimestampExtra.getTime(), 1000L);
        assertEquals(dateFromTimestampTwiceExtra.getTime(), 2000L);

        Ln.d(talker.talk());

        backgroundTaskProvider.execute();

        // It's better to use @Inject Injector to get an injector, but you can always use RoboGuice.getInjector() in a pinch
        final Injector injector = RoboGuice.getInjector(this.getApplication());
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743323777/fstmerge_var2_4108138542416629194

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_bee33_b6d1a/rev_bee33-b6d1a/samples/src/roboguice/astroboy/activity/DoctorTenma.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ ##FSTMerge## @Inject protected AstroboyApplication application; ##FSTMerge## @Inject protected Application application;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_bee33_b6d1a/rev_bee33-b6d1a/samples/src/roboguice/astroboy/service/TalkingThingMockImpl.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_a6878_42d25/rev_a6878-42d25.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_8ea37_29fac/rev_8ea37-29fac.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_708a2_f0033/rev_708a2-f0033.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_f2df2_708a2/rev_f2df2-708a2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_cd77e_1f910/rev_cd77e-1f910.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public <T> Provider<T> scope(final Key<T> key, final Provider<T> unscoped) {
        return new Provider<T>() {
            public T get() {
                Map<Key<?>, WeakReference<Object>> scopedObjects = getScopedObjectMap(key);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743358123/fstmerge_var1_8246782991568196433
                @SuppressWarnings({"unchecked"}) T current = (T) scopedObjects.get(key).get();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743358123/fstmerge_base_6464629832081504363
                @SuppressWarnings("unchecked")
                T current = (T) scopedObjects.get(key);
=======
                @SuppressWarnings({"unchecked"}) T current = (T) scopedObjects.get(key);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743358123/fstmerge_var2_8656463317114192440
                if (current == null && !scopedObjects.containsKey(key)) {
                    current = unscoped.get();
                    scopedObjects.put(key, new WeakReference<Object>(current));
                }
                return current;
            }
        };
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_cd77e_1f910/rev_cd77e-1f910/roboguice/src/main/java/roboguice/inject/ContextScope.java
Conflict type: LineBasedMCFd
Conflict body: 
public <I> void hear(TypeLiteral<I> typeLiteral, TypeEncounter<I> typeEncounter) {

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743358197/fstmerge_var1_6203855745987441914
        Class<?> c = typeLiteral.getRawType();
        while (c != null) {
            for (Field field : c.getDeclaredFields()) {
                if (field.isAnnotationPresent(InjectExtra.class))
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743358197/fstmerge_base_6478515922933288521
        Class<?> c = typeLiteral.getRawType();
        while (c != null) {
            for (Field field : c.getDeclaredFields()) {
                if (field.isAnnotationPresent(InjectExtra.class)) {
=======
        for( Class<?> c = typeLiteral.getRawType(); c!=Object.class; c=c.getSuperclass() )
            for (Field field : c.getDeclaredFields())
                if (field.isAnnotationPresent(InjectExtra.class))
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743358197/fstmerge_var2_5872239719696140815
                    typeEncounter.register(new ExtrasMembersInjector<I>(field, contextProvider, field.getAnnotation(InjectExtra.class)));
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743358197/fstmerge_var1_6203855745987441914

            }
            c = c.getSuperclass();
        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743358197/fstmerge_base_6478515922933288521
                }
            }
            c = c.getSuperclass();
        }
=======


>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743358197/fstmerge_var2_5872239719696140815
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_cd77e_1f910/rev_cd77e-1f910/roboguice/src/main/java/roboguice/inject/ExtrasListener.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_0e2eb_87717/rev_0e2eb-87717.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_4b0f0_e06fb/rev_4b0f0-e06fb.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743372807/fstmerge_var1_5554133466575722196
public void reallyInjectMembers() {
        final T instance = instanceRef.get();
        if( instance==null )
            return;

        Object value = null;

        try {

            value = ((PreferenceActivity) contextProvider.get()).findPreference(annotation.value());

            if (value == null && field.getAnnotation(Nullable.class) == null)
                throw new NullPointerException(String.format("Can't inject null value into %s.%s when field is not @Nullable", field.getDeclaringClass(), field.getName()));


            field.setAccessible(true);
            field.set(instance, value);

        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);

        } catch (IllegalArgumentException f) {
            throw new IllegalArgumentException(String.format("Can't assign %s value %s to %s field %s", value != null ? value.getClass() : "(null)", value,
                    field.getType(), field.getName()));
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743372807/fstmerge_base_1866543495372229747
public void reallyInjectMembers() {
        final T instance = instanceRef.get();
        if( instance==null )
            return;

        Object value = null;

        try {

            value = ((PreferenceActivity) contextProvider.get()).findPreference(annotation.value());

            if (value == null && field.getAnnotation(Nullable.class) == null)
                throw new NullPointerException(String.format("Can't inject null value into %s.%s when field is not @Nullable", field.getDeclaringClass(), field.getName()));


            field.setAccessible(true);
            field.set(instanceRef, value);

        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);

        } catch (IllegalArgumentException f) {
            throw new IllegalArgumentException(String.format("Can't assign %s value %s to %s field %s", value != null ? value.getClass() : "(null)", value,
                    field.getType(), field.getName()));
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743372807/fstmerge_var2_6512903871778072304

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_4b0f0_e06fb/rev_4b0f0-e06fb/roboguice/src/main/java/roboguice/inject/PreferenceListener.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_6492f_86b02/rev_6492f-86b02.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_c76e1_ca2e0/rev_c76e1-ca2e0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_a76a4_2f8d0/rev_a76a4-2f8d0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_7076a_6d916/rev_7076a-6d916.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_0c617_7bd42/rev_0c617-7bd42.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_3d3fa_4c35b/rev_3d3fa-4c35b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b761c_a9f25/rev_b761c-a9f25.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_1a9ff_2e674/rev_1a9ff-2e674.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_cb9cf_9a9a6/rev_cb9cf-9a9a6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_23f32_75a42/rev_23f32-75a42.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_fad03_9a2fe/rev_fad03-9a2fe.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_444ad_9ca72/rev_444ad-9ca72.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_d7778_192e2/rev_d7778-192e2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_ed98d_c41c5/rev_ed98d-c41c5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b0dc7_e5a37/rev_b0dc7-e5a37.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_39996_5e6ce/rev_39996-5e6ce.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_9d649_7b90c/rev_9d649-7b90c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_ad147_4fbd7/rev_ad147-4fbd7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_2ba14_c767f/rev_2ba14-c767f.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public void fire(Object event) {

        final Set<EventListener<?>> observers = registrations.get(event.getClass());
        if (observers == null) return;

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743557107/fstmerge_var1_7715133941559753122
        for (EventListener observer : copyObservers(observers))
            observer.onEvent(event);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743557107/fstmerge_base_8648953866423122462
        // As documented in http://docs.oracle.com/javase/1.4.2/docs/api/java/util/Collections.html#synchronizedSet(java.util.Set)
        //noinspection SynchronizationOnLocalVariableOrMethodParameter
        synchronized (observers) {
            for (EventListener observer : observers)
                observer.onEvent(event);
        }
=======
        // As documented in http://docs.oracle.com/javase/1.4.2/docs/api/java/util/Collections.html#synchronizedSet(java.util.Set)
        //noinspection SynchronizationOnLocalVariableOrMethodParameter
        synchronized (observers) {
            for (EventListener observer : observers)
                //noinspection unchecked
                observer.onEvent(event);
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743557107/fstmerge_var2_7851682501593448884

    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_2ba14_c767f/rev_2ba14-c767f/roboguice/src/main/java/roboguice/event/EventManager.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_56987_21bf8/rev_56987-21bf8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_9743a_d6d72/rev_9743a-d6d72.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_980a9_8d07b/rev_980a9-8d07b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b78ce_1c3a9/rev_b78ce-1c3a9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b1751_3927f/rev_b1751-3927f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_5583c_c0c61/rev_5583c-c0c61.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_e7f78_6de9f/rev_e7f78-6de9f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_0acf6_32af1/rev_0acf6-32af1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_7dbde_50c40/rev_7dbde-50c40.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public static Injector setBaseApplicationInjector(Application application, Stage stage) {

        synchronized (RoboGuice.class) {

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743668361/fstmerge_var1_7633156261355385232
            final ArrayList<Module> modules = new ArrayList<Module>();

            try {
                final ApplicationInfo ai = application.getPackageManager().getApplicationInfo(application.getPackageName(), PackageManager.GET_META_DATA);
                final Bundle bundle = ai.metaData;
                final String roboguiceModules = bundle!=null ? bundle.getString("roboguice.modules") : null;
                final DefaultRoboModule defaultRoboModule = newDefaultRoboModule(application);
                final String[] moduleNames = roboguiceModules!=null ? roboguiceModules.split("[\\s,]") : new String[]{};

                modules.add(defaultRoboModule);

                for (String name : moduleNames) {
                    if( Strings.notEmpty(name)) {
                        final Class<? extends Module> clazz = Class.forName(name).asSubclass(Module.class);
                        try {
                            modules.add(clazz.getDeclaredConstructor(Application.class).newInstance(application));
                        } catch( NoSuchMethodException ignored ) {
                            modules.add( clazz.newInstance() );
                        }
                    }
                }

            } catch (Exception e) {
                throw new RuntimeException("Unable to instantiate your Module.  Check your roboguice.modules metadata in your AndroidManifest.xml",e);
            }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743668361/fstmerge_base_7136897081395807485
            final ArrayList<Module> modules = new ArrayList<Module>();

            try {
                final ApplicationInfo ai = application.getPackageManager().getApplicationInfo(application.getPackageName(), PackageManager.GET_META_DATA);
                final Bundle bundle = ai.metaData;
                final String roboguiceModules = bundle!=null ? bundle.getString("roboguice.modules") : null;
                final DefaultRoboModule defaultRoboModule = newDefaultRoboModule(application);
                final String[] moduleNames = roboguiceModules!=null ? roboguiceModules.split("[\\s,]") : new String[]{};

                modules.add(defaultRoboModule);

                for (String name : moduleNames) {
                    if( Strings.notEmpty(name)) {
                        final Class<? extends Module> clazz = Class.forName(name).asSubclass(Module.class);
                        try {
                            modules.add(clazz.getDeclaredConstructor(Context.class).newInstance(application));
                        } catch( NoSuchMethodException ignored ) {
                            modules.add( clazz.newInstance() );
                        }
                    }
                }

            } catch (Exception e) {
                throw new RuntimeException("Unable to instantiate your Module.  Check your roboguice.modules metadata in your AndroidManifest.xml",e);
            }
=======
            final ArrayList<Module> modules = getModulesFromManifest(application);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743668361/fstmerge_var2_941687352508468692

            final Injector rtrn = setBaseApplicationInjector(application, stage, modules.toArray(new Module[modules.size()]));
            injectors.put(application,rtrn);
            return rtrn;
        }

    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_7dbde_50c40/rev_7dbde-50c40/roboguice/src/main/java/roboguice/RoboGuice.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_6ee8e_f6718/rev_6ee8e-f6718.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743722811/fstmerge_var1_9196559543245671742
public void testOverrideBehavior() {
    Set<InjectionPoint> points;

    points = InjectionPoint.forInstanceMethodsAndFields(Super.class);
    assertEquals(points.toString(), 8, points.size());
    assertPoints(points, Super.class, "atField", "gField", "atInject", "gInject", "privateAtAndPublicG",
        "privateGAndPublicAt", "atFirstThenG", "gFirstThenAt");

    points = InjectionPoint.forInstanceMethodsAndFields(Sub.class);
    assertEquals(points.toString(), 9, points.size());
    // Superclass will always have is private members injected,
    // and 'gInject' was last @Injected in Super, so that remains the owner
    assertPoints(points, Super.class, "privateAtAndPublicG", "gInject", "atField", "gField", "privateGAndPublicAt");
    // Subclass also has the "private" methods, but they do not override
    // the superclass' methods, and it now owns the inject2 methods.
    assertPoints(points, Sub.class, "privateAtAndPublicG", "privateGAndPublicAt",
        "atFirstThenG", "gFirstThenAt");
    
    points = InjectionPoint.forInstanceMethodsAndFields(SubSub.class);
    assertEquals(points.toString(), 8, points.size());
    // Superclass still has all the injection points it did before..
    assertPoints(points, Super.class, "privateAtAndPublicG", "gInject", "atField", "gField", "privateGAndPublicAt");
    // Subclass is missing the privateGAndPublicAt because it first became public with
    // javax.inject.Inject and was overrode without an annotation, which means it
    // disappears.  (It was guice @Inject in Super, but it was private there, so it doesn't
    // effect the annotations of the subclasses.)
    assertPoints(points, Sub.class, "privateAtAndPublicG", "atFirstThenG", "gFirstThenAt");    
  }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743722811/fstmerge_base_858371564599767733
public void testOverrideBehavior() {
    Set<InjectionPoint> points;

    points = InjectionPoint.forInstanceMethodsAndFields(Super.class);
    assertEquals(points.toString(), 6, points.size());
    assertPoints(points, Super.class, "atInject", "gInject", "privateAtAndPublicG",
        "privateGAndPublicAt", "atFirstThenG", "gFirstThenAt");

    points = InjectionPoint.forInstanceMethodsAndFields(Sub.class);
    assertEquals(points.toString(), 7, points.size());
    // Superclass will always have is private members injected,
    // and 'gInject' was last @Injected in Super, so that remains the owner
    assertPoints(points, Super.class, "privateAtAndPublicG", "privateGAndPublicAt", "gInject");
    // Subclass also has the "private" methods, but they do not override
    // the superclass' methods, and it now owns the inject2 methods.
    assertPoints(points, Sub.class, "privateAtAndPublicG", "privateGAndPublicAt",
        "atFirstThenG", "gFirstThenAt");
    
    points = InjectionPoint.forInstanceMethodsAndFields(SubSub.class);
    assertEquals(points.toString(), 6, points.size());
    // Superclass still has all the injection points it did before..
    assertPoints(points, Super.class, "privateAtAndPublicG", "privateGAndPublicAt", "gInject");
    // Subclass is missing the privateGAndPublicAt because it first became public with
    // javax.inject.Inject and was overrode without an annotation, which means it
    // disappears.  (It was guice @Inject in Super, but it was private there, so it doesn't
    // effect the annotations of the subclasses.)
    assertPoints(points, Sub.class, "privateAtAndPublicG", "atFirstThenG", "gFirstThenAt");    
  }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743722811/fstmerge_var2_4743774475795135323

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_6ee8e_f6718/rev_6ee8e-f6718/core/test/com/google/inject/spi/InjectionPointTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743723160/fstmerge_var1_125259423730276902
public static Injector createInjector(Stage stage,
      Iterable<? extends Module> modules) {
    doSetAnnotationDatabaseFinderToModules(modules);
    return new InternalInjectorCreator()
        .stage(stage)
        .addModules(modules)
        .build();
  }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743723160/fstmerge_base_5026098911945192157
public static Injector createInjector(Stage stage,
      Iterable<? extends Module> modules) {
    return new InternalInjectorCreator()
        .stage(stage)
        .addModules(modules)
        .build();
  }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743723160/fstmerge_var2_6823989254361060724

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_6ee8e_f6718/rev_6ee8e-f6718/core/src/com/google/inject/Guice.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743723171/fstmerge_var1_7170337739964437024
static Type getSuperclassTypeParameter(Class<?> subclass) {
    Type superclass = MoreTypes.getGenericSuperclass(subclass);
    if (superclass instanceof Class) {
      throw new RuntimeException("Missing type parameter.");
    }
    ParameterizedType parameterized = (ParameterizedType) superclass;
    return canonicalize(parameterized.getActualTypeArguments()[0]);
  }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743723171/fstmerge_base_6043828861826409648
static Type getSuperclassTypeParameter(Class<?> subclass) {
    Type superclass = subclass.getGenericSuperclass();
    if (superclass instanceof Class) {
      throw new RuntimeException("Missing type parameter.");
    }
    ParameterizedType parameterized = (ParameterizedType) superclass;
    return canonicalize(parameterized.getActualTypeArguments()[0]);
  }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743723171/fstmerge_var2_7893257214856603926

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_6ee8e_f6718/rev_6ee8e-f6718/core/src/com/google/inject/TypeLiteral.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743723402/fstmerge_var1_5963303090807339992
@SuppressWarnings("unchecked")
  protected <T> AnnotatedBindingBuilder<T> bind(Class<T> clazz) {
    if( isInjectable(clazz) ) {
      return binder().bind(clazz);
    } else {
      return noOpAnnotatedBindingBuilder;
    }
  }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743723402/fstmerge_base_8949269070222373160
protected <T> AnnotatedBindingBuilder<T> bind(Class<T> clazz) {
    return binder().bind(clazz);
  }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743723402/fstmerge_var2_5977495969813765303

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_6ee8e_f6718/rev_6ee8e-f6718/core/src/com/google/inject/AbstractModule.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743723408/fstmerge_var1_4230087788946711020
protected void install(Module module) {
    if( annotationDatabaseFinder != null && module instanceof AbstractModule) {
      ((AbstractModule)module).setAnnotationDatabaseFinder(annotationDatabaseFinder);
    }
    binder().install(module);
  }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743723408/fstmerge_base_4536292418896723924
protected void install(Module module) {
    binder().install(module);
  }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743723408/fstmerge_var2_2607086399789570833

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_6ee8e_f6718/rev_6ee8e-f6718/core/src/com/google/inject/AbstractModule.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743724749/fstmerge_var1_7522123251718464636
public static Type getGenericSupertype(Type type, Class<?> rawType, Class<?> toResolve) {
    if (toResolve == rawType) {
      return type;
    }

    // we skip searching through interfaces if unknown is an interface
    if (toResolve.isInterface()) {
      Class[] interfaces = rawType.getInterfaces();
      for (int i = 0, length = interfaces.length; i < length; i++) {
        if (interfaces[i] == toResolve) {
          return rawType.getGenericInterfaces()[i];
        } else if (toResolve.isAssignableFrom(interfaces[i])) {
          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
        }
      }
    }

    // check our supertypes
    if (!rawType.isInterface()) {
        HierarchyTraversalFilter filter = Guice.createHierarchyTraversalFilter();
      while (filter.isWorthScanning(rawType)) {
        Class<?> rawSupertype = rawType.getSuperclass();
        if (rawSupertype == toResolve) {
          return getGenericSuperclass(rawType);
        } else if (toResolve.isAssignableFrom(rawSupertype)) {
          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
        }
        rawType = rawSupertype;
      }
    }

    // we can't resolve this further
    return toResolve;
  }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743724749/fstmerge_base_4790550890716478607
public static Type getGenericSupertype(Type type, Class<?> rawType, Class<?> toResolve) {
    if (toResolve == rawType) {
      return type;
    }

    // we skip searching through interfaces if unknown is an interface
    if (toResolve.isInterface()) {
      Class[] interfaces = rawType.getInterfaces();
      for (int i = 0, length = interfaces.length; i < length; i++) {
        if (interfaces[i] == toResolve) {
          return rawType.getGenericInterfaces()[i];
        } else if (toResolve.isAssignableFrom(interfaces[i])) {
          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
        }
      }
    }

    // check our supertypes
    if (!rawType.isInterface()) {
      while (rawType != Object.class) {
        Class<?> rawSupertype = rawType.getSuperclass();
        if (rawSupertype == toResolve) {
          return rawType.getGenericSuperclass();
        } else if (toResolve.isAssignableFrom(rawSupertype)) {
          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
        }
        rawType = rawSupertype;
      }
    }

    // we can't resolve this further
    return toResolve;
  }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743724749/fstmerge_var2_2777087959699728717

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_6ee8e_f6718/rev_6ee8e-f6718/core/src/com/google/inject/internal/MoreTypes.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743727162/fstmerge_var1_1835008601436209484
private ProviderMethodsModule(Object delegate) {
    this.delegate = checkNotNull(delegate, "delegate");
    this.typeLiteral = TypeLiteral.get(this.delegate.getClass());
    filter = Guice.createHierarchyTraversalFilter();
  }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743727162/fstmerge_base_5545937007795671033
private ProviderMethodsModule(Object delegate) {
    this.delegate = checkNotNull(delegate, "delegate");
    this.typeLiteral = TypeLiteral.get(this.delegate.getClass());
  }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743727162/fstmerge_var2_6747765264249268970

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_6ee8e_f6718/rev_6ee8e-f6718/core/src/com/google/inject/internal/ProviderMethodsModule.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743727176/fstmerge_var1_462950033319734887
public List<ProviderMethod<?>> getProviderMethods(Binder binder) {
    List<ProviderMethod<?>> result = Lists.newArrayList();
    Multimap<Signature, Method> methodsBySignature = HashMultimap.create();
    filter.reset();
    Class<?> c = delegate.getClass();
    while (filter.isWorthScanningForMethods(Provides.class.getName(), c)) {
      for (Method method : filter.getAllMethods(Provides.class.getName(), c)) {
        // private/static methods cannot override or be overridden by other methods, so there is no
        // point in indexing them.
        // Skip synthetic methods and bridge methods since java will automatically generate
        // synthetic overrides in some cases where we don't want to generate an error (e.g.
        // increasing visibility of a subclass).
        if (((method.getModifiers() & (Modifier.PRIVATE | Modifier.STATIC)) == 0)
            && !method.isBridge() && !method.isSynthetic()) {
          methodsBySignature.put(new Signature(method), method);
        }
        if (isProvider(method)) {
          result.add(createProviderMethod(binder, method));
        }
      }
      c = c.getSuperclass();
    }
    // we have found all the providers and now need to identify if any were overridden
    // In the worst case this will have O(n^2) in the number of @Provides methods, but that is only
    // assuming that every method is an override, in general it should be very quick.
    for (ProviderMethod<?> provider : result) {
      Method method = provider.getMethod();
      for (Method matchingSignature : methodsBySignature.get(new Signature(method))) {
        // matching signature is in the same class or a super class, therefore method cannot be
        // overridding it.
        if (matchingSignature.getDeclaringClass().isAssignableFrom(method.getDeclaringClass())) {
          continue;
        }
        // now we know matching signature is in a subtype of method.getDeclaringClass()
        if (overrides(matchingSignature, method)) {
          binder.addError(
              "Overriding @Provides methods is not allowed."
                  + "\n\t@Provides method: %s\n\toverridden by: %s",
              method,
              matchingSignature);
          break;
        }
      }
    }
    return result;
  }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743727176/fstmerge_base_8680279231094167237
public List<ProviderMethod<?>> getProviderMethods(Binder binder) {
    List<ProviderMethod<?>> result = Lists.newArrayList();
    Multimap<Signature, Method> methodsBySignature = HashMultimap.create();
    for (Class<?> c = delegate.getClass(); c != Object.class; c = c.getSuperclass()) {
      for (Method method : c.getDeclaredMethods()) {
        // private/static methods cannot override or be overridden by other methods, so there is no
        // point in indexing them.
        // Skip synthetic methods and bridge methods since java will automatically generate
        // synthetic overrides in some cases where we don't want to generate an error (e.g.
        // increasing visibility of a subclass).
        if (((method.getModifiers() & (Modifier.PRIVATE | Modifier.STATIC)) == 0)
            && !method.isBridge() && !method.isSynthetic()) {
          methodsBySignature.put(new Signature(method), method);
        }
        if (isProvider(method)) {
          result.add(createProviderMethod(binder, method));
        }
      }
    }
    // we have found all the providers and now need to identify if any were overridden
    // In the worst case this will have O(n^2) in the number of @Provides methods, but that is only
    // assuming that every method is an override, in general it should be very quick.
    for (ProviderMethod<?> provider : result) {
      Method method = provider.getMethod();
      for (Method matchingSignature : methodsBySignature.get(new Signature(method))) {
        // matching signature is in the same class or a super class, therefore method cannot be
        // overridding it.
        if (matchingSignature.getDeclaringClass().isAssignableFrom(method.getDeclaringClass())) {
          continue;
        }
        // now we know matching signature is in a subtype of method.getDeclaringClass()
        if (overrides(matchingSignature, method)) {
          binder.addError(
              "Overriding @Provides methods is not allowed."
                  + "\n\t@Provides method: %s\n\toverridden by: %s",
              method,
              matchingSignature);
          break;
        }
      }
    }
    return result;
  }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743727176/fstmerge_var2_812445085205652155

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_6ee8e_f6718/rev_6ee8e-f6718/core/src/com/google/inject/internal/ProviderMethodsModule.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743727863/fstmerge_var1_7024806786098153845
public long reset() {
    long now = System.currentTimeMillis();
    long l = now - start;
    start = now;
    return l;
  }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743727863/fstmerge_base_4916767546787557034
public long reset() {
    long now = System.currentTimeMillis();
    try {
      return now - start;
    } finally {
      start = now;
    }
  }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743727863/fstmerge_var2_1440710605449034511

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_6ee8e_f6718/rev_6ee8e-f6718/core/src/com/google/inject/internal/util/Stopwatch.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743728502/fstmerge_var1_7793534062002231457
public static InjectionPoint forConstructorOf(TypeLiteral<?> type) {
    Class<?> rawType = getRawType(type.getType());
    Errors errors = new Errors(rawType);

    Constructor<?> injectableConstructor = null;
    if( filter.isWorthScanningForConstructors(Inject.class.getName(), rawType)) {
      for (Constructor<?> constructor : filter.getAllConstructors(Inject.class.getName(), rawType)) {
        boolean optional;
        Inject guiceInject = constructor.getAnnotation(Inject.class);
        if (guiceInject == null) {
          javax.inject.Inject javaxInject = constructor.getAnnotation(javax.inject.Inject.class);
          if (javaxInject == null) {
            continue;
          }
          optional = false;
        } else {
          optional = guiceInject.optional();
        }

        if (optional) {
          errors.optionalConstructor(constructor);
        }

        if (injectableConstructor != null) {
          errors.tooManyConstructors(rawType);
        }

        injectableConstructor = constructor;
        checkForMisplacedBindingAnnotations(injectableConstructor, errors);
      }
    }

    errors.throwConfigurationExceptionIfErrorsExist();

    if (injectableConstructor != null) {
      return new InjectionPoint(type, injectableConstructor);
    }

    // If no annotated constructor is found, look for a no-arg constructor instead.
    try {
      Constructor<?> noArgConstructor = rawType.getDeclaredConstructor();

      // Disallow private constructors on non-private classes (unless they have @Inject)
      if (Modifier.isPrivate(noArgConstructor.getModifiers())
          && !Modifier.isPrivate(rawType.getModifiers())) {
        errors.missingConstructor(rawType);
        throw new ConfigurationException(errors.getMessages());
      }

      checkForMisplacedBindingAnnotations(noArgConstructor, errors);
      return new InjectionPoint(type, noArgConstructor);
    } catch (NoSuchMethodException e) {
      errors.missingConstructor(rawType);
      throw new ConfigurationException(errors.getMessages());
    }
  }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743728502/fstmerge_base_7363130088399472650
public static InjectionPoint forConstructorOf(TypeLiteral<?> type) {
    Class<?> rawType = getRawType(type.getType());
    Errors errors = new Errors(rawType);

    Constructor<?> injectableConstructor = null;
    for (Constructor<?> constructor : rawType.getDeclaredConstructors()) {

      boolean optional;
      Inject guiceInject = constructor.getAnnotation(Inject.class);
      if (guiceInject == null) {
        javax.inject.Inject javaxInject = constructor.getAnnotation(javax.inject.Inject.class);
        if (javaxInject == null) {
          continue;
        }
        optional = false;
      } else {
        optional = guiceInject.optional();
      }

      if (optional) {
        errors.optionalConstructor(constructor);
      }

      if (injectableConstructor != null) {
        errors.tooManyConstructors(rawType);
      }

      injectableConstructor = constructor;
      checkForMisplacedBindingAnnotations(injectableConstructor, errors);
    }

    errors.throwConfigurationExceptionIfErrorsExist();

    if (injectableConstructor != null) {
      return new InjectionPoint(type, injectableConstructor);
    }

    // If no annotated constructor is found, look for a no-arg constructor instead.
    try {
      Constructor<?> noArgConstructor = rawType.getDeclaredConstructor();

      // Disallow private constructors on non-private classes (unless they have @Inject)
      if (Modifier.isPrivate(noArgConstructor.getModifiers())
          && !Modifier.isPrivate(rawType.getModifiers())) {
        errors.missingConstructor(rawType);
        throw new ConfigurationException(errors.getMessages());
      }

      checkForMisplacedBindingAnnotations(noArgConstructor, errors);
      return new InjectionPoint(type, noArgConstructor);
    } catch (NoSuchMethodException e) {
      errors.missingConstructor(rawType);
      throw new ConfigurationException(errors.getMessages());
    }
  }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743728502/fstmerge_var2_954016126955889916

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_6ee8e_f6718/rev_6ee8e-f6718/core/src/com/google/inject/spi/InjectionPoint.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743728512/fstmerge_var1_6707987344740426164
public static Set<InjectionPoint> forStaticMethodsAndFields(TypeLiteral<?> type) {
    Errors errors = new Errors();

    Set<InjectionPoint> result;

    if (type.getRawType().isInterface()) {
      errors.staticInjectionOnInterface(type.getRawType());
      result = null;
    } else {
      result = getInjectionPoints(type, true, errors);
    }

    if (errors.hasErrors()) {
      throw new ConfigurationException(errors.getMessages()).withPartialValue(result);
    }
    return result;
  }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743728512/fstmerge_base_4726487590356826767
public static Set<InjectionPoint> forStaticMethodsAndFields(TypeLiteral<?> type) {
    Errors errors = new Errors();
    
    Set<InjectionPoint> result;
    
    if (type.getRawType().isInterface()) {
      errors.staticInjectionOnInterface(type.getRawType());
      result = null;
    } else {
      result = getInjectionPoints(type, true, errors);
    }
    
    if (errors.hasErrors()) {
      throw new ConfigurationException(errors.getMessages()).withPartialValue(result);
    }
    return result;
  }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743728512/fstmerge_var2_3791160247100783534

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_6ee8e_f6718/rev_6ee8e-f6718/core/src/com/google/inject/spi/InjectionPoint.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743728560/fstmerge_var1_5172191967093513092
boolean removeIfOverriddenBy(Method method, boolean alwaysRemove,
        InjectableMethod injectableMethod) {
      if (position == Position.TOP) {
        // If we're at the top of the hierarchy, there's nothing to override.
        return false;
      }

      if (bySignature == null) {
        // We encountered a method in a subclass. Time to index the
        // methods in the parent class.
        bySignature = new HashMap<Signature, List<InjectableMethod>>();
        for (InjectableMember member = injectableMembers.head; member != null;
            member = member.next) {
          if (!(member instanceof InjectableMethod)) continue;
          InjectableMethod im = (InjectableMethod) member;
          if (im.isFinal()) continue;
          List<InjectableMethod> methods = new ArrayList<InjectableMethod>();
          methods.add(im);
          bySignature.put(new Signature(im.method), methods);
        }
      }

      lastMethod = method;
      Signature signature = lastSignature = new Signature(method);
      List<InjectableMethod> methods = bySignature.get(signature);
      boolean removed = false;
      if (methods != null) {
        for (Iterator<InjectableMethod> iterator = methods.iterator();
            iterator.hasNext();) {
          InjectableMethod possiblyOverridden = iterator.next();
          if (overrides(method, possiblyOverridden.method)) {
            boolean wasGuiceInject =
              !possiblyOverridden.jsr330 || possiblyOverridden.overrodeGuiceInject;
            if(injectableMethod != null) {
              injectableMethod.overrodeGuiceInject = wasGuiceInject;
            }
            // Only actually remove the methods if we want to force
            // remove or if the signature never specified @com.google.inject.Inject
            // somewhere.
            if(alwaysRemove || !wasGuiceInject) {
              removed = true;
              iterator.remove();
              injectableMembers.remove(possiblyOverridden);
            }
          }
        }
      }
      return removed;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743728560/fstmerge_base_1538587972237219842
boolean removeIfOverriddenBy(Method method, boolean alwaysRemove, 
        InjectableMethod injectableMethod) {
      if (position == Position.TOP) {
        // If we're at the top of the hierarchy, there's nothing to override.
        return false;
      }

      if (bySignature == null) {
        // We encountered a method in a subclass. Time to index the
        // methods in the parent class.
        bySignature = new HashMap<Signature, List<InjectableMethod>>();
        for (InjectableMember member = injectableMembers.head; member != null;
            member = member.next) {
          if (!(member instanceof InjectableMethod)) continue;
          InjectableMethod im = (InjectableMethod) member;
          if (im.isFinal()) continue;
          List<InjectableMethod> methods = new ArrayList<InjectableMethod>();
          methods.add(im);
          bySignature.put(new Signature(im.method), methods);
        }
      }

      lastMethod = method;
      Signature signature = lastSignature = new Signature(method);
      List<InjectableMethod> methods = bySignature.get(signature);
      boolean removed = false;
      if (methods != null) {
        for (Iterator<InjectableMethod> iterator = methods.iterator();
            iterator.hasNext();) {
          InjectableMethod possiblyOverridden = iterator.next();
          if (overrides(method, possiblyOverridden.method)) {
            boolean wasGuiceInject =
              !possiblyOverridden.jsr330 || possiblyOverridden.overrodeGuiceInject;
            if(injectableMethod != null) {
              injectableMethod.overrodeGuiceInject = wasGuiceInject;
            }
            // Only actually remove the methods if we want to force
            // remove or if the signature never specified @com.google.inject.Inject
            // somewhere.
            if(alwaysRemove || !wasGuiceInject) {
              removed = true;
              iterator.remove();
              injectableMembers.remove(possiblyOverridden);
            }
          }
        }
      }
      return removed;
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743728560/fstmerge_var2_5884357358455906853

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_6ee8e_f6718/rev_6ee8e-f6718/core/src/com/google/inject/spi/InjectionPoint.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743728565/fstmerge_var1_7629645687988223581
private static Set<InjectionPoint> getInjectionPoints(final TypeLiteral<?> type,
      boolean statics, Errors errors) {

  	InjectableMembers injectableMembers = new InjectableMembers();
    final OverrideIndex overrideIndex = new OverrideIndex(injectableMembers);
    overrideIndex.position = Position.BOTTOM; // we start at the bottom of inheritance hierarchy

  	filter.reset();
  	computeInjectableMembers(type, statics, errors, injectableMembers, overrideIndex, filter);

    if (injectableMembers.isEmpty()) {
      return Collections.emptySet();
    }

    ImmutableSet.Builder<InjectionPoint> builder = ImmutableSet.builder();
    for (InjectableMember im = injectableMembers.head; im != null;
        im = im.next) {
      try {
        builder.add(im.toInjectionPoint());
      } catch (ConfigurationException ignorable) {
        if (!im.optional) {
          errors.merge(ignorable.getErrorMessages());
        }
      }
    }
    return builder.build();
  }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743728565/fstmerge_base_3317839565817558036
private static Set<InjectionPoint> getInjectionPoints(final TypeLiteral<?> type,
      boolean statics, Errors errors) {
    InjectableMembers injectableMembers = new InjectableMembers();
    OverrideIndex overrideIndex = null;

    List<TypeLiteral<?>> hierarchy = hierarchyFor(type);
    int topIndex = hierarchy.size() - 1;
    for (int i = topIndex; i >= 0; i--) {
      if (overrideIndex != null && i < topIndex) {
        // Knowing the position within the hierarchy helps us make optimizations.
        if (i == 0) {
          overrideIndex.position = Position.BOTTOM;
        } else {
          overrideIndex.position = Position.MIDDLE;
        }
      }

      TypeLiteral<?> current = hierarchy.get(i);

      for (Field field : current.getRawType().getDeclaredFields()) {
        if (Modifier.isStatic(field.getModifiers()) == statics) {
          Annotation atInject = getAtInject(field);
          if (atInject != null) {
            InjectableField injectableField = new InjectableField(current, field, atInject);
            if (injectableField.jsr330 && Modifier.isFinal(field.getModifiers())) {
              errors.cannotInjectFinalField(field);
            }
            injectableMembers.add(injectableField);
          }
        }
      }

      for (Method method : current.getRawType().getDeclaredMethods()) {
        if (isEligibleForInjection(method, statics)) {
          Annotation atInject = getAtInject(method);
          if (atInject != null) {
            InjectableMethod injectableMethod = new InjectableMethod(
                current, method, atInject);
            if (checkForMisplacedBindingAnnotations(method, errors)
                || !isValidMethod(injectableMethod, errors)) {
              if (overrideIndex != null) {
                boolean removed = overrideIndex.removeIfOverriddenBy(method, false, injectableMethod);
                if(removed) {
                  logger.log(Level.WARNING, "Method: {0} is not a valid injectable method ("
                      + "because it either has misplaced binding annotations "
                      + "or specifies type parameters) but is overriding a method that is valid. "
                      + "Because it is not valid, the method will not be injected. "
                      + "To fix this, make the method a valid injectable method.", method);
                }
              }
              continue;
            }
            if (statics) {
              injectableMembers.add(injectableMethod);
            } else {
              if (overrideIndex == null) {
                /*
                 * Creating the override index lazily means that the first type in the hierarchy
                 * with injectable methods (not necessarily the top most type) will be treated as
                 * the TOP position and will enjoy the same optimizations (no checks for overridden
                 * methods, etc.).
                 */
                overrideIndex = new OverrideIndex(injectableMembers);
              } else {
                // Forcibly remove the overriden method, otherwise we'll inject
                // it twice.
                overrideIndex.removeIfOverriddenBy(method, true, injectableMethod);
              }
              overrideIndex.add(injectableMethod);
            }
          } else {
            if(overrideIndex != null) {
              boolean removed = overrideIndex.removeIfOverriddenBy(method, false, null);
              if(removed) {
                logger.log(Level.WARNING, "Method: {0} is not annotated with @Inject but "
                    + "is overriding a method that is annotated with @javax.inject.Inject.  Because "
                    + "it is not annotated with @Inject, the method will not be injected. "
                    + "To fix this, annotate the method with @Inject.", method);
              }
            }
          }
        }
      }
    }

    if (injectableMembers.isEmpty()) {
      return Collections.emptySet();
    }

    ImmutableSet.Builder<InjectionPoint> builder = ImmutableSet.builder();
    for (InjectableMember im = injectableMembers.head; im != null;
        im = im.next) {
      try {
        builder.add(im.toInjectionPoint());
      } catch (ConfigurationException ignorable) {
        if (!im.optional) {
          errors.merge(ignorable.getErrorMessages());
        }
      }
    }
    return builder.build();
  }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743728565/fstmerge_var2_6221317049447059272

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_6ee8e_f6718/rev_6ee8e-f6718/core/src/com/google/inject/spi/InjectionPoint.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743728593/fstmerge_var1_5382970271519054110
private static List<TypeLiteral<?>> hierarchyFor(TypeLiteral<?> type) {
    List<TypeLiteral<?>> hierarchy = new ArrayList<TypeLiteral<?>>();
    TypeLiteral<?> current = type;
    while (current.getRawType() != Object.class) {
      hierarchy.add(current);
      current = current.getSupertype(current.getRawType().getSuperclass());
    }
    return hierarchy;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743728593/fstmerge_base_6163785067227890600
private static List<TypeLiteral<?>> hierarchyFor(TypeLiteral<?> type) {
    List<TypeLiteral<?>> hierarchy = new ArrayList<TypeLiteral<?>>();
    TypeLiteral<?> current = type;
    while (current.getRawType() != Object.class) {
      hierarchy.add(current);
      current = current.getSupertype(current.getRawType().getSuperclass());
    }
    return hierarchy;
  }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743728593/fstmerge_var2_6312976759900659015

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_6ee8e_f6718/rev_6ee8e-f6718/core/src/com/google/inject/spi/InjectionPoint.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_019e7_9417a/rev_019e7-9417a.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743835287/fstmerge_var1_6142882368130435234
public AnnotationDatabaseFinder(String[] additionalPackageNames) throws AnnotationDatabaseNotFoundException {
        for( String pkg : additionalPackageNames ) {
        	try {
                String annotationDatabaseClassName = "AnnotationDatabaseImpl";
                if( pkg != null && !"".equals(pkg) ) {
                    annotationDatabaseClassName = pkg + "." + annotationDatabaseClassName;
                }
                AnnotationDatabase annotationDatabase = getAnnotationDatabaseInstance(annotationDatabaseClassName);
                addAnnotationDatabase(annotationDatabase);
        	} catch (Exception e) {
        		throw new AnnotationDatabaseNotFoundException(e);
        	}
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743835287/fstmerge_base_3375632095379775299
public AnnotationDatabaseFinder(String[] additionalPackageNames) {
        try {
            for( String pkg : additionalPackageNames ) {
                String annotationDatabaseClassName = "AnnotationDatabaseImpl";
                if( pkg != null && !"".equals(pkg) ) {
                    annotationDatabaseClassName = pkg + "." + annotationDatabaseClassName;
                }
                AnnotationDatabase annotationDatabase = getAnnotationDatabaseInstance(annotationDatabaseClassName);
                addAnnotationDatabase(annotationDatabase);
            }
        } catch (InstantiationException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743835287/fstmerge_var2_1601618515763705379

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_019e7_9417a/rev_019e7-9417a/core/src/com/google/inject/AnnotationDatabaseFinder.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743835363/fstmerge_var1_6780380968990165921
public static HierarchyTraversalFilter createHierarchyTraversalFilter() {
    HierarchyTraversalFilter hierarchyTraversalFilter = hierarchyTraversalFilterFactory.createHierarchyTraversalFilter();
    if( annotationDatabaseFinder == null ) {
      return hierarchyTraversalFilter;
    } else {
      return new AnnotatedHierarchyTraversalFilter(annotationDatabaseFinder, hierarchyTraversalFilter);
    }
  }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743835363/fstmerge_base_4154455799787961420
public static HierarchyTraversalFilter createHierarchyTraversalFilter() {
    HierarchyTraversalFilter hierarchyTraversalFilter = hierarchyTraversalFilterFactory.createHierarchyTraversalFilter();
    if( annotationDatabaseFinder == null ) {
      return hierarchyTraversalFilter;
    } else {
      return new AnnotatedGuiceHierarchyTraversalFilter(annotationDatabaseFinder, hierarchyTraversalFilter);
    }
  }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743835363/fstmerge_var2_4654896601403203482

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_019e7_9417a/rev_019e7-9417a/core/src/com/google/inject/Guice.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743835371/fstmerge_var1_7918139490855963577
public static void setAnnotationDatabasePackageNames(final String[] packageNames) throws AnnotationDatabaseNotFoundException {
    if( packageNames != null && packageNames.length != 0 ) {
      annotationDatabaseFinder = new AnnotationDatabaseFinder(packageNames);
    } else {
      annotationDatabaseFinder = null;
    }
  }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743835371/fstmerge_base_5206803640846197097
public static void setAnnotationDatabasePackageNames(final String[] packageNames) {
    if( packageNames != null && packageNames.length != 0 ) {
      annotationDatabaseFinder = new AnnotationDatabaseFinder(packageNames);
    } else {
      annotationDatabaseFinder = null;
    }
  }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743835371/fstmerge_var2_1940259419188549991

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_019e7_9417a/rev_019e7-9417a/core/src/com/google/inject/Guice.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743835872/fstmerge_var1_1743154376291459080
public Set<Field> getAllFields(String annotationClassName, Class<?> c) throws AnnotationFieldNotFoundException {
        HashSet<Field> set = new HashSet<Field>();
        for( Field field : c.getDeclaredFields() ) {
            set.add(field);
        }
        return set;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743835872/fstmerge_base_4734241471725198639
public Set<Field> getAllFields(String annotationClassName, Class<?> c) {
        HashSet<Field> set = new HashSet<Field>();
        for( Field field : c.getDeclaredFields() ) {
            set.add(field);
        }
        return set;
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743835872/fstmerge_var2_5056095168803530271

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_019e7_9417a/rev_019e7-9417a/core/src/com/google/inject/HierarchyTraversalFilter.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743841144/fstmerge_var1_4313410021594775301
private static Set<InjectionPoint> getInjectionPoints(final TypeLiteral<?> type,
      boolean statics, Errors errors) {

  	InjectableMembers injectableMembers = new InjectableMembers();
    final OverrideIndex overrideIndex = new OverrideIndex(injectableMembers);
    overrideIndex.position = Position.BOTTOM; // we start at the bottom of inheritance hierarchy

  	filter.reset();
  	try {
		computeInjectableMembers(type, statics, errors, injectableMembers, overrideIndex, filter);
	} catch (AnnotationFieldNotFoundException e) {
		errors.addMessage(e.getMessage());
	}

    if (injectableMembers.isEmpty()) {
      return Collections.emptySet();
    }

    ImmutableSet.Builder<InjectionPoint> builder = ImmutableSet.builder();
    for (InjectableMember im = injectableMembers.head; im != null;
        im = im.next) {
      try {
        builder.add(im.toInjectionPoint());
      } catch (ConfigurationException ignorable) {
        if (!im.optional) {
          errors.merge(ignorable.getErrorMessages());
        }
      }
    }
    return builder.build();
  }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743841144/fstmerge_base_78813569583836376
private static Set<InjectionPoint> getInjectionPoints(final TypeLiteral<?> type,
      boolean statics, Errors errors) {

  	InjectableMembers injectableMembers = new InjectableMembers();
    final OverrideIndex overrideIndex = new OverrideIndex(injectableMembers);
    overrideIndex.position = Position.BOTTOM; // we start at the bottom of inheritance hierarchy

  	filter.reset();
  	computeInjectableMembers(type, statics, errors, injectableMembers, overrideIndex, filter);

    if (injectableMembers.isEmpty()) {
      return Collections.emptySet();
    }

    ImmutableSet.Builder<InjectionPoint> builder = ImmutableSet.builder();
    for (InjectableMember im = injectableMembers.head; im != null;
        im = im.next) {
      try {
        builder.add(im.toInjectionPoint());
      } catch (ConfigurationException ignorable) {
        if (!im.optional) {
          errors.merge(ignorable.getErrorMessages());
        }
      }
    }
    return builder.build();
  }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743841144/fstmerge_var2_1924944943461495126

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_019e7_9417a/rev_019e7-9417a/core/src/com/google/inject/spi/InjectionPoint.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743841149/fstmerge_var1_270599682869577301
private static void computeInjectableMembers(final TypeLiteral<?> type,
      boolean statics, Errors errors, InjectableMembers injectableMembers, OverrideIndex overrideIndex, HierarchyTraversalFilter filter) throws AnnotationFieldNotFoundException {

    Class<?> rawType = type.getRawType();
    if( !isWorthScanning(filter, rawType) ) {
      return;
    }

    //recursive call on parents
    Class<?> parentRawType = rawType.getSuperclass();
    if( isWorthScanning(filter, parentRawType) ) {
      computeInjectableMembers(type.getSupertype(parentRawType), statics, errors, injectableMembers, overrideIndex, filter);
      overrideIndex.position = Position.MIDDLE;
    } else {
      overrideIndex.position = Position.TOP; // we're at the top of the inheritance hierarchy
    }

    Set<Field> allFields = filter.getAllFields(Inject.class.getName(), rawType);
    if( allFields != null ) {
    	for( Field field : allFields ) {
    		//System.out.printf("Field %s is injectable in class %s ",field.getName(),rawType.getName());
    		if (Modifier.isStatic(field.getModifiers()) == statics) {
    			Annotation atInject = getAtInject(field);
    			if (atInject != null) {
    				//System.out.printf("Field %s is gonna be injected in class %s ",field.getName(),rawType.getName());
    				InjectableField injectableField = new InjectableField(type, field, atInject);
    				if (injectableField.jsr330 && Modifier.isFinal(field.getModifiers())) {
    					errors.cannotInjectFinalField(field);
    				}
    				injectableMembers.add(injectableField);
    			}
    		}
    	}
    }

    Set<Method> allMethods = filter.getAllMethods(Inject.class.getName(), rawType);
    if(allMethods != null ) {
      for (Method method : allMethods) {
        if (isEligibleForInjection(method, statics)) {
          Annotation atInject = getAtInject(method);
          if (atInject != null) {
            InjectableMethod injectableMethod = new InjectableMethod(
                type, method, atInject);
            if (checkForMisplacedBindingAnnotations(method, errors)
                || !isValidMethod(injectableMethod, errors)) {
            	boolean removed = overrideIndex.removeIfOverriddenBy(method, false, injectableMethod);
              if(removed) {
                logger.log(Level.WARNING, "Method: {0} is not a valid injectable method ("
                    + "because it either has misplaced binding annotations "
                    + "or specifies type parameters) but is overriding a method that is valid. "
                    + "Because it is not valid, the method will not be injected. "
                    + "To fix this, make the method a valid injectable method.", method);
              }
              continue;
            }
            if (statics) {
              injectableMembers.add(injectableMethod);
            } else {
          		// Forcibly remove the overriden method, otherwise we'll inject
          		// it twice.
          		overrideIndex.removeIfOverriddenBy(method, true, injectableMethod);
            	overrideIndex.add(injectableMethod);
            }
          } else {
            boolean removed = overrideIndex.removeIfOverriddenBy(method, false, null);
            if(removed) {
              logger.log(Level.WARNING, "Method: {0} is not annotated with @Inject but "
                  + "is overriding a method that is annotated with @javax.inject.Inject.  Because "
                  + "it is not annotated with @Inject, the method will not be injected. "
                  + "To fix this, annotate the method with @Inject.", method);
            }
          }
        }
      }
    }
  }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743841149/fstmerge_base_439417010676861072
private static void computeInjectableMembers(final TypeLiteral<?> type,
      boolean statics, Errors errors, InjectableMembers injectableMembers, OverrideIndex overrideIndex, HierarchyTraversalFilter filter) {

    Class<?> rawType = type.getRawType();
    if( !isWorthScanning(filter, rawType) ) {
      return;
    }

    //recursive call on parents
    Class<?> parentRawType = rawType.getSuperclass();
    if( isWorthScanning(filter, parentRawType) ) {
      computeInjectableMembers(type.getSupertype(parentRawType), statics, errors, injectableMembers, overrideIndex, filter);
      overrideIndex.position = Position.MIDDLE;
    } else {
      overrideIndex.position = Position.TOP; // we're at the top of the inheritance hierarchy
    }

    Set<Field> allFields = filter.getAllFields(Inject.class.getName(), rawType);
    if( allFields != null ) {
    	for( Field field : allFields ) {
    		//System.out.printf("Field %s is injectable in class %s ",field.getName(),rawType.getName());
    		if (Modifier.isStatic(field.getModifiers()) == statics) {
    			Annotation atInject = getAtInject(field);
    			if (atInject != null) {
    				//System.out.printf("Field %s is gonna be injected in class %s ",field.getName(),rawType.getName());
    				InjectableField injectableField = new InjectableField(type, field, atInject);
    				if (injectableField.jsr330 && Modifier.isFinal(field.getModifiers())) {
    					errors.cannotInjectFinalField(field);
    				}
    				injectableMembers.add(injectableField);
    			}
    		}
    	}
    }

    Set<Method> allMethods = filter.getAllMethods(Inject.class.getName(), rawType);
    if(allMethods != null ) {
      for (Method method : allMethods) {
        if (isEligibleForInjection(method, statics)) {
          Annotation atInject = getAtInject(method);
          if (atInject != null) {
            InjectableMethod injectableMethod = new InjectableMethod(
                type, method, atInject);
            if (checkForMisplacedBindingAnnotations(method, errors)
                || !isValidMethod(injectableMethod, errors)) {
            	boolean removed = overrideIndex.removeIfOverriddenBy(method, false, injectableMethod);
              if(removed) {
                logger.log(Level.WARNING, "Method: {0} is not a valid injectable method ("
                    + "because it either has misplaced binding annotations "
                    + "or specifies type parameters) but is overriding a method that is valid. "
                    + "Because it is not valid, the method will not be injected. "
                    + "To fix this, make the method a valid injectable method.", method);
              }
              continue;
            }
            if (statics) {
              injectableMembers.add(injectableMethod);
            } else {
          		// Forcibly remove the overriden method, otherwise we'll inject
          		// it twice.
          		overrideIndex.removeIfOverriddenBy(method, true, injectableMethod);
            	overrideIndex.add(injectableMethod);
            }
          } else {
            boolean removed = overrideIndex.removeIfOverriddenBy(method, false, null);
            if(removed) {
              logger.log(Level.WARNING, "Method: {0} is not annotated with @Inject but "
                  + "is overriding a method that is annotated with @javax.inject.Inject.  Because "
                  + "it is not annotated with @Inject, the method will not be injected. "
                  + "To fix this, annotate the method with @Inject.", method);
            }
          }
        }
      }
    }
  }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743841149/fstmerge_var2_4342340089005961684

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_019e7_9417a/rev_019e7-9417a/core/src/com/google/inject/spi/InjectionPoint.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743848364/fstmerge_var1_721698803462159611
@Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        // Not sure why, but sometimes we're getting called with an empty list of annotations.
        if(annotations.isEmpty())
            return true;

        for( TypeElement annotation : annotations ) {
            String annotationClassName = getTypeName(annotation);
            //merge the 2 inject annotations
            if( "javax.inject.Inject".equals(annotationClassName) ) {
                annotationClassName = "com.google.inject.Inject";
            }
            
            for( Element injectionPoint : roundEnv.getElementsAnnotatedWith(annotation)) {
                if( injectionPoint.getEnclosingElement() instanceof TypeElement && injectionPoint instanceof VariableElement ) {
                    addFieldToAnnotationDatabase(annotationClassName, injectionPoint);
                } else if( injectionPoint.getEnclosingElement() instanceof ExecutableElement && injectionPoint instanceof VariableElement ) {
                    addParameterToAnnotationDatabase(annotationClassName, injectionPoint);
                } else if( injectionPoint instanceof ExecutableElement ) {
                    addMethodOrConstructorToAnnotationDatabase(annotationClassName, injectionPoint);
                } else if( injectionPoint instanceof TypeElement ) {
                    addClassToAnnotationDatabase(injectionPoint);
                }
            }
        }


        for( Map<String, Set<String>> entryAnnotationToclassesContainingInjectionPoints : mapAnnotationToMapClassContainingInjectionToInjectedFieldSet.values() ) {
            classesContainingInjectionPointsSet.addAll(entryAnnotationToclassesContainingInjectionPoints.keySet());
        }

        for( Map<String, Set<String>> entryAnnotationToclassesContainingInjectionPoints : mapAnnotationToMapClassContainingInjectionToInjectedMethodSet.values() ) {
            classesContainingInjectionPointsSet.addAll(entryAnnotationToclassesContainingInjectionPoints.keySet());
        }

        for( Map<String, Set<String>> entryAnnotationToclassesContainingInjectionPoints : mapAnnotationToMapClassContainingInjectionToInjectedConstructorsSet.values() ) {
            classesContainingInjectionPointsSet.addAll(entryAnnotationToclassesContainingInjectionPoints.keySet());
        }

        JavaFileObject jfo;
        try {
            String className = "AnnotationDatabaseImpl";
            if( annotationDatabasePackageName != null && !annotationDatabasePackageName.isEmpty() ) {
                className = annotationDatabasePackageName+'.'+className;
            }
            jfo = processingEnv.getFiler().createSourceFile( className );
            annotationDatabaseGenerator.generateAnnotationDatabase(jfo, annotationDatabasePackageName, mapAnnotationToMapClassContainingInjectionToInjectedFieldSet, mapAnnotationToMapClassContainingInjectionToInjectedMethodSet, mapAnnotationToMapClassContainingInjectionToInjectedConstructorsSet, classesContainingInjectionPointsSet, bindableClasses);
        } catch (IOException e) {
            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, e.getMessage());
        }

        return true;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743848364/fstmerge_base_3925689594364294217
@Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        // Not sure why, but sometimes we're getting called with an empty list of annotations.
        if(annotations.isEmpty())
            return true;

        for( TypeElement annotation : annotations ) {
            String annotationClassName = getTypeName(annotation);
            //merge the 2 inject annotations
            if( "javax.inject.Inject".equals(annotationClassName) ) {
                annotationClassName = "com.google.inject.Inject";
            }
            
            for( Element injectionPoint : roundEnv.getElementsAnnotatedWith(annotation)) {
                if( injectionPoint.getEnclosingElement() instanceof TypeElement && injectionPoint instanceof VariableElement ) {
                    addFieldToAnnotationDatabase(annotationClassName, injectionPoint);
                } else if( injectionPoint.getEnclosingElement() instanceof ExecutableElement && injectionPoint instanceof VariableElement ) {
                    addParameterToAnnotationDatabase(annotationClassName, injectionPoint);
                } else if( injectionPoint instanceof ExecutableElement ) {
                    addMethodOrConstructorToAnnotationDatabase(annotationClassName, injectionPoint);
                } else if( injectionPoint instanceof TypeElement ) {
                    addClassToAnnotationDatabase(injectionPoint);
                }
            }
        }


        for( Map<String, Set<String>> entryAnnotationToclassesContainingInjectionPoints : mapAnnotationToMapClassContainingInjectionToInjectedFieldSet.values() ) {
            classesContainingInjectionPointsSet.addAll(entryAnnotationToclassesContainingInjectionPoints.keySet());
        }

        for( Map<String, Set<String>> entryAnnotationToclassesContainingInjectionPoints : mapAnnotationToMapClassContainingInjectionToInjectedMethodSet.values() ) {
            classesContainingInjectionPointsSet.addAll(entryAnnotationToclassesContainingInjectionPoints.keySet());
        }

        for( Map<String, Set<String>> entryAnnotationToclassesContainingInjectionPoints : mapAnnotationToMapClassContainingInjectionToInjectedConstructorsSet.values() ) {
            classesContainingInjectionPointsSet.addAll(entryAnnotationToclassesContainingInjectionPoints.keySet());
        }

        JavaFileObject jfo;
        try {
            String className = "AnnotationDatabaseImpl";
            if( annotationDatabasePackageName != null && !annotationDatabasePackageName.isEmpty() ) {
                className = annotationDatabasePackageName+'.'+className;
            }
            jfo = processingEnv.getFiler().createSourceFile( className );
            annotationDatabaseGenerator.generateAnnotationDatabase(jfo, annotationDatabasePackageName, mapAnnotationToMapClassContainingInjectionToInjectedFieldSet, mapAnnotationToMapClassContainingInjectionToInjectedMethodSet, mapAnnotationToMapClassContainingInjectionToInjectedConstructorsSet, classesContainingInjectionPointsSet, bindableClasses);
        } catch (IOException e) {
            e.printStackTrace();
            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, e.getMessage());
        }

        return true;
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743848364/fstmerge_var2_8581619649916686748

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_019e7_9417a/rev_019e7-9417a/blender/src/com/google/inject/blender/GuiceAnnotationProcessor.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743848369/fstmerge_var1_8537834370908557701
private void addClassToAnnotationDatabase(Element injectionPoint) {
        TypeElement typeElementRequiringScanning = (TypeElement) injectionPoint;
        String typeElementName = getTypeName(typeElementRequiringScanning);
        classesContainingInjectionPointsSet.add(typeElementName);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743848369/fstmerge_base_7525256471621029542
private void addClassToAnnotationDatabase(Element injectionPoint) {
        TypeElement typeElementRequiringScanning = (TypeElement) injectionPoint;
        String typeElementName = getTypeName(typeElementRequiringScanning);
        //System.out.printf("Type: %s, is injected\n",typeElementName);
        classesContainingInjectionPointsSet.add(typeElementName);
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743848369/fstmerge_var2_32822353483516787

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_019e7_9417a/rev_019e7-9417a/blender/src/com/google/inject/blender/GuiceAnnotationProcessor.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743848374/fstmerge_var1_7280822813207005896
private void addFieldToAnnotationDatabase(String annotationClassName, Element injectionPoint) {
        String injectionPointName;
        String injectedClassName = getTypeName(injectionPoint);
        bindableClasses.add( injectedClassName );
        injectionPointName = injectionPoint.getSimpleName().toString();

        TypeElement typeElementRequiringScanning = (TypeElement) injectionPoint.getEnclosingElement();
        String typeElementName = getTypeName(typeElementRequiringScanning);
        addToInjectedFields(annotationClassName, typeElementName, injectionPointName);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743848374/fstmerge_base_7942332234210890065
private void addFieldToAnnotationDatabase(String annotationClassName, Element injectionPoint) {
        String injectionPointName;
        String injectedClassName = getTypeName(injectionPoint);
        bindableClasses.add( injectedClassName );
        injectionPointName = injectionPoint.getSimpleName().toString();

        TypeElement typeElementRequiringScanning = (TypeElement) injectionPoint.getEnclosingElement();
        String typeElementName = getTypeName(typeElementRequiringScanning);
        //System.out.printf("Type: %s, injection: %s \n",typeElementName, injectionPointName);
        addToInjectedFields(annotationClassName, typeElementName, injectionPointName);
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743848374/fstmerge_var2_353113626209162443

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_019e7_9417a/rev_019e7-9417a/blender/src/com/google/inject/blender/GuiceAnnotationProcessor.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743848378/fstmerge_var1_4116903762131328783
private void addParameterToAnnotationDatabase(String annotationClassName, Element injectionPoint) {
        Element enclosing = injectionPoint.getEnclosingElement();
        String injectionPointName = enclosing.getSimpleName().toString();
        for( VariableElement variable : ((ExecutableElement)enclosing).getParameters() ) {
            String parameterTypeName = getTypeName(variable);
            bindableClasses.add( parameterTypeName );
            injectionPointName += ":"+parameterTypeName;
        }

        TypeElement typeElementRequiringScanning = (TypeElement) ((ExecutableElement) injectionPoint.getEnclosingElement()).getEnclosingElement();
        String typeElementName = getTypeName(typeElementRequiringScanning);
        if( injectionPointName.startsWith("<init>") ) {
            addToInjectedConstructors(annotationClassName, typeElementName, injectionPointName );
        } else {
            addToInjectedMethods(annotationClassName, typeElementName, injectionPointName );
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743848378/fstmerge_base_821290047991490034
private void addParameterToAnnotationDatabase(String annotationClassName, Element injectionPoint) {
        Element enclosing = injectionPoint.getEnclosingElement();
        String injectionPointName = enclosing.getSimpleName().toString();
        for( VariableElement variable : ((ExecutableElement)enclosing).getParameters() ) {
            String parameterTypeName = getTypeName(variable);
            bindableClasses.add( parameterTypeName );
            injectionPointName += ":"+parameterTypeName;
        }

        TypeElement typeElementRequiringScanning = (TypeElement) ((ExecutableElement) injectionPoint.getEnclosingElement()).getEnclosingElement();
        String typeElementName = getTypeName(typeElementRequiringScanning);
        //System.out.printf("Type: %s, injection: %s \n",typeElementName, injectionPointName);
        if( injectionPointName.startsWith("<init>") ) {
            addToInjectedConstructors(annotationClassName, typeElementName, injectionPointName );
        } else {
            addToInjectedMethods(annotationClassName, typeElementName, injectionPointName );
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743848378/fstmerge_var2_459974915507817071

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_019e7_9417a/rev_019e7-9417a/blender/src/com/google/inject/blender/GuiceAnnotationProcessor.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743848383/fstmerge_var1_3477037070976323906
private void addMethodOrConstructorToAnnotationDatabase(String annotationClassName, Element injectionPoint) {
        String injectionPointName = injectionPoint.getSimpleName().toString();
        for( VariableElement variable : ((ExecutableElement)injectionPoint).getParameters() ) {
            String parameterTypeName = getTypeName((TypeElement)((DeclaredType)variable.asType()).asElement());
            bindableClasses.add( parameterTypeName );
            injectionPointName += ":"+parameterTypeName;
        }

        TypeElement typeElementRequiringScanning = (TypeElement) injectionPoint.getEnclosingElement();
        String typeElementName = getTypeName(typeElementRequiringScanning);

        if( injectionPointName.startsWith("<init>") ) {
            addToInjectedConstructors(annotationClassName, typeElementName, injectionPointName );
        } else {
            addToInjectedMethods(annotationClassName, typeElementName, injectionPointName );
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743848383/fstmerge_base_2996866396723667146
private void addMethodOrConstructorToAnnotationDatabase(String annotationClassName, Element injectionPoint) {
        String injectionPointName = injectionPoint.getSimpleName().toString();
        for( VariableElement variable : ((ExecutableElement)injectionPoint).getParameters() ) {
            String parameterTypeName = getTypeName((TypeElement)((DeclaredType)variable.asType()).asElement());
            bindableClasses.add( parameterTypeName );
            injectionPointName += ":"+parameterTypeName;
        }

        TypeElement typeElementRequiringScanning = (TypeElement) injectionPoint.getEnclosingElement();
        String typeElementName = getTypeName(typeElementRequiringScanning);

        //System.out.printf("Type: %s, injection: %s \n",typeElementName, injectionPointName);
        if( injectionPointName.startsWith("<init>") ) {
            addToInjectedConstructors(annotationClassName, typeElementName, injectionPointName );
        } else {
            addToInjectedMethods(annotationClassName, typeElementName, injectionPointName );
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743848383/fstmerge_var2_2981411912274638244

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_019e7_9417a/rev_019e7-9417a/blender/src/com/google/inject/blender/GuiceAnnotationProcessor.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743848411/fstmerge_var1_8521409562935215852
public void generateAnnotationDatabase(JavaFileObject jfo, final String packageName, final HashMap<String, Map<String, Set<String>>> mapAnnotationToMapClassWithInjectionNameToFieldSet,
            HashMap<String, Map<String, Set<String>>> mapAnnotationToMapClassWithInjectionNameToMethodSet,
            HashMap<String, Map<String, Set<String>>> mapAnnotationToMapClassWithInjectionNameToConstructorSet, final HashSet<String> classesContainingInjectionPointsSet, HashSet<String> bindableClasses) throws IOException {

        Properties props = new Properties();
        props.put("resource.loader", "class");
        props.put("class.resource.loader.class", "org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader");
        Velocity.init(props);

        VelocityContext context = new VelocityContext();

        context.put("packageName", packageName);
        context.put("mapAnnotationToMapClassWithInjectionNameToFieldSet", mapAnnotationToMapClassWithInjectionNameToFieldSet);
        context.put("mapAnnotationToMapClassWithInjectionNameToMethodSet", mapAnnotationToMapClassWithInjectionNameToMethodSet);
        context.put("mapAnnotationToMapClassWithInjectionNameToConstructorSet", mapAnnotationToMapClassWithInjectionNameToConstructorSet);
        context.put("classesContainingInjectionPointsSet", classesContainingInjectionPointsSet);
        context.put("injectedClasses", bindableClasses);

        Template template = null;

        PrintWriter w =  null;
        try {
            template = Velocity.getTemplate("templates/AnnotationDatabaseImpl.vm");
            w = new PrintWriter(jfo.openWriter());
            template.merge(context, w);
        } catch (Exception ex) {
            throw new IOException("Impossible to generate annotation database.", ex);
        } finally {
            if( w != null ) {
                try {
                    w.close();
                } catch( Exception ex ) {
                    throw new IOException("Impossible to close annotation database.", ex);
                }
            }
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743848411/fstmerge_base_4152342406222442568
public void generateAnnotationDatabase(JavaFileObject jfo, final String packageName, final HashMap<String, Map<String, Set<String>>> mapAnnotationToMapClassWithInjectionNameToFieldSet,
            HashMap<String, Map<String, Set<String>>> mapAnnotationToMapClassWithInjectionNameToMethodSet,
            HashMap<String, Map<String, Set<String>>> mapAnnotationToMapClassWithInjectionNameToConstructorSet, final HashSet<String> classesContainingInjectionPointsSet, HashSet<String> bindableClasses) throws IOException {

        Properties props = new Properties();
        props.put("resource.loader", "class");
        props.put("class.resource.loader.class", "org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader");
        Velocity.init(props);

        VelocityContext context = new VelocityContext();

        context.put("packageName", packageName);
        context.put("mapAnnotationToMapClassWithInjectionNameToFieldSet", mapAnnotationToMapClassWithInjectionNameToFieldSet);
        context.put("mapAnnotationToMapClassWithInjectionNameToMethodSet", mapAnnotationToMapClassWithInjectionNameToMethodSet);
        context.put("mapAnnotationToMapClassWithInjectionNameToConstructorSet", mapAnnotationToMapClassWithInjectionNameToConstructorSet);
        context.put("classesContainingInjectionPointsSet", classesContainingInjectionPointsSet);
        context.put("injectedClasses", bindableClasses);

        Template template = null;

        PrintWriter w =  null;
        try {
            template = Velocity.getTemplate("templates/AnnotationDatabaseImpl.vm");
            w = new PrintWriter(jfo.openWriter());
            template.merge(context, w);
        } catch (Exception ex) {
            ex.printStackTrace();
            throw new IOException("Impossible to generate annotation database.", ex);
        } finally {
            if( w != null ) {
                try {
                    w.close();
                } catch( Exception ex ) {
                    ex.printStackTrace();
                    throw new IOException("Impossible to close annotation database.", ex);
                }
            }
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420743848411/fstmerge_var2_5800739277847141676

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_019e7_9417a/rev_019e7-9417a/blender/src/com/google/inject/blender/AnnotationDatabaseGenerator.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_7b897_5c9b6/rev_7b897-5c9b6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_f6591_cefe7/rev_f6591-cefe7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_076e7_94dd0/rev_076e7-94dd0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_9cfc5_18120/rev_9cfc5-18120.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_646e4_400eb/rev_646e4-400eb.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420744369084/fstmerge_var1_4608200087118668139
@Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
        annotationDatabasePackageName = processingEnv.getOptions().get("guiceAnnotationDatabasePackageName");
        mapAnnotationToMapClassContainingInjectionToInjectedFieldSet = new HashMap<String, Map<String,Set<String>> >();
        mapAnnotationToMapClassContainingInjectionToInjectedMethodSet = new HashMap<String, Map<String,Set<String>> >();
        mapAnnotationToMapClassContainingInjectionToInjectedConstructorsSet = new HashMap<String, Map<String,Set<String>> >();
        bindableClasses = new HashSet<String>();
        elementUtils = processingEnv.getElementUtils();
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420744369084/fstmerge_base_956695265926474839
@Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
        annotationDatabasePackageName = processingEnv.getOptions().get("guiceAnnotationDatabasePackageName");
        mapAnnotationToMapClassContainingInjectionToInjectedFieldSet = new HashMap<String, Map<String,Set<String>> >();
        mapAnnotationToMapClassContainingInjectionToInjectedMethodSet = new HashMap<String, Map<String,Set<String>> >();
        mapAnnotationToMapClassContainingInjectionToInjectedConstructorsSet = new HashMap<String, Map<String,Set<String>> >();
        bindableClasses = new HashSet<String>();
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420744369084/fstmerge_var2_7910152727406686240

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_646e4_400eb/rev_646e4-400eb/blender/src/com/google/inject/blender/GuiceAnnotationProcessor.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420744369088/fstmerge_var1_4255200861663444797
@Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        // Not sure why, but sometimes we're getting called with an empty list of annotations.
        if(annotations.isEmpty())
            return true;

        for( TypeElement annotation : annotations ) {
            String annotationClassName = getTypeName(annotation);
            //merge the 2 inject annotations
            if( "javax.inject.Inject".equals(annotationClassName) ) {
                annotationClassName = "com.google.inject.Inject";
            }
            
            for( Element injectionPoint : roundEnv.getElementsAnnotatedWith(annotation)) {
                if( injectionPoint.getEnclosingElement() instanceof TypeElement && injectionPoint instanceof VariableElement ) {
                    addFieldToAnnotationDatabase(annotationClassName, injectionPoint);
                } else if( injectionPoint.getEnclosingElement() instanceof ExecutableElement && injectionPoint instanceof VariableElement ) {
                    addParameterToAnnotationDatabase(annotationClassName, injectionPoint);
                } else if( injectionPoint instanceof ExecutableElement ) {
                    addMethodOrConstructorToAnnotationDatabase(annotationClassName, injectionPoint);
                } else if( injectionPoint instanceof TypeElement ) {
                    addClassToAnnotationDatabase(injectionPoint);
                }
            }
        }


        for( Map<String, Set<String>> entryAnnotationToclassesContainingInjectionPoints : mapAnnotationToMapClassContainingInjectionToInjectedFieldSet.values() ) {
            classesContainingInjectionPointsSet.addAll(entryAnnotationToclassesContainingInjectionPoints.keySet());
        }

        for( Map<String, Set<String>> entryAnnotationToclassesContainingInjectionPoints : mapAnnotationToMapClassContainingInjectionToInjectedMethodSet.values() ) {
            classesContainingInjectionPointsSet.addAll(entryAnnotationToclassesContainingInjectionPoints.keySet());
        }

        for( Map<String, Set<String>> entryAnnotationToclassesContainingInjectionPoints : mapAnnotationToMapClassContainingInjectionToInjectedConstructorsSet.values() ) {
            classesContainingInjectionPointsSet.addAll(entryAnnotationToclassesContainingInjectionPoints.keySet());
        }

        JavaFileObject jfo;
        try {
            String className = "AnnotationDatabaseImpl";
            String packageName = "";
            if( annotationDatabasePackageName != null && !annotationDatabasePackageName.isEmpty() ) {
                className = annotationDatabasePackageName+'.'+className;
                packageName = annotationDatabasePackageName;
            }
            jfo = processingEnv.getFiler().createSourceFile( className, elementUtils.getTypeElement(packageName+".package-info") );
            annotationDatabaseGenerator.generateAnnotationDatabase(jfo, annotationDatabasePackageName, mapAnnotationToMapClassContainingInjectionToInjectedFieldSet, mapAnnotationToMapClassContainingInjectionToInjectedMethodSet, mapAnnotationToMapClassContainingInjectionToInjectedConstructorsSet, classesContainingInjectionPointsSet, bindableClasses);
        } catch (IOException e) {
            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, e.getMessage());
        }
        return true;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420744369088/fstmerge_base_7262985425891641518
@Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        // Not sure why, but sometimes we're getting called with an empty list of annotations.
        if(annotations.isEmpty())
            return true;

        for( TypeElement annotation : annotations ) {
            String annotationClassName = getTypeName(annotation);
            //merge the 2 inject annotations
            if( "javax.inject.Inject".equals(annotationClassName) ) {
                annotationClassName = "com.google.inject.Inject";
            }
            
            for( Element injectionPoint : roundEnv.getElementsAnnotatedWith(annotation)) {
                if( injectionPoint.getEnclosingElement() instanceof TypeElement && injectionPoint instanceof VariableElement ) {
                    addFieldToAnnotationDatabase(annotationClassName, injectionPoint);
                } else if( injectionPoint.getEnclosingElement() instanceof ExecutableElement && injectionPoint instanceof VariableElement ) {
                    addParameterToAnnotationDatabase(annotationClassName, injectionPoint);
                } else if( injectionPoint instanceof ExecutableElement ) {
                    addMethodOrConstructorToAnnotationDatabase(annotationClassName, injectionPoint);
                } else if( injectionPoint instanceof TypeElement ) {
                    addClassToAnnotationDatabase(injectionPoint);
                }
            }
        }


        for( Map<String, Set<String>> entryAnnotationToclassesContainingInjectionPoints : mapAnnotationToMapClassContainingInjectionToInjectedFieldSet.values() ) {
            classesContainingInjectionPointsSet.addAll(entryAnnotationToclassesContainingInjectionPoints.keySet());
        }

        for( Map<String, Set<String>> entryAnnotationToclassesContainingInjectionPoints : mapAnnotationToMapClassContainingInjectionToInjectedMethodSet.values() ) {
            classesContainingInjectionPointsSet.addAll(entryAnnotationToclassesContainingInjectionPoints.keySet());
        }

        for( Map<String, Set<String>> entryAnnotationToclassesContainingInjectionPoints : mapAnnotationToMapClassContainingInjectionToInjectedConstructorsSet.values() ) {
            classesContainingInjectionPointsSet.addAll(entryAnnotationToclassesContainingInjectionPoints.keySet());
        }

        JavaFileObject jfo;
        try {
            String className = "AnnotationDatabaseImpl";
            if( annotationDatabasePackageName != null && !annotationDatabasePackageName.isEmpty() ) {
                className = annotationDatabasePackageName+'.'+className;
            }
            jfo = processingEnv.getFiler().createSourceFile( className );
            annotationDatabaseGenerator.generateAnnotationDatabase(jfo, annotationDatabasePackageName, mapAnnotationToMapClassContainingInjectionToInjectedFieldSet, mapAnnotationToMapClassContainingInjectionToInjectedMethodSet, mapAnnotationToMapClassContainingInjectionToInjectedConstructorsSet, classesContainingInjectionPointsSet, bindableClasses);
        } catch (IOException e) {
            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, e.getMessage());
        }

        return true;
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420744369088/fstmerge_var2_151294991177240738

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_646e4_400eb/rev_646e4-400eb/blender/src/com/google/inject/blender/GuiceAnnotationProcessor.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_9bc69_400eb/rev_9bc69-400eb.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_4b2c1_86d6e/rev_4b2c1-86d6e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_f15e0_73a97/rev_f15e0-73a97.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_030ff_662ee/rev_030ff-662ee.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_43513_755dc/rev_43513-755dc.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_749b7_9a766/rev_749b7-9a766.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_57c25_35af6/rev_57c25-35af6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_5a207_ae1f5/rev_5a207-ae1f5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_c7cc9_594d1/rev_c7cc9-594d1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_ec3ab_daa64/rev_ec3ab-daa64.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_0fc1b_875e8/rev_0fc1b-875e8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_0b346_2ce24/rev_0b346-2ce24.revisions
Conflict type: ModifierList
Conflict body: 
~~FSTMerge~~ @SupportedAnnotationTypes({"com.google.inject.Inject", "javax.inject.Inject", "com.google.inject.Provides"})
@SupportedSourceVersion(SourceVersion.RELEASE_6)
@SupportedOptions({"guiceAnnotationDatabasePackageName", "guiceUsesFragmentUtil"})
public ##FSTMerge## @SupportedAnnotationTypes({"com.google.inject.Inject", "javax.inject.Inject", "com.google.inject.Provides"})
@SupportedSourceVersion(SourceVersion.RELEASE_6)
@SupportedOptions({"guiceAnnotationDatabasePackageName"})
public ##FSTMerge##
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_0b346_2ce24/rev_0b346-2ce24/blender/src/com/google/inject/blender/GuiceAnnotationProcessor.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420745858449/fstmerge_var1_4742535653983681821
@Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        // Not sure why, but sometimes we're getting called with an empty list of annotations.
        if(annotations.isEmpty())
            return true;

        for( TypeElement annotation : annotations ) {
            String annotationClassName = getTypeName(annotation);
            //merge the 2 inject annotations
            if( "javax.inject.Inject".equals(annotationClassName) ) {
                annotationClassName = "com.google.inject.Inject";
            }

            for( Element injectionPoint : roundEnv.getElementsAnnotatedWith(annotation)) {
                if( injectionPoint.getEnclosingElement() instanceof TypeElement && injectionPoint instanceof VariableElement ) {
                    addFieldToAnnotationDatabase(annotationClassName, injectionPoint);
                } else if( injectionPoint.getEnclosingElement() instanceof ExecutableElement && injectionPoint instanceof VariableElement ) {
                    addParameterToAnnotationDatabase(annotationClassName, injectionPoint);
                } else if( injectionPoint instanceof ExecutableElement ) {
                    addMethodOrConstructorToAnnotationDatabase(annotationClassName, injectionPoint);
                } else if( injectionPoint instanceof TypeElement ) {
                    addClassToAnnotationDatabase(injectionPoint);
                }
            }
        }


        for( Map<String, Set<String>> entryAnnotationToclassesContainingInjectionPoints : mapAnnotationToMapClassContainingInjectionToInjectedFieldSet.values() ) {
            classesContainingInjectionPointsSet.addAll(entryAnnotationToclassesContainingInjectionPoints.keySet());
        }

        for( Map<String, Set<String>> entryAnnotationToclassesContainingInjectionPoints : mapAnnotationToMapClassContainingInjectionToInjectedMethodSet.values() ) {
            classesContainingInjectionPointsSet.addAll(entryAnnotationToclassesContainingInjectionPoints.keySet());
        }

        for( Map<String, Set<String>> entryAnnotationToclassesContainingInjectionPoints : mapAnnotationToMapClassContainingInjectionToInjectedConstructorsSet.values() ) {
            classesContainingInjectionPointsSet.addAll(entryAnnotationToclassesContainingInjectionPoints.keySet());
        }

        JavaFileObject jfo;
        try {
            String className = "AnnotationDatabaseImpl";
            if( annotationDatabasePackageName != null && !annotationDatabasePackageName.isEmpty() ) {
                className = annotationDatabasePackageName+'.'+className;
            }
            jfo = processingEnv.getFiler().createSourceFile( className );
            AnnotationDatabaseGenerator annotationDatabaseGenerator = createAnnotationDatabaseGenerator();
            configure(annotationDatabaseGenerator);
            annotationDatabaseGenerator.generateAnnotationDatabase(jfo);
        } catch (IOException e) {
            e.printStackTrace();
            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, e.getMessage());
        }

        return true;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420745858449/fstmerge_base_4715180001005906064
@Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        // Not sure why, but sometimes we're getting called with an empty list of annotations.
        if(annotations.isEmpty())
            return true;

        for( TypeElement annotation : annotations ) {
            String annotationClassName = getTypeName(annotation);
            //merge the 2 inject annotations
            if( "javax.inject.Inject".equals(annotationClassName) ) {
                annotationClassName = "com.google.inject.Inject";
            }
            
            for( Element injectionPoint : roundEnv.getElementsAnnotatedWith(annotation)) {
                if( injectionPoint.getEnclosingElement() instanceof TypeElement && injectionPoint instanceof VariableElement ) {
                    addFieldToAnnotationDatabase(annotationClassName, injectionPoint);
                } else if( injectionPoint.getEnclosingElement() instanceof ExecutableElement && injectionPoint instanceof VariableElement ) {
                    addParameterToAnnotationDatabase(annotationClassName, injectionPoint);
                } else if( injectionPoint instanceof ExecutableElement ) {
                    addMethodOrConstructorToAnnotationDatabase(annotationClassName, injectionPoint);
                } else if( injectionPoint instanceof TypeElement ) {
                    addClassToAnnotationDatabase(injectionPoint);
                }
            }
        }


        for( Map<String, Set<String>> entryAnnotationToclassesContainingInjectionPoints : mapAnnotationToMapClassContainingInjectionToInjectedFieldSet.values() ) {
            classesContainingInjectionPointsSet.addAll(entryAnnotationToclassesContainingInjectionPoints.keySet());
        }

        for( Map<String, Set<String>> entryAnnotationToclassesContainingInjectionPoints : mapAnnotationToMapClassContainingInjectionToInjectedMethodSet.values() ) {
            classesContainingInjectionPointsSet.addAll(entryAnnotationToclassesContainingInjectionPoints.keySet());
        }

        for( Map<String, Set<String>> entryAnnotationToclassesContainingInjectionPoints : mapAnnotationToMapClassContainingInjectionToInjectedConstructorsSet.values() ) {
            classesContainingInjectionPointsSet.addAll(entryAnnotationToclassesContainingInjectionPoints.keySet());
        }

        JavaFileObject jfo;
        try {
            String className = "AnnotationDatabaseImpl";
            if( annotationDatabasePackageName != null && !annotationDatabasePackageName.isEmpty() ) {
                className = annotationDatabasePackageName+'.'+className;
            }
            jfo = processingEnv.getFiler().createSourceFile( className );
            annotationDatabaseGenerator.generateAnnotationDatabase(jfo, annotationDatabasePackageName, mapAnnotationToMapClassContainingInjectionToInjectedFieldSet, mapAnnotationToMapClassContainingInjectionToInjectedMethodSet, mapAnnotationToMapClassContainingInjectionToInjectedConstructorsSet, classesContainingInjectionPointsSet, bindableClasses);
        } catch (IOException e) {
            e.printStackTrace();
            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, e.getMessage());
        }

        return true;
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420745858449/fstmerge_var2_9099937181804769590

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_0b346_2ce24/rev_0b346-2ce24/blender/src/com/google/inject/blender/GuiceAnnotationProcessor.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_dca66_e735b/rev_dca66-e735b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b376e_c459e/rev_b376e-c459e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_b10cb_59131/rev_b10cb-59131.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_a6117_f5fef/rev_a6117-f5fef.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_caad9_d45e1/rev_caad9-d45e1.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420746463383/fstmerge_var1_8203646288489100446
public static InjectionPoint forConstructorOf(TypeLiteral<?> type) {
        Class<?> rawType = getRawType(type.getType());
        Errors errors = new Errors(rawType);

        filter.reset();
        Constructor<?> injectableConstructor = null;
        if( filter.isWorthScanningForConstructors(Inject.class.getName(), rawType)) {
            for (Constructor<?> constructor : filter.getAllConstructors(Inject.class.getName(), rawType)) {
                boolean optional;
                Inject guiceInject = constructor.getAnnotation(Inject.class);
                if (guiceInject == null) {
                    javax.inject.Inject javaxInject = constructor.getAnnotation(javax.inject.Inject.class);
                    if (javaxInject == null) {
                        continue;
                    }
                    optional = false;
                } else {
                    optional = guiceInject.optional();
                }

                if (optional) {
                    errors.optionalConstructor(constructor);
                }

                if (injectableConstructor != null) {
                    errors.tooManyConstructors(rawType);
                }

                injectableConstructor = constructor;
                checkForMisplacedBindingAnnotations(injectableConstructor, errors);
            }
        }

        errors.throwConfigurationExceptionIfErrorsExist();

        if (injectableConstructor != null) {
            return new InjectionPoint(type, injectableConstructor);
        }

        // If no annotated constructor is found, look for a no-arg constructor instead.
        try {
            Constructor<?> noArgConstructor = rawType.getDeclaredConstructor();

            // Disallow private constructors on non-private classes (unless they have @Inject)
            if (Modifier.isPrivate(noArgConstructor.getModifiers())
                    && !Modifier.isPrivate(rawType.getModifiers())) {
                errors.missingConstructor(rawType);
                throw new ConfigurationException(errors.getMessages());
            }

            checkForMisplacedBindingAnnotations(noArgConstructor, errors);
            return new InjectionPoint(type, noArgConstructor);
        } catch (NoSuchMethodException e) {
            errors.missingConstructor(rawType);
            throw new ConfigurationException(errors.getMessages());
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420746463383/fstmerge_base_2982219391603388408
public static InjectionPoint forConstructorOf(TypeLiteral<?> type) {
        Class<?> rawType = getRawType(type.getType());
        Errors errors = new Errors(rawType);

        Constructor<?> injectableConstructor = null;
        if( filter.isWorthScanningForConstructors(Inject.class.getName(), rawType)) {
            for (Constructor<?> constructor : filter.getAllConstructors(Inject.class.getName(), rawType)) {
                boolean optional;
                Inject guiceInject = constructor.getAnnotation(Inject.class);
                if (guiceInject == null) {
                    javax.inject.Inject javaxInject = constructor.getAnnotation(javax.inject.Inject.class);
                    if (javaxInject == null) {
                        continue;
                    }
                    optional = false;
                } else {
                    optional = guiceInject.optional();
                }

                if (optional) {
                    errors.optionalConstructor(constructor);
                }

                if (injectableConstructor != null) {
                    errors.tooManyConstructors(rawType);
                }

                injectableConstructor = constructor;
                checkForMisplacedBindingAnnotations(injectableConstructor, errors);
            }
        }

        errors.throwConfigurationExceptionIfErrorsExist();

        if (injectableConstructor != null) {
            return new InjectionPoint(type, injectableConstructor);
        }

        // If no annotated constructor is found, look for a no-arg constructor instead.
        try {
            Constructor<?> noArgConstructor = rawType.getDeclaredConstructor();

            // Disallow private constructors on non-private classes (unless they have @Inject)
            if (Modifier.isPrivate(noArgConstructor.getModifiers())
                    && !Modifier.isPrivate(rawType.getModifiers())) {
                errors.missingConstructor(rawType);
                throw new ConfigurationException(errors.getMessages());
            }

            checkForMisplacedBindingAnnotations(noArgConstructor, errors);
            return new InjectionPoint(type, noArgConstructor);
        } catch (NoSuchMethodException e) {
            errors.missingConstructor(rawType);
            throw new ConfigurationException(errors.getMessages());
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1420746463383/fstmerge_var2_1648531917904442931

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/roboguice/revisions/rev_caad9_d45e1/rev_caad9-d45e1/core/src/com/google/inject/spi/InjectionPoint.java

=========================================================