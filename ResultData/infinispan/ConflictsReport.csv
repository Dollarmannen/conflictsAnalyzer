=========================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_4f7f0_e5ca2/rev_4f7f0-e5ca2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_75df1_272c0/rev_75df1-272c0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_74716_45342/rev_74716-45342.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_1d8fa_ce636/rev_1d8fa-ce636.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_bcfc4_d4426/rev_bcfc4-d4426.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_d86dc_01714/rev_d86dc-01714.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_e7572_cb4e5/rev_e7572-cb4e5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_ae043_30050/rev_ae043-30050.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_49843_f1695/rev_49843-f1695.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_e2317_e98e5/rev_e2317-e98e5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a7f55_f906c/rev_a7f55-f906c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_30c86_cce5b/rev_30c86-cce5b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_7a083_2d21a/rev_7a083-2d21a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_972ed_dd21a/rev_972ed-dd21a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_db40f_24fa0/rev_db40f-24fa0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_cd48c_11015/rev_cd48c-11015.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@BeforeTest
   public void setUp() {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929844056/fstmerge_var1_7106398042727837693
      cm = TestCacheManagerFactory.createLocalCacheManager(false);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929844056/fstmerge_base_7525602559916341635
      cm = TestCacheManagerFactory.createLocalCacheManager();
=======
      // Use a clustered cache manager to be able to test global marshaller interaction too
      cm = TestCacheManagerFactory.createClusteredCacheManager();
      cm.getDefaultConfiguration().fluent().clustering().mode(Configuration.CacheMode.DIST_SYNC);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929844056/fstmerge_var2_4687065552273548260
      marshaller = extractCacheMarshaller(cm.getCache());
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_cd48c_11015/rev_cd48c-11015/core/src/test/java/org/infinispan/marshall/VersionAwareMarshallerTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
   protected EmbeddedCacheManager createCacheManager() throws Exception {
      Configuration c = getDefaultStandaloneConfig(true);
      c.fluent()
         .indexing()
         .indexLocalOnly(false)
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929852512/fstmerge_var1_982707217172023545
         .addProperty("hibernate.search.default.directory_provider", "ram");
      m_cacheManager = TestCacheManagerFactory.createCacheManager(c);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929852512/fstmerge_base_3176501325108197836
         .addProperty("hibernate.search.default.directory_provider", "ram");
      m_cacheManager = TestCacheManagerFactory.createCacheManager(c, true);
=======
         .addProperty("hibernate.search.default.directory_provider", "ram")
         .addProperty("hibernate.search.lucene_version", "LUCENE_CURRENT");
      m_cacheManager = TestCacheManagerFactory.createCacheManager(c, true);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929852512/fstmerge_var2_8289763870780728773
      m_cache = m_cacheManager.getCache();
      m_transactionManager = m_cache.getAdvancedCache().getTransactionManager();
      return m_cacheManager;
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_cd48c_11015/rev_cd48c-11015/query/src/test/java/org/infinispan/query/tx/TransactionalQueryTest.java
Conflict type: LineBasedMCFd
Conflict body: 
protected EmbeddedCacheManager createCacheManager() throws Exception {
      Configuration c = getDefaultStandaloneConfig(true);
      c.fluent()
         .indexing()
         .indexLocalOnly(false)
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929852823/fstmerge_var1_6635150175028652764
         .addProperty("hibernate.search.default.directory_provider", "ram");
      return TestCacheManagerFactory.createCacheManager(c);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929852823/fstmerge_base_6080915411896364748
         .addProperty("hibernate.search.default.directory_provider", "ram");
      return TestCacheManagerFactory.createCacheManager(c, true);
=======
         .addProperty("hibernate.search.default.directory_provider", "ram")
         .addProperty("hibernate.search.lucene_version", "LUCENE_CURRENT");
      return TestCacheManagerFactory.createCacheManager(c, true);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929852823/fstmerge_var2_3160553329749029801
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_cd48c_11015/rev_cd48c-11015/query/src/test/java/org/infinispan/query/api/ReplaceTest.java
Conflict type: LineBasedMCFd
Conflict body: 
public void testCorrectShutdown() {
      CacheContainer cc = null;

      try {
         Configuration c = SingleCacheManagerTest.getDefaultClusteredConfig(LOCAL, true);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929852930/fstmerge_var1_6739555406888348037
         c.fluent().indexing().indexLocalOnly(false);
         cc = TestCacheManagerFactory.createCacheManager(c);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929852930/fstmerge_base_43438261732594172
         c.fluent().indexing().indexLocalOnly(false);
         cc = TestCacheManagerFactory.createCacheManager(c, true);
=======
         c.fluent().indexing().indexLocalOnly(false)
            .addProperty("hibernate.search.lucene_version", "LUCENE_CURRENT");
         cc = TestCacheManagerFactory.createCacheManager(c, true);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929852930/fstmerge_var2_6165425004113040123
         Cache<?, ?> cache = cc.getCache();
         SearchFactoryIntegrator sfi = TestingUtil.extractComponent(cache, SearchFactoryIntegrator.class);

         assert ! sfi.isStopped();

         cc.stop();

         assert sfi.isStopped();
      } finally {
         // proper cleanup for exceptional execution
         TestingUtil.killCacheManagers(cc);
      }
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_cd48c_11015/rev_cd48c-11015/query/src/test/java/org/infinispan/query/blackbox/SearchFactoryShutdownTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
   protected StreamingMarshaller getMarshaller() {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929855973/fstmerge_var1_7810691764895935066
      cm = TestCacheManagerFactory.createLocalCacheManager(false);
      return extractCacheMarshaller(cm.getCache());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929855973/fstmerge_base_2316015155193507423
      cm = TestCacheManagerFactory.createLocalCacheManager();
      return extractCacheMarshaller(cm.getCache());
=======
      return marshaller;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929855973/fstmerge_var2_6930036270386597089
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_cd48c_11015/rev_cd48c-11015/cachestore/cloud/src/integrationtest/java/org/infinispan/loaders/cloud/CloudCacheStoreIntegrationVamTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
   protected StreamingMarshaller getMarshaller() {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929855982/fstmerge_var1_4392539183963912982
      cm = TestCacheManagerFactory.createLocalCacheManager(false);
      return extractCacheMarshaller(cm.getCache());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929855982/fstmerge_base_2099094014370259964
      cm = TestCacheManagerFactory.createLocalCacheManager();
      return extractCacheMarshaller(cm.getCache());
=======
      return marshaller;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929855982/fstmerge_var2_1061955579028678900
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_cd48c_11015/rev_cd48c-11015/cachestore/cloud/src/test/java/org/infinispan/loaders/cloud/CloudCacheStoreVamTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
   protected StreamingMarshaller getMarshaller() {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929857770/fstmerge_var1_2502093736865289491
      cm = TestCacheManagerFactory.createLocalCacheManager(false);
      return extractCacheMarshaller(cm.getCache());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929857770/fstmerge_base_5723474825722980387
      cm = TestCacheManagerFactory.createLocalCacheManager();
      return extractCacheMarshaller(cm.getCache());
=======
      return marshaller;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929857770/fstmerge_var2_8218664149421836550
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_cd48c_11015/rev_cd48c-11015/cachestore/jdbc/src/test/java/org/infinispan/loaders/jdbc/stringbased/JdbcStringBasedCacheStoreVamTest2.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
   protected StreamingMarshaller getMarshaller() {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929857785/fstmerge_var1_1997350402717694723
      cm = TestCacheManagerFactory.createLocalCacheManager(false);
      return extractCacheMarshaller(cm.getCache());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929857785/fstmerge_base_8942965988305110977
      cm = TestCacheManagerFactory.createLocalCacheManager();
      return extractCacheMarshaller(cm.getCache());
=======
      return marshaller;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929857785/fstmerge_var2_876187050202324774
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_cd48c_11015/rev_cd48c-11015/cachestore/jdbc/src/test/java/org/infinispan/loaders/jdbc/stringbased/JdbcStringBasedCacheStoreVamTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
   protected StreamingMarshaller getMarshaller() {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929857849/fstmerge_var1_7319213366210909154
      cm = TestCacheManagerFactory.createLocalCacheManager(false);
      return extractCacheMarshaller(cm.getCache());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929857849/fstmerge_base_7278497128189674204
      cm = TestCacheManagerFactory.createLocalCacheManager();
      return extractCacheMarshaller(cm.getCache());
=======
      return marshaller;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929857849/fstmerge_var2_3019934332646488362
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_cd48c_11015/rev_cd48c-11015/cachestore/jdbc/src/test/java/org/infinispan/loaders/jdbc/mixed/JdbcMixedCacheStoreVamTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
   protected StreamingMarshaller getMarshaller() {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929857870/fstmerge_var1_7940426225461306360
      cm = TestCacheManagerFactory.createLocalCacheManager(false);
      return extractCacheMarshaller(cm.getCache());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929857870/fstmerge_base_2932126655467392032
      cm = TestCacheManagerFactory.createLocalCacheManager();
      return extractCacheMarshaller(cm.getCache());
=======
      return marshaller;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929857870/fstmerge_var2_7983929425048605086
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_cd48c_11015/rev_cd48c-11015/cachestore/jdbc/src/test/java/org/infinispan/loaders/jdbc/mixed/JdbcMixedCacheStoreVamTest2.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
   protected StreamingMarshaller getMarshaller() {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929858030/fstmerge_var1_1271208635463165275
      cm = TestCacheManagerFactory.createLocalCacheManager(false);
      return extractCacheMarshaller(cm.getCache());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929858030/fstmerge_base_2096538120502442060
      cm = TestCacheManagerFactory.createLocalCacheManager();
      return extractCacheMarshaller(cm.getCache());
=======
      return marshaller;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929858030/fstmerge_var2_3893513240422594810
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_cd48c_11015/rev_cd48c-11015/cachestore/jdbc/src/test/java/org/infinispan/loaders/jdbc/binary/JdbcBinaryCacheStoreVamTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
   protected StreamingMarshaller getMarshaller() {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929858418/fstmerge_var1_4359893365976104633
      cm = TestCacheManagerFactory.createLocalCacheManager(false);
      return extractCacheMarshaller(cm.getCache());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929858418/fstmerge_base_6951055867362545579
      cm = TestCacheManagerFactory.createLocalCacheManager();
      return extractCacheMarshaller(cm.getCache());
=======
      return marshaller;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929858418/fstmerge_var2_3332794126041525310
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_cd48c_11015/rev_cd48c-11015/cachestore/jdbm/src/test/java/org/infinispan/loaders/jdbm/JdbmCacheStoreVamTest.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
   protected StreamingMarshaller getMarshaller() {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929859335/fstmerge_var1_547249686068762409
      cm = TestCacheManagerFactory.createLocalCacheManager(false);
      return extractCacheMarshaller(cm.getCache());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929859335/fstmerge_base_4690653053657911003
      cm = TestCacheManagerFactory.createLocalCacheManager();
      return extractCacheMarshaller(cm.getCache());
=======
      return marshaller;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418929859335/fstmerge_var2_5608690822395284550
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_cd48c_11015/rev_cd48c-11015/cachestore/bdbje/src/test/java/org/infinispan/loaders/bdbje/BdbjeCacheStoreIntegrationVamTest.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public final boolean remove(Object key, Object value) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130402/fstmerge_var1_4781941424421604412
      return remove(key, value, null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130402/fstmerge_base_3190132598272170926
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContext(false);
      RemoveCommand command = commandsFactory.buildRemoveCommand(key, value, ctx.getFlags());
      return (Boolean) invoker.invoke(ctx, command);
=======
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContextAndStartTx();
      RemoveCommand command = commandsFactory.buildRemoveCommand(key, value, ctx.getFlags());
      return (Boolean) invokeNextAndCommitIfNeeded(ctx, command);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130402/fstmerge_var2_4273566825950276392
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
public final int size() {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130407/fstmerge_var1_7319685889370608225
      return size(null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130407/fstmerge_base_513940039049423347
      SizeCommand command = commandsFactory.buildSizeCommand();
      return (Integer) invoker.invoke(getInvocationContext(false), command);
=======
      SizeCommand command = commandsFactory.buildSizeCommand();
      return (Integer) invoker.invoke(getInvocationContextForRead(null), command);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130407/fstmerge_var2_1117997483788429598
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
public final boolean containsKey(Object key) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130417/fstmerge_var1_895952279014116078
      return containsKey(key, null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130417/fstmerge_base_6467404721284049487
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContext(false);
      GetKeyValueCommand command = commandsFactory.buildGetKeyValueCommand(key, ctx.getFlags());
      Object response = invoker.invoke(ctx, command);
      return response != null;
=======
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContextForRead(null);
      GetKeyValueCommand command = commandsFactory.buildGetKeyValueCommand(key, ctx.getFlags());
      Object response = invoker.invoke(ctx, command);
      return response != null;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130417/fstmerge_var2_1677357494768726750
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130428/fstmerge_var1_6111744143636150112
public final V get(Object key) {
      return get(key, null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130428/fstmerge_base_7704815340556688391
@SuppressWarnings("unchecked")
   public final V get(Object key) {
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContext(false);
      GetKeyValueCommand command = commandsFactory.buildGetKeyValueCommand(key, ctx.getFlags());
      return (V) invoker.invoke(ctx, command);
=======
@SuppressWarnings("unchecked")
   public final V get(Object key) {
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContextForRead(null);
      GetKeyValueCommand command = commandsFactory.buildGetKeyValueCommand(key, ctx.getFlags());
      return (V) invoker.invoke(ctx, command);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130428/fstmerge_var2_6798056703343442926
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130432/fstmerge_var1_3396116564569548183
public final V remove(Object key) {
      return remove(key, null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130432/fstmerge_base_7968324341292323126
@SuppressWarnings("unchecked")
   public final V remove(Object key) {
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContext(false);
      RemoveCommand command = commandsFactory.buildRemoveCommand(key, null, ctx.getFlags());
      return (V) invoker.invoke(ctx, command);
=======
@SuppressWarnings("unchecked")
   public final V remove(Object key) {
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContextAndStartTx();
      RemoveCommand command = commandsFactory.buildRemoveCommand(key, null, ctx.getFlags());
      return (V) invokeNextAndCommitIfNeeded(ctx, command);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130432/fstmerge_var2_5996144252397012729
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
public final void clear() {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130437/fstmerge_var1_1197390125994211866
      clear(null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130437/fstmerge_base_4836105806761717211
      InvocationContext ctx = getInvocationContext(false);
      ClearCommand command = commandsFactory.buildClearCommand(ctx.getFlags());
      invoker.invoke(ctx, command);
=======
      InvocationContext ctx = getInvocationContextAndStartTx();
      ClearCommand command = commandsFactory.buildClearCommand(ctx.getFlags());
      invokeNextAndCommitIfNeeded(ctx, command);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130437/fstmerge_var2_3673371698732166711
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130442/fstmerge_var1_6876525461740220495
public Set<K> keySet() {
      return keySet(null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130442/fstmerge_base_3377951956553474553
@SuppressWarnings("unchecked")
   public Set<K> keySet() {
      InvocationContext ctx = getInvocationContext(false);
      KeySetCommand command = commandsFactory.buildKeySetCommand();
      return (Set<K>) invoker.invoke(ctx, command);
=======
@SuppressWarnings("unchecked")
   public Set<K> keySet() {
      InvocationContext ctx = getInvocationContextForRead(null);
      KeySetCommand command = commandsFactory.buildKeySetCommand();
      return (Set<K>) invoker.invoke(ctx, command);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130442/fstmerge_var2_1770629627324851962
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130447/fstmerge_var1_2180245514949519965
public Collection<V> values() {
      return values(null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130447/fstmerge_base_7201810173562914873
@SuppressWarnings("unchecked")
   public Collection<V> values() {
      InvocationContext ctx = getInvocationContext(false);
      ValuesCommand command = commandsFactory.buildValuesCommand();
      return (Collection<V>) invoker.invoke(ctx, command);
=======
@SuppressWarnings("unchecked")
   public Collection<V> values() {
      InvocationContext ctx = getInvocationContextForRead(null);
      ValuesCommand command = commandsFactory.buildValuesCommand();
      return (Collection<V>) invoker.invoke(ctx, command);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130447/fstmerge_var2_1842592072293717806
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130452/fstmerge_var1_6879564169713240148
public Set<Map.Entry<K, V>> entrySet() {
      return entrySet(null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130452/fstmerge_base_4930850529042345398
@SuppressWarnings("unchecked")
   public Set<Map.Entry<K, V>> entrySet() {
      InvocationContext ctx = getInvocationContext(false);
      EntrySetCommand command = commandsFactory.buildEntrySetCommand();
      return (Set<Map.Entry<K, V>>) invoker.invoke(ctx, command);
=======
@SuppressWarnings("unchecked")
   public Set<Map.Entry<K, V>> entrySet() {
      InvocationContext ctx = getInvocationContextForRead(null);
      EntrySetCommand command = commandsFactory.buildEntrySetCommand();
      return (Set<Map.Entry<K, V>>) invoker.invoke(ctx, command);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130452/fstmerge_var2_7857079004373470308
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
public final void evict(K key) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130461/fstmerge_var1_7412034671625943095
      evict(key, null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130461/fstmerge_base_5344895355541856578
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContext(true);
      EvictCommand command = commandsFactory.buildEvictCommand(key);
      invoker.invoke(ctx, command);
=======
      assertKeyNotNull(key);
      InvocationContext ctx = createNonTxInvocationContext();
      EvictCommand command = commandsFactory.buildEvictCommand(key);
      invoker.invoke(ctx, command);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130461/fstmerge_var2_5946247387475435373
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
public boolean lock(Collection<? extends K> keys) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130497/fstmerge_var1_7989515028223453069
      return lock(keys, null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130497/fstmerge_base_254515003651130792
      if (keys == null || keys.isEmpty()) {
         throw new IllegalArgumentException("Cannot lock empty list of keys");
      }
      InvocationContext ctx = getInvocationContext(false);
      LockControlCommand command = commandsFactory.buildLockControlCommand(keys, false, ctx.getFlags());
      return (Boolean) invoker.invoke(ctx, command);
=======
      if (keys == null || keys.isEmpty()) {
         throw new IllegalArgumentException("Cannot lock empty list of keys");
      }
      InvocationContext ctx = getInvocationContextForWrite();
      LockControlCommand command = commandsFactory.buildLockControlCommand(keys, false, ctx.getFlags());
      return (Boolean) invoker.invoke(ctx, command);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130497/fstmerge_var2_8632352829134492700
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
@ManagedOperation(description = "Stops the cache.")
   @Operation(displayName = "Stops cache.")
   public void stop() {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130509/fstmerge_var1_8947219680859087085
      stop(null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130509/fstmerge_base_563596288875127930
      if (log.isDebugEnabled()) log.debugf("Stopping cache %s on %s", getName(), getCacheManager().getAddress());

      // Create invocation context to pass flags
      getInvocationContext(false);
      componentRegistry.stop();
=======
      if (log.isDebugEnabled()) log.debugf("Stopping cache %s on %s", getName(), getCacheManager().getAddress());

      // Create invocation context to pass flags
      createNonTxInvocationContext();
      componentRegistry.stop();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130509/fstmerge_var2_240205298900052603
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130636/fstmerge_var1_3907487140368708684
public final V put(K key, V value, long lifespan, TimeUnit lifespanUnit, long maxIdleTime, TimeUnit idleTimeUnit) {
      return put(key, value, lifespan, lifespanUnit, maxIdleTime, idleTimeUnit, null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130636/fstmerge_base_3091701310219059406
@SuppressWarnings("unchecked")
   public final V put(K key, V value, long lifespan, TimeUnit lifespanUnit, long maxIdleTime, TimeUnit idleTimeUnit) {
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContext(false);
      PutKeyValueCommand command = commandsFactory.buildPutKeyValueCommand(key, value, lifespanUnit.toMillis(lifespan), idleTimeUnit.toMillis(maxIdleTime), ctx.getFlags());
      return (V) invoker.invoke(ctx, command);
=======
@SuppressWarnings("unchecked")
   public final V put(K key, V value, long lifespan, TimeUnit lifespanUnit, long maxIdleTime, TimeUnit idleTimeUnit) {
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContextAndStartTx();
      PutKeyValueCommand command = commandsFactory.buildPutKeyValueCommand(key, value, lifespanUnit.toMillis(lifespan), idleTimeUnit.toMillis(maxIdleTime), ctx.getFlags());
      return (V) invokeNextAndCommitIfNeeded(ctx, command);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130636/fstmerge_var2_7070438316381457299
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130641/fstmerge_var1_4465663183371581354
public final V putIfAbsent(K key, V value, long lifespan, TimeUnit lifespanUnit, long maxIdleTime, TimeUnit idleTimeUnit) {
      return putIfAbsent(key, value, lifespan, lifespanUnit, maxIdleTime, idleTimeUnit, null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130641/fstmerge_base_3799084685359433653
@SuppressWarnings("unchecked")
   public final V putIfAbsent(K key, V value, long lifespan, TimeUnit lifespanUnit, long maxIdleTime, TimeUnit idleTimeUnit) {
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContext(false);
      PutKeyValueCommand command = commandsFactory.buildPutKeyValueCommand(key, value, lifespanUnit.toMillis(lifespan), idleTimeUnit.toMillis(maxIdleTime), ctx.getFlags());
      command.setPutIfAbsent(true);
      return (V) invoker.invoke(ctx, command);
=======
@SuppressWarnings("unchecked")
   public final V putIfAbsent(K key, V value, long lifespan, TimeUnit lifespanUnit, long maxIdleTime, TimeUnit idleTimeUnit) {
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContextAndStartTx();
      PutKeyValueCommand command = commandsFactory.buildPutKeyValueCommand(key, value, lifespanUnit.toMillis(lifespan), idleTimeUnit.toMillis(maxIdleTime), ctx.getFlags());
      command.setPutIfAbsent(true);
      return (V) invokeNextAndCommitIfNeeded(ctx, command);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130641/fstmerge_var2_7672393373328890553
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
public final void putAll(Map<? extends K, ? extends V> map, long lifespan, TimeUnit lifespanUnit, long maxIdleTime, TimeUnit idleTimeUnit) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130646/fstmerge_var1_8161206452258212707
      putAll(map, lifespan, lifespanUnit, maxIdleTime, idleTimeUnit, null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130646/fstmerge_base_89681149977869997
      assertKeysNotNull(map);
      InvocationContext ctx = getInvocationContext(false);
      PutMapCommand command = commandsFactory.buildPutMapCommand(map, lifespanUnit.toMillis(lifespan), idleTimeUnit.toMillis(maxIdleTime), ctx.getFlags());
      invoker.invoke(ctx, command);
=======
      assertKeysNotNull(map);
      InvocationContext ctx = getInvocationContextAndStartTx();
      PutMapCommand command = commandsFactory.buildPutMapCommand(map, lifespanUnit.toMillis(lifespan), idleTimeUnit.toMillis(maxIdleTime), ctx.getFlags());
      invokeNextAndCommitIfNeeded(ctx, command);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130646/fstmerge_var2_8821298894743928027
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130651/fstmerge_var1_2371801557364738232
public final V replace(K key, V value, long lifespan, TimeUnit lifespanUnit, long maxIdleTime, TimeUnit idleTimeUnit) {
      return replace(key, value, lifespan, lifespanUnit, maxIdleTime, idleTimeUnit, null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130651/fstmerge_base_4789556524386009742
@SuppressWarnings("unchecked")
   public final V replace(K key, V value, long lifespan, TimeUnit lifespanUnit, long maxIdleTime, TimeUnit idleTimeUnit) {
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContext(false);
      ReplaceCommand command = commandsFactory.buildReplaceCommand(key, null, value, lifespanUnit.toMillis(lifespan), idleTimeUnit.toMillis(maxIdleTime), ctx.getFlags());
      return (V) invoker.invoke(ctx, command);

=======
@SuppressWarnings("unchecked")
   public final V replace(K key, V value, long lifespan, TimeUnit lifespanUnit, long maxIdleTime, TimeUnit idleTimeUnit) {
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContextAndStartTx();
      ReplaceCommand command = commandsFactory.buildReplaceCommand(key, null, value, lifespanUnit.toMillis(lifespan), idleTimeUnit.toMillis(maxIdleTime), ctx.getFlags());
      return (V) invokeNextAndCommitIfNeeded(ctx, command);

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130651/fstmerge_var2_4345832620817367898
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
public final boolean replace(K key, V oldValue, V value, long lifespan, TimeUnit lifespanUnit, long maxIdleTime, TimeUnit idleTimeUnit) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130655/fstmerge_var1_1555163648068975869
      return replace(key, oldValue, value, lifespan, lifespanUnit, maxIdleTime, idleTimeUnit, null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130655/fstmerge_base_261815230286178742
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContext(false);
      ReplaceCommand command = commandsFactory.buildReplaceCommand(key, oldValue, value, lifespanUnit.toMillis(lifespan), idleTimeUnit.toMillis(maxIdleTime), ctx.getFlags());
      return (Boolean) invoker.invoke(ctx, command);
=======
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContextAndStartTx();
      ReplaceCommand command = commandsFactory.buildReplaceCommand(key, oldValue, value, lifespanUnit.toMillis(lifespan), idleTimeUnit.toMillis(maxIdleTime), ctx.getFlags());
      return (Boolean) invokeNextAndCommitIfNeeded(ctx, command);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130655/fstmerge_var2_8864945409730037924
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
public final NotifyingFuture<V> putAsync(K key, V value, long lifespan, TimeUnit lifespanUnit, long maxIdle, TimeUnit maxIdleUnit) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130665/fstmerge_var1_7810826134152306626
      return putAsync(key, value, lifespan, lifespanUnit, maxIdle, maxIdleUnit, null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130665/fstmerge_base_8536116613697473756
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContext(false);
      ctx.setUseFutureReturnType(true);
      PutKeyValueCommand command = commandsFactory.buildPutKeyValueCommand(key, value, lifespanUnit.toMillis(lifespan), maxIdleUnit.toMillis(maxIdle), ctx.getFlags());
      return wrapInFuture(invoker.invoke(ctx, command));
=======
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContextForWrite();
      ctx.setUseFutureReturnType(true);
      PutKeyValueCommand command = commandsFactory.buildPutKeyValueCommand(key, value, lifespanUnit.toMillis(lifespan), maxIdleUnit.toMillis(maxIdle), ctx.getFlags());
      return wrapInFuture(invoker.invoke(ctx, command));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130665/fstmerge_var2_3800537277719774873
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
public final NotifyingFuture<Void> putAllAsync(Map<? extends K, ? extends V> data, long lifespan, TimeUnit lifespanUnit, long maxIdle, TimeUnit maxIdleUnit) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130669/fstmerge_var1_8360898960895880971
      return putAllAsync(data, lifespan, lifespanUnit, maxIdle, maxIdleUnit, null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130669/fstmerge_base_2747002998801827772
      assertKeysNotNull(data);
      InvocationContext ctx = getInvocationContext(false);
      ctx.setUseFutureReturnType(true);
      PutMapCommand command = commandsFactory.buildPutMapCommand(data, lifespanUnit.toMillis(lifespan), maxIdleUnit.toMillis(maxIdle), ctx.getFlags());
      return wrapInFuture(invoker.invoke(ctx, command));
=======
      assertKeysNotNull(data);
      InvocationContext ctx = getInvocationContextForWrite();
      ctx.setUseFutureReturnType(true);
      PutMapCommand command = commandsFactory.buildPutMapCommand(data, lifespanUnit.toMillis(lifespan), maxIdleUnit.toMillis(maxIdle), ctx.getFlags());
      return wrapInFuture(invoker.invoke(ctx, command));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130669/fstmerge_var2_4682119985919500595
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
public final NotifyingFuture<Void> clearAsync() {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130674/fstmerge_var1_4429882384011113478
      return clearAsync(null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130674/fstmerge_base_7954108231659637561
      InvocationContext ctx = getInvocationContext(false);
      ctx.setUseFutureReturnType(true);
      ClearCommand command = commandsFactory.buildClearCommand(ctx.getFlags());
      return wrapInFuture(invoker.invoke(ctx, command));
=======
      InvocationContext ctx = getInvocationContextForWrite();
      ctx.setUseFutureReturnType(true);
      ClearCommand command = commandsFactory.buildClearCommand(ctx.getFlags());
      return wrapInFuture(invoker.invoke(ctx, command));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130674/fstmerge_var2_7855413491044453809
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
public final NotifyingFuture<V> putIfAbsentAsync(K key, V value, long lifespan, TimeUnit lifespanUnit, long maxIdle, TimeUnit maxIdleUnit) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130679/fstmerge_var1_7518578840631967815
      return putIfAbsentAsync(key, value, lifespan, lifespanUnit, maxIdle, maxIdleUnit, null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130679/fstmerge_base_2673831549410502174
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContext(false);
      ctx.setUseFutureReturnType(true);
      PutKeyValueCommand command = commandsFactory.buildPutKeyValueCommand(key, value, lifespanUnit.toMillis(lifespan), maxIdleUnit.toMillis(maxIdle), ctx.getFlags());
      command.setPutIfAbsent(true);
      return wrapInFuture(invoker.invoke(ctx, command));
=======
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContextForWrite();
      ctx.setUseFutureReturnType(true);
      PutKeyValueCommand command = commandsFactory.buildPutKeyValueCommand(key, value, lifespanUnit.toMillis(lifespan), maxIdleUnit.toMillis(maxIdle), ctx.getFlags());
      command.setPutIfAbsent(true);
      return wrapInFuture(invoker.invoke(ctx, command));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130679/fstmerge_var2_8562396698193507049
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
public final NotifyingFuture<V> removeAsync(Object key) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130684/fstmerge_var1_32351721732642013
      return removeAsync(key, null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130684/fstmerge_base_6225838200402284062
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContext(false);
      ctx.setUseFutureReturnType(true);
      RemoveCommand command = commandsFactory.buildRemoveCommand(key, null, ctx.getFlags());
      return wrapInFuture(invoker.invoke(ctx, command));
=======
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContextForWrite();
      ctx.setUseFutureReturnType(true);
      RemoveCommand command = commandsFactory.buildRemoveCommand(key, null, ctx.getFlags());
      return wrapInFuture(invoker.invoke(ctx, command));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130684/fstmerge_var2_1118785119744677742
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
public final NotifyingFuture<Boolean> removeAsync(Object key, Object value) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130689/fstmerge_var1_856329204187665796
      return removeAsync(key, value, null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130689/fstmerge_base_2822991798622886414
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContext(false);
      ctx.setUseFutureReturnType(true);
      RemoveCommand command = commandsFactory.buildRemoveCommand(key, value, ctx.getFlags());
      return wrapInFuture(invoker.invoke(ctx, command));
=======
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContextForWrite();
      ctx.setUseFutureReturnType(true);
      RemoveCommand command = commandsFactory.buildRemoveCommand(key, value, ctx.getFlags());
      return wrapInFuture(invoker.invoke(ctx, command));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130689/fstmerge_var2_7691138119108258592
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
public final NotifyingFuture<V> replaceAsync(K key, V value, long lifespan, TimeUnit lifespanUnit, long maxIdle, TimeUnit maxIdleUnit) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130693/fstmerge_var1_6682534856998219291
      return replaceAsync(key, value, lifespan, lifespanUnit, maxIdle, maxIdleUnit, null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130693/fstmerge_base_5620946405860408769
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContext(false);
      ctx.setUseFutureReturnType(true);
      ReplaceCommand command = commandsFactory.buildReplaceCommand(key, null, value, lifespanUnit.toMillis(lifespan), maxIdleUnit.toMillis(maxIdle), ctx.getFlags());
      return wrapInFuture(invoker.invoke(ctx, command));
=======
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContextForWrite();
      ctx.setUseFutureReturnType(true);
      ReplaceCommand command = commandsFactory.buildReplaceCommand(key, null, value, lifespanUnit.toMillis(lifespan), maxIdleUnit.toMillis(maxIdle), ctx.getFlags());
      return wrapInFuture(invoker.invoke(ctx, command));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130693/fstmerge_var2_7524032514721645708
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
public final NotifyingFuture<Boolean> replaceAsync(K key, V oldValue, V newValue, long lifespan, TimeUnit lifespanUnit, long maxIdle, TimeUnit maxIdleUnit) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130698/fstmerge_var1_3282449766708201643
      return replaceAsync(key, oldValue, newValue, lifespan, lifespanUnit, maxIdle, maxIdleUnit, null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130698/fstmerge_base_7318916569926910454
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContext(false);
      ctx.setUseFutureReturnType(true);
      ReplaceCommand command = commandsFactory.buildReplaceCommand(key, oldValue, newValue, lifespanUnit.toMillis(lifespan), maxIdleUnit.toMillis(maxIdle), ctx.getFlags());
      return wrapInFuture(invoker.invoke(ctx, command));
=======
      assertKeyNotNull(key);
      InvocationContext ctx = getInvocationContextForWrite();
      ctx.setUseFutureReturnType(true);
      ReplaceCommand command = commandsFactory.buildReplaceCommand(key, oldValue, newValue, lifespanUnit.toMillis(lifespan), maxIdleUnit.toMillis(maxIdle), ctx.getFlags());
      return wrapInFuture(invoker.invoke(ctx, command));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130698/fstmerge_var2_2735370497819580480
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130703/fstmerge_var1_2966665938792087225
public NotifyingFuture<V> getAsync(K key) {
      return getAsync(key, null, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130703/fstmerge_base_5047069987595906293
@Override
   public NotifyingFuture<V> getAsync(final K key) {
      final Transaction tx = getOngoingTransaction();
      final NotifyingNotifiableFuture f = new DeferredReturnFuture();
      final EnumSet<Flag> flags = flagHolder.get() == null ? null : flagHolder.get().flags;

      // Optimization to not start a new thread only when the operation is cheap:
      if (asyncSkipsThread(flags, key)) {
         return wrapInFuture(get(key));
      } else {
         // Make sure the flags are cleared
         final EnumSet<Flag> appliedFlags;
         if (flags == null) {
            appliedFlags = null;
         }
         else {
            appliedFlags = flags.clone();
            flags.clear();
         }
         Callable<V> c = new Callable<V>() {
            @Override
            public V call() throws Exception {
               assertKeyNotNull(key);
               InvocationContext ctx = getInvocationContext(tx);
               if (appliedFlags != null)
                  ctx.setFlags(appliedFlags);

               GetKeyValueCommand command = commandsFactory.buildGetKeyValueCommand(key, appliedFlags);
               Object ret = invoker.invoke(ctx, command);
               f.notifyDone();
               return (V) ret;
            }
         };
         f.setNetworkFuture(asyncExecutor.submit(c));
         return f;
      }
=======
@Override
   public NotifyingFuture<V> getAsync(final K key) {
      final Transaction tx = getOngoingTransaction();
      final NotifyingNotifiableFuture f = new DeferredReturnFuture();
      final EnumSet<Flag> flags = flagHolder.get() == null ? null : flagHolder.get().flags;

      // Optimization to not start a new thread only when the operation is cheap:
      if (asyncSkipsThread(flags, key)) {
         return wrapInFuture(get(key));
      } else {
         // Make sure the flags are cleared
         final EnumSet<Flag> appliedFlags;
         if (flags == null) {
            appliedFlags = null;
         }
         else {
            appliedFlags = flags.clone();
            flags.clear();
         }
         Callable<V> c = new Callable<V>() {
            @Override
            public V call() throws Exception {
               assertKeyNotNull(key);
               InvocationContext ctx = getInvocationContextForRead(tx);
               if (appliedFlags != null)
                  ctx.setFlags(appliedFlags);

               GetKeyValueCommand command = commandsFactory.buildGetKeyValueCommand(key, appliedFlags);
               Object ret = invoker.invoke(ctx, command);
               f.notifyDone();
               return (V) ret;
            }
         };
         f.setNetworkFuture(asyncExecutor.submit(c));
         return f;
      }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930130703/fstmerge_var2_726256841481475679
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930136098/fstmerge_var1_6580060339928067510
private MVCCEntry wrapEntryForWriting(InvocationContext ctx, Object key, InternalCacheEntry entry, boolean createIfAbsent, boolean forceLockIfAbsent, boolean alreadyLocked, boolean forRemoval, boolean undeleteIfNeeded) throws InterruptedException {
      try {
         CacheEntry cacheEntry = ctx.lookupEntry(key);
         MVCCEntry mvccEntry = null;
         if (createIfAbsent && cacheEntry != null && cacheEntry.isNull()) cacheEntry = null;
         if (cacheEntry != null) // exists in context!  Just acquire lock if needed, and wrap.
         {
            if (trace) log.trace("Exists in context.");
            // Acquire lock if needed. Add necessary check for skip locking in advance in order to avoid marshalled value issues
            if (alreadyLocked || ctx.hasFlag(Flag.SKIP_LOCKING) || acquireLock(ctx, key)) {

               if (cacheEntry instanceof MVCCEntry && (!forRemoval || !(cacheEntry instanceof NullMarkerEntry))) {
                  mvccEntry = (MVCCEntry) cacheEntry;
               } else {
                  // this is a read-only entry that needs to be copied to a proper read-write entry!!
                  mvccEntry = createWrappedEntry(key, cacheEntry.getValue(), false, forRemoval, cacheEntry.getLifespan());
                  cacheEntry = mvccEntry;
                  ctx.putLookedUpEntry(key, cacheEntry);
               }

               // create a copy of the underlying entry
               mvccEntry.copyForUpdate(container, writeSkewCheck);
            } else if (ctx.hasFlag(Flag.FORCE_WRITE_LOCK)) {
               // If lock was already held and force write lock is on, just wrap
               if (cacheEntry instanceof MVCCEntry && (!forRemoval || !(cacheEntry instanceof NullMarkerEntry))) {
                  mvccEntry = (MVCCEntry) cacheEntry;
               }
            }

            if (cacheEntry.isRemoved() && createIfAbsent && undeleteIfNeeded) {
               if (trace) log.trace("Entry is deleted in current scope.  Need to un-delete.");
               if (mvccEntry != cacheEntry) mvccEntry = (MVCCEntry) cacheEntry;
               mvccEntry.setRemoved(false);
               mvccEntry.setValid(true);
            }

            return mvccEntry;

         } else {
            boolean lockAcquired = false;
            if (!alreadyLocked) {
               lockAcquired = acquireLock(ctx, key);
            }
            // else, fetch from dataContainer or used passed entry.
            cacheEntry = entry != null ? entry : container.get(key);
            if (cacheEntry != null) {
               if (trace) log.trace("Retrieved from container.");
               // exists in cache!  Just acquire lock if needed, and wrap.
               // do we need a lock?
               boolean needToCopy = alreadyLocked || lockAcquired || ctx.hasFlag(Flag.SKIP_LOCKING); // even if we do not acquire a lock, if skip-locking is enabled we should copy
               mvccEntry = createWrappedEntry(key, cacheEntry.getValue(), false, false, cacheEntry.getLifespan());
               ctx.putLookedUpEntry(key, mvccEntry);
               if (needToCopy) mvccEntry.copyForUpdate(container, writeSkewCheck);
            } else if (createIfAbsent) {
               // this is the *only* point where new entries can be created!!
               if (trace) log.trace("Creating new entry.");
               // now to lock and create the entry.  Lock first to prevent concurrent creation!
               try {
                  notifier.notifyCacheEntryCreated(key, true, ctx);
               } catch (CacheException e) {
                  // If any exception, release the lock cos the locking
                  // interceptor cannot do it due to the key not being in the
                  // ctx looked up entries yet
                  releaseLock(ctx, key);
                  throw e;
               }
               mvccEntry = createWrappedEntry(key, null, true, false, -1);
               mvccEntry.setCreated(true);
               ctx.putLookedUpEntry(key, mvccEntry);
               mvccEntry.copyForUpdate(container, writeSkewCheck);
               notifier.notifyCacheEntryCreated(key, false, ctx);
            } else {
               if (lockAcquired) {
                  releaseLock(ctx, key);
               }
            }
         }

         // see if we need to force the lock on nonexistent entries.
         if (mvccEntry == null && forceLockIfAbsent) {
            // make sure we record this! Null value since this is a forced lock on the key
            if (acquireLock(ctx, key)) ctx.putLookedUpEntry(key, null);
         }

         return mvccEntry;
      } catch (InvalidTransactionException ite) {
         try {
            releaseLock(ctx, key);
         } catch (Exception e) {
            // may not be necessary?
         }
         throw ite;
      }
   }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930136098/fstmerge_base_9190995493295036135
private MVCCEntry wrapEntryForWriting(InvocationContext ctx, Object key, InternalCacheEntry entry, boolean createIfAbsent, boolean forceLockIfAbsent, boolean alreadyLocked, boolean forRemoval, boolean undeleteIfNeeded) throws InterruptedException {
      try {
         CacheEntry cacheEntry = ctx.lookupEntry(key);
         MVCCEntry mvccEntry = null;
         if (createIfAbsent && cacheEntry != null && cacheEntry.isNull()) cacheEntry = null;
         if (cacheEntry != null) // exists in context!  Just acquire lock if needed, and wrap.
         {
            if (trace) log.trace("Exists in context.");
            // Acquire lock if needed. Add necessary check for skip locking in advance in order to avoid marshalled value issues
            if (alreadyLocked || ctx.hasFlag(Flag.SKIP_LOCKING) || acquireLock(ctx, key)) {

               if (cacheEntry instanceof MVCCEntry && (!forRemoval || !(cacheEntry instanceof NullMarkerEntry))) {
                  mvccEntry = (MVCCEntry) cacheEntry;
               } else {
                  // this is a read-only entry that needs to be copied to a proper read-write entry!!
                  mvccEntry = createWrappedEntry(key, cacheEntry.getValue(), false, forRemoval, cacheEntry.getLifespan());
                  cacheEntry = mvccEntry;
                  ctx.putLookedUpEntry(key, cacheEntry);
               }

               // create a copy of the underlying entry
               mvccEntry.copyForUpdate(container, writeSkewCheck);
            } else if (ctx.hasFlag(Flag.FORCE_WRITE_LOCK)) {
               // If lock was already held and force write lock is on, just wrap
               if (cacheEntry instanceof MVCCEntry && (!forRemoval || !(cacheEntry instanceof NullMarkerEntry))) {
                  mvccEntry = (MVCCEntry) cacheEntry;
               }
            }

            if (cacheEntry.isRemoved() && createIfAbsent && undeleteIfNeeded) {
               if (trace) log.trace("Entry is deleted in current scope.  Need to un-delete.");
               if (mvccEntry != cacheEntry) mvccEntry = (MVCCEntry) cacheEntry;
               mvccEntry.setRemoved(false);
               mvccEntry.setValid(true);
            }

            return mvccEntry;

         } else {
            boolean lockAcquired = false;
            if (!alreadyLocked) {
               lockAcquired = acquireLock(ctx, key);
            }
            // else, fetch from dataContainer or used passed entry.
            cacheEntry = entry != null ? entry : container.get(key);
            if (cacheEntry != null) {
               if (trace) log.trace("Retrieved from container.");
               // exists in cache!  Just acquire lock if needed, and wrap.
               // do we need a lock?
               boolean needToCopy = alreadyLocked || lockAcquired || ctx.hasFlag(Flag.SKIP_LOCKING); // even if we do not acquire a lock, if skip-locking is enabled we should copy
               mvccEntry = createWrappedEntry(key, cacheEntry.getValue(), false, false, cacheEntry.getLifespan());
               ctx.putLookedUpEntry(key, mvccEntry);
               if (needToCopy) mvccEntry.copyForUpdate(container, writeSkewCheck);
            } else if (createIfAbsent) {
               // this is the *only* point where new entries can be created!!
               if (trace) log.trace("Creating new entry.");
               // now to lock and create the entry.  Lock first to prevent concurrent creation!
               try {
                  notifier.notifyCacheEntryCreated(key, true, ctx);
               } catch (CacheException e) {
                  // If any exception, release the lock cos the locking
                  // interceptor cannot do it due to the key not being in the
                  // ctx looked up entries yet
                  releaseLock(key);
                  throw e;
               }
               mvccEntry = createWrappedEntry(key, null, true, false, -1);
               mvccEntry.setCreated(true);
               ctx.putLookedUpEntry(key, mvccEntry);
               mvccEntry.copyForUpdate(container, writeSkewCheck);
               notifier.notifyCacheEntryCreated(key, false, ctx);
            } else {
               if (lockAcquired) {
                  releaseLock(key);
               }
            }
         }

         // see if we need to force the lock on nonexistent entries.
         if (mvccEntry == null && forceLockIfAbsent) {
            // make sure we record this! Null value since this is a forced lock on the key
            if (acquireLock(ctx, key)) ctx.putLookedUpEntry(key, null);
         }

         return mvccEntry;
      } catch (InvalidTransactionException ite) {
         try {
            releaseLock(key);
         } catch (Exception e) {
            // may not be necessary?
         }
         throw ite;
      }
   }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930136098/fstmerge_var2_7588493720497206739

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/container/EntryFactoryImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
public boolean lockAndRecord(Object key, InvocationContext ctx) throws InterruptedException {
      long lockTimeout = getLockAcquisitionTimeout(ctx);
      if (trace) log.tracef("Attempting to lock %s with acquisition timeout of %s millis", key, lockTimeout);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930145326/fstmerge_var1_4389700320978572515
      if (lockContainer.acquireLock(ctx, key, lockTimeout, MILLISECONDS) != null) {
         // successfully locked!
         if (ctx instanceof TxInvocationContext) {
            TxInvocationContext tctx = (TxInvocationContext) ctx;
            if (!tctx.isTransactionValid()) {
               Transaction tx = tctx.getTransaction();
               log.debugf("Successfully acquired lock, but the transaction %s is no longer valid!  Releasing lock.", tx);
               lockContainer.releaseLock(ctx, key);
               throw new IllegalStateException("Transaction "+tx+" appears to no longer be valid!");
            }
         }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930145326/fstmerge_base_5229849370716690143
      if (lockContainer.acquireLock(key, lockTimeout, MILLISECONDS) != null) {
         // successfully locked!
         if (ctx instanceof TxInvocationContext) {
            TxInvocationContext tctx = (TxInvocationContext) ctx;
            if (!tctx.isTransactionValid()) {
               Transaction tx = tctx.getTransaction();
               log.debugf("Successfully acquired lock, but the transaction %s is no longer valid!  Releasing lock.", tx);
               lockContainer.releaseLock(key);
               throw new IllegalStateException("Transaction "+tx+" appears to no longer be valid!");
            }
         }
=======
      if (lockContainer.acquireLock(key, lockTimeout, MILLISECONDS) != null) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930145326/fstmerge_var2_2890552678454618335
         if (trace) log.tracef("Successfully acquired lock %s!", key);
         return true;
      }

      // couldn't acquire lock!
      if (log.isDebugEnabled()) {
         log.debugf("Failed to acquire lock %s, owner is %s", key, getOwner(key));
         Object owner = ctx.getLockOwner();
         Set<Map.Entry<Object, CacheEntry>> entries = ctx.getLookedUpEntries().entrySet();
         List<Object> lockedKeys = new ArrayList<Object>(entries.size());
         for (Map.Entry<Object, CacheEntry> e : entries) {
            Object lockedKey = e.getKey();
            if (ownsLock(lockedKey, owner)) {
               lockedKeys.add(lockedKey);
            }
         }
         log.debugf("This transaction (%s) already owned locks %s", owner, lockedKeys);
      }
      return false;
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/util/concurrent/locks/LockManagerImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
@SuppressWarnings("unchecked")
   public void unlock(InvocationContext ctx) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930145339/fstmerge_var1_6431274341194947489
      ReversibleOrderedSet<Map.Entry<Object, CacheEntry>> entries = ctx.getLookedUpEntries().entrySet();
      if (!entries.isEmpty()) {
         // unlocking needs to be done in reverse order.
         Iterator<Map.Entry<Object, CacheEntry>> it = entries.reverseIterator();
         while (it.hasNext()) {
            Map.Entry<Object, CacheEntry> e = it.next();
            CacheEntry entry = e.getValue();
            if (possiblyLocked(entry)) {
               // has been locked!
               Object k = e.getKey();
               if (trace) log.tracef("Attempting to unlock %s", k);
               lockContainer.releaseLock(ctx, k);
            }
         }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930145339/fstmerge_base_7147802323693863958
      ReversibleOrderedSet<Map.Entry<Object, CacheEntry>> entries = ctx.getLookedUpEntries().entrySet();
      if (!entries.isEmpty()) {
         // unlocking needs to be done in reverse order.
         Iterator<Map.Entry<Object, CacheEntry>> it = entries.reverseIterator();
         while (it.hasNext()) {
            Map.Entry<Object, CacheEntry> e = it.next();
            CacheEntry entry = e.getValue();
            if (possiblyLocked(entry)) {
               // has been locked!
               Object k = e.getKey();
               if (trace) log.tracef("Attempting to unlock %s", k);
               lockContainer.releaseLock(k);
            }
         }
=======
      for (Object k : ctx.getLockedKeys()) {
         if (trace) log.tracef("Attempting to unlock %s", k);
         lockContainer.releaseLock(k);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930145339/fstmerge_var2_3134572673135409492
      }
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/util/concurrent/locks/LockManagerImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930145392/fstmerge_var1_7284672519181745732
public void releaseLocks(InvocationContext ctx) {
      Object owner = ctx.getLockOwner();
      // clean up.
      // unlocking needs to be done in reverse order.
      ReversibleOrderedSet<Map.Entry<Object, CacheEntry>> entries = ctx.getLookedUpEntries().entrySet();
      Iterator<Map.Entry<Object, CacheEntry>> it = entries.reverseIterator();
      if (trace) log.tracef("Number of entries in context: %s", entries.size());

      while (it.hasNext()) {
         Map.Entry<Object, CacheEntry> e = it.next();
         CacheEntry entry = e.getValue();
         Object key = e.getKey();
         boolean needToUnlock = possiblyLocked(entry);
         // could be null with read-committed
         if (entry != null && entry.isChanged()) entry.rollback();
         else {
            if (trace) log.tracef("Entry for key %s is null, not calling rollbackUpdate", key);
         }
         // and then unlock
         if (needToUnlock) {
            if (trace) log.tracef("Releasing lock on [%s] for owner %s", key, owner);
            unlock(ctx, key);
         }
      }
   }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930145392/fstmerge_base_562242238446392250
public void releaseLocks(InvocationContext ctx) {
      Object owner = ctx.getLockOwner();
      // clean up.
      // unlocking needs to be done in reverse order.
      ReversibleOrderedSet<Map.Entry<Object, CacheEntry>> entries = ctx.getLookedUpEntries().entrySet();
      Iterator<Map.Entry<Object, CacheEntry>> it = entries.reverseIterator();
      if (trace) log.tracef("Number of entries in context: %s", entries.size());

      while (it.hasNext()) {
         Map.Entry<Object, CacheEntry> e = it.next();
         CacheEntry entry = e.getValue();
         Object key = e.getKey();
         boolean needToUnlock = possiblyLocked(entry);
         // could be null with read-committed
         if (entry != null && entry.isChanged()) entry.rollback();
         else {
            if (trace) log.tracef("Entry for key %s is null, not calling rollbackUpdate", key);
         }
         // and then unlock
         if (needToUnlock) {
            if (trace) log.tracef("Releasing lock on [%s] for owner %s", key, owner);
            unlock(key);
         }
      }
   }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930145392/fstmerge_var2_2959363380769253269

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/util/concurrent/locks/LockManagerImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930145516/fstmerge_var1_7568295679933564065
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930145516/fstmerge_base_7796554148688175314
public Lock acquireLock(Object key, long timeout, TimeUnit unit) throws InterruptedException {
      while (true) {
         Lock lock = getLock(key);
         boolean locked = false;
         try {
            locked = lock.tryLock(timeout, unit);
         } catch (InterruptedException ie) {
            safeRelease(lock);
            throw ie;
         } catch (Throwable th) {
            safeRelease(lock);
            locked = false;
         }
         if (locked) {
            // lock acquired.  Now check if it is the *correct* lock!
            Lock existingLock = locks.putIfAbsent(key, lock);
            if (existingLock != null && existingLock != lock) {
               // we have the wrong lock!  Unlock and retry.
               safeRelease(lock);
            } else {
               // we got the right lock.
               return lock;
            }
         } else {
            // we couldn't acquire the lock within the timeout period
            return null;
         }
      }
   }
=======
public Lock acquireLock(Object key, long timeout, TimeUnit unit) throws InterruptedException {
      while (true) {
         Lock lock = getLock(key);
         boolean locked = false;
         try {
            locked = lock.tryLock(timeout, unit);
         } catch (InterruptedException ie) {
            safeRelease(lock);
            throw ie;
         } catch (Throwable th) {
             locked = false;
         }
         if (locked) {
            // lock acquired.  Now check if it is the *correct* lock!
            Lock existingLock = locks.putIfAbsent(key, lock);
            if (existingLock != null && existingLock != lock) {
               // we have the wrong lock!  Unlock and retry.
               safeRelease(lock);
            } else {
               // we got the right lock.
               return lock;
            }
         } else {
            // we couldn't acquire the lock within the timeout period
            return null;
         }
      }
   }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930145516/fstmerge_var2_6841276038513736544

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/util/concurrent/locks/containers/AbstractPerEntryLockContainer.java
Conflict type: LineBasedMCFd
Conflict body: 
private boolean loadIfNeeded(InvocationContext ctx, Object key) throws Throwable {
      if (ctx.hasFlag(Flag.SKIP_CACHE_STORE) || ctx.hasFlag(Flag.SKIP_CACHE_LOAD)) {
         return false; //skip operation
      }
      // first check if the container contains the key we need.  Try and load this into the context.
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930152619/fstmerge_var1_8120623109418396490
      CacheEntry e = entryFactory.wrapEntryForReading(ctx, key);
      if (e == null || e.isNull()) {

         // Obtain a temporary lock to verify the key is not being concurrently added
         boolean keyLocked = entryFactory.acquireLock(ctx, key);
         boolean unlockOnWayOut = false;
         try {
            // check again, in case there is a concurrent addition
            if (dataContainer.containsKey(key)) {
               log.trace("No need to load.  Key exists in the data container.");
               unlockOnWayOut = true;
               return true;
            }
         } finally {
            if (keyLocked && unlockOnWayOut) {
               entryFactory.releaseLock(ctx, key);
            }
         }

         // we *may* need to load this.
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930152619/fstmerge_base_7592855585735966969
      CacheEntry e = entryFactory.wrapEntryForReading(ctx, key);
      if (e == null || e.isNull()) {

         // Obtain a temporary lock to verify the key is not being concurrently added
         boolean keyLocked = entryFactory.acquireLock(ctx, key);
         boolean unlockOnWayOut = false;
         try {
            // check again, in case there is a concurrent addition
            if (dataContainer.containsKey(key)) {
               log.trace("No need to load.  Key exists in the data container.");
               unlockOnWayOut = true;
               return true;
            }
         } finally {
            if (keyLocked && unlockOnWayOut) {
               entryFactory.releaseLock(key);
            }
         }

         // we *may* need to load this.
=======
      CacheEntry e = ctx.lookupEntry(key);
      if (e == null || e.isNull() || e.getValue() == null) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930152619/fstmerge_var2_4635660478195835817
         InternalCacheEntry loaded = loader.load(key);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930152619/fstmerge_var1_8120623109418396490
         if (loaded == null) {
            if (log.isTraceEnabled()) {
               log.trace("No need to load.  Key doesn't exist in the loader.");
            }
            if (keyLocked) {
               entryFactory.releaseLock(ctx, key);
            }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930152619/fstmerge_base_7592855585735966969
         if (loaded == null) {
            if (log.isTraceEnabled()) {
               log.trace("No need to load.  Key doesn't exist in the loader.");
            }
            if (keyLocked) {
               entryFactory.releaseLock(key);
            }
=======
         if (loaded != null) {
            MVCCEntry mvccEntry = entryFactory.wrapEntryForPut(ctx, key, loaded, false);
            recordLoadedEntry(ctx, key, mvccEntry, loaded);
            return true;
         } else {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930152619/fstmerge_var2_4635660478195835817
            return false;
         }
      } else {
         return true;
      }
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/interceptors/CacheLoaderInterceptor.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930153213/fstmerge_var1_6223984635291019856
private void cleanupLocks(InvocationContext ctx, boolean commit) {
      if (commit) {
         Object owner = ctx.getLockOwner();
         ReversibleOrderedSet<Map.Entry<Object, CacheEntry>> entries = ctx.getLookedUpEntries().entrySet();
         Iterator<Map.Entry<Object, CacheEntry>> it = entries.reverseIterator();
         if (trace) log.tracef("Number of entries in context: %s", entries.size());
         while (it.hasNext()) {
            Map.Entry<Object, CacheEntry> e = it.next();
            CacheEntry entry = e.getValue();
            Object key = e.getKey();
            boolean needToUnlock = lockManager.possiblyLocked(entry);
            // could be null with read-committed
            if (entry != null && entry.isChanged()) {
               commitEntry(entry, ctx.hasFlag(Flag.SKIP_OWNERSHIP_CHECK));
            } else {
               if (trace) log.tracef("Entry for key %s is null, not calling commitUpdate", key);
            }

            // and then unlock
            if (needToUnlock && !ctx.hasFlag(Flag.SKIP_LOCKING)) {
               if (trace) log.tracef("Releasing lock on [%s] for owner %s", key, owner);
               lockManager.unlock(ctx, key);
            }
         }
      } else {
         lockManager.releaseLocks(ctx);
      }
   }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930153213/fstmerge_base_6945304741807856212
private void cleanupLocks(InvocationContext ctx, boolean commit) {
      if (commit) {
         Object owner = ctx.getLockOwner();
         ReversibleOrderedSet<Map.Entry<Object, CacheEntry>> entries = ctx.getLookedUpEntries().entrySet();
         Iterator<Map.Entry<Object, CacheEntry>> it = entries.reverseIterator();
         if (trace) log.tracef("Number of entries in context: %s", entries.size());
         while (it.hasNext()) {
            Map.Entry<Object, CacheEntry> e = it.next();
            CacheEntry entry = e.getValue();
            Object key = e.getKey();
            boolean needToUnlock = lockManager.possiblyLocked(entry);
            // could be null with read-committed
            if (entry != null && entry.isChanged()) {
               commitEntry(entry, ctx.hasFlag(Flag.SKIP_OWNERSHIP_CHECK));
            } else {
               if (trace) log.tracef("Entry for key %s is null, not calling commitUpdate", key);
            }

            // and then unlock
            if (needToUnlock && !ctx.hasFlag(Flag.SKIP_LOCKING)) {
               if (trace) log.tracef("Releasing lock on [%s] for owner %s", key, owner);
               lockManager.unlock(key);
            }
         }
      } else {
         lockManager.releaseLocks(ctx);
      }
   }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930153213/fstmerge_var2_2475710850373238546

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/interceptors/LockingInterceptor.java
Conflict type: ModifierList
Conflict body: 
~~FSTMerge~~ @DefaultFactoryFor(classes = {CacheNotifier.class, EntryFactory.class, CommandsFactory.class,
        CacheLoaderManager.class, InvocationContextContainer.class, PassivationManager.class,
        BatchContainer.class, TransactionLog.class, EvictionManager.class, InvocationContextContainer.class,
        TransactionCoordinator.class, RecoveryAdminOperations.class, StateTransferLock.class})
public ##FSTMerge## @DefaultFactoryFor(classes = {CacheNotifier.class, EntryFactory.class, CommandsFactory.class,
        CacheLoaderManager.class, InvocationContextContainer.class, PassivationManager.class,
        BatchContainer.class, TransactionLog.class, EvictionManager.class, InvocationContextContainer.class,
        TransactionCoordinator.class, RecoveryAdminOperations.class})
public ##FSTMerge## @DefaultFactoryFor(classes = {CacheNotifier.class, EntryFactory.class, CommandsFactory.class,
        CacheLoaderManager.class, InvocationContextContainer.class, PassivationManager.class,
        BatchContainer.class, TransactionLog.class, EvictionManager.class, InvocationContextContainer.class,
        TransactionCoordinator.class, RecoveryAdminOperations.class, ClusteringDependentLogic.class})
public
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/factories/EmptyConstructorNamedCacheFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930155891/fstmerge_var1_422955045822578500
@Override
   public InvocationContext createInvocationContext(Transaction tx) {
      InvocationContext ctx;
      if (tx != null) {
         LocalTxInvocationContext localContext;
         localContext = new LocalTxInvocationContext();
         LocalTransaction localTransaction = transactionTable.getLocalTransaction(tx);
         localContext.setLocalTransaction(localTransaction);
         localContext.setTransaction(tx);
         ctx = localContext;
      } else {
         NonTxInvocationContext nonTxContext;
         nonTxContext = new NonTxInvocationContext();
         nonTxContext.setOriginLocal(true);
         ctx = nonTxContext;
      }
      ctxHolder.set(ctx);
      return ctx;
   }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930155891/fstmerge_base_3549716788168020787
@Override
   public InvocationContext createInvocationContext(Transaction tx) {
      InvocationContext existing = icTl.get();
      if (tx != null) {
         LocalTxInvocationContext localContext;
         if ((existing == null) || !(existing instanceof LocalTxInvocationContext)) {
            localContext = new LocalTxInvocationContext();
            icTl.set(localContext);
         } else {
            localContext = (LocalTxInvocationContext) existing;
         }
         LocalTransaction localTransaction = transactionTable.getLocalTransaction(tx);
         localContext.setLocalTransaction(localTransaction);
         localContext.setTransaction(tx);
         return localContext;
      } else {
         NonTxInvocationContext nonTxContext;
         if ((existing == null) || !(existing instanceof NonTxInvocationContext)) {
            nonTxContext = new NonTxInvocationContext();
            icTl.set(nonTxContext);
         } else {
            nonTxContext = (NonTxInvocationContext) existing;
         }
         nonTxContext.setOriginLocal(true);
         return nonTxContext;
      }
   }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930155891/fstmerge_var2_4127283403163825949

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/context/InvocationContextContainerImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930155895/fstmerge_var1_4202680313199732904
public LocalTxInvocationContext createTxInvocationContext() {
      LocalTxInvocationContext ctx = new LocalTxInvocationContext();
      ctxHolder.set(ctx);
      return ctx;
   }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930155895/fstmerge_base_1263502225549128172
public LocalTxInvocationContext createTxInvocationContext() {
      InvocationContext existing = icTl.get();
      if (existing != null && existing instanceof LocalTxInvocationContext) {
         return (LocalTxInvocationContext) existing;
      }
      LocalTxInvocationContext localTxContext = new LocalTxInvocationContext();
      icTl.set(localTxContext);
      return localTxContext;
   }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930155895/fstmerge_var2_3524660693028083005

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/context/InvocationContextContainerImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930155899/fstmerge_var1_440180603938592990
public RemoteTxInvocationContext createRemoteTxInvocationContext(Address origin) {
      RemoteTxInvocationContext ctx = new RemoteTxInvocationContext();
      ctx.setOrigin(origin);
      ctxHolder.set(ctx);
      return ctx;
   }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930155899/fstmerge_base_5140375070283448627
public RemoteTxInvocationContext createRemoteTxInvocationContext(Address origin) {
      InvocationContext existing = icTl.get();
      if (existing != null && existing instanceof RemoteTxInvocationContext) {
         return (RemoteTxInvocationContext) existing;
      }
      RemoteTxInvocationContext remoteTxContext = new RemoteTxInvocationContext();
      icTl.set(remoteTxContext);
      remoteTxContext.setOrigin(origin);
      return remoteTxContext;
   }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930155899/fstmerge_var2_6260986620353242260

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/context/InvocationContextContainerImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930155903/fstmerge_var1_4201348788013001745
public NonTxInvocationContext createNonTxInvocationContext() {
      NonTxInvocationContext ctx = new NonTxInvocationContext();
      ctxHolder.set(ctx);
      return ctx;
   }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930155903/fstmerge_base_2979215129090854600
public NonTxInvocationContext createNonTxInvocationContext() {
      InvocationContext existing = icTl.get();
      if (existing != null && existing instanceof NonTxInvocationContext) {
         NonTxInvocationContext context = (NonTxInvocationContext) existing;
         context.setOriginLocal(true);
         return context;
      }
      NonTxInvocationContext remoteTxContext = new NonTxInvocationContext();
      icTl.set(remoteTxContext);
      return remoteTxContext;
   }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930155903/fstmerge_var2_7464119188470522721

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/context/InvocationContextContainerImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930155907/fstmerge_var1_2441269822053609197
@Override
   public InvocationContext createRemoteInvocationContextForCommand(VisitableCommand cacheCommand, Address origin) {
      InvocationContext context = createRemoteInvocationContext(origin);
      if (cacheCommand != null && cacheCommand instanceof FlagAffectedCommand) {
         FlagAffectedCommand command = (FlagAffectedCommand) cacheCommand;
         Set<Flag> flags = command.getFlags();
         if (flags != null && !flags.isEmpty()) {
            context = new InvocationContextFlagsOverride(context, flags);
            ctxHolder.set(context);
         }
      }
      return context;
   }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930155907/fstmerge_base_2715952765491791725
@Override
   public InvocationContext createRemoteInvocationContextForCommand(VisitableCommand cacheCommand, Address origin) {
      InvocationContext context = createRemoteInvocationContext(origin);
      if (cacheCommand != null && cacheCommand instanceof FlagAffectedCommand) {
         FlagAffectedCommand command = (FlagAffectedCommand) cacheCommand;
         Set<Flag> flags = command.getFlags();
         if (flags != null && !flags.isEmpty()) {
            return new InvocationContextFlagsOverride(context, flags);
         }
      }
      return context;
   }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930155907/fstmerge_var2_339446054598783461

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/context/InvocationContextContainerImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930155911/fstmerge_var1_9047997153922282077
public NonTxInvocationContext createRemoteInvocationContext(Address origin) {
      NonTxInvocationContext remoteNonTxContext = new NonTxInvocationContext();
      remoteNonTxContext.setOriginLocal(false);
      remoteNonTxContext.setOrigin(origin);
      ctxHolder.set(remoteNonTxContext);
      return remoteNonTxContext;
   }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930155911/fstmerge_base_8272660281881527228
public NonTxInvocationContext createRemoteInvocationContext(Address origin) {
      InvocationContext existing = icTl.get();
      if (existing != null && existing instanceof NonTxInvocationContext) {
         NonTxInvocationContext context = (NonTxInvocationContext) existing;
         context.setOriginLocal(false);
         context.setOrigin(origin);
         return context;
      }
      NonTxInvocationContext remoteNonTxContext = new NonTxInvocationContext();
      remoteNonTxContext.setOriginLocal(false);
      remoteNonTxContext.setOrigin(origin);
      icTl.set(remoteNonTxContext);
      return remoteNonTxContext;
   }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930155911/fstmerge_var2_8348192227929891393

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/context/InvocationContextContainerImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930156154/fstmerge_var1_138329845150020602
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930156154/fstmerge_base_9065721310900973775
private Map<Object, InternalCacheValue> applyStateMap(Map<Object, InternalCacheValue> state, boolean withRetry) {
      Map<Object, InternalCacheValue> retry = withRetry ? new HashMap<Object, InternalCacheValue>() : null;

      for (Map.Entry<Object, InternalCacheValue> e : state.entrySet()) {
         InternalCacheValue v = e.getValue();
         InvocationContext ctx = icc.createInvocationContext();
         // locking not necessary in the case of a join since the node isn't doing anything else
         // TODO what if the node is already running?
         ctx.setFlags(CACHE_MODE_LOCAL, SKIP_CACHE_LOAD, SKIP_REMOTE_LOOKUP, SKIP_SHARED_CACHE_STORE, SKIP_LOCKING,
                      SKIP_OWNERSHIP_CHECK);
         try {
            PutKeyValueCommand put = cf.buildPutKeyValueCommand(e.getKey(), v.getValue(), v.getLifespan(), v.getMaxIdle(), ctx.getFlags());
            interceptorChain.invoke(ctx, put);
         } catch (Exception ee) {
            if (withRetry) {
               if (trace)
                  log.tracef("Problem %s encountered when applying state for key %s. Adding entry to retry queue.", ee.getMessage(), e.getKey());
               retry.put(e.getKey(), e.getValue());
            } else {
               log.problemApplyingStateForKey(ee.getMessage(), e.getKey());
            }
         }
      }
      return retry;
   }
=======
private Map<Object, InternalCacheValue> applyStateMap(Map<Object, InternalCacheValue> state, boolean withRetry) {
      Map<Object, InternalCacheValue> retry = withRetry ? new HashMap<Object, InternalCacheValue>() : null;

      for (Map.Entry<Object, InternalCacheValue> e : state.entrySet()) {
         InternalCacheValue v = e.getValue();
         NonTxInvocationContext ctx = (NonTxInvocationContext) icc.createInvocationContext(false);
         // locking not necessary in the case of a join since the node isn't doing anything else
         // TODO what if the node is already running?
         ctx.setFlags(CACHE_MODE_LOCAL, SKIP_CACHE_LOAD, SKIP_REMOTE_LOOKUP, SKIP_SHARED_CACHE_STORE, SKIP_LOCKING,
                      SKIP_OWNERSHIP_CHECK);
         try {
            PutKeyValueCommand put = cf.buildPutKeyValueCommand(e.getKey(), v.getValue(), v.getLifespan(), v.getMaxIdle(), ctx.getFlags());
            interceptorChain.invoke(ctx, put);
         } catch (Exception ee) {
            if (withRetry) {
               if (trace)
                  log.tracef("Problem %s encountered when applying state for key %s. Adding entry to retry queue.", ee.getMessage(), e.getKey());
               retry.put(e.getKey(), e.getValue());
            } else {
               log.problemApplyingStateForKey(ee.getMessage(), e.getKey());
            }
         }
      }
      return retry;
   }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930156154/fstmerge_var2_6784013048184253192

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/distribution/DistributionManagerImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930156198/fstmerge_var1_3594352101715251405
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930156198/fstmerge_base_5861452720452639885
public void applyRemoteTxLog(List<WriteCommand> commands) {
      for (WriteCommand cmd : commands) {
         try {
            // this is a remotely originating tx
            cf.initializeReplicableCommand(cmd, true);
            InvocationContext ctx = icc.createInvocationContext();
            ctx.setFlags(SKIP_REMOTE_LOOKUP, CACHE_MODE_LOCAL, SKIP_SHARED_CACHE_STORE, SKIP_LOCKING);
            interceptorChain.invoke(ctx, cmd);
         } catch (Exception e) {
            log.exceptionWhenReplaying(cmd, e);
         }
      }

   }
=======
public void applyRemoteTxLog(List<WriteCommand> commands) {
      for (WriteCommand cmd : commands) {
         try {
            // this is a remotely originating tx
            cf.initializeReplicableCommand(cmd, true);
            InvocationContext ctx = icc.createInvocationContext(true);
            ctx.setFlags(SKIP_REMOTE_LOOKUP, CACHE_MODE_LOCAL, SKIP_SHARED_CACHE_STORE, SKIP_LOCKING);
            interceptorChain.invoke(ctx, cmd);
         } catch (Exception e) {
            log.exceptionWhenReplaying(cmd, e);
         }
      }

   }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930156198/fstmerge_var2_8300422710685588567

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/main/java/org/infinispan/distribution/DistributionManagerImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
@BeforeMethod
   public void setUp() {
      n = new CacheNotifierImpl();
      mockCache = createNiceMock(Cache.class);
      EasyMock.replay(mockCache);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930162316/fstmerge_var1_3370424226562862153
      n.injectDependencies(mockCache);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930162316/fstmerge_base_8904645190526764979
      InvocationContextContainer icc = new InvocationContextContainerImpl();
      n.injectDependencies(icc, mockCache);
=======
      InvocationContextContainer icc = new NonTransactionalInvocationContextContainer();
      n.injectDependencies(icc, mockCache);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930162316/fstmerge_var2_2008111154648995916
      cl = new CacheListener();
      n.start();
      n.addListener(cl);
      ctx = new NonTxInvocationContext();
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/test/java/org/infinispan/notifications/cachelistener/CacheNotifierImplTest.java
Conflict type: LineBasedMCFd
Conflict body: 
public void doTest() throws Throwable {
      cache.put(k, "value"); // init value

      assertNotLocked(cache, k);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930162814/fstmerge_var1_1611862140799283021
      InvocationContextContainerImpl icc = (InvocationContextContainerImpl) TestingUtil.extractComponent(cache, InvocationContextContainer.class);
      InvocationContext ctx = icc.getInvocationContext(true);
      LockManager lockManager = TestingUtil.extractComponent(cache, LockManager.class);
      lockManager.lockAndRecord(k, ctx);
      ctx.putLookedUpEntry(k, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930162814/fstmerge_base_4190365740075408801
      InvocationContextContainerImpl icc = (InvocationContextContainerImpl) TestingUtil.extractComponent(cache, InvocationContextContainer.class);
      InvocationContext ctx = icc.getInvocationContext();
      LockManager lockManager = TestingUtil.extractComponent(cache, LockManager.class);
      lockManager.lockAndRecord(k, ctx);
      ctx.putLookedUpEntry(k, null);
=======
//      InvocationContextContainerImpl icc = (InvocationContextContainerImpl) TestingUtil.extractComponent(cache, InvocationContextContainer.class);
//      InvocationContext ctx = icc.getInvocationContext();
//      LockManager lockManager = TestingUtil.extractComponent(cache, LockManager.class);
//      lockManager.lockAndRecord(k, ctx);
//      ctx.putLookedUpEntry(k, null);

      DummyTransactionManager dtm = (DummyTransactionManager) tm();
      tm().begin();
      cache.put(k, "some");
      final DummyTransaction transaction = dtm.getTransaction();
      transaction.runPrepare();
      tm().suspend();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930162814/fstmerge_var2_3735956243998027217

      // test that the key is indeed locked.
      assertLocked(cache, k);
      final CountDownLatch txStartedLatch = new CountDownLatch(1);

      TxThread transactionThread = new TxThread(cache, txStartedLatch);

      transactionThread.start();
      txStartedLatch.countDown();
      Thread.sleep(500); // in case the thread needs some time to get to the locking code

      // now abort the tx.
      transactionThread.tm.resume(transactionThread.tx);
      transactionThread.tm.rollback();

      // now release the lock
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930162814/fstmerge_var1_1611862140799283021
      lockManager.releaseLocks(ctx);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930162814/fstmerge_base_4190365740075408801
      icc.resume(ctx);
      lockManager.releaseLocks(ctx);
=======
      tm().resume(transaction);
      transaction.runRollback();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930162814/fstmerge_var2_3735956243998027217
      transactionThread.join();

      assertNotLocked(cache, k);
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/test/java/org/infinispan/tx/StaleLockAfterTxAbortTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930164148/fstmerge_var1_2183377771228965875
public void testDeadlockDetectedOneTx() throws Exception {
      t1.setKeyValue("key", "value1");

      LockManager lm2 = TestingUtil.extractComponent(cache(1), LockManager.class);
      NonTxInvocationContext ctx = cache(1).getAdvancedCache().getInvocationContextContainer().createNonTxInvocationContext();
      lm2.lockAndRecord("key", ctx);
      assert lm2.isLocked("key");


      assert PerCacheExecutorThread.OperationsResult.BEGGIN_TX_OK == t1.execute(PerCacheExecutorThread.Operations.BEGGIN_TX) : "but received " + t1.lastResponse();
      t1.execute(PerCacheExecutorThread.Operations.PUT_KEY_VALUE);

      t1.clearResponse();
      t1.executeNoResponse(PerCacheExecutorThread.Operations.COMMIT_TX);

      replicationLatch.countDown();
      System.out.println("Now replication is triggered");

      t1.waitForResponse();


      Object t1CommitRsp = t1.lastResponse();

      assert t1CommitRsp instanceof Exception : "expected exception, received " + t1.lastResponse();

      LockManager lm1 = TestingUtil.extractComponent(cache(0), LockManager.class);
      assert !lm1.isLocked("key") : "It is locked by " + lm1.getOwner("key");

      lm2.unlock(ctx, "key");
      assert !lm2.isLocked("key");
      assert !lm1.isLocked("key");
   }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930164148/fstmerge_base_427673385600478715
public void testDeadlockDetectedOneTx() throws Exception {
      t1.setKeyValue("key", "value1");

      LockManager lm2 = TestingUtil.extractComponent(cache(1), LockManager.class);
      NonTxInvocationContext ctx = cache(1).getAdvancedCache().getInvocationContextContainer().createNonTxInvocationContext();
      lm2.lockAndRecord("key", ctx);
      assert lm2.isLocked("key");


      assert PerCacheExecutorThread.OperationsResult.BEGGIN_TX_OK == t1.execute(PerCacheExecutorThread.Operations.BEGGIN_TX) : "but received " + t1.lastResponse();
      t1.execute(PerCacheExecutorThread.Operations.PUT_KEY_VALUE);

      t1.clearResponse();
      t1.executeNoResponse(PerCacheExecutorThread.Operations.COMMIT_TX);

      replicationLatch.countDown();
      System.out.println("Now replication is triggered");

      t1.waitForResponse();


      Object t1CommitRsp = t1.lastResponse();

      assert t1CommitRsp instanceof Exception : "expected exception, received " + t1.lastResponse();

      LockManager lm1 = TestingUtil.extractComponent(cache(0), LockManager.class);
      assert !lm1.isLocked("key") : "It is locked by " + lm1.getOwner("key");

      lm2.unlock("key");
      assert !lm2.isLocked("key");
      assert !lm1.isLocked("key");
   }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930164148/fstmerge_var2_3975938850650032103

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/test/java/org/infinispan/tx/dld/DldLazyLockingReplicationTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930164158/fstmerge_var1_4812847944525855397
public void testLockReleasedWhileTryingToAcquire() throws Exception {
      t1.setKeyValue("key", "value1");

      LockManager lm2 = TestingUtil.extractComponent(cache(1), LockManager.class);
      NonTxInvocationContext ctx = cache(1).getAdvancedCache().getInvocationContextContainer().createNonTxInvocationContext();
      lm2.lockAndRecord("key", ctx);
      assert lm2.isLocked("key");


      assert PerCacheExecutorThread.OperationsResult.BEGGIN_TX_OK == t1.execute(PerCacheExecutorThread.Operations.BEGGIN_TX) : "but received " + t1.lastResponse();
      t1.execute(PerCacheExecutorThread.Operations.PUT_KEY_VALUE);

      t1.clearResponse();
      t1.executeNoResponse(PerCacheExecutorThread.Operations.COMMIT_TX);

      replicationLatch.countDown();

      Thread.sleep(3000); //just to make sure the remote tx thread managed to spin around for some times.
      lm2.unlock(ctx, "key");

      t1.waitForResponse();


      Object t1CommitRsp = t1.lastResponse();

      assert t1CommitRsp == PerCacheExecutorThread.OperationsResult.COMMIT_TX_OK : "expected true, received " + t1.lastResponse();

      LockManager lm1 = TestingUtil.extractComponent(cache(0), LockManager.class);
      assert !lm1.isLocked("key") : "It is locked by " + lm1.getOwner("key");

      assert !lm2.isLocked("key");
      assert !lm1.isLocked("key");
   }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930164158/fstmerge_base_8484731372123594196
public void testLockReleasedWhileTryingToAcquire() throws Exception {
      t1.setKeyValue("key", "value1");

      LockManager lm2 = TestingUtil.extractComponent(cache(1), LockManager.class);
      NonTxInvocationContext ctx = cache(1).getAdvancedCache().getInvocationContextContainer().createNonTxInvocationContext();
      lm2.lockAndRecord("key", ctx);
      assert lm2.isLocked("key");


      assert PerCacheExecutorThread.OperationsResult.BEGGIN_TX_OK == t1.execute(PerCacheExecutorThread.Operations.BEGGIN_TX) : "but received " + t1.lastResponse();
      t1.execute(PerCacheExecutorThread.Operations.PUT_KEY_VALUE);

      t1.clearResponse();
      t1.executeNoResponse(PerCacheExecutorThread.Operations.COMMIT_TX);

      replicationLatch.countDown();

      Thread.sleep(3000); //just to make sure the remote tx thread managed to spin around for some times.
      lm2.unlock("key");

      t1.waitForResponse();


      Object t1CommitRsp = t1.lastResponse();

      assert t1CommitRsp == PerCacheExecutorThread.OperationsResult.COMMIT_TX_OK : "expected true, received " + t1.lastResponse();

      LockManager lm1 = TestingUtil.extractComponent(cache(0), LockManager.class);
      assert !lm1.isLocked("key") : "It is locked by " + lm1.getOwner("key");

      assert !lm2.isLocked("key");
      assert !lm1.isLocked("key");
   }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930164158/fstmerge_var2_3644078449022169801

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/test/java/org/infinispan/tx/dld/DldLazyLockingReplicationTest.java
Conflict type: LineBasedMCFd
Conflict body: 
protected EmbeddedCacheManager addClusterEnabledCacheManager(Configuration defaultConfig) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930164376/fstmerge_var1_7047591148965512534
      return addClusterEnabledCacheManager(defaultConfig, new TransportFlags());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930164376/fstmerge_base_2503538976911984241
      return addClusterEnabledCacheManager(defaultConfig, false);
=======
      EmbeddedCacheManager cm = TestCacheManagerFactory.createClusteredCacheManager(defaultConfig);
      cacheManagers.add(cm);
      return cm;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930164376/fstmerge_var2_682711566564917386
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/test/java/org/infinispan/test/MultipleCacheManagersTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930164537/fstmerge_var1_1094296813079259174
protected EmbeddedCacheManager addClusterEnabledCacheManager(Configuration defaultConfig, boolean transactional) {
      return addClusterEnabledCacheManager(defaultConfig, transactional, new TransportFlags());
   }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930164537/fstmerge_base_9115651551459802096
protected EmbeddedCacheManager addClusterEnabledCacheManager(Configuration defaultConfig, boolean transactional) {
      EmbeddedCacheManager cm = TestCacheManagerFactory.createClusteredCacheManager(defaultConfig, transactional);
      cacheManagers.add(cm);
      return cm;
   }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930164537/fstmerge_var2_2637205968523888655

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/test/java/org/infinispan/test/MultipleCacheManagersTest.java
Conflict type: LineBasedMCFd
Conflict body: 
public static Configuration getDefaultClusteredConfig(Configuration.CacheMode mode, boolean transactional) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930165210/fstmerge_var1_3378497642286109729
      return TestCacheManagerFactory.getDefaultConfiguration(transactional).fluent()
         .mode(mode)
         .clustering()
            .sync()
               .stateRetrieval().fetchInMemoryState(false)
            .transaction().syncCommitPhase(true).syncRollbackPhase(true)
         .build();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930165210/fstmerge_base_6046142458130069605
      Configuration configuration = TestCacheManagerFactory.getDefaultConfiguration(transactional);
      configuration.setCacheMode(mode);
      configuration.setSyncCommitPhase(true);
      configuration.setSyncRollbackPhase(true);
      configuration.setFetchInMemoryState(false);
      return configuration;
=======
      Configuration configuration = TestCacheManagerFactory.getDefaultConfiguration(transactional);
      configuration.fluent().transaction().cacheStopTimeout(0);
      configuration.setCacheMode(mode);
      configuration.setSyncCommitPhase(true);
      configuration.setSyncRollbackPhase(true);
      configuration.setFetchInMemoryState(false);
      return configuration;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930165210/fstmerge_var2_6878401129988462750
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/test/java/org/infinispan/test/AbstractCacheTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930165715/fstmerge_var1_7638749683560918910
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930165715/fstmerge_base_5292736445352899413
public static EmbeddedCacheManager createClusteredCacheManager(boolean withFD) {
      return createClusteredCacheManager(withFD, new Configuration(), false);
   }
=======
public static EmbeddedCacheManager createClusteredCacheManager(boolean withFD) {
      return createClusteredCacheManager(withFD, new Configuration());
   }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930165715/fstmerge_var2_7070825304577537913

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/test/java/org/infinispan/test/fwk/TestCacheManagerFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930165863/fstmerge_var1_8374937458545542751
public static EmbeddedCacheManager createClusteredCacheManager(Configuration defaultCacheConfig, boolean transactional) {
      return createClusteredCacheManager(defaultCacheConfig, transactional, new TransportFlags());
   }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930165863/fstmerge_base_9066351463868920735
public static EmbeddedCacheManager createClusteredCacheManager(Configuration defaultCacheConfig, boolean transactional) {
      return createClusteredCacheManager(false, defaultCacheConfig, transactional);
   }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930165863/fstmerge_var2_885122159029154191

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/test/java/org/infinispan/test/fwk/TestCacheManagerFactory.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930171155/fstmerge_var1_6947519482663957680
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930171155/fstmerge_base_7615196742061364078
@Override
   protected EmbeddedCacheManager addClusterEnabledCacheManager(boolean withFD) {
      Configuration cfg = new Configuration();
      CacheLoaderManagerConfig clmc = new CacheLoaderManagerConfig();
      clmc.setShared(shared);
      int idToUse = shared ? 999 : id++;
      clmc.addCacheLoaderConfig(new DummyInMemoryCacheStore.Cfg(getClass().getSimpleName() + "_" + idToUse));
      cfg.setCacheLoaderManagerConfig(clmc);
      EmbeddedCacheManager cm = TestCacheManagerFactory.createClusteredCacheManager(withFD, cfg, false);
      cacheManagers.add(cm);
      return cm;
   }
=======
@Override
   protected EmbeddedCacheManager addClusterEnabledCacheManager(boolean withFD) {
      Configuration cfg = new Configuration();
      CacheLoaderManagerConfig clmc = new CacheLoaderManagerConfig();
      clmc.setShared(shared);
      int idToUse = shared ? 999 : id++;
      clmc.addCacheLoaderConfig(new DummyInMemoryCacheStore.Cfg(getClass().getSimpleName() + "_" + idToUse));
      cfg.setCacheLoaderManagerConfig(clmc);
      EmbeddedCacheManager cm = TestCacheManagerFactory.createClusteredCacheManager(withFD, cfg);
      cacheManagers.add(cm);
      return cm;
   }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930171155/fstmerge_var2_3591720495936102859

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/core/src/test/java/org/infinispan/distribution/BaseDistCacheStoreTest.java
Conflict type: LineBasedMCFd
Conflict body: 
protected EmbeddedCacheManager createCacheManager() throws Exception {
      Configuration c = getDefaultStandaloneConfig(true);
      c.fluent()
         .indexing()
         .indexLocalOnly(false)
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930182283/fstmerge_var1_967516262047850151
         .addProperty("hibernate.search.default.directory_provider", "ram")
         .addProperty("hibernate.search.lucene_version", "LUCENE_CURRENT");
      return TestCacheManagerFactory.createCacheManager(c, true);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930182283/fstmerge_base_7495244788406552705
         .addProperty("hibernate.search.default.directory_provider", "ram");
      return TestCacheManagerFactory.createCacheManager(c, true);
=======
         .addProperty("hibernate.search.default.directory_provider", "ram");
      return TestCacheManagerFactory.createCacheManager(c);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930182283/fstmerge_var2_9186499440911641379
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_a2154_744e9/rev_a2154-744e9/query/src/test/java/org/infinispan/query/indexedembedded/CollectionsIndexingTest.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_f95e9_3dd8d/rev_f95e9-3dd8d.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@SuppressWarnings("unchecked")
   NotifyingFuture<V> getAsync(final K key, final EnumSet<Flag> explicitFlags, final ClassLoader explicitClassLoader) {
      final Transaction tx = getOngoingTransaction();
      final NotifyingNotifiableFuture f = new DeferredReturnFuture();

      // Optimization to not start a new thread only when the operation is cheap:
      if (asyncSkipsThread(explicitFlags, key)) {
         return wrapInFuture(get(key));
      } else {
         // Make sure the flags are cleared
         final EnumSet<Flag> appliedFlags;
         if (explicitFlags == null) {
            appliedFlags = null;
         } else {
            appliedFlags = explicitFlags.clone();
            explicitFlags.clear();
         }
         Callable<V> c = new Callable<V>() {
            @Override
            public V call() throws Exception {
               assertKeyNotNull(key);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930463303/fstmerge_var1_1655323721689003675
               InvocationContext ctx = getInvocationContext(tx, appliedFlags, explicitClassLoader);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930463303/fstmerge_base_6134498332671510027
               InvocationContext ctx = getInvocationContext(tx, explicitFlags, explicitClassLoader);
               if (appliedFlags != null)
                  ctx.setFlags(appliedFlags);

=======
               InvocationContext ctx = getInvocationContextForRead(tx, explicitFlags, explicitClassLoader);
               if (appliedFlags != null)
                  ctx.setFlags(appliedFlags);

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930463303/fstmerge_var2_7724380258916499264
               GetKeyValueCommand command = commandsFactory.buildGetKeyValueCommand(key, appliedFlags);
               Object ret = invoker.invoke(ctx, command);
               f.notifyDone();
               return (V) ret;
            }
         };
         f.setNetworkFuture(asyncExecutor.submit(c));
         return f;
      }
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_f95e9_3dd8d/rev_f95e9-3dd8d/core/src/main/java/org/infinispan/CacheImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
@Stop
   public void stop() {
      if (loader != null) {
         try {
            CacheStore store = getCacheStore();
            if (store != null) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930470717/fstmerge_var1_5922221724940831326
               InvocationContext ctx = icc.getInvocationContext(true);
               if (ctx != null && ctx.hasFlag(REMOVE_DATA_ON_STOP)) {
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930470717/fstmerge_base_3191045138139984343
               InvocationContext ctx = icc.createInvocationContext();
               if (ctx.hasFlag(REMOVE_DATA_ON_STOP)) {
=======
               InvocationContext ctx = icc.createNonTxInvocationContext();
               if (ctx.hasFlag(REMOVE_DATA_ON_STOP)) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930470717/fstmerge_var2_681125331887208239
                  if (log.isTraceEnabled()) log.trace("Requested removal of data on stop, so clear cache store");
                  store.clear();
               }
            }
            loader.stop();
         } catch (CacheLoaderException e) {
            throw new CacheException(e);
         } finally {
            loader = null;
         }
      }
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_f95e9_3dd8d/rev_f95e9-3dd8d/core/src/main/java/org/infinispan/loaders/CacheLoaderManagerImpl.java
Conflict type: LineBasedMCFd
Conflict body: 
public static Configuration getDefaultClusteredConfig(Configuration.CacheMode mode, boolean transactional) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930498562/fstmerge_var1_2555321663002604854
      if (mode.isSynchronous()) {
         return TestCacheManagerFactory.getDefaultConfiguration(transactional).fluent()
            .mode(mode)
            .clustering()
               .sync()
                  .stateRetrieval().fetchInMemoryState(false)
               .transaction().syncCommitPhase(true).syncRollbackPhase(true)
            .build();
      } else {
         return TestCacheManagerFactory.getDefaultConfiguration(transactional).fluent()
            .mode(mode)
            .clustering()
               .async()
                  .stateRetrieval().fetchInMemoryState(false)
               .transaction().syncCommitPhase(true).syncRollbackPhase(true)
            .build();
      }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930498562/fstmerge_base_796058094292001871
      return TestCacheManagerFactory.getDefaultConfiguration(transactional).fluent()
         .mode(mode)
         .clustering()
            .sync()
               .stateRetrieval().fetchInMemoryState(false)
            .transaction().syncCommitPhase(true).syncRollbackPhase(true)
         .build();
=======
      return TestCacheManagerFactory.getDefaultConfiguration(transactional).fluent()
         .mode(mode)
         .clustering()
            .sync()
               .stateRetrieval().fetchInMemoryState(false)
            .transaction().syncCommitPhase(true).syncRollbackPhase(true)
               .cacheStopTimeout(0)
         .build();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930498562/fstmerge_var2_4103857336807671817
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_f95e9_3dd8d/rev_f95e9-3dd8d/core/src/test/java/org/infinispan/test/AbstractCacheTest.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_9284d_166ec/rev_9284d-166ec.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@Override
   protected EmbeddedCacheManager createCacheManager() throws Exception {
      Configuration c = getDefaultClusteredConfig(LOCAL, true);
      c.fluent()
         .indexing()
         .indexLocalOnly(false)
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930849119/fstmerge_var1_4482984447785285856
         .addProperty("hibernate.search.default.directory_provider", "ram")
         .addProperty("hibernate.search.lucene_version", "LUCENE_CURRENT");
      cacheManager = TestCacheManagerFactory.createCacheManager(c, true);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930849119/fstmerge_base_792950934311325537
         .addProperty("hibernate.search.default.directory_provider", "ram");
      cacheManager = TestCacheManagerFactory.createCacheManager(c, true);
=======
         .addProperty("hibernate.search.default.directory_provider", "ram");
      cacheManager = TestCacheManagerFactory.createCacheManager(c);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418930849119/fstmerge_var2_925923249844736532

      person1 = new Person();
      person1.setName("Navin");
      person1.setBlurb("Owns a macbook");
      person1.setAge(20);
      return cacheManager;
   }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_9284d_166ec/rev_9284d-166ec/query/src/test/java/org/infinispan/query/blackbox/KeyTypeTest.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_c91fe_92913/rev_c91fe-92913.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_b52dc_577ea/rev_b52dc-577ea.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_5a92c_92a47/rev_5a92c-92a47.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/infinispan/revisions/rev_72f92_50dc4/rev_72f92-50dc4.revisions

==================================================================================================================
