=========================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_ca1ef_4a57f/rev_ca1ef-4a57f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_4a929_7b78d/rev_4a929-7b78d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_c2714_79daa/rev_c2714-79daa.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_4528b_9f863/rev_4528b-9f863.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_d9870_bcf99/rev_d9870-bcf99.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_b8b54_730c1/rev_b8b54-730c1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_77173_68d87/rev_77173-68d87.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_6dc43_72e9d/rev_6dc43-72e9d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_05381_756ee/rev_05381-756ee.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_07103_1ea4d/rev_07103-1ea4d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_64ce1_518e8/rev_64ce1-518e8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_73f15_2fda9/rev_73f15-2fda9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_30d45_5147a/rev_30d45-5147a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_6d8c1_8acf8/rev_6d8c1-8acf8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_0088d_b6b31/rev_0088d-b6b31.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_29aab_5b402/rev_29aab-5b402.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_5b402_29aab/rev_5b402-29aab.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_2d756_d7505/rev_2d756-d7505.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_bac85_eb504/rev_bac85-eb504.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f2a19_e3b82/rev_f2a19-e3b82.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_eb504_bac85/rev_eb504-bac85.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_20cfc_83732/rev_20cfc-83732.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_83732_20cfc/rev_83732-20cfc.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_35355_9b8e7/rev_35355-9b8e7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_6f647_4b572/rev_6f647-4b572.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_3a94c_dfaa3/rev_3a94c-dfaa3.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@RequestMapping(value = "applications/{applicationName}/services/{serviceName}/timeout/{timeoutInMinutes}/undeploy", method = RequestMethod.DELETE)
	public @ResponseBody
	Map<String, Object> undeploy(@PathVariable final String applicationName,
			@PathVariable final String serviceName,
			@PathVariable final int timeoutInMinutes) {
		final String absolutePuName = ServiceUtils.getAbsolutePUName(
				applicationName, serviceName);
		final ProcessingUnit processingUnit = admin.getProcessingUnits()
				.waitFor(absolutePuName, PU_DISCOVERY_TIMEOUT_SEC,
						TimeUnit.SECONDS);
		if (processingUnit == null) {
			return unavailableServiceError(absolutePuName);
		}

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418610154920/fstmerge_var1_3625046137177664557
		FutureTask<Boolean> undeployTask = new FutureTask<Boolean>(  
				new Callable<Boolean>() {  
					public Boolean call() throws Exception {  
						return processingUnit.undeployAndWait(timeoutInMinutes, TimeUnit.MINUTES);
					}  

				});
		undeployTask.run();
		final UUID lifecycleEventContainerID =
				startPollingForServiceUninstallLifecycleEvents(applicationName, serviceName,
						timeoutInMinutes, undeployTask);
		
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418610154920/fstmerge_base_6935689381288079578
		logger.log(Level.INFO, "Starting to poll for uninstall lifecycle events.");
		final UUID lifecycleEventContainerID =
				startPollingForServiceUninstallLifecycleEvents(applicationName, serviceName, timeoutInMinutes);
		processingUnit.undeploy();
=======
		logger.log(Level.INFO,
				"Starting to poll for uninstall lifecycle events.");
		final UUID lifecycleEventContainerID = startPollingForServiceUninstallLifecycleEvents(
				applicationName, serviceName, timeoutInMinutes);
		processingUnit.undeploy();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418610154920/fstmerge_var2_633672171630455684
		final Map<String, Object> returnMap = new HashMap<String, Object>();
		returnMap.put(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID,
				lifecycleEventContainerID);
		return successStatus(returnMap);
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_3a94c_dfaa3/rev_3a94c-dfaa3/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418610154937/fstmerge_var1_2525023580625746350
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418610154937/fstmerge_base_8784416125044505188
private UUID startPollingForServiceUninstallLifecycleEvents(final String applicationName, final String serviceName,
			final int timeoutInMinutes) {
		RestPollingRunnable restPollingRunnable;
		final LifecycleEventsContainer lifecycleEventsContainer = new LifecycleEventsContainer();
		final UUID lifecycleEventsContainerID = UUID.randomUUID();
		lifecycleEventsContainer.setEventsSet(this.eventsSet);

		restPollingRunnable = new RestPollingRunnable(applicationName, timeoutInMinutes, TimeUnit.MINUTES);
		restPollingRunnable.addService(serviceName, 0);
		restPollingRunnable.setIsServiceInstall(false);
		restPollingRunnable.setAdmin(admin);
		restPollingRunnable.setLifecycleEventsContainer(lifecycleEventsContainer);
		restPollingRunnable.setIsUninstall(true);
		restPollingRunnable.setEndTime(timeoutInMinutes, TimeUnit.MINUTES);

		final ScheduledFuture<?> scheduleWithFixedDelay =
				scheduledExecutor.scheduleWithFixedDelay(restPollingRunnable, 0, LIFECYCLE_EVENT_POLLING_INTERVAL_SEC,
						TimeUnit.SECONDS);
		restPollingRunnable.setFutureTask(scheduleWithFixedDelay);
		this.lifecyclePollingThreadContainer.put(lifecycleEventsContainerID, restPollingRunnable);
		logger.log(Level.INFO, "polling container UUID is " + lifecycleEventsContainerID.toString());
		return lifecycleEventsContainerID;
	}
=======
private UUID startPollingForServiceUninstallLifecycleEvents(
			final String applicationName, final String serviceName,
			final int timeoutInMinutes) {
		RestPollingRunnable restPollingRunnable;
		final LifecycleEventsContainer lifecycleEventsContainer = new LifecycleEventsContainer();
		final UUID lifecycleEventsContainerID = UUID.randomUUID();
		lifecycleEventsContainer.setEventsSet(this.eventsSet);

		restPollingRunnable = new RestPollingRunnable(applicationName,
				timeoutInMinutes, TimeUnit.MINUTES);
		restPollingRunnable.addService(serviceName, 0);
		restPollingRunnable.setIsServiceInstall(false);
		restPollingRunnable.setAdmin(admin);
		restPollingRunnable
				.setLifecycleEventsContainer(lifecycleEventsContainer);
		restPollingRunnable.setIsUninstall(true);
		restPollingRunnable.setEndTime(timeoutInMinutes, TimeUnit.MINUTES);

		final ScheduledFuture<?> scheduleWithFixedDelay = scheduledExecutor
				.scheduleWithFixedDelay(restPollingRunnable, 0,
						LIFECYCLE_EVENT_POLLING_INTERVAL_SEC, TimeUnit.SECONDS);
		restPollingRunnable.setFutureTask(scheduleWithFixedDelay);
		this.lifecyclePollingThreadContainer.put(lifecycleEventsContainerID,
				restPollingRunnable);
		logger.log(Level.INFO, "polling container UUID is "
				+ lifecycleEventsContainerID.toString());
		return lifecycleEventsContainerID;
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418610154937/fstmerge_var2_2720109675740765108

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_3a94c_dfaa3/rev_3a94c-dfaa3/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
@RequestMapping(value = "applications/{applicationName}/timeout/{timeoutInMinutes}", method = RequestMethod.DELETE)
	public @ResponseBody
	Map<String, Object> uninstallApplication(
			@PathVariable final String applicationName,
			@PathVariable final int timeoutInMinutes) {

		// Check that Application exists
		final Application app = this.admin.getApplications().waitFor(
				applicationName, 10, TimeUnit.SECONDS);
		if (app == null) {
			logger.log(Level.INFO, "Cannot uninstall application "
					+ applicationName
					+ " since it has not been discovered yet.");
			return RestUtils.errorStatus(
					ResponseConstants.FAILED_TO_LOCATE_APP, applicationName);
		}
		final ProcessingUnit[] pus = app.getProcessingUnits()
				.getProcessingUnits();

		final StringBuilder sb = new StringBuilder();
		final List<ProcessingUnit> uninstallOrder = createUninstallOrder(pus,
				applicationName);
		// TODO: Add timeout.
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418610154974/fstmerge_var1_5606419510335725284
		FutureTask<Boolean> undeployTask = null;
		logger.log(Level.INFO, "Starting to poll for uninstall lifecycle events.");
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418610154974/fstmerge_base_8247492989365009988
		logger.log(Level.INFO, "Starting to poll for uninstall lifecycle events.");
		final UUID lifecycleEventContainerID =
				startPollingForApplicationUninstallLifecycleEvents(applicationName, uninstallOrder, timeoutInMinutes);
=======
		logger.log(Level.INFO,
				"Starting to poll for uninstall lifecycle events.");
		final UUID lifecycleEventContainerID = startPollingForApplicationUninstallLifecycleEvents(
				applicationName, uninstallOrder, timeoutInMinutes);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418610154974/fstmerge_var2_7630714624625713542
		if (uninstallOrder.size() > 0) {
			undeployTask = new FutureTask<Boolean>(new Runnable() {
				long startTime = System.currentTimeMillis();
				@Override
				public void run() {
					for (final ProcessingUnit processingUnit : uninstallOrder) {
						long undeployTimeout = TimeUnit.MINUTES.toMillis(timeoutInMinutes) - (System.currentTimeMillis() - startTime);
						try {
							if (processingUnit.waitForManaged(10,
									TimeUnit.SECONDS) == null) {
								logger.log(Level.WARNING,
										"Failed to locate GSM that is managing Processing Unit "
												+ processingUnit.getName());
							} else {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418610154974/fstmerge_var1_5606419510335725284
								logger.log(Level.INFO, "Undeploying Processing Unit " + processingUnit.getName());
								processingUnit.undeployAndWait(undeployTimeout, TimeUnit.MINUTES);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418610154974/fstmerge_base_8247492989365009988
								logger.log(Level.INFO, "Undeploying Processing Unit " + processingUnit.getName());
								processingUnit.undeploy();
=======
								logger.log(Level.INFO,
										"Undeploying Processing Unit "
												+ processingUnit.getName());
								processingUnit.undeploy();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418610154974/fstmerge_var2_7630714624625713542
							}
						} catch (final Exception e) {
							final String msg = "Failed to undeploy processing unit: "
									+ processingUnit.getName()
									+ " while uninstalling application "
									+ applicationName
									+ ". Uninstall will continue, but service "
									+ processingUnit.getName()
									+ " may remain in an unstable state";

							logger.log(Level.SEVERE, msg, e);
						}
					}
					logger.log(Level.INFO, "Application " + applicationName
							+ " undeployment complete");
				}
			}, true);
			
			((InternalAdmin) admin).scheduleAdminOperation(undeployTask);

		}
		final UUID lifecycleEventContainerID =
				startPollingForApplicationUninstallLifecycleEvents(applicationName, uninstallOrder, timeoutInMinutes, undeployTask);

		final String errors = sb.toString();
		if (errors.length() == 0) {
			final Map<String, Object> returnMap = new HashMap<String, Object>();
			returnMap.put(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID,
					lifecycleEventContainerID);
			return RestUtils.successStatus(returnMap);
		}
		return RestUtils.errorStatus(errors);
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_3a94c_dfaa3/rev_3a94c-dfaa3/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418610154993/fstmerge_var1_6262482223575265705
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418610154993/fstmerge_base_3124927253639866958
private UUID startPollingForApplicationUninstallLifecycleEvents(final String applicationName,
			final List<ProcessingUnit> uninstallOrder, final int timeoutInMinutes) {

		RestPollingRunnable restPollingRunnable;
		final LifecycleEventsContainer lifecycleEventsContainer = new LifecycleEventsContainer();
		final UUID lifecycleEventsContainerID = UUID.randomUUID();
		lifecycleEventsContainer.setEventsSet(this.eventsSet);

		restPollingRunnable = new RestPollingRunnable(applicationName, timeoutInMinutes, TimeUnit.MINUTES);
		for (final ProcessingUnit processingUnit : uninstallOrder) {
			final String processingUnitName = processingUnit.getName();
			final String serviceName = ServiceUtils.getApplicationServiceName(processingUnitName, applicationName);
			restPollingRunnable.addService(serviceName, 0);
		}
		restPollingRunnable.setIsServiceInstall(false);
		restPollingRunnable.setAdmin(admin);
		restPollingRunnable.setLifecycleEventsContainer(lifecycleEventsContainer);
		restPollingRunnable.setIsUninstall(true);
		restPollingRunnable.setEndTime(timeoutInMinutes, TimeUnit.MINUTES);
		this.lifecyclePollingThreadContainer.put(lifecycleEventsContainerID, restPollingRunnable);
		final ScheduledFuture<?> scheduleWithFixedDelay =
				scheduledExecutor.scheduleWithFixedDelay(restPollingRunnable, 0, LIFECYCLE_EVENT_POLLING_INTERVAL_SEC,
						TimeUnit.SECONDS);
		restPollingRunnable.setFutureTask(scheduleWithFixedDelay);

		logger.log(Level.INFO, "polling container UUID is " + lifecycleEventsContainerID.toString());
		return lifecycleEventsContainerID;

	}
=======
private UUID startPollingForApplicationUninstallLifecycleEvents(
			final String applicationName,
			final List<ProcessingUnit> uninstallOrder,
			final int timeoutInMinutes) {

		RestPollingRunnable restPollingRunnable;
		final LifecycleEventsContainer lifecycleEventsContainer = new LifecycleEventsContainer();
		final UUID lifecycleEventsContainerID = UUID.randomUUID();
		lifecycleEventsContainer.setEventsSet(this.eventsSet);

		restPollingRunnable = new RestPollingRunnable(applicationName,
				timeoutInMinutes, TimeUnit.MINUTES);
		for (final ProcessingUnit processingUnit : uninstallOrder) {
			final String processingUnitName = processingUnit.getName();
			final String serviceName = ServiceUtils.getApplicationServiceName(
					processingUnitName, applicationName);
			restPollingRunnable.addService(serviceName, 0);
		}
		restPollingRunnable.setIsServiceInstall(false);
		restPollingRunnable.setAdmin(admin);
		restPollingRunnable
				.setLifecycleEventsContainer(lifecycleEventsContainer);
		restPollingRunnable.setIsUninstall(true);
		restPollingRunnable.setEndTime(timeoutInMinutes, TimeUnit.MINUTES);
		this.lifecyclePollingThreadContainer.put(lifecycleEventsContainerID,
				restPollingRunnable);
		final ScheduledFuture<?> scheduleWithFixedDelay = scheduledExecutor
				.scheduleWithFixedDelay(restPollingRunnable, 0,
						LIFECYCLE_EVENT_POLLING_INTERVAL_SEC, TimeUnit.SECONDS);
		restPollingRunnable.setFutureTask(scheduleWithFixedDelay);

		logger.log(Level.INFO, "polling container UUID is "
				+ lifecycleEventsContainerID.toString());
		return lifecycleEventsContainerID;

	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418610154993/fstmerge_var2_3239518569221442100

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_3a94c_dfaa3/rev_3a94c-dfaa3/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_1f938_0331f/rev_1f938-0331f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f03a6_b508f/rev_f03a6-b508f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f6477_ad3db/rev_f6477-ad3db.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_9b64b_69029/rev_9b64b-69029.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_df084_76bca/rev_df084-76bca.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_e26d9_55242/rev_e26d9-55242.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_87377_cd3c5/rev_87377-cd3c5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_10385_c1f71/rev_10385-c1f71.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_40278_d1c5b/rev_40278-d1c5b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_dccd0_dcac4/rev_dccd0-dcac4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_d68aa_e6119/rev_d68aa-e6119.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7314_c1cfe/rev_f7314-c1cfe.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_a9f1d_ed190/rev_a9f1d-ed190.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_b0e6b_77a87/rev_b0e6b-77a87.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_eecdd_0edcb/rev_eecdd-0edcb.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_7691c_15605/rev_7691c-15605.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_01c9b_9ff9e/rev_01c9b-9ff9e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_d85ef_bb498/rev_d85ef-bb498.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_7879e_5a792/rev_7879e-5a792.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_5975c_77d3b/rev_5975c-77d3b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_53c36_6d2ae/rev_53c36-6d2ae.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_ac80b_8756d/rev_ac80b-8756d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_98f85_a0efa/rev_98f85-a0efa.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_abe0f_7b900/rev_abe0f-7b900.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_76da4_53d09/rev_76da4-53d09.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_de461_22da6/rev_de461-22da6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_5783b_92c95/rev_5783b-92c95.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f9298_a57f2/rev_f9298-a57f2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_37a1f_41395/rev_37a1f-41395.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_baeab_b6e13/rev_baeab-b6e13.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_af44d_8b5cd/rev_af44d-8b5cd.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_17de9_c04bf/rev_17de9-c04bf.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_4b05d_34d3a/rev_4b05d-34d3a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_cfbb3_5ffe1/rev_cfbb3-5ffe1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_04755_65efd/rev_04755-65efd.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_676e9_1a23d/rev_676e9-1a23d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_9d0cc_f0677/rev_9d0cc-f0677.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_adf8a_375d7/rev_adf8a-375d7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_c8ee1_d5e59/rev_c8ee1-d5e59.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_13cc2_401f0/rev_13cc2-401f0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_0d9cd_3d77e/rev_0d9cd-3d77e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_b3a99_c7cdd/rev_b3a99-c7cdd.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_88f0f_89f12/rev_88f0f-89f12.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_342de_afaf6/rev_342de-afaf6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_a3e49_0ab19/rev_a3e49-0ab19.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_22bd9_5b928/rev_22bd9-5b928.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_9c338_31959/rev_9c338-31959.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_e940f_9bbc1/rev_e940f-9bbc1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_3e152_8721d/rev_3e152-8721d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_ae857_7560b/rev_ae857-7560b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_ff6fd_af250/rev_ff6fd-af250.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_19dc6_2a777/rev_19dc6-2a777.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_49043_275b9/rev_49043-275b9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_36001_af35c/rev_36001-af35c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_7f644_f2e79/rev_7f644-f2e79.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_001fa_59b7d/rev_001fa-59b7d.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418614197464/fstmerge_var1_996309695511470445
private void doDeploy(final String applicationName, final String serviceName, final String templateName,
			final String[] agentZones, final File serviceFile, final Properties contextProperties, final Service service, 
			final byte[] serviceCloudConfigurationContents)
			throws TimeoutException, DSLException{

		
		boolean locationAware = false;
		boolean shared = false;
		if (service != null) {
			locationAware = service.isLocationAware();
		}
		if (service != null) {
			shared = service.isShared();
		}
		final int externalProcessMemoryInMB = 512;
		final int containerMemoryInMB = 128;
		final int reservedMemoryCapacityPerMachineInMB = 256;

		contextProperties.put(CloudifyConstants.CONTEXT_PROPERTY_ASYNC_INSTALL, "true");
		
		final ElasticStatelessProcessingUnitDeployment deployment =
				new ElasticStatelessProcessingUnitDeployment(serviceFile)
						.memoryCapacityPerContainer(externalProcessMemoryInMB, MemoryUnit.MEGABYTES)
						.addCommandLineArgument("-Xmx" + containerMemoryInMB + "m")
						.addCommandLineArgument("-Xms" + containerMemoryInMB + "m")
						.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME, applicationName)
						.name(serviceName);
		
		if (cloud == null) { // Azure or local-cloud
			if (!isLocalCloud()) {
				// Azure: Eager scale (1 container per machine per PU)
				setSharedMachineProvisioning(deployment, agentZones, reservedMemoryCapacityPerMachineInMB);
				deployment.scale(ElasticScaleConfigFactory.createEagerScaleConfig());
			} else {
				// local cloud
				setPublicMachineProvisioning(deployment, agentZones, reservedMemoryCapacityPerMachineInMB);
				if (service == null || service.getScalingRules() == null) {

					int totalMemoryInMB = calculateTotalMemoryInMB(serviceName, service, externalProcessMemoryInMB);
					final ManualCapacityScaleConfig scaleConfig =
							new ManualCapacityScaleConfigurer().memoryCapacity(totalMemoryInMB,MemoryUnit.MEGABYTES).create();
					deployment.scale(scaleConfig);
				} else {
					final AutomaticCapacityScaleConfig scaleConfig =
							ElasticScaleConfigFactory.createAutomaticCapacityScaleConfig(serviceName, service,
									externalProcessMemoryInMB, false);
					deployment.scale(scaleConfig);
				}
			}
		} else {

			final CloudTemplate template = getComputeTemplate(cloud, templateName);
			
			final long cloudExternalProcessMemoryInMB;
			if (shared) {
				cloudExternalProcessMemoryInMB = service.getInstanceMemoryMB();
			} else {
				cloudExternalProcessMemoryInMB = calculateExternalProcessMemory(cloud, template);
			}

			logger.info("Creating cloud machine provisioning config. Template remote directory is: " + template.getRemoteDirectory());
			final CloudifyMachineProvisioningConfig config =
					new CloudifyMachineProvisioningConfig(cloud, template, templateName, this.managementTemplate.getRemoteDirectory());

			if (serviceCloudConfigurationContents != null) {

				config.setServiceCloudConfiguration(serviceCloudConfigurationContents);
			}

			final String locators = extractLocators(admin);
			config.setLocator(locators);

			// management machine should be isolated from other services. no matter of the deployment mode.
			config.setDedicatedManagementMachines(true);
			if (shared) {
				logger.info("public mode is on. will use public machine provisioning for " + serviceName + " deployment.");
				// service instances can be deployed across all agents
				setPublicMachineProvisioning(deployment, config);
			} else {
				// service deployment will have a dedicated agent per instance
				setDedicatedMachineProvisioning(deployment, config);
			}
			
			
			deployment.memoryCapacityPerContainer((int) cloudExternalProcessMemoryInMB, MemoryUnit.MEGABYTES);

			if (service == null || service.getScalingRules() == null) {
				int totalMemoryInMB = calculateTotalMemoryInMB(serviceName, service, (int) cloudExternalProcessMemoryInMB);
				double totalCpuCores = calculateTotalCpuCores(serviceName, service);
				final ManualCapacityScaleConfig scaleConfig =
						ElasticScaleConfigFactory.createManualCapacityScaleConfig(totalMemoryInMB, 
								totalCpuCores, locationAware, shared);
				if (!shared) {
					scaleConfig.setAtMostOneContainerPerMachine(true);
				}
				deployment.scale(scaleConfig);
			} else {
				final AutomaticCapacityScaleConfig scaleConfig =
						ElasticScaleConfigFactory.createAutomaticCapacityScaleConfig(serviceName, service,
								(int) cloudExternalProcessMemoryInMB,locationAware);
				if (!shared) {
					scaleConfig.setAtMostOneContainerPerMachine(true);	
				}
				deployment.scale(scaleConfig);
			}
		}

		// add context properties
		setContextProperties(deployment, contextProperties);

		verifyEsmExistsInCluster();
		deployAndWait(serviceName, deployment);

	}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418614197464/fstmerge_base_6543486155483057763
private void doDeploy(final String applicationName, final String serviceName, final String templateName,
			final String[] agentZones, final File serviceFile, final Properties contextProperties, final Service service, 
			final byte[] serviceCloudConfigurationContents)
			throws TimeoutException, DSLException{

		
		boolean locationAware = false;
		if (service != null) {
			locationAware = service.isLocationAware();
		}
		final int externalProcessMemoryInMB = 512;
		final int containerMemoryInMB = 128;
		final int reservedMemoryCapacityPerMachineInMB = 256;

		contextProperties.put(CloudifyConstants.CONTEXT_PROPERTY_ASYNC_INSTALL, "true");
		
		final ElasticStatelessProcessingUnitDeployment deployment =
				new ElasticStatelessProcessingUnitDeployment(serviceFile)
						.memoryCapacityPerContainer(externalProcessMemoryInMB, MemoryUnit.MEGABYTES)
						.addCommandLineArgument("-Xmx" + containerMemoryInMB + "m")
						.addCommandLineArgument("-Xms" + containerMemoryInMB + "m")
						.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME, applicationName)
						.name(serviceName);
		
        if (isLocalCloud()) {
            setPublicMachineProvisioning(deployment, agentZones, reservedMemoryCapacityPerMachineInMB);
        } else {
		// All PUs on this role share the same machine. 
		// Machines are identified by zone.
            setSharedMachineProvisioning(deployment, agentZones, reservedMemoryCapacityPerMachineInMB);
        }

		if (cloud == null) {
			if (!isLocalCloud()) {

				// Azure: Eager scale (1 container per machine per PU)
				deployment.scale(ElasticScaleConfigFactory.createEagerScaleConfig());
			} else {
				// local cloud
				if (service == null || service.getScalingRules() == null) {

					int totalMemoryInMB = calculateTotalMemoryInMB(serviceName, service, externalProcessMemoryInMB);
					final ManualCapacityScaleConfig scaleConfig =
							new ManualCapacityScaleConfigurer().memoryCapacity(totalMemoryInMB,MemoryUnit.MEGABYTES).create();
					deployment.scale(scaleConfig);
				} else {
					final AutomaticCapacityScaleConfig scaleConfig =
							ElasticScaleConfigFactory.createAutomaticCapacityScaleConfig(serviceName, service,
									externalProcessMemoryInMB, false);
					deployment.scale(scaleConfig);
				}
			}
		} else {

			final CloudTemplate template = getComputeTemplate(cloud, templateName);

			final long cloudExternalProcessMemoryInMB = calculateExternalProcessMemory(cloud, template);

			logger.info("Creating cloud machine provisioning config. Template remote directory is: " + template.getRemoteDirectory());
			final CloudifyMachineProvisioningConfig config =
					new CloudifyMachineProvisioningConfig(cloud, template, templateName, this.managementTemplate.getRemoteDirectory());

			final String[] zones = new String[] { serviceName }; //TODO: [itaif] consider using agentZones

			config.setGridServiceAgentZones(zones);

			if (serviceCloudConfigurationContents != null) {

				config.setServiceCloudConfiguration(serviceCloudConfigurationContents);
			}

			final String locators = extractLocators(admin);
			config.setLocator(locators);

			setDedicatedMachineProvisioning(deployment, config);
			deployment.memoryCapacityPerContainer((int) cloudExternalProcessMemoryInMB, MemoryUnit.MEGABYTES);

			if (service == null || service.getScalingRules() == null) {
				int totalMemoryInMB = calculateTotalMemoryInMB(serviceName, service, (int) cloudExternalProcessMemoryInMB);
				final ManualCapacityScaleConfig scaleConfig =
						ElasticScaleConfigFactory.createManualCapacityScaleConfig(totalMemoryInMB, locationAware);

				scaleConfig.setAtMostOneContainerPerMachine(true);
				deployment.scale(scaleConfig);
			} else {
				final AutomaticCapacityScaleConfig scaleConfig =
						ElasticScaleConfigFactory.createAutomaticCapacityScaleConfig(serviceName, service,
								(int) cloudExternalProcessMemoryInMB,locationAware);
				scaleConfig.setAtMostOneContainerPerMachine(true);
				deployment.scale(scaleConfig);
			}
		}

		// add context properties
		setContextProperties(deployment, contextProperties);

		verifyEsmExistsInCluster();
		deployAndWait(serviceName, deployment);

	}
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418614197464/fstmerge_var2_374018722207008152

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_001fa_59b7d/rev_001fa-59b7d/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_ea045_c7cfc/rev_ea045-c7cfc.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_2c4d1_60118/rev_2c4d1-60118.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_a6c37_84427/rev_a6c37-84427.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_46e0b_ae083/rev_46e0b-ae083.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_36b7f_48223/rev_36b7f-48223.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_9297f_af646/rev_9297f-af646.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_6ddbd_dcab5/rev_6ddbd-dcab5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f8c9a_94aee/rev_f8c9a-94aee.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_e166a_5ae4e/rev_e166a-5ae4e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_fb655_cedd7/rev_fb655-cedd7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_a2c28_c02ba/rev_a2c28-c02ba.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_b76cf_07e3d/rev_b76cf-07e3d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_d8c40_b540a/rev_d8c40-b540a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_15f55_448de/rev_15f55-448de.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f1cb8_34797/rev_f1cb8-34797.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418615345354/fstmerge_var1_2113850159620864757
private InstallationDetails createInstallationDetails(final Cloud cloud, final MachineDetails md, 
			final GSAReservationId reservationId)
			throws FileNotFoundException {
		final CloudTemplate template = this.cloud.getTemplates().get(this.cloudTemplateName);

		// Start with the default zone that are also used for discovering agents
		// By default cloudify puts the service-name as the zone.
		// We then add the location of the machine to the zone, so if it fails the ESM starts it with these zones
		// and this adapter can look for the CLOUD_ZONE_PREFIX and start a machine with the same location.
		// TODO Fix GS-9484 and then remove the service name from the machine zone and remove the CLOUD_ZONE_PREFIX.

		ExactZonesConfigurer configurer = new ExactZonesConfigurer()
				.addZones(config.getGridServiceAgentZones().getZones());
		
		if (!StringUtils.isBlank(md.getLocationId())) {
			configurer.addZone(CLOUD_ZONE_PREFIX + md.getLocationId());
		}
		
		final ExactZonesConfig zones = configurer.create();

		final InstallationDetails details =
				Utils.createInstallationDetails(md, cloud, template, zones, lookupLocatorsString,
						this.originalESMAdmin, false,
						null, reservationId, cloudTemplateName);

		logger.info("Created new Installation Details: " + details);
		return details;

	}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418615345354/fstmerge_base_4316736675942023278
private InstallationDetails createInstallationDetails(final Cloud cloud, final MachineDetails md, 
			final GSAReservationId reservationId)
			throws FileNotFoundException {
		final CloudTemplate template = this.cloud.getTemplates().get(this.cloudTemplateName);

		// Start with the default zone that are also used for discovering agents
		// By default cloudify puts the service-name as the zone.
		// We then add the location of the machine to the zone, so if it fails the ESM starts it with these zones
		// and this adapter can look for the CLOUD_ZONE_PREFIX and start a machine with the same location.
		// TODO Fix GS-9484 and then remove the service name from the machine zone and remove the CLOUD_ZONE_PREFIX.

		ExactZonesConfigurer configurer = new ExactZonesConfigurer()
				.addZones(config.getGridServiceAgentZones().getZones());
		
		if (!StringUtils.isBlank(md.getLocationId())) {
			configurer.addZone(CLOUD_ZONE_PREFIX + md.getLocationId());
		}
		
		final ExactZonesConfig zones = configurer.create();

		final InstallationDetails details =
				Utils.createInstallationDetails(md, cloud, template, zones, lookupLocatorsString,
						this.originalESMAdmin, false,
						null, reservationId);
		details.setTemplateName(cloudTemplateName);

		logger.info("Created new Installation Details: " + details);
		return details;

	}
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418615345354/fstmerge_var2_1396196307904411236

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f1cb8_34797/rev_f1cb8-34797/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/ElasticMachineProvisioningCloudifyAdapter.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_90d1a_e64fb/rev_90d1a-e64fb.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_6e88c_5520e/rev_6e88c-5520e.revisions
Conflict type: LineBasedMCFd
Conflict body: 
private void uninstallApplications(final long end) throws CLIException,
			InterruptedException, TimeoutException {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418615512755/fstmerge_var1_144695562111287493
		final Collection<String> applicationsList = adminFacade.getApplicationsNamesAndAuthGroups().values();
		
		final long startTime = System.currentTimeMillis();
		final long millisToEnd = end - startTime;
		final int minutesToEnd = (int) TimeUnit.MILLISECONDS.toMinutes(millisToEnd);
		
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418615512755/fstmerge_base_2727623946218554926
		final Collection<String> applicationsList = adminFacade.getApplicationsNamesAndAuthGroups().values();
=======
		final Collection<String> applicationsList = adminFacade.getApplicationNamesList();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418615512755/fstmerge_var2_8653690437790614541
		if (applicationsList.size() > 0) {
			logger.info("Uninstalling the currently deployed applications");
			for (final String application : applicationsList) {
				if (!application.equals(MANAGEMENT_APPLICATION)) {
					adminFacade.uninstallApplication(application, minutesToEnd);
				}
			}
		}

		waitForUninstallApplications(Utils.millisUntil(end),
				TimeUnit.MILLISECONDS);
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_6e88c_5520e/rev_6e88c-5520e/esc-commands/src/main/java/org/cloudifysource/esc/shell/installer/CloudGridAgentBootstrapper.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_ca0f6_55ea9/rev_ca0f6-55ea9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_367da_98095/rev_367da-98095.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_7d843_dc5b3/rev_7d843-dc5b3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_7817d_852ba/rev_7817d-852ba.revisions
Conflict type: LineBasedMCFd
Conflict body: 
private void remoteExecuteAgentOnServer(final InstallationDetails details, final long end, final String targetHost)
			throws InstallerException, TimeoutException, InterruptedException {

		// get script for execution mode
		final String scriptFileName = getScriptFileName(details);

		String remoteDirectory = details.getRemoteDir();
		if (remoteDirectory.endsWith("/")) {
			remoteDirectory = remoteDirectory.substring(0, remoteDirectory.length() - 1);
		}
		if (details.isLus()) { // TODO - fix - use local dir of template
			// add the relative path to the cloud file location
			remoteDirectory = remoteDirectory + "/" + details.getRelativeLocalDir();
		}

		final String scriptPath = remoteDirectory + "/" + scriptFileName;

		final ShellCommandBuilder scb = new ShellCommandBuilder(details.getRemoteExecutionMode())
				.exportVar(LUS_IP_ADDRESS_ENV, details.getLocator())
				.exportVar(GSA_MODE_ENV, details.isLus() ? "lus" : "agent")
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418615843227/fstmerge_var1_7351120519070517538
				.exportVar(NO_WEB_SERVICES_ENV, details.isNoWebServices() ? "true" : "false")
				.exportVar(MACHINE_IP_ADDRESS_ENV,
						details.isBindToPrivateIp() ? details.getPrivateIp() : details.getPublicIp())
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418615843227/fstmerge_base_8475838519107056522
				.exportVar(NO_WEB_SERVICES_ENV,
						details.isNoWebServices() ? "true" : "false")
				.exportVar(
						MACHINE_IP_ADDRESS_ENV,
						details.isBindToPrivateIp() ? details.getPrivateIp()
								: details.getPublicIp())
=======
				.exportVar(CloudifyConstants.SPRING_BEANS_PROFILE_ENV_VAR, "nonsecure")
				.exportVar(NO_WEB_SERVICES_ENV,
						details.isNoWebServices() ? "true" : "false")
				.exportVar(
						MACHINE_IP_ADDRESS_ENV,
						details.isBindToPrivateIp() ? details.getPrivateIp()
								: details.getPublicIp())
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418615843227/fstmerge_var2_2180717296504133135
				.exportVar(MACHINE_ZONES_ENV, details.getZones())
				.exportVar(CLOUDIFY_LINK_ENV,
						details.getCloudifyUrl() != null ? "\"" + details.getCloudifyUrl() + "\"" : "")
				.exportVar(CLOUDIFY_OVERRIDES_LINK_ENV,
						details.getOverridesUrl() != null ? "\"" + details.getOverridesUrl() + "\"" : "")
				.exportVar(WORKING_HOME_DIRECTORY_ENV, remoteDirectory)
				.exportVar(CloudifyConstants.GIGASPACES_AGENT_ENV_PRIVATE_IP, details.getPrivateIp())
				.exportVar(CloudifyConstants.GIGASPACES_AGENT_ENV_PUBLIC_IP, details.getPublicIp())
				.exportVar(CloudifyConstants.GIGASPACES_CLOUD_TEMPLATE_NAME, details.getTemplateName())

				// maintain backwards compatibility for pre 2.3.0
				.exportVar(CloudifyConstants.CLOUDIFY_AGENT_ENV_PRIVATE_IP, details.getPrivateIp())
				.exportVar(CloudifyConstants.CLOUDIFY_AGENT_ENV_PUBLIC_IP, details.getPublicIp());

		if (details.getReservationId() != null) {
			scb.exportVar(GSA_RESERVATION_ID_ENV, details.getReservationId().toString());
		}

		if (details.isLus()) {
			String remotePath = details.getRemoteDir();
			if (!remotePath.endsWith("/")) {
				remotePath += "/";
			}
			scb.exportVar(CLOUD_FILE, remotePath + details.getCloudFile().getName());
		}

		if (details.getUsername() != null) {
			scb.exportVar("USERNAME", details.getUsername());
		}
		if (details.getPassword() != null) {
			scb.exportVar("PASSWORD", details.getPassword());
		}

		final Set<Entry<String, String>> entries = details.getExtraRemoteEnvironmentVariables().entrySet();
		for (final Entry<String, String> entry : entries) {
			scb.exportVar(entry.getKey(), entry.getValue());
		}

		scb.chmodExecutable(scriptPath).call(scriptPath);

		final String command = scb.toString();

		logger.fine("Calling startup script on target: " + targetHost + " with LOCATOR=" + details.getLocator()
				+ "\nThis may take a few minutes");

		switch (details.getRemoteExecutionMode()) {
		case SSH:
			sshCommand(targetHost, command, details.getUsername(), details.getPassword(), details.getKeyFile(),
					Utils.millisUntil(end), TimeUnit.MILLISECONDS);

			break;
		case WINRM:
			powershellCommand(targetHost, command, details.getUsername(), details.getPassword(), details.getKeyFile(),
					Utils.millisUntil(end), TimeUnit.MILLISECONDS, details.getLocalDir());
			break;
		default:
			throw new UnsupportedOperationException();
		}
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_7817d_852ba/rev_7817d-852ba/esc/src/main/java/org/cloudifysource/esc/installer/AgentlessInstaller.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_36470_243ee/rev_36470-243ee.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_9c05f_2da29/rev_9c05f-2da29.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f6937_74d9c/rev_f6937-74d9c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_519d4_d3239/rev_519d4-d3239.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_9ed11_646bd/rev_9ed11-646bd.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_46351_0974b/rev_46351-0974b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_cee08_a229f/rev_cee08-a229f.revisions
Conflict type: LineBasedMCFd
Conflict body: 
private Object readDslObject()
			throws DSLException {
		try {
			init();
		} catch (final IOException e) {
			throw new DSLException("Failed to initialize DSL Reader: " + e.getMessage(), e);
		}

		LinkedHashMap<Object, Object> properties = null;
		try {
			properties = createDSLProperties();
			createDSLOverrides(overridesFile, overridesScript, overrideProperties);
			overrideProperties(properties);
			addApplicationProperties(properties);
		} catch (final Exception e) {
			// catching exception here, as groovy config slurper may throw just
			// about anything
			String msg = null;
			if (propertiesFile != null) {
				msg = "Failed to load properties file " + this.propertiesFile.getName() + ": " + e.getMessage();
			} else {
				msg = "Failed to load properties file: " + e.getMessage();
			}
			throw new IllegalArgumentException(msg, e);
		}

		if (this.variables != null) {
			properties.putAll(this.variables);
		}
		ClusterInfo clusterInfoToUseInGsc = this.clusterInfo;
		if (clusterInfoToUseInGsc == null) {
			clusterInfoToUseInGsc = new ClusterInfo(null, 1, 0, 1, 0);
		}

		// create an uninitialized service context
		if (this.createServiceContext) {
			if (this.context == null) {
				if (isRunningInGSC) {
					this.context = new ServiceContextImpl(clusterInfoToUseInGsc, workDir.getAbsolutePath());
				} else {
					this.context = new ServiceContextImpl(new ClusterInfo(null, 1, 0, 1, 0), workDir.getAbsolutePath());
				}
			}

		}

		// create the groovy shell, loaded with our settings
		final GroovyShell gs = createGroovyShell(properties);
		final Object result = evaluateGroovyScript(gs);

		if (result == null) {
			throw new DSLException("The DSL evaluated to a null - check your syntax and try again");
		}

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418616420864/fstmerge_var1_4024160452915815295
		// overrideFields(result);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418616420864/fstmerge_base_7905329081872130444
//		overrideFields(result);
=======
		//		overrideFields(result);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418616420864/fstmerge_var2_5012918386132547016

		if (this.createServiceContext) {
			if (!(result instanceof Service)) {
				throw new IllegalArgumentException(
						"The DSL reader cannot create a service context to a DSL that does not evaluate to a Service. "
								+ "Set the 'createServiceContext' option to false if you do not need a service conext");
			}

			if (isRunningInGSC) {
				if (clusterInfoToUseInGsc.getName() == null) {
					clusterInfoToUseInGsc.setName(ServiceUtils.getAbsolutePUName(
							CloudifyConstants.DEFAULT_APPLICATION_NAME, ((Service) result).getName()));
				}

				this.context.init((Service) result, admin, clusterInfoToUseInGsc);
			} else {

				this.context.initInIntegratedContainer((Service) result);
			}
		}

		return result;

	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_cee08_a229f/rev_cee08-a229f/dsl/src/main/java/org/cloudifysource/dsl/internal/DSLReader.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_b1512_c6998/rev_b1512-c6998.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_b645e_eee5d/rev_b645e-eee5d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_4dc05_6d380/rev_4dc05-6d380.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_c7439_9f776/rev_c7439-9f776.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_43066_5fdf4/rev_43066-5fdf4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_a346e_1b56c/rev_a346e-1b56c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_a968d_bafc5/rev_a968d-bafc5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_4e951_16e16/rev_4e951-16e16.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_1152e_28798/rev_1152e-28798.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_c5f44_180a0/rev_c5f44-180a0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_1fb02_abbcf/rev_1fb02-abbcf.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_bcda9_f7ae8/rev_bcda9-f7ae8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_ccee9_81cd8/rev_ccee9-81cd8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_18647_e1cb7/rev_18647-e1cb7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617878060/fstmerge_var1_8061362974530362110
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617878060/fstmerge_base_1313168832752504564
public Map<String, CloudTemplate> getTemplates() {
		return templates;
	}
=======
public Map<String, CloudTemplate> getTemplates() {
		return templates;
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617878060/fstmerge_var2_2242573821667521505

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/dsl/src/main/java/org/cloudifysource/dsl/cloud/Cloud.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617878064/fstmerge_var1_7655417052285703213
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617878064/fstmerge_base_324616998218370335
public void setTemplates(final Map<String, CloudTemplate> templates) {
		this.templates = templates;
	}
=======
public void setTemplates(final Map<String, CloudTemplate> templates) {
		this.templates = templates;
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617878064/fstmerge_var2_3112365954956082506

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/dsl/src/main/java/org/cloudifysource/dsl/cloud/Cloud.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617878088/fstmerge_var1_722272760094983412
@Override
	public String toString() {
		return "Cloud [name=" + name + ", provider=" + provider + ", user=" + user + ", configuration="
				+ configuration + ", cloudCompute=" + cloudCompute + ", custom=" + custom + "]";
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617878088/fstmerge_base_3041253572278521914
@Override
	public String toString() {
		return "Cloud [name=" + name + ", provider=" + provider + ", user=" + user + ", configuration="
				+ configuration + ", templates=" + templates + ", custom=" + custom + "]";
=======
@Override
	public String toString() {
		return "Cloud [name=" + name + ", provider=" + provider + ", user=" + user + ", configuration="
				+ configuration + ", templates=" + templates + ", custom=" + custom + "]";
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617878088/fstmerge_var2_4932138299370136233
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/dsl/src/main/java/org/cloudifysource/dsl/cloud/Cloud.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617878093/fstmerge_var1_3524535695818754604
@DSLValidation
	void validateManagementTemplateName(final DSLValidationContext validationContext)
			throws DSLValidationException {

		final CloudConfiguration configuration = getConfiguration();
		final Map<String, ComputeTemplate> templates = getCloudCompute().getTemplates();

		final String managementTemplateName = configuration.getManagementMachineTemplate();

		if (StringUtils.isBlank(managementTemplateName)) {
			throw new DSLValidationException("managementMachineTemplate may not be empty");
		}

		if (!templates.containsKey(managementTemplateName)) {
			throw new DSLValidationException("The management machine template \"" + managementTemplateName + "\" is "
					+ "not listed in the cloud's templates section");
		}

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617878093/fstmerge_base_8070115575313243944
@DSLValidation
	void validateManagementTemplateName(final DSLValidationContext validationContext)
			throws DSLValidationException {

		final CloudConfiguration configuration = getConfiguration();
		final Map<String, CloudTemplate> templates = getTemplates();

		final String managementTemplateName = configuration.getManagementMachineTemplate();

		if (StringUtils.isBlank(managementTemplateName)) {
			throw new DSLValidationException("managementMachineTemplate may not be empty");
		}

		if (!templates.containsKey(managementTemplateName)) {
			throw new DSLValidationException("The management machine template \"" + managementTemplateName + "\" is "
					+ "not listed in the cloud's templates section");
		}

=======
@DSLValidation
	void validateManagementTemplateName(final DSLValidationContext validationContext)
			throws DSLValidationException {

		final CloudConfiguration configuration = getConfiguration();
		final Map<String, CloudTemplate> templates = getTemplates();

		final String managementTemplateName = configuration.getManagementMachineTemplate();

		if (StringUtils.isBlank(managementTemplateName)) {
			throw new DSLValidationException("managementMachineTemplate may not be empty");
		}

		if (!templates.containsKey(managementTemplateName)) {
			throw new DSLValidationException("The management machine template \"" + managementTemplateName + "\" is "
					+ "not listed in the cloud's templates section");
		}

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617878093/fstmerge_var2_1072133564676737499
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/dsl/src/main/java/org/cloudifysource/dsl/cloud/Cloud.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617878103/fstmerge_var1_5486974116004977514
@DSLValidation
	public void validateDynamicNodesClosures(final DSLValidationContext validationContext) 
			throws DSLValidationException {
		if (CloudifyConstants.DYNAMIC_BYON_NAME.equals(name)) {
			String managementMachineTemplateName = configuration.getManagementMachineTemplate();
			ComputeTemplate managementMachineTemplate = getCloudCompute().
					getTemplates().get(managementMachineTemplateName);
			Map<String, Object> mngTemplateCustom = managementMachineTemplate.getCustom();
			validateClosureExists(mngTemplateCustom, CloudifyConstants.DYNAMIC_BYON_START_MNG_MACHINES_KEY, 
					managementMachineTemplateName);			
			validateClosureExists(mngTemplateCustom, CloudifyConstants.DYNAMIC_BYON_STOP_MNG_MACHINES_KEY, 
					managementMachineTemplateName);
			for (Entry<String, ComputeTemplate> templateEntry : getCloudCompute().getTemplates().entrySet()) {
				final String templateName = templateEntry.getKey();
				Map<String, Object> templateCustom = templateEntry.getValue().getCustom();
				validateClosureExists(templateCustom, CloudifyConstants.DYNAMIC_BYON_START_MACHINE_KEY, templateName);
				validateClosureExists(templateCustom, CloudifyConstants.DYNAMIC_BYON_STOP_MACHINE_KEY, templateName);
			}
		}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617878103/fstmerge_base_8061179844450864535
@DSLValidation
	public void validateDynamicNodesClosures(final DSLValidationContext validationContext) 
			throws DSLValidationException {
		if (CloudifyConstants.DYNAMIC_BYON_NAME.equals(name)) {
			String managementMachineTemplateName = configuration.getManagementMachineTemplate();
			CloudTemplate managementMachineTemplate = templates.get(managementMachineTemplateName);
			Map<String, Object> mngTemplateCustom = managementMachineTemplate.getCustom();
			validateClosureExists(mngTemplateCustom, CloudifyConstants.DYNAMIC_BYON_START_MNG_MACHINES_KEY, 
					managementMachineTemplateName);			
			validateClosureExists(mngTemplateCustom, CloudifyConstants.DYNAMIC_BYON_STOP_MNG_MACHINES_KEY, 
					managementMachineTemplateName);
			for (Entry<String, CloudTemplate> templateEntry : templates.entrySet()) {
				final String templateName = templateEntry.getKey();
				Map<String, Object> templateCustom = templateEntry.getValue().getCustom();
				validateClosureExists(templateCustom, CloudifyConstants.DYNAMIC_BYON_START_MACHINE_KEY, templateName);
				validateClosureExists(templateCustom, CloudifyConstants.DYNAMIC_BYON_STOP_MACHINE_KEY, templateName);
			}
		}
=======
@DSLValidation
	public void validateDynamicNodesClosures(final DSLValidationContext validationContext) 
			throws DSLValidationException {
		if (CloudifyConstants.DYNAMIC_BYON_NAME.equals(name)) {
			String managementMachineTemplateName = configuration.getManagementMachineTemplate();
			CloudTemplate managementMachineTemplate = templates.get(managementMachineTemplateName);
			Map<String, Object> mngTemplateCustom = managementMachineTemplate.getCustom();
			validateClosureExists(mngTemplateCustom, CloudifyConstants.DYNAMIC_BYON_START_MNG_MACHINES_KEY, 
					managementMachineTemplateName);			
			validateClosureExists(mngTemplateCustom, CloudifyConstants.DYNAMIC_BYON_STOP_MNG_MACHINES_KEY, 
					managementMachineTemplateName);
			for (Entry<String, CloudTemplate> templateEntry : templates.entrySet()) {
				final String templateName = templateEntry.getKey();
				Map<String, Object> templateCustom = templateEntry.getValue().getCustom();
				validateClosureExists(templateCustom, CloudifyConstants.DYNAMIC_BYON_START_MACHINE_KEY, templateName);
				validateClosureExists(templateCustom, CloudifyConstants.DYNAMIC_BYON_STOP_MACHINE_KEY, templateName);
			}
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617878103/fstmerge_var2_6845060006862557243
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/dsl/src/main/java/org/cloudifysource/dsl/cloud/Cloud.java
Conflict type: ModifierList
Conflict body: 
~~FSTMerge~~ @CloudifyDSLEntity(name = "installer", clazz = CloudTemplateInstallerConfiguration.class,
		allowInternalNode = true, allowRootNode = true, parent = "computeTemplate")
public ##FSTMerge## ##FSTMerge## @CloudifyDSLEntity(name = "installer", clazz = CloudTemplateInstallerConfiguration.class,
		allowInternalNode = true, allowRootNode = true, parent = "template")
public
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/dsl/src/main/java/org/cloudifysource/dsl/cloud/CloudTemplateInstallerConfiguration.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617879776/fstmerge_var1_8180392025263261405
public static synchronized Map<String, DSLObjectInitializerData> getDSLInitializers() {
		if (dslObjectInitializersByName == null) {
			dslObjectInitializersByName = new HashMap<String, BaseDslScript.DSLObjectInitializerData>();

			addObjectInitializerForClass(dslObjectInitializersByName, Application.class);
			addObjectInitializerForClass(dslObjectInitializersByName, Service.class);
			addObjectInitializerForClass(dslObjectInitializersByName, PluginDescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ServiceNetwork.class);

			addObjectInitializerForClass(dslObjectInitializersByName, DataGrid.class);
			addObjectInitializerForClass(dslObjectInitializersByName, Memcached.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ServiceLifecycle.class);
			addObjectInitializerForClass(dslObjectInitializersByName, StatefulProcessingUnit.class);
			addObjectInitializerForClass(dslObjectInitializersByName, StatelessProcessingUnit.class);
			addObjectInitializerForClass(dslObjectInitializersByName, MirrorProcessingUnit.class);

			addObjectInitializerForClass(dslObjectInitializersByName, Cloud.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudProvider.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudUser.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ComputeTemplate.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudCompute.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudConfiguration.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ComputeDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudStorage.class);
			addObjectInitializerForClass(dslObjectInitializersByName, StorageTemplate.class);
			addObjectInitializerForClass(dslObjectInitializersByName, StorageDetails.class);

			addObjectInitializerForClass(dslObjectInitializersByName, ComputeDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, Sla.class);

			dslObjectInitializersByName.put("userInterface", new DSLObjectInitializerData("userInterface",
					UserInterface.class, true, true, "service"));

			dslObjectInitializersByName.put("metricGroup", new DSLObjectInitializerData("metricGroup",
					MetricGroup.class, false, true, "userInterface"));
			dslObjectInitializersByName.put("widgetGroup", new DSLObjectInitializerData("widgetGroup",
					WidgetGroup.class, false, true, "userInterface"));
			dslObjectInitializersByName.put("balanceGauge", new DSLObjectInitializerData("balanceGauge",
					BalanceGauge.class, false, true, "widgetGroup"));
			dslObjectInitializersByName.put("barLineChart", new DSLObjectInitializerData("barLineChart",
					BarLineChart.class, false, true, "widgetGroup"));

			addObjectInitializerForClass(dslObjectInitializersByName, ScalingRuleDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, HighThresholdDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, LowThresholdDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ServiceStatisticsDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, PerInstanceStatisticsDetails.class);

			addObjectInitializerForClass(dslObjectInitializersByName, IsolationSLA.class);
			addObjectInitializerForClass(dslObjectInitializersByName, GlobalIsolationSLADescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, TenantSharedIsolationSLADescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, AppSharedIsolationSLADescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, DedicatedIsolationSLADescriptor.class);

			addObjectInitializerForClass(dslObjectInitializersByName, GridComponents.class);
			addObjectInitializerForClass(dslObjectInitializersByName, OrchestratorComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, DiscoveryComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, DeployerComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, WebuiComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, UsmComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, RestComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, AgentComponent.class);

			addObjectInitializerForClass(dslObjectInitializersByName, CloudTemplateInstallerConfiguration.class);

		}
		return dslObjectInitializersByName;

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617879776/fstmerge_base_6288294487659354433
public static synchronized Map<String, DSLObjectInitializerData> getDSLInitializers() {
		if (dslObjectInitializersByName == null) {
			dslObjectInitializersByName = new HashMap<String, BaseDslScript.DSLObjectInitializerData>();

			addObjectInitializerForClass(dslObjectInitializersByName, Application.class);
			addObjectInitializerForClass(dslObjectInitializersByName, Service.class);
			addObjectInitializerForClass(dslObjectInitializersByName, PluginDescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ServiceNetwork.class);

			addObjectInitializerForClass(dslObjectInitializersByName, DataGrid.class);
			addObjectInitializerForClass(dslObjectInitializersByName, Memcached.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ServiceLifecycle.class);
			addObjectInitializerForClass(dslObjectInitializersByName, StatefulProcessingUnit.class);
			addObjectInitializerForClass(dslObjectInitializersByName, StatelessProcessingUnit.class);
			addObjectInitializerForClass(dslObjectInitializersByName, MirrorProcessingUnit.class);

			addObjectInitializerForClass(dslObjectInitializersByName, Cloud.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudProvider.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudUser.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudTemplate.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudConfiguration.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ComputeDetails.class);

			addObjectInitializerForClass(dslObjectInitializersByName, ComputeDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, Sla.class);

			dslObjectInitializersByName.put("userInterface", new DSLObjectInitializerData("userInterface",
					UserInterface.class, true, true, "service"));

			dslObjectInitializersByName.put("metricGroup", new DSLObjectInitializerData("metricGroup",
					MetricGroup.class, false, true, "userInterface"));
			dslObjectInitializersByName.put("widgetGroup", new DSLObjectInitializerData("widgetGroup",
					WidgetGroup.class, false, true, "userInterface"));
			dslObjectInitializersByName.put("balanceGauge", new DSLObjectInitializerData("balanceGauge",
					BalanceGauge.class, false, true, "widgetGroup"));
			dslObjectInitializersByName.put("barLineChart", new DSLObjectInitializerData("barLineChart",
					BarLineChart.class, false, true, "widgetGroup"));

			addObjectInitializerForClass(dslObjectInitializersByName, ScalingRuleDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, HighThresholdDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, LowThresholdDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ServiceStatisticsDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, PerInstanceStatisticsDetails.class);

			addObjectInitializerForClass(dslObjectInitializersByName, IsolationSLA.class);
			addObjectInitializerForClass(dslObjectInitializersByName, GlobalIsolationSLADescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, TenantSharedIsolationSLADescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, AppSharedIsolationSLADescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, DedicatedIsolationSLADescriptor.class);

			addObjectInitializerForClass(dslObjectInitializersByName, GridComponents.class);
			addObjectInitializerForClass(dslObjectInitializersByName, OrchestratorComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, DiscoveryComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, DeployerComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, WebuiComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, UsmComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, RestComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, AgentComponent.class);

		}
		return dslObjectInitializersByName;

=======
public static synchronized Map<String, DSLObjectInitializerData> getDSLInitializers() {
		if (dslObjectInitializersByName == null) {
			dslObjectInitializersByName = new HashMap<String, BaseDslScript.DSLObjectInitializerData>();

			addObjectInitializerForClass(dslObjectInitializersByName, Application.class);
			addObjectInitializerForClass(dslObjectInitializersByName, Service.class);
			addObjectInitializerForClass(dslObjectInitializersByName, PluginDescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ServiceNetwork.class);

			addObjectInitializerForClass(dslObjectInitializersByName, DataGrid.class);
			addObjectInitializerForClass(dslObjectInitializersByName, Memcached.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ServiceLifecycle.class);
			addObjectInitializerForClass(dslObjectInitializersByName, StatefulProcessingUnit.class);
			addObjectInitializerForClass(dslObjectInitializersByName, StatelessProcessingUnit.class);
			addObjectInitializerForClass(dslObjectInitializersByName, MirrorProcessingUnit.class);

			addObjectInitializerForClass(dslObjectInitializersByName, Cloud.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudProvider.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudUser.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudTemplate.class);
			addObjectInitializerForClass(dslObjectInitializersByName, CloudConfiguration.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ComputeDetails.class);

			addObjectInitializerForClass(dslObjectInitializersByName, ComputeDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, Sla.class);

			dslObjectInitializersByName.put("userInterface", new DSLObjectInitializerData("userInterface",
					UserInterface.class, true, true, "service"));

			dslObjectInitializersByName.put("metricGroup", new DSLObjectInitializerData("metricGroup",
					MetricGroup.class, false, true, "userInterface"));
			dslObjectInitializersByName.put("widgetGroup", new DSLObjectInitializerData("widgetGroup",
					WidgetGroup.class, false, true, "userInterface"));
			dslObjectInitializersByName.put("balanceGauge", new DSLObjectInitializerData("balanceGauge",
					BalanceGauge.class, false, true, "widgetGroup"));
			dslObjectInitializersByName.put("barLineChart", new DSLObjectInitializerData("barLineChart",
					BarLineChart.class, false, true, "widgetGroup"));

			addObjectInitializerForClass(dslObjectInitializersByName, ScalingRuleDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, HighThresholdDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, LowThresholdDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, ServiceStatisticsDetails.class);
			addObjectInitializerForClass(dslObjectInitializersByName, PerInstanceStatisticsDetails.class);

			addObjectInitializerForClass(dslObjectInitializersByName, IsolationSLA.class);
			addObjectInitializerForClass(dslObjectInitializersByName, GlobalIsolationSLADescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, TenantSharedIsolationSLADescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, AppSharedIsolationSLADescriptor.class);
			addObjectInitializerForClass(dslObjectInitializersByName, DedicatedIsolationSLADescriptor.class);

			addObjectInitializerForClass(dslObjectInitializersByName, GridComponents.class);
			addObjectInitializerForClass(dslObjectInitializersByName, OrchestratorComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, DiscoveryComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, DeployerComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, WebuiComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, UsmComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, RestComponent.class);
			addObjectInitializerForClass(dslObjectInitializersByName, AgentComponent.class);

			addObjectInitializerForClass(dslObjectInitializersByName, CloudTemplateInstallerConfiguration.class);

		}
		return dslObjectInitializersByName;

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617879776/fstmerge_var2_5120282124413188188
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/dsl/src/main/java/org/cloudifysource/dsl/internal/BaseDslScript.java
Conflict type: LineBasedMCFd
Conflict body: 
@Test
	public void testCloudParser() throws Exception {
		final org.cloudifysource.dsl.cloud.Cloud cloud = ServiceReader.readCloud(new File(SIMPLE_CLOUD_PATH));
		assertNotNull(cloud);
		assertNotNull(cloud.getProvider());
		assertNotNull(cloud.getCloudCompute().getTemplates());
		assertNotNull(cloud.getUser());
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617881848/fstmerge_var1_4260749640925216364
		assertNotNull(cloud.getCloudCompute().getTemplates().size() == 1);
		assertNotNull(cloud.getCloudCompute().getTemplates().get("SMALL_LINUX"));
		Assert.assertEquals(FileTransferModes.CIFS, cloud.getCloudCompute()
				.getTemplates().get("SMALL_LINUX").getFileTransfer());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617881848/fstmerge_base_9057288751287971266
		assertNotNull(cloud.getTemplates().size() == 1);
		assertNotNull(cloud.getTemplates().get("SMALL_LINUX"));
		Assert.assertEquals(FileTransferModes.CIFS, cloud.getTemplates().get("SMALL_LINUX").getFileTransfer());
=======
		assertNotNull(cloud.getTemplates().size() == 1);
		assertNotNull(cloud.getTemplates().get("SMALL_LINUX"));
		assertEquals(FileTransferModes.CIFS, cloud.getTemplates().get("SMALL_LINUX").getFileTransfer());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617881848/fstmerge_var2_7485988236410010243

	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/dsl/src/test/java/org/cloudifysource/dsl/CloudParserTest.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617881853/fstmerge_var1_6675377165979952710
@Test
	public void testCloudParserWithInstaller() throws Exception {
		final org.cloudifysource.dsl.cloud.Cloud cloud = ServiceReader.readCloud(new File(INSTALLER_CLOUD_PATH));
		assertNotNull(cloud);
		assertNotNull(cloud.getCloudCompute().getTemplates());
		assertNotNull(cloud.getCloudCompute().getTemplates().size() == 1);
		assertNotNull(cloud.getCloudCompute().getTemplates().get("SMALL_LINUX"));

		ComputeTemplate template = cloud.getCloudCompute().getTemplates().values().iterator().next();
		assertNotNull(template);
		assertNotNull(template.getInstaller());

		CloudTemplateInstallerConfiguration installer = template.getInstaller();
		assertEquals(5000, installer.getConnectionTestConnectTimeoutMillis());
		assertEquals(5000, installer.getConnectionTestIntervalMillis());
		assertEquals(5, installer.getFileTransferRetries());


	}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617881853/fstmerge_base_307220268335188721
=======
@Test
	public void testCloudParserWithInstaller() throws Exception {
		final org.cloudifysource.dsl.cloud.Cloud cloud = ServiceReader.readCloud(new File(INSTALLER_CLOUD_PATH));
		assertNotNull(cloud);
		assertNotNull(cloud.getTemplates());
		assertNotNull(cloud.getTemplates().size() == 1);
		assertNotNull(cloud.getTemplates().get("SMALL_LINUX"));

		CloudTemplate template = cloud.getTemplates().values().iterator().next();
		assertNotNull(template);
		assertNotNull(template.getInstaller());

		CloudTemplateInstallerConfiguration installer = template.getInstaller();
		assertEquals(5000, installer.getConnectionTestConnectTimeoutMillis());
		assertEquals(5000, installer.getConnectionTestIntervalMillis());
		assertEquals(5, installer.getFileTransferRetries());


	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617881853/fstmerge_var2_6615113525270005142

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/dsl/src/test/java/org/cloudifysource/dsl/CloudParserTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617881971/fstmerge_var1_976415008657925482
@Test(expected = org.cloudifysource.dsl.internal.DSLValidationException.class)
	public void testValidateDefaultValues_1()
			throws Exception {
		final ComputeTemplate fixture = new ComputeTemplate();
		fixture.setRemoteExecution(RemoteExecutionModes.SSH);
		fixture.setImageId("");
		fixture.setOptions(new HashMap());
		fixture.setHardwareId("");
		fixture.setRemoteDirectory((String) null);
		fixture.setNumberOfCores(1);
		fixture.setFileTransfer(FileTransferModes.CIFS);
		fixture.setCustom(new HashMap());
		fixture.setUsername("");
		fixture.setLocationId("");
		fixture.setOverrides(new HashMap());
		fixture.setPassword("");
		fixture.setMachineMemoryMB(1);

		fixture.validateDefaultValues(new DSLValidationContext());

		// add additional test code here
		// unverified
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617881971/fstmerge_base_8138767742883503066
@Test(expected = org.cloudifysource.dsl.internal.DSLValidationException.class)
	public void testValidateDefaultValues_1()
			throws Exception {
		final CloudTemplate fixture = new CloudTemplate();
		fixture.setRemoteExecution(RemoteExecutionModes.SSH);
		fixture.setImageId("");
		fixture.setOptions(new HashMap());
		fixture.setHardwareId("");
		fixture.setRemoteDirectory((String) null);
		fixture.setNumberOfCores(1);
		fixture.setFileTransfer(FileTransferModes.CIFS);
		fixture.setCustom(new HashMap());
		fixture.setUsername("");
		fixture.setLocationId("");
		fixture.setOverrides(new HashMap());
		fixture.setPassword("");
		fixture.setMachineMemoryMB(1);

		fixture.validateDefaultValues(new DSLValidationContext());

		// add additional test code here
		// unverified
=======
@Test(expected = org.cloudifysource.dsl.internal.DSLValidationException.class)
	public void testValidateDefaultValues_1()
			throws Exception {
		final CloudTemplate fixture = new CloudTemplate();
		fixture.setRemoteExecution(RemoteExecutionModes.SSH);
		fixture.setImageId("");
		fixture.setOptions(new HashMap());
		fixture.setHardwareId("");
		fixture.setRemoteDirectory((String) null);
		fixture.setNumberOfCores(1);
		fixture.setFileTransfer(FileTransferModes.CIFS);
		fixture.setCustom(new HashMap());
		fixture.setUsername("");
		fixture.setLocationId("");
		fixture.setOverrides(new HashMap());
		fixture.setPassword("");
		fixture.setMachineMemoryMB(1);

		fixture.validateDefaultValues(new DSLValidationContext());

		// add additional test code here
		// unverified
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617881971/fstmerge_var2_8215319680136568960
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/dsl/src/test/java/org/cloudifysource/dsl/cloud/CloudTemplateTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617881976/fstmerge_var1_6978764656958221590
@Test(expected = org.cloudifysource.dsl.internal.DSLValidationException.class)
	public void testValidateDefaultValues_2()
			throws Exception {
		final ComputeTemplate fixture = new ComputeTemplate();
		fixture.setRemoteExecution(RemoteExecutionModes.SSH);
		fixture.setImageId("");
		fixture.setOptions(new HashMap());
		fixture.setHardwareId("");
		fixture.setRemoteDirectory("");
		fixture.setNumberOfCores(1);
		fixture.setFileTransfer(FileTransferModes.CIFS);
		fixture.setCustom(new HashMap());
		fixture.setUsername("");
		fixture.setLocationId("");
		fixture.setOverrides(new HashMap());
		fixture.setPassword("");
		fixture.setMachineMemoryMB(1);

		fixture.validateDefaultValues(new DSLValidationContext());

		// add additional test code here
		// unverified
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617881976/fstmerge_base_4263555172924996809
@Test(expected = org.cloudifysource.dsl.internal.DSLValidationException.class)
	public void testValidateDefaultValues_2()
			throws Exception {
		final CloudTemplate fixture = new CloudTemplate();
		fixture.setRemoteExecution(RemoteExecutionModes.SSH);
		fixture.setImageId("");
		fixture.setOptions(new HashMap());
		fixture.setHardwareId("");
		fixture.setRemoteDirectory("");
		fixture.setNumberOfCores(1);
		fixture.setFileTransfer(FileTransferModes.CIFS);
		fixture.setCustom(new HashMap());
		fixture.setUsername("");
		fixture.setLocationId("");
		fixture.setOverrides(new HashMap());
		fixture.setPassword("");
		fixture.setMachineMemoryMB(1);

		fixture.validateDefaultValues(new DSLValidationContext());

		// add additional test code here
		// unverified
=======
@Test(expected = org.cloudifysource.dsl.internal.DSLValidationException.class)
	public void testValidateDefaultValues_2()
			throws Exception {
		final CloudTemplate fixture = new CloudTemplate();
		fixture.setRemoteExecution(RemoteExecutionModes.SSH);
		fixture.setImageId("");
		fixture.setOptions(new HashMap());
		fixture.setHardwareId("");
		fixture.setRemoteDirectory("");
		fixture.setNumberOfCores(1);
		fixture.setFileTransfer(FileTransferModes.CIFS);
		fixture.setCustom(new HashMap());
		fixture.setUsername("");
		fixture.setLocationId("");
		fixture.setOverrides(new HashMap());
		fixture.setPassword("");
		fixture.setMachineMemoryMB(1);

		fixture.validateDefaultValues(new DSLValidationContext());

		// add additional test code here
		// unverified
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617881976/fstmerge_var2_5255560023580908325
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/dsl/src/test/java/org/cloudifysource/dsl/cloud/CloudTemplateTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617881981/fstmerge_var1_6259641179900781791
@Test(expected = org.cloudifysource.dsl.internal.DSLValidationException.class)
	public void testValidateDefaultValues_3()
			throws Exception {
		final ComputeTemplate fixture = new ComputeTemplate();
		fixture.setRemoteExecution(RemoteExecutionModes.SSH);
		fixture.setImageId("");
		fixture.setOptions(new HashMap());
		fixture.setHardwareId("");
		fixture.setRemoteDirectory("");
		fixture.setNumberOfCores(1);
		fixture.setFileTransfer(FileTransferModes.CIFS);
		fixture.setCustom(new HashMap());
		fixture.setUsername("");
		fixture.setLocationId("");
		fixture.setOverrides(new HashMap());
		fixture.setPassword("");
		fixture.setMachineMemoryMB(1);

		fixture.validateDefaultValues(new DSLValidationContext());

		// add additional test code here
		// unverified
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617881981/fstmerge_base_1943985091407963378
@Test(expected = org.cloudifysource.dsl.internal.DSLValidationException.class)
	public void testValidateDefaultValues_3()
			throws Exception {
		final CloudTemplate fixture = new CloudTemplate();
		fixture.setRemoteExecution(RemoteExecutionModes.SSH);
		fixture.setImageId("");
		fixture.setOptions(new HashMap());
		fixture.setHardwareId("");
		fixture.setRemoteDirectory("");
		fixture.setNumberOfCores(1);
		fixture.setFileTransfer(FileTransferModes.CIFS);
		fixture.setCustom(new HashMap());
		fixture.setUsername("");
		fixture.setLocationId("");
		fixture.setOverrides(new HashMap());
		fixture.setPassword("");
		fixture.setMachineMemoryMB(1);

		fixture.validateDefaultValues(new DSLValidationContext());

		// add additional test code here
		// unverified
=======
@Test(expected = org.cloudifysource.dsl.internal.DSLValidationException.class)
	public void testValidateDefaultValues_3()
			throws Exception {
		final CloudTemplate fixture = new CloudTemplate();
		fixture.setRemoteExecution(RemoteExecutionModes.SSH);
		fixture.setImageId("");
		fixture.setOptions(new HashMap());
		fixture.setHardwareId("");
		fixture.setRemoteDirectory("");
		fixture.setNumberOfCores(1);
		fixture.setFileTransfer(FileTransferModes.CIFS);
		fixture.setCustom(new HashMap());
		fixture.setUsername("");
		fixture.setLocationId("");
		fixture.setOverrides(new HashMap());
		fixture.setPassword("");
		fixture.setMachineMemoryMB(1);

		fixture.validateDefaultValues(new DSLValidationContext());

		// add additional test code here
		// unverified
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617881981/fstmerge_var2_1682881527781287089
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/dsl/src/test/java/org/cloudifysource/dsl/cloud/CloudTemplateTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883462/fstmerge_var1_161275133991439907
@PostConstruct
	public void init() {
		logger.info("Initializing service controller cloud configuration");
		this.cloud = readCloud();
		if (cloud != null) {
			initCloudTemplates();
			if (this.cloud.getCloudCompute().getTemplates().isEmpty()) {
				throw new IllegalArgumentException(
						"No templates defined in cloud configuration!");
			}
			this.defaultTemplateName = this.cloud.getCloudCompute().getTemplates().keySet()
					.iterator().next();
			logger.info("Setting default template name to: "
					+ defaultTemplateName
					+ ". This template will be used for services that do not specify an explicit template");

			this.managementTemplate = this.cloud.getCloudCompute().getTemplates().get(
					this.cloud.getConfiguration()
							.getManagementMachineTemplate());
		} else {
			logger.info("Service Controller is running in local cloud mode");
		}

		/**
		 * Sets the folder used for temporary files. The value can be set in the configuration file
		 * ("config.properties"), otherwise the system's default setting will apply.
		 */
		try {
			if (StringUtils.isBlank(temporaryFolder)) {
				temporaryFolder = getTempFolderPath();
			}
		} catch (final IOException e) {
			logger.log(Level.SEVERE,
					"ServiceController failed to locate temp directory", e);
			throw new IllegalStateException(
					"ServiceController failed to locate temp directory", e);
		}

		startLifecycleLogsCleanupTask();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883462/fstmerge_base_5686721734784465983
@PostConstruct
	public void init() {
		logger.info("Initializing service controller cloud configuration");
		this.cloud = readCloud();
		if (cloud != null) {
			initCloudTemplates();
			if (this.cloud.getTemplates().isEmpty()) {
				throw new IllegalArgumentException(
						"No templates defined in cloud configuration!");
			}
			this.defaultTemplateName = this.cloud.getTemplates().keySet()
					.iterator().next();
			logger.info("Setting default template name to: "
					+ defaultTemplateName
					+ ". This template will be used for services that do not specify an explicit template");

			this.managementTemplate = this.cloud.getTemplates().get(
					this.cloud.getConfiguration()
					.getManagementMachineTemplate());
		} else {
			logger.info("Service Controller is running in local cloud mode");
		}

		/**
		 * Sets the folder used for temporary files. The value can be set in the
		 * configuration file ("config.properties"), otherwise the system's
		 * default setting will apply.
		 */
		try {
			if (StringUtils.isBlank(temporaryFolder)) {
				temporaryFolder = getTempFolderPath();
			}
		} catch (final IOException e) {
			logger.log(Level.SEVERE,
					"ServiceController failed to locate temp directory", e);
			throw new IllegalStateException(
					"ServiceController failed to locate temp directory", e);
		}

		startLifecycleLogsCleanupTask();
=======
@PostConstruct
	public void init() {
		logger.info("Initializing service controller cloud configuration");
		this.cloud = readCloud();
		if (cloud != null) {
			initCloudTemplates();
			if (this.cloud.getTemplates().isEmpty()) {
				throw new IllegalArgumentException(
						"No templates defined in cloud configuration!");
			}
			this.defaultTemplateName = this.cloud.getTemplates().keySet()
					.iterator().next();
			logger.info("Setting default template name to: "
					+ defaultTemplateName
					+ ". This template will be used for services that do not specify an explicit template");

			this.managementTemplate = this.cloud.getTemplates().get(
					this.cloud.getConfiguration()
							.getManagementMachineTemplate());
		} else {
			logger.info("Service Controller is running in local cloud mode");
		}

		/**
		 * Sets the folder used for temporary files. The value can be set in the configuration file
		 * ("config.properties"), otherwise the system's default setting will apply.
		 */
		try {
			if (StringUtils.isBlank(temporaryFolder)) {
				temporaryFolder = getTempFolderPath();
			}
		} catch (final IOException e) {
			logger.log(Level.SEVERE,
					"ServiceController failed to locate temp directory", e);
			throw new IllegalStateException(
					"ServiceController failed to locate temp directory", e);
		}

		startLifecycleLogsCleanupTask();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883462/fstmerge_var2_4299935029716658829
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883508/fstmerge_var1_5127433990819389880
private void initCloudTemplates() {
		final File additionalTemplatesFolder = new File(cloudConfigurationDir,
				CloudifyConstants.ADDITIONAL_TEMPLATES_FOLDER_NAME);
		logger.info("initCloudTemplates - Adding templates from folder: "
				+ additionalTemplatesFolder.getAbsolutePath());
		if (!additionalTemplatesFolder.exists()) {
			logger.info("initCloudTemplates - no templates to add from folder: "
					+ additionalTemplatesFolder.getAbsolutePath());
			return;
		}
		File[] listFiles = additionalTemplatesFolder.listFiles();
		ComputeTemplatesReader reader = new ComputeTemplatesReader();
		List<ComputeTemplate> addedTemplates = reader.addAdditionalTemplates(cloud, listFiles);
		logger.info("initCloudTemplates - Added the following templates: " + addedTemplates);
		lastTemplateFileNum.addAndGet(listFiles.length);

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883508/fstmerge_base_6997835846107953757
private void initCloudTemplates() {
		File additionalTemplatesFolder = new File(cloudConfigurationDir,
				CloudifyConstants.ADDITIONAL_TEMPLATES_FOLDER_NAME);
		logger.info("initCloudTemplates - Adding templates from folder: "
				+ additionalTemplatesFolder.getAbsolutePath());
		if (!additionalTemplatesFolder.exists()) {
			logger.info("initCloudTemplates - no templates to add from folder: "
					+ additionalTemplatesFolder.getAbsolutePath());
			return;
		}
		File[] listFiles = additionalTemplatesFolder.listFiles();
		CloudTemplatesReader reader = new CloudTemplatesReader();
		List<CloudTemplate> addedTemplates = reader.addAdditionalTemplates(cloud, listFiles);
		logger.info("initCloudTemplates - Added the following templates: " + addedTemplates);
		lastTemplateFileNum.addAndGet(listFiles.length);

=======
private void initCloudTemplates() {
		final File additionalTemplatesFolder = new File(cloudConfigurationDir,
				CloudifyConstants.ADDITIONAL_TEMPLATES_FOLDER_NAME);
		logger.info("initCloudTemplates - Adding templates from folder: "
				+ additionalTemplatesFolder.getAbsolutePath());
		if (!additionalTemplatesFolder.exists()) {
			logger.info("initCloudTemplates - no templates to add from folder: "
					+ additionalTemplatesFolder.getAbsolutePath());
			return;
		}
		final File[] listFiles = additionalTemplatesFolder.listFiles();
		final CloudTemplatesReader reader = new CloudTemplatesReader();
		final List<CloudTemplate> addedTemplates = reader.addAdditionalTemplates(cloud, listFiles);
		logger.info("initCloudTemplates - Added the following templates: " + addedTemplates);
		lastTemplateFileNum.addAndGet(listFiles.length);

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883508/fstmerge_var2_340364788699727953
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883649/fstmerge_var1_6534560686132124014
@JsonRequestExample(requestBody = "{\"applicationName\" : \"petclinic\" , \"srcFile\" :"
			+ " \"packaged application file\" "
			+ ", \"recipeOverridesFile\" : \"recipe overrides file\"}")
	@JsonResponseExample(status = "success", responseBody = "{\"serviceOrder\":\"[mongod,mongoConfig,"
			+ "apacheLB,mongos,tomcat]\""
			+ ",\"lifecycleEventContainerID\":\"07db2a16-62f8-4669-ac41-ed9afe3a3b02\"}", comments = "")
	@PossibleResponseStatuses(responseStatuses = {
			@PossibleResponseStatus(code = HTTP_OK, description = "success"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, description = "DSLException"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, description = "IOException") })
	@RequestMapping(value = "applications/{applicationName}/timeout/{timeout}", method = RequestMethod.POST)
	@PreAuthorize("isFullyAuthenticated() and hasPermission(#authGroups, 'deploy')")
	@ResponseBody
	public Object deployApplication(
			@PathVariable final String applicationName,
			@PathVariable final int timeout,
			@RequestParam(value = "file", required = true) final MultipartFile srcFile,
			@RequestParam(value = "authGroups", required = false) final String authGroups,
			@RequestParam(value = APPLICATION_OVERRIDES_FILE_PARAM, required = false) final MultipartFile recipeOverridesFile,
			@RequestParam(value = CLOUD_OVERRIDES_FILE_PARAM, required = false) final MultipartFile cloudOverrides,
			@RequestParam(value = "selfHealing", required = false) final Boolean selfHealing)
			throws IOException, DSLException, RestErrorException {
		boolean actualSelfHealing = true;
		if (selfHealing != null && !selfHealing) {
			actualSelfHealing = false;
		}
		final File applicationFile = copyMultipartFileToLocalFile(srcFile);

		String effectiveAuthGroups = authGroups;
		if (StringUtils.isBlank(effectiveAuthGroups)) {
			if (permissionEvaluator != null) {
				effectiveAuthGroups = permissionEvaluator.getUserAuthGroupsString();
			} else {
				effectiveAuthGroups = "";
			}
		}

		final File applicationOverridesFile = copyMultipartFileToLocalFile(recipeOverridesFile);
		final File cloudOverridesFile = copyMultipartFileToLocalFile(cloudOverrides);
		final Object returnObject = doDeployApplication(
				applicationName,
				applicationFile,
				applicationOverridesFile,
				effectiveAuthGroups,
				timeout,
				actualSelfHealing,
				cloudOverridesFile);
		FileUtils.deleteQuietly(applicationOverridesFile);
		applicationFile.delete();
		return returnObject;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883649/fstmerge_base_1094795400720384467
@JsonRequestExample(requestBody = "{\"applicationName\" : \"petclinic\" , \"srcFile\" :"
			+ " \"packaged application file\" "
			+ ", \"recipeOverridesFile\" : \"recipe overrides file\"}")
	@JsonResponseExample(status = "success", responseBody = "{\"srviceOrder\":\"[mongod,mongoConfig,"
			+ "apacheLB,mongos,tomcat]\""
			+ ",\"lifecycleEventContainerID\":\"07db2a16-62f8-4669-ac41-ed9afe3a3b02\"}", comments = "")
	@PossibleResponseStatuses(responseStatuses = {
			@PossibleResponseStatus(code = HTTP_OK, description = "success"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, description = "DSLException"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, description = "IOException") })
	@RequestMapping(value = "applications/{applicationName}/timeout/{timeout}", method = RequestMethod.POST)
	@PreAuthorize("isFullyAuthenticated() and hasPermission(#authGroups, 'deploy')")
	@ResponseBody
	public Object deployApplication(
			@PathVariable final String applicationName,
			@PathVariable final int timeout,
			@RequestParam(value = "file", required = true) final MultipartFile srcFile,
			@RequestParam(value = "authGroups", required = false) final String authGroups,
			@RequestParam(value = APPLICATION_OVERRIDES_FILE_PARAM, required = false) 
			final MultipartFile recipeOverridesFile,
			@RequestParam(value = CLOUD_OVERRIDES_FILE_PARAM, required = false) final MultipartFile cloudOverrides,
			@RequestParam(value = "selfHealing", required = false) final Boolean selfHealing)
					throws IOException, DSLException, RestErrorException {
		boolean actualSelfHealing = true;
		if (selfHealing != null && !selfHealing) {
			actualSelfHealing = false;
		}
		final File applicationFile = copyMultipartFileToLocalFile(srcFile);

		String effectiveAuthGroups = authGroups;
		if (StringUtils.isBlank(effectiveAuthGroups)) {
			if (permissionEvaluator != null) {
				effectiveAuthGroups = permissionEvaluator.getUserAuthGroupsString();
			} else {
				effectiveAuthGroups = "";
			}
		}

		final File applicationOverridesFile = copyMultipartFileToLocalFile(recipeOverridesFile);
		final File cloudOverridesFile = copyMultipartFileToLocalFile(cloudOverrides);
		final Object returnObject = doDeployApplication(
				applicationName,
				applicationFile,
				applicationOverridesFile,
				effectiveAuthGroups,
				timeout,
				actualSelfHealing,
				cloudOverridesFile);
		FileUtils.deleteQuietly(applicationOverridesFile);
		applicationFile.delete();
		return returnObject;
=======
@JsonRequestExample(requestBody = "{\"applicationName\" : \"petclinic\" , \"srcFile\" :"
			+ " \"packaged application file\" "
			+ ", \"recipeOverridesFile\" : \"recipe overrides file\"}")
	@JsonResponseExample(status = "success", responseBody = "{\"srviceOrder\":\"[mongod,mongoConfig,"
			+ "apacheLB,mongos,tomcat]\""
			+ ",\"lifecycleEventContainerID\":\"07db2a16-62f8-4669-ac41-ed9afe3a3b02\"}", comments = "")
	@PossibleResponseStatuses(responseStatuses = {
			@PossibleResponseStatus(code = HTTP_OK, description = "success"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, description = "DSLException"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, description = "IOException") })
	@RequestMapping(value = "applications/{applicationName}/timeout/{timeout}", method = RequestMethod.POST)
	@PreAuthorize("isFullyAuthenticated() and hasPermission(#authGroups, 'deploy')")
	@ResponseBody
	public Object deployApplication(
			@PathVariable final String applicationName,
			@PathVariable final int timeout,
			@RequestParam(value = "file", required = true) final MultipartFile srcFile,
			@RequestParam(value = "authGroups", required = false) final String authGroups,
			@RequestParam(value = APPLICATION_OVERRIDES_FILE_PARAM, required = false) final MultipartFile recipeOverridesFile,
			@RequestParam(value = CLOUD_OVERRIDES_FILE_PARAM, required = false) final MultipartFile cloudOverrides,
			@RequestParam(value = "selfHealing", required = false) final Boolean selfHealing)
			throws IOException, DSLException, RestErrorException {
		boolean actualSelfHealing = true;
		if (selfHealing != null && !selfHealing) {
			actualSelfHealing = false;
		}
		final File applicationFile = copyMultipartFileToLocalFile(srcFile);

		String effectiveAuthGroups = authGroups;
		if (StringUtils.isBlank(effectiveAuthGroups)) {
			if (permissionEvaluator != null) {
				effectiveAuthGroups = permissionEvaluator.getUserAuthGroupsString();
			} else {
				effectiveAuthGroups = "";
			}
		}

		final File applicationOverridesFile = copyMultipartFileToLocalFile(recipeOverridesFile);
		final File cloudOverridesFile = copyMultipartFileToLocalFile(cloudOverrides);
		final Object returnObject = doDeployApplication(
				applicationName,
				applicationFile,
				applicationOverridesFile,
				effectiveAuthGroups,
				timeout,
				actualSelfHealing,
				cloudOverridesFile);
		FileUtils.deleteQuietly(applicationOverridesFile);
		applicationFile.delete();
		return returnObject;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883649/fstmerge_var2_3599012608520522999
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883749/fstmerge_var1_1631244550797165603
private void doDeploy(
			final String applicationName,
			final String serviceName,
			final String authGroups,
			final String templateName,
			final String[] agentZones,
			final File serviceFile,
			final Properties contextProperties,
			final Service service,
			final byte[] serviceCloudConfigurationContents,
			final boolean selfHealing,
			final File cloudOverrides) throws TimeoutException, DSLException, IOException, RestErrorException {

		boolean locationAware = false;
		boolean dedicated = true;
		if (service != null) {
			locationAware = service.isLocationAware();
			dedicated = IsolationUtils.isDedicated(service);
		}

		final int externalProcessMemoryInMB = 512;
		final int containerMemoryInMB = 128;
		final int reservedMemoryCapacityPerMachineInMB = 256;

		contextProperties.setProperty(CloudifyConstants.CONTEXT_PROPERTY_ASYNC_INSTALL,
				"true");
		if (!selfHealing) {
			contextProperties.setProperty(
					CloudifyConstants.CONTEXT_PROPERTY_DISABLE_SELF_HEALING,
					"false");
		}

		final ElasticStatelessProcessingUnitDeployment deployment =
				new ElasticStatelessProcessingUnitDeployment(serviceFile)
						.memoryCapacityPerContainer(externalProcessMemoryInMB, MemoryUnit.MEGABYTES)
						.addCommandLineArgument("-Xmx" + containerMemoryInMB + "m")
						.addCommandLineArgument("-Xms" + containerMemoryInMB + "m")
						.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME, applicationName)
						.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_AUTH_GROUPS, authGroups)
						.name(serviceName);
		if (cloud == null) { // Azure or local-cloud
			if (!isLocalCloud()) {
				// Azure: Eager scale (1 container per machine per PU)
				setSharedMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				deployment.scale(ElasticScaleConfigFactory
						.createEagerScaleConfig());
			} else {
				// local cloud
				setPublicMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				if (service == null || service.getScalingRules() == null) {
					final int totalMemoryInMB = calculateTotalMemoryInMB(
							serviceName, service, externalProcessMemoryInMB);
					final ManualCapacityScaleConfig scaleConfig = new ManualCapacityScaleConfigurer()
							.memoryCapacity(totalMemoryInMB, MemoryUnit.MEGABYTES).create();
					deployment.scale(scaleConfig);
				} else {
					final AutomaticCapacityScaleConfig scaleConfig = ElasticScaleConfigFactory
							.createAutomaticCapacityScaleConfig(serviceName,
									service, externalProcessMemoryInMB, false, false);
					deployment.scale(scaleConfig);
				}
			}
		} else {
			
			deployment.addCommandLineArgument("-Xmx" + cloud.getConfiguration().getComponents().getUsm().getMaxMemory())
			.addCommandLineArgument("-Xms" + cloud.getConfiguration().getComponents().getUsm().getMinMemory())
			.addCommandLineArgument("-D" + CloudifyConstants.LRMI_BIND_PORT_CONTEXT_PROPERTY + "=" 
									+ cloud.getConfiguration().getComponents().getUsm().getPortRange());

			final ComputeTemplate template = getComputeTemplate(cloud, templateName);

			long cloudExternalProcessMemoryInMB = 0;

			if (dedicated) {
				cloudExternalProcessMemoryInMB = calculateExternalProcessMemory(cloud, template);
			} else {
				cloudExternalProcessMemoryInMB = IsolationUtils.getInstanceMemoryMB(service);
			}

			logger.info("Creating cloud machine provisioning config. Template remote directory is: "
					+ template.getRemoteDirectory());

			final CloudifyMachineProvisioningConfig config = new CloudifyMachineProvisioningConfig(
					cloud, template, templateName, this.managementTemplate.getRemoteDirectory(), 
					service.getStorage().getTemplate());
			config.setAuthGroups(authGroups);
			if (cloudOverrides != null) {
				if (logger.isLoggable(Level.FINE)) {
					logger.fine("Recieved request for installation of "
							+ serviceName + " with cloud overrides parameters [ "
							+ FileUtils.readFileToString(cloudOverrides) + "]");
				}
				config.setCloudOverridesPerService(cloudOverrides);
			} else {
				if (logger.isLoggable(Level.FINE)) {
					logger.fine("No cloud overrides parameters were requested for the installation of "
							+ serviceName);
				}
			}
			if (serviceCloudConfigurationContents != null) {
				config.setServiceCloudConfiguration(serviceCloudConfigurationContents);
			}

			final String locators = extractLocators(admin);
			config.setLocator(locators);

			if (IsolationUtils.isUseManagement(service)) {
				config.setDedicatedManagementMachines(false);
			} else {
				config.setDedicatedManagementMachines(true);
			}
			if (dedicated) {
				// service deployment will have a dedicated agent per instance
				setDedicatedMachineProvisioning(deployment, config);
			} else {

				// check what mode of isolation we should use
				if (IsolationUtils.isGlobal(service)) {
					logger.info("global mode is on. will use public machine provisioning for "
							+ serviceName + " deployment.");
					logger.info("isolationSLA = " + service.getIsolationSLA());
					// service instances can be deployed across all agents
					setPublicMachineProvisioning(deployment, config);

				} else if (IsolationUtils.isAppShared(service)) {
					logger.info("app shared mode is on. will use shared machine provisioning for "
							+ serviceName + " deployment. isolation id = " + applicationName);
					// service instances can be deployed across all agents with the correct isolation id
					setSharedMachineProvisioning(deployment, config, applicationName);
				} else if (IsolationUtils.isTenantShared(service)) {
					if (authGroups == null) {
						throw new IllegalStateException("authGroups cannot be null when using tenant shared isolation");
					}
					logger.info("tenant shared mode is on. will use shared machine provisioning for "
							+ serviceName + " deployment. isolation id = " + authGroups);
					// service instances can be deployed across all agents with the correct isolation id
					setSharedMachineProvisioning(deployment, config, authGroups);
				}
			}

			deployment.memoryCapacityPerContainer((int) cloudExternalProcessMemoryInMB, MemoryUnit.MEGABYTES);
			if (service == null || service.getScalingRules() == null) {
				final int totalMemoryInMB = calculateTotalMemoryInMB(
						serviceName, service,
						(int) cloudExternalProcessMemoryInMB);
				final double totalCpuCores = calculateTotalCpuCores(service);
				final ManualCapacityScaleConfig scaleConfig = ElasticScaleConfigFactory
						.createManualCapacityScaleConfig(totalMemoryInMB,
								totalCpuCores, locationAware, dedicated);
				deployment.scale(scaleConfig);
			} else {
				final AutomaticCapacityScaleConfig scaleConfig = ElasticScaleConfigFactory
						.createAutomaticCapacityScaleConfig(serviceName,
								service, (int) cloudExternalProcessMemoryInMB,
								locationAware, dedicated);
				deployment.scale(scaleConfig);
			}
		}

		// add context properties
		setContextProperties(deployment, contextProperties);
		verifyEsmExistsInCluster();
		deployAndWait(serviceName, deployment);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883749/fstmerge_base_6678788595902081407
private void doDeploy(
			final String applicationName,
			final String serviceName,
			final String authGroups,
			final String templateName,
			final String[] agentZones,
			final File serviceFile,
			final Properties contextProperties,
			final Service service,
			final byte[] serviceCloudConfigurationContents,
			final boolean selfHealing,
			final File cloudOverrides) throws TimeoutException, DSLException, IOException, RestErrorException {

		boolean locationAware = false;
		boolean dedicated = true;
		if (service != null) {
			locationAware = service.isLocationAware();
			dedicated = IsolationUtils.isDedicated(service);
		}

		final int externalProcessMemoryInMB = 512;
		final int containerMemoryInMB = 128;
		final int reservedMemoryCapacityPerMachineInMB = 256;

		contextProperties.setProperty(CloudifyConstants.CONTEXT_PROPERTY_ASYNC_INSTALL,
				"true");
		if (!selfHealing) {
			contextProperties.setProperty(
					CloudifyConstants.CONTEXT_PROPERTY_DISABLE_SELF_HEALING,
					"false");
		}

		final ElasticStatelessProcessingUnitDeployment deployment =
				new ElasticStatelessProcessingUnitDeployment(serviceFile)
		.memoryCapacityPerContainer(externalProcessMemoryInMB, MemoryUnit.MEGABYTES)
		.addCommandLineArgument("-Xmx" + containerMemoryInMB + "m")
		.addCommandLineArgument("-Xms" + containerMemoryInMB + "m")
		.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME, applicationName)
		.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_AUTH_GROUPS, authGroups)
		.name(serviceName);
		if (cloud == null) { // Azure or local-cloud
			if (!isLocalCloud()) {
				// Azure: Eager scale (1 container per machine per PU)
				setSharedMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				deployment.scale(ElasticScaleConfigFactory
						.createEagerScaleConfig());
			} else {
				// local cloud
				setPublicMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				if (service == null || service.getScalingRules() == null) {
					final int totalMemoryInMB = calculateTotalMemoryInMB(
							serviceName, service, externalProcessMemoryInMB);
					final ManualCapacityScaleConfig scaleConfig = new ManualCapacityScaleConfigurer()
					.memoryCapacity(totalMemoryInMB, MemoryUnit.MEGABYTES).create();
					deployment.scale(scaleConfig);
				} else {
					final AutomaticCapacityScaleConfig scaleConfig = ElasticScaleConfigFactory
							.createAutomaticCapacityScaleConfig(serviceName,
									service, externalProcessMemoryInMB, false, false);
					deployment.scale(scaleConfig);
				}
			}
		} else {
			final CloudTemplate template = getComputeTemplate(cloud, templateName);


			long cloudExternalProcessMemoryInMB = 0;

			if (dedicated) {
				cloudExternalProcessMemoryInMB = calculateExternalProcessMemory(cloud, template);
			} else {
				cloudExternalProcessMemoryInMB = IsolationUtils.getInstanceMemoryMB(service);
			}


			logger.info("Creating cloud machine provisioning config. Template remote directory is: "
					+ template.getRemoteDirectory());
						
			final CloudifyMachineProvisioningConfig config = new CloudifyMachineProvisioningConfig(
					cloud, template, templateName, this.managementTemplate.getRemoteDirectory());
			config.setAuthGroups(authGroups);
			if (cloudOverrides != null) {
				if (logger.isLoggable(Level.FINE)) {
					logger.fine("Recieved request for installation of "
							+ serviceName + " with cloud overrides parameters [ "
							+ FileUtils.readFileToString(cloudOverrides) + "]");
				}
				config.setCloudOverridesPerService(cloudOverrides);
			} else {
				if (logger.isLoggable(Level.FINE)) {
					logger.fine("No cloud overrides parameters were requested for the installation of "
							+ serviceName);
				}
			}
			if (serviceCloudConfigurationContents != null) {
				config.setServiceCloudConfiguration(serviceCloudConfigurationContents);
			}

			final String locators = extractLocators(admin);
			config.setLocator(locators);

			if (IsolationUtils.isUseManagement(service)) {
				config.setDedicatedManagementMachines(false);
			} else {
				config.setDedicatedManagementMachines(true);
			}
			if (dedicated) {
				// service deployment will have a dedicated agent per instance
				setDedicatedMachineProvisioning(deployment, config);
			} else {

				// check what mode of isolation we should use
				if (IsolationUtils.isGlobal(service)) {
					logger.info("global mode is on. will use public machine provisioning for "
							+ serviceName + " deployment.");
					logger.info("isolationSLA = " + service.getIsolationSLA());
					// service instances can be deployed across all agents
					setPublicMachineProvisioning(deployment, config);
					
					
					
				} else if (IsolationUtils.isAppShared(service)) {
					logger.info("app shared mode is on. will use shared machine provisioning for "
							+ serviceName + " deployment. isolation id = " + applicationName);
					// service instances can be deployed across all agents with the correct isolation id
					setSharedMachineProvisioning(deployment, config, applicationName);
				} else if (IsolationUtils.isTenantShared(service)) {
					if (authGroups == null) {
						throw new IllegalStateException("authGroups cannot be null when using tenant shared isolation");
					}
					logger.info("tenant shared mode is on. will use shared machine provisioning for "
							+ serviceName + " deployment. isolation id = " + authGroups);
					// service instances can be deployed across all agents with the correct isolation id
					setSharedMachineProvisioning(deployment, config, authGroups);
				}
			}

			deployment.memoryCapacityPerContainer((int) cloudExternalProcessMemoryInMB, MemoryUnit.MEGABYTES);
			if (service == null || service.getScalingRules() == null) {
				final int totalMemoryInMB = calculateTotalMemoryInMB(
						serviceName, service,
						(int) cloudExternalProcessMemoryInMB);
				final double totalCpuCores = calculateTotalCpuCores(service);
				final ManualCapacityScaleConfig scaleConfig = ElasticScaleConfigFactory
						.createManualCapacityScaleConfig(totalMemoryInMB,
								totalCpuCores, locationAware, dedicated);
				deployment.scale(scaleConfig);
			} else {
				final AutomaticCapacityScaleConfig scaleConfig = ElasticScaleConfigFactory
						.createAutomaticCapacityScaleConfig(serviceName,
								service, (int) cloudExternalProcessMemoryInMB,
								locationAware, dedicated);
				deployment.scale(scaleConfig);
			}
		}

		// add context properties
		setContextProperties(deployment, contextProperties);
		verifyEsmExistsInCluster();
		deployAndWait(serviceName, deployment);
=======
private void doDeploy(
			final String applicationName,
			final String serviceName,
			final String authGroups,
			final String templateName,
			final String[] agentZones,
			final File serviceFile,
			final Properties contextProperties,
			final Service service,
			final byte[] serviceCloudConfigurationContents,
			final boolean selfHealing,
			final File cloudOverrides) throws TimeoutException, DSLException, IOException, RestErrorException {

		boolean locationAware = false;
		boolean dedicated = true;
		if (service != null) {
			locationAware = service.isLocationAware();
			dedicated = IsolationUtils.isDedicated(service);
		}

		final int externalProcessMemoryInMB = 512;
		final int containerMemoryInMB = 128;
		final int reservedMemoryCapacityPerMachineInMB = 256;

		contextProperties.setProperty(CloudifyConstants.CONTEXT_PROPERTY_ASYNC_INSTALL,
				"true");
		if (!selfHealing) {
			contextProperties.setProperty(
					CloudifyConstants.CONTEXT_PROPERTY_DISABLE_SELF_HEALING,
					"false");
		}

		final ElasticStatelessProcessingUnitDeployment deployment =
				new ElasticStatelessProcessingUnitDeployment(serviceFile)
						.memoryCapacityPerContainer(externalProcessMemoryInMB, MemoryUnit.MEGABYTES)
						.addCommandLineArgument("-Xmx" + containerMemoryInMB + "m")
						.addCommandLineArgument("-Xms" + containerMemoryInMB + "m")
						.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME, applicationName)
						.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_AUTH_GROUPS, authGroups)
						.name(serviceName);
		if (cloud == null) { // Azure or local-cloud
			if (!isLocalCloud()) {
				// Azure: Eager scale (1 container per machine per PU)
				setSharedMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				deployment.scale(ElasticScaleConfigFactory
						.createEagerScaleConfig());
			} else {
				// local cloud
				setPublicMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				if (service == null || service.getScalingRules() == null) {
					final int totalMemoryInMB = calculateTotalMemoryInMB(
							serviceName, service, externalProcessMemoryInMB);
					final ManualCapacityScaleConfig scaleConfig = new ManualCapacityScaleConfigurer()
							.memoryCapacity(totalMemoryInMB, MemoryUnit.MEGABYTES).create();
					deployment.scale(scaleConfig);
				} else {
					final AutomaticCapacityScaleConfig scaleConfig = ElasticScaleConfigFactory
							.createAutomaticCapacityScaleConfig(serviceName,
									service, externalProcessMemoryInMB, false, false);
					deployment.scale(scaleConfig);
				}
			}
		} else {
			deployment
					.addCommandLineArgument("-Xmx" + cloud.getConfiguration().getComponents().getUsm().getMaxMemory())
					.addCommandLineArgument("-Xms" + cloud.getConfiguration().getComponents().getUsm().getMinMemory())
					.addCommandLineArgument("-D" + CloudifyConstants.LRMI_BIND_PORT_CONTEXT_PROPERTY + "="
							+ cloud.getConfiguration().getComponents().getUsm().getPortRange());

			final CloudTemplate template = getComputeTemplate(cloud, templateName);

			long cloudExternalProcessMemoryInMB = 0;

			if (dedicated) {
				cloudExternalProcessMemoryInMB = calculateExternalProcessMemory(cloud, template);
			} else {
				cloudExternalProcessMemoryInMB = IsolationUtils.getInstanceMemoryMB(service);
			}

			logger.info("Creating cloud machine provisioning config. Template remote directory is: "
					+ template.getRemoteDirectory());

			final CloudifyMachineProvisioningConfig config = new CloudifyMachineProvisioningConfig(
					cloud, template, templateName, this.managementTemplate.getRemoteDirectory());
			config.setAuthGroups(authGroups);
			if (cloudOverrides != null) {
				if (logger.isLoggable(Level.FINE)) {
					logger.fine("Recieved request for installation of "
							+ serviceName + " with cloud overrides parameters [ "
							+ FileUtils.readFileToString(cloudOverrides) + "]");
				}
				config.setCloudOverridesPerService(cloudOverrides);
			} else {
				if (logger.isLoggable(Level.FINE)) {
					logger.fine("No cloud overrides parameters were requested for the installation of "
							+ serviceName);
				}
			}
			if (serviceCloudConfigurationContents != null) {
				config.setServiceCloudConfiguration(serviceCloudConfigurationContents);
			}

			final String locators = extractLocators(admin);
			config.setLocator(locators);

			if (IsolationUtils.isUseManagement(service)) {
				config.setDedicatedManagementMachines(false);
			} else {
				config.setDedicatedManagementMachines(true);
			}
			if (dedicated) {
				// service deployment will have a dedicated agent per instance
				setDedicatedMachineProvisioning(deployment, config);
			} else {

				// check what mode of isolation we should use
				if (IsolationUtils.isGlobal(service)) {
					logger.info("global mode is on. will use public machine provisioning for "
							+ serviceName + " deployment.");
					logger.info("isolationSLA = " + service.getIsolationSLA());
					// service instances can be deployed across all agents
					setPublicMachineProvisioning(deployment, config);

				} else if (IsolationUtils.isAppShared(service)) {
					logger.info("app shared mode is on. will use shared machine provisioning for "
							+ serviceName + " deployment. isolation id = " + applicationName);
					// service instances can be deployed across all agents with the correct isolation id
					setSharedMachineProvisioning(deployment, config, applicationName);
				} else if (IsolationUtils.isTenantShared(service)) {
					if (authGroups == null) {
						throw new IllegalStateException("authGroups cannot be null when using tenant shared isolation");
					}
					logger.info("tenant shared mode is on. will use shared machine provisioning for "
							+ serviceName + " deployment. isolation id = " + authGroups);
					// service instances can be deployed across all agents with the correct isolation id
					setSharedMachineProvisioning(deployment, config, authGroups);
				}
			}

			deployment.memoryCapacityPerContainer((int) cloudExternalProcessMemoryInMB, MemoryUnit.MEGABYTES);
			if (service == null || service.getScalingRules() == null) {
				final int totalMemoryInMB = calculateTotalMemoryInMB(
						serviceName, service,
						(int) cloudExternalProcessMemoryInMB);
				final double totalCpuCores = calculateTotalCpuCores(service);
				final ManualCapacityScaleConfig scaleConfig = ElasticScaleConfigFactory
						.createManualCapacityScaleConfig(totalMemoryInMB,
								totalCpuCores, locationAware, dedicated);
				deployment.scale(scaleConfig);
			} else {
				final AutomaticCapacityScaleConfig scaleConfig = ElasticScaleConfigFactory
						.createAutomaticCapacityScaleConfig(serviceName,
								service, (int) cloudExternalProcessMemoryInMB,
								locationAware, dedicated);
				deployment.scale(scaleConfig);
			}
		}

		// add context properties
		setContextProperties(deployment, contextProperties);
		verifyEsmExistsInCluster();
		deployAndWait(serviceName, deployment);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883749/fstmerge_var2_2284944632232297343
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883774/fstmerge_var1_7163544684644574750
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883774/fstmerge_base_8260810339462484229
private long calculateExternalProcessMemory(final Cloud cloud,
			final CloudTemplate template) throws DSLException {
		// TODO remove hardcoded number
		logger.info("Calculating external proc mem for template: " + template);
		final int machineMemoryMB = template.getMachineMemoryMB();
		final int reservedMemoryCapacityPerMachineInMB = cloud.getProvider()
				.getReservedMemoryCapacityPerMachineInMB();
		final int safteyMargin = 100; // get rid of this constant. see
		// CLOUDIFY-297
		final long cloudExternalProcessMemoryInMB = machineMemoryMB
				- reservedMemoryCapacityPerMachineInMB - safteyMargin;
		if (cloudExternalProcessMemoryInMB <= 0) {
			throw new DSLException("Cloud template machineMemoryMB ("
					+ machineMemoryMB + "MB) must be bigger than "
					+ "reservedMemoryCapacityPerMachineInMB+" + safteyMargin
					+ " ("
					+ (reservedMemoryCapacityPerMachineInMB + safteyMargin)
					+ ")");
		}
		logger.fine("template.machineMemoryMB = "
				+ template.getMachineMemoryMB() + "MB\n"
				+ "cloud.provider.reservedMemoryCapacityPerMachineInMB = "
				+ reservedMemoryCapacityPerMachineInMB + "MB\n"
				+ "cloudExternalProcessMemoryInMB = "
				+ cloudExternalProcessMemoryInMB + "MB"
				+ "cloudExternalProcessMemoryInMB = cloud.machineMemoryMB - "
				+ "cloud.reservedMemoryCapacityPerMachineInMB" + " = "
				+ cloudExternalProcessMemoryInMB);
		return cloudExternalProcessMemoryInMB;
	}
=======
private long calculateExternalProcessMemory(final Cloud cloud,
			final CloudTemplate template) throws DSLException {
		// TODO remove hardcoded number
		logger.info("Calculating external proc mem for template: " + template);
		final int machineMemoryMB = template.getMachineMemoryMB();
		final int reservedMemoryCapacityPerMachineInMB = cloud.getProvider()
				.getReservedMemoryCapacityPerMachineInMB();
		final int safteyMargin = 100; // get rid of this constant. see
		// CLOUDIFY-297
		final long cloudExternalProcessMemoryInMB = machineMemoryMB
				- reservedMemoryCapacityPerMachineInMB - safteyMargin;
		if (cloudExternalProcessMemoryInMB <= 0) {
			throw new DSLException("Cloud template machineMemoryMB ("
					+ machineMemoryMB + "MB) must be bigger than "
					+ "reservedMemoryCapacityPerMachineInMB+" + safteyMargin
					+ " ("
					+ (reservedMemoryCapacityPerMachineInMB + safteyMargin)
					+ ")");
		}
		logger.fine("template.machineMemoryMB = "
				+ template.getMachineMemoryMB() + "MB\n"
				+ "cloud.provider.reservedMemoryCapacityPerMachineInMB = "
				+ reservedMemoryCapacityPerMachineInMB + "MB\n"
				+ "cloudExternalProcessMemoryInMB = "
				+ cloudExternalProcessMemoryInMB + "MB"
				+ "cloudExternalProcessMemoryInMB = cloud.machineMemoryMB - "
				+ "cloud.reservedMemoryCapacityPerMachineInMB" + " = "
				+ cloudExternalProcessMemoryInMB);
		return cloudExternalProcessMemoryInMB;
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883774/fstmerge_var2_5433359549645883465

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883803/fstmerge_var1_750049365292518014
@JsonRequestExample(requestBody = "{\"zone\":5,\"template\":\"SMALL_LINUX\","
			+ "\"file\":\"packaged service file\",\"props\":\"packaged properties file\"}")
	@JsonResponseExample(status = "success", responseBody = "\"b41febb7-f48e-48d4-b14a-a6000d402d93\"")
	@PossibleResponseStatuses(responseStatuses = {
			@PossibleResponseStatus(code = HTTP_OK, description = "success"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, description = "TimeoutException"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, description = "PackagingException"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, description = "IOException"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, description = "AdminException"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, description = "DSLException") })
	@RequestMapping(value = "applications/{applicationName}/services/{serviceName}/timeout/{timeout}",
			method = RequestMethod.POST)
	@PreAuthorize("isFullyAuthenticated() and hasPermission(#authGroups, 'deploy')")
	@ResponseBody
	public Object deployElastic(
			@PathVariable final String applicationName,
			@PathVariable final String serviceName,
			@PathVariable final int timeout,
			@RequestParam(value = "template", required = false) final String templateName,
			@RequestParam(value = "zone", required = true) final String zone,
			@RequestParam(value = "file", required = true) final MultipartFile srcFile,
			@RequestParam(value = "props", required = true) final MultipartFile propsFile,
			@RequestParam(value = "authGroups", required = false) final String authGroups,
			@RequestParam(value = SERVICE_OVERRIDES_FILE_PARAM, required = false) final MultipartFile serviceOverridesFile,
			@RequestParam(value = CLOUD_OVERRIDES_FILE_PARAM, required = false) final MultipartFile cloudOverridesFile,
			@RequestParam(value = "selfHealing", required = false, defaultValue = "true") final Boolean selfHealing)
			throws TimeoutException, IOException,
			DSLException, RestErrorException, PackagingException {

		logger.info("Deploying service with template: " + templateName);
		String actualTemplateName = templateName;

		if (cloud != null) {
			if (templateName == null || templateName.length() == 0) {
				if (cloud.getCloudCompute().getTemplates().isEmpty()) {
					throw new IllegalStateException(
							"Cloud configuration has no compute template defined!");
				}
				actualTemplateName = cloud.getCloudCompute().getTemplates().keySet().iterator()
						.next();
				logger.warning("Compute Template name missing from service deployment request."
						+ " Defaulting to first template: "
						+ actualTemplateName);

			}
		}

		final String absolutePuName = ServiceUtils.getAbsolutePUName(
				applicationName, serviceName);
		final byte[] propsBytes = propsFile.getBytes();
		final Properties props = new Properties();
		final InputStream is = new ByteArrayInputStream(propsBytes);
		props.load(is);
		final File dest = copyMultipartFileToLocalFile(srcFile);
		final File cloudOverrides = copyMultipartFileToLocalFile(cloudOverridesFile);
		final File destFile = new File(dest.getParent(), absolutePuName + "."
				+ FilenameUtils.getExtension(dest.getName()));
		if (destFile.exists()) {
			FileUtils.deleteQuietly(destFile);
		}

		String effectiveAuthGroups = authGroups;
		if (StringUtils.isBlank(effectiveAuthGroups)) {
			if (permissionEvaluator != null) {
				effectiveAuthGroups = permissionEvaluator.getUserAuthGroupsString();
			} else {
				effectiveAuthGroups = "";
			}
		}
		final File localServiceOverridesFile = copyMultipartFileToLocalFile(serviceOverridesFile);

		String lifecycleEventsContainerID = "";
		if (dest.renameTo(destFile)) {
			FileUtils.deleteQuietly(dest);

			final File cloudConfigurationFile = ZipUtils
					.unzipEntry(
							destFile,
							"ext/"
									+ CloudifyConstants.SERVICE_CLOUD_CONFIGURATION_FILE_NAME,
							CloudifyConstants.SERVICE_CLOUD_CONFIGURATION_FILE_NAME);
			byte[] cloudConfigurationContents = null;
			if (cloudConfigurationFile != null) {
				cloudConfigurationContents = FileUtils
						.readFileToByteArray(cloudConfigurationFile);
			}

			lifecycleEventsContainerID = deployElasticProcessingUnit(
					absolutePuName,
					applicationName,
					effectiveAuthGroups,
					zone,
					destFile,
					props,
					actualTemplateName,
					false,
					timeout,
					TimeUnit.MINUTES,
					cloudConfigurationContents,
					selfHealing.booleanValue(),
					localServiceOverridesFile,
					cloudOverrides);
			destFile.deleteOnExit();
		} else {
			logger.warning("Deployment file could not be renamed to the absolute pu name."
					+ " Deploaying using the name " + dest.getName());
			lifecycleEventsContainerID = deployElasticProcessingUnit(
					absolutePuName,
					applicationName,
					effectiveAuthGroups,
					zone,
					dest,
					props,
					actualTemplateName,
					false,
					timeout,
					TimeUnit.MINUTES,
					null,
					selfHealing.booleanValue(),
					localServiceOverridesFile,
					cloudOverrides);
			dest.deleteOnExit();
		}

		// TODO: move this Key String to the DSL project as a constant.
		// Map<String, String> serviceDetails = new HashMap<String, String>();
		// serviceDetails.put("lifecycleEventsContainerID",
		// lifecycleEventsContainerID.toString());
		return successStatus(lifecycleEventsContainerID);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883803/fstmerge_base_5139745125414815625
@JsonRequestExample(requestBody = "{\"zone\":5,\"template\":\"SMALL_LINUX\","
			+ "\"file\":\"packaged service file\",\"props\":\"packaged properties file\"}")
	@JsonResponseExample(status = "success", responseBody = "\"b41febb7-f48e-48d4-b14a-a6000d402d93\"")
	@PossibleResponseStatuses(responseStatuses = {
			@PossibleResponseStatus(code = HTTP_OK, description = "success"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, description = "TimeoutException"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, description = "PackagingException"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, description = "IOException"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, description = "AdminException"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, description = "DSLException") })
	@RequestMapping(value = "applications/{applicationName}/services/{serviceName}/timeout/{timeout}",
	method = RequestMethod.POST)
	@PreAuthorize("isFullyAuthenticated() and hasPermission(#authGroups, 'deploy')")
	@ResponseBody
	public Object deployElastic(
			@PathVariable final String applicationName,
			@PathVariable final String serviceName,
			@PathVariable final int timeout,
			@RequestParam(value = "template", required = false) final String templateName,
			@RequestParam(value = "zone", required = true) final String zone,
			@RequestParam(value = "file", required = true) final MultipartFile srcFile,
			@RequestParam(value = "props", required = true) final MultipartFile propsFile,
			@RequestParam(value = "authGroups", required = false) final String authGroups,
			@RequestParam(value = SERVICE_OVERRIDES_FILE_PARAM, required = false) 
			final MultipartFile serviceOverridesFile,
			@RequestParam(value = CLOUD_OVERRIDES_FILE_PARAM, required = false) final MultipartFile cloudOverridesFile, 
			@RequestParam(value = "selfHealing", required = false, defaultValue = "true") final Boolean selfHealing)
					throws TimeoutException, IOException,
					DSLException, RestErrorException, PackagingException {

		
		
		logger.info("Deploying service with template: " + templateName);
		String actualTemplateName = templateName;

		if (cloud != null) {
			if (templateName == null || templateName.length() == 0) {
				if (cloud.getTemplates().isEmpty()) {
					throw new IllegalStateException(
							"Cloud configuration has no compute template defined!");
				}
				actualTemplateName = cloud.getTemplates().keySet().iterator()
						.next();
				logger.warning("Compute Template name missing from service deployment request."
						+ " Defaulting to first template: "
						+ actualTemplateName);

			}
		}

		final String absolutePuName = ServiceUtils.getAbsolutePUName(
				applicationName, serviceName);
		final byte[] propsBytes = propsFile.getBytes();
		final Properties props = new Properties();
		final InputStream is = new ByteArrayInputStream(propsBytes);
		props.load(is);
		final File dest = copyMultipartFileToLocalFile(srcFile);
		final File cloudOverrides = copyMultipartFileToLocalFile(cloudOverridesFile);
		final File destFile = new File(dest.getParent(), absolutePuName + "."
				+ FilenameUtils.getExtension(dest.getName()));
		if (destFile.exists()) {
			FileUtils.deleteQuietly(destFile);
		}

		String effectiveAuthGroups = authGroups;
		if (StringUtils.isBlank(effectiveAuthGroups)) {
			if (permissionEvaluator != null) {
				effectiveAuthGroups = permissionEvaluator.getUserAuthGroupsString();
			} else {
				effectiveAuthGroups = "";
			}
		}
		final File localServiceOverridesFile = copyMultipartFileToLocalFile(serviceOverridesFile);

		
		String lifecycleEventsContainerID = "";
		if (dest.renameTo(destFile)) {
			FileUtils.deleteQuietly(dest);

			final File cloudConfigurationFile = ZipUtils
					.unzipEntry(
							destFile,
							"ext/"
									+ CloudifyConstants.SERVICE_CLOUD_CONFIGURATION_FILE_NAME,
									CloudifyConstants.SERVICE_CLOUD_CONFIGURATION_FILE_NAME);
			byte[] cloudConfigurationContents = null;
			if (cloudConfigurationFile != null) {
				cloudConfigurationContents = FileUtils
						.readFileToByteArray(cloudConfigurationFile);
			}

			lifecycleEventsContainerID = deployElasticProcessingUnit(
					absolutePuName, 
					applicationName, 
					effectiveAuthGroups, 
					zone, 
					destFile, 
					props,
					actualTemplateName, 
					false, 
					timeout,
					TimeUnit.MINUTES,
					cloudConfigurationContents, 
					selfHealing.booleanValue(),
					localServiceOverridesFile,
					cloudOverrides);
			destFile.deleteOnExit();
		} else {
			logger.warning("Deployment file could not be renamed to the absolute pu name."
					+ " Deploaying using the name " + dest.getName());
			lifecycleEventsContainerID = deployElasticProcessingUnit(
					absolutePuName,
					applicationName,
					effectiveAuthGroups,
					zone,
					dest,
					props,
					actualTemplateName,
					false,
					timeout,
					TimeUnit.MINUTES,
					null,
					selfHealing.booleanValue(),
					localServiceOverridesFile,
					cloudOverrides);
			dest.deleteOnExit();
		}

		// TODO: move this Key String to the DSL project as a constant.
		// Map<String, String> serviceDetails = new HashMap<String, String>();
		// serviceDetails.put("lifecycleEventsContainerID",
		// lifecycleEventsContainerID.toString());
		return successStatus(lifecycleEventsContainerID);
=======
@JsonRequestExample(requestBody = "{\"zone\":5,\"template\":\"SMALL_LINUX\","
			+ "\"file\":\"packaged service file\",\"props\":\"packaged properties file\"}")
	@JsonResponseExample(status = "success", responseBody = "\"b41febb7-f48e-48d4-b14a-a6000d402d93\"")
	@PossibleResponseStatuses(responseStatuses = {
			@PossibleResponseStatus(code = HTTP_OK, description = "success"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, description = "TimeoutException"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, description = "PackagingException"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, description = "IOException"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, description = "AdminException"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, description = "DSLException") })
	@RequestMapping(value = "applications/{applicationName}/services/{serviceName}/timeout/{timeout}",
			method = RequestMethod.POST)
	@PreAuthorize("isFullyAuthenticated() and hasPermission(#authGroups, 'deploy')")
	@ResponseBody
	public Object deployElastic(
			@PathVariable final String applicationName,
			@PathVariable final String serviceName,
			@PathVariable final int timeout,
			@RequestParam(value = "template", required = false) final String templateName,
			@RequestParam(value = "zone", required = true) final String zone,
			@RequestParam(value = "file", required = true) final MultipartFile srcFile,
			@RequestParam(value = "props", required = true) final MultipartFile propsFile,
			@RequestParam(value = "authGroups", required = false) final String authGroups,
			@RequestParam(value = SERVICE_OVERRIDES_FILE_PARAM, required = false) final MultipartFile serviceOverridesFile,
			@RequestParam(value = CLOUD_OVERRIDES_FILE_PARAM, required = false) final MultipartFile cloudOverridesFile,
			@RequestParam(value = "selfHealing", required = false, defaultValue = "true") final Boolean selfHealing)
			throws TimeoutException, IOException,
			DSLException, RestErrorException, PackagingException {

		logger.info("Deploying service with template: " + templateName);
		String actualTemplateName = templateName;

		if (cloud != null) {
			if (templateName == null || templateName.length() == 0) {
				if (cloud.getTemplates().isEmpty()) {
					throw new IllegalStateException(
							"Cloud configuration has no compute template defined!");
				}
				actualTemplateName = cloud.getTemplates().keySet().iterator()
						.next();
				logger.warning("Compute Template name missing from service deployment request."
						+ " Defaulting to first template: "
						+ actualTemplateName);

			}
		}

		final String absolutePuName = ServiceUtils.getAbsolutePUName(
				applicationName, serviceName);
		final byte[] propsBytes = propsFile.getBytes();
		final Properties props = new Properties();
		final InputStream is = new ByteArrayInputStream(propsBytes);
		props.load(is);
		final File dest = copyMultipartFileToLocalFile(srcFile);
		final File cloudOverrides = copyMultipartFileToLocalFile(cloudOverridesFile);
		final File destFile = new File(dest.getParent(), absolutePuName + "."
				+ FilenameUtils.getExtension(dest.getName()));
		if (destFile.exists()) {
			FileUtils.deleteQuietly(destFile);
		}

		String effectiveAuthGroups = authGroups;
		if (StringUtils.isBlank(effectiveAuthGroups)) {
			if (permissionEvaluator != null) {
				effectiveAuthGroups = permissionEvaluator.getUserAuthGroupsString();
			} else {
				effectiveAuthGroups = "";
			}
		}
		final File localServiceOverridesFile = copyMultipartFileToLocalFile(serviceOverridesFile);

		String lifecycleEventsContainerID = "";
		if (dest.renameTo(destFile)) {
			FileUtils.deleteQuietly(dest);

			final File cloudConfigurationFile = ZipUtils
					.unzipEntry(
							destFile,
							"ext/"
									+ CloudifyConstants.SERVICE_CLOUD_CONFIGURATION_FILE_NAME,
							CloudifyConstants.SERVICE_CLOUD_CONFIGURATION_FILE_NAME);
			byte[] cloudConfigurationContents = null;
			if (cloudConfigurationFile != null) {
				cloudConfigurationContents = FileUtils
						.readFileToByteArray(cloudConfigurationFile);
			}

			lifecycleEventsContainerID = deployElasticProcessingUnit(
					absolutePuName,
					applicationName,
					effectiveAuthGroups,
					zone,
					destFile,
					props,
					actualTemplateName,
					false,
					timeout,
					TimeUnit.MINUTES,
					cloudConfigurationContents,
					selfHealing.booleanValue(),
					localServiceOverridesFile,
					cloudOverrides);
			destFile.deleteOnExit();
		} else {
			logger.warning("Deployment file could not be renamed to the absolute pu name."
					+ " Deploaying using the name " + dest.getName());
			lifecycleEventsContainerID = deployElasticProcessingUnit(
					absolutePuName,
					applicationName,
					effectiveAuthGroups,
					zone,
					dest,
					props,
					actualTemplateName,
					false,
					timeout,
					TimeUnit.MINUTES,
					null,
					selfHealing.booleanValue(),
					localServiceOverridesFile,
					cloudOverrides);
			dest.deleteOnExit();
		}

		// TODO: move this Key String to the DSL project as a constant.
		// Map<String, String> serviceDetails = new HashMap<String, String>();
		// serviceDetails.put("lifecycleEventsContainerID",
		// lifecycleEventsContainerID.toString());
		return successStatus(lifecycleEventsContainerID);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883803/fstmerge_var2_8735776552467815198
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883819/fstmerge_var1_7354926597339749307
private ComputeTemplate getComputeTemplate(final Cloud cloud,
			final String templateName) {
		if (templateName == null) {
			final Entry<String, ComputeTemplate> entry = cloud.getCloudCompute().getTemplates()
					.entrySet().iterator().next();

			logger.warning("Service does not specify template name! Defaulting to template: "
					+ entry.getKey());
			return entry.getValue();
		}
		final ComputeTemplate template = cloud.getCloudCompute().getTemplates().get(templateName);
		if (template == null) {
			throw new IllegalArgumentException(
					"Could not find compute template: " + templateName);
		}
		return template;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883819/fstmerge_base_7758252538754662585
private CloudTemplate getComputeTemplate(final Cloud cloud,
			final String templateName) {
		if (templateName == null) {
			final Entry<String, CloudTemplate> entry = cloud.getTemplates()
					.entrySet().iterator().next();

			logger.warning("Service does not specify template name! Defaulting to template: "
					+ entry.getKey());
			return entry.getValue();
		}
		final CloudTemplate template = cloud.getTemplates().get(templateName);
		if (template == null) {
			throw new IllegalArgumentException(
					"Could not find compute template: " + templateName);
		}
		return template;
=======
private CloudTemplate getComputeTemplate(final Cloud cloud,
			final String templateName) {
		if (templateName == null) {
			final Entry<String, CloudTemplate> entry = cloud.getTemplates()
					.entrySet().iterator().next();

			logger.warning("Service does not specify template name! Defaulting to template: "
					+ entry.getKey());
			return entry.getValue();
		}
		final CloudTemplate template = cloud.getTemplates().get(templateName);
		if (template == null) {
			throw new IllegalArgumentException(
					"Could not find compute template: " + templateName);
		}
		return template;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883819/fstmerge_var2_5718731675430449378
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883828/fstmerge_var1_1787805993032553914
private void validateTemplate(final String templateName)
			throws RestErrorException {

		if (cloud == null) {
			// no template validation for local cloud
			return;
		}
		final ComputeTemplate template = cloud.getCloudCompute().getTemplates().get(
				templateName);
		if (template == null) {
			throw new RestErrorException(
					CloudifyErrorMessages.MISSING_TEMPLATE.getName(),
					templateName);
		}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883828/fstmerge_base_3816872439002853855
private void validateTemplate(final String templateName)
			throws RestErrorException {

		if (cloud == null) {
			// no template validation for local cloud
			return;
		}
		final CloudTemplate template = cloud.getTemplates().get(
				templateName);
		if (template == null) {
			throw new RestErrorException(
					CloudifyErrorMessages.MISSING_TEMPLATE.getName(),
					templateName);
		}
=======
private void validateTemplate(final String templateName)
			throws RestErrorException {

		if (cloud == null) {
			// no template validation for local cloud
			return;
		}
		final CloudTemplate template = cloud.getTemplates().get(
				templateName);
		if (template == null) {
			throw new RestErrorException(
					CloudifyErrorMessages.MISSING_TEMPLATE.getName(),
					templateName);
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883828/fstmerge_var2_8242442513592844334
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883838/fstmerge_var1_8746514841341217854
private void deployDataGrid(final String applicationName, final String serviceName,
			final String authGroups, final String[] agentZones,
			final File srcFile, final Properties contextProperties,
			final DataGrid dataGridConfig, final String templateName,
			final boolean locationAware,
			final File cloudOverrides) throws AdminException,
			TimeoutException, DSLException, IOException {

		final int containerMemoryInMB = dataGridConfig.getSla()
				.getMemoryCapacityPerContainer();
		final int maxMemoryInMB = dataGridConfig.getSla()
				.getMaxMemoryCapacity();
		final int reservedMemoryCapacityPerMachineInMB = 256;

		logger.finer("received request to install datagrid");

		final ElasticSpaceDeployment deployment = new ElasticSpaceDeployment(
				serviceName)
				.memoryCapacityPerContainer(containerMemoryInMB,
						MemoryUnit.MEGABYTES)
				.maxMemoryCapacity(maxMemoryInMB, MemoryUnit.MEGABYTES)
				.addContextProperty(
						CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME,
						applicationName)
				.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_AUTH_GROUPS, authGroups)
				.highlyAvailable(dataGridConfig.getSla().getHighlyAvailable())
				// allow single machine for local development purposes
				.singleMachineDeployment();

		setContextProperties(deployment, contextProperties);

		if (cloud == null) {
			if (isLocalCloud()) {
				setPublicMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				deployment.scale(new ManualCapacityScaleConfigurer()
						.memoryCapacity(
								dataGridConfig.getSla().getMemoryCapacity(),
								MemoryUnit.MEGABYTES).create());

			} else {
				setSharedMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				// eager scaling. 1 container per machine
				deployment.scale(ElasticScaleConfigFactory
						.createEagerScaleConfig());
			}

		} else {

			final ComputeTemplate template = getComputeTemplate(cloud,
					templateName);

			validateAndPrepareStatefulSla(serviceName, dataGridConfig.getSla(),
					cloud, template);

			final long cloudExternalProcessMemoryInMB = calculateExternalProcessMemory(
					cloud, template);

			final CloudifyMachineProvisioningConfig config = new CloudifyMachineProvisioningConfig(
					cloud, template, templateName,
					this.managementTemplate.getRemoteDirectory(), null);
			config.setAuthGroups(authGroups);

			if (cloudOverrides != null) {
				config.setCloudOverridesPerService(cloudOverrides);
			}

			final String locators = extractLocators(admin);
			config.setLocator(locators);

			setDedicatedMachineProvisioning(deployment, config);
			deployment.memoryCapacityPerContainer(
					(int) cloudExternalProcessMemoryInMB, MemoryUnit.MEGABYTES);

			// TODO: [itaif] Why only capacity of one container ?
			deployment.scale(ElasticScaleConfigFactory
					.createManualCapacityScaleConfig(
							(int) cloudExternalProcessMemoryInMB, 0,
							locationAware, true));
		}

		deployAndWait(serviceName, deployment);

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883838/fstmerge_base_4310559269002679910
private void deployDataGrid(final String applicationName, final String serviceName,
			final String authGroups, final String[] agentZones,
			final File srcFile, final Properties contextProperties,
			final DataGrid dataGridConfig, final String templateName,
			final boolean locationAware,
			final File cloudOverrides) throws AdminException,
			TimeoutException, DSLException, IOException {

		final int containerMemoryInMB = dataGridConfig.getSla()
				.getMemoryCapacityPerContainer();
		final int maxMemoryInMB = dataGridConfig.getSla()
				.getMaxMemoryCapacity();
		final int reservedMemoryCapacityPerMachineInMB = 256;

		logger.finer("received request to install datagrid");

		final ElasticSpaceDeployment deployment = new ElasticSpaceDeployment(
				serviceName)
		.memoryCapacityPerContainer(containerMemoryInMB,
				MemoryUnit.MEGABYTES)
				.maxMemoryCapacity(maxMemoryInMB, MemoryUnit.MEGABYTES)
				.addContextProperty(
						CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME,
						applicationName)
						.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_AUTH_GROUPS, authGroups)
						.highlyAvailable(dataGridConfig.getSla().getHighlyAvailable())
						// allow single machine for local development purposes
						.singleMachineDeployment();

		setContextProperties(deployment, contextProperties);

		if (cloud == null) {
			if (isLocalCloud()) {
				setPublicMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				deployment.scale(new ManualCapacityScaleConfigurer()
				.memoryCapacity(
						dataGridConfig.getSla().getMemoryCapacity(),
						MemoryUnit.MEGABYTES).create());

			} else {
				setSharedMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				// eager scaling. 1 container per machine
				deployment.scale(ElasticScaleConfigFactory
						.createEagerScaleConfig());
			}

		} else {

			final CloudTemplate template = getComputeTemplate(cloud,
					templateName);

			validateAndPrepareStatefulSla(serviceName, dataGridConfig.getSla(),
					cloud, template);

			final long cloudExternalProcessMemoryInMB = calculateExternalProcessMemory(
					cloud, template);

			final CloudifyMachineProvisioningConfig config = new CloudifyMachineProvisioningConfig(
					cloud, template, templateName,
					this.managementTemplate.getRemoteDirectory());
			config.setAuthGroups(authGroups);
			
			if (cloudOverrides != null) {
				config.setCloudOverridesPerService(cloudOverrides);
			}

			final String locators = extractLocators(admin);
			config.setLocator(locators);

			setDedicatedMachineProvisioning(deployment, config);
			deployment.memoryCapacityPerContainer(
					(int) cloudExternalProcessMemoryInMB, MemoryUnit.MEGABYTES);

			// TODO: [itaif] Why only capacity of one container ?
			deployment.scale(ElasticScaleConfigFactory
					.createManualCapacityScaleConfig(
							(int) cloudExternalProcessMemoryInMB, 0,
							locationAware, true));
		}

		deployAndWait(serviceName, deployment);

=======
private void deployDataGrid(final String applicationName, final String serviceName,
			final String authGroups, final String[] agentZones,
			final File srcFile, final Properties contextProperties,
			final DataGrid dataGridConfig, final String templateName,
			final boolean locationAware,
			final File cloudOverrides) throws AdminException,
			TimeoutException, DSLException, IOException {

		final int containerMemoryInMB = dataGridConfig.getSla()
				.getMemoryCapacityPerContainer();
		final int maxMemoryInMB = dataGridConfig.getSla()
				.getMaxMemoryCapacity();
		final int reservedMemoryCapacityPerMachineInMB = 256;

		logger.finer("received request to install datagrid");

		final ElasticSpaceDeployment deployment = new ElasticSpaceDeployment(
				serviceName)
				.memoryCapacityPerContainer(containerMemoryInMB,
						MemoryUnit.MEGABYTES)
				.maxMemoryCapacity(maxMemoryInMB, MemoryUnit.MEGABYTES)
				.addContextProperty(
						CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME,
						applicationName)
				.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_AUTH_GROUPS, authGroups)
				.highlyAvailable(dataGridConfig.getSla().getHighlyAvailable())
				// allow single machine for local development purposes
				.singleMachineDeployment();

		setContextProperties(deployment, contextProperties);

		if (cloud == null) {
			if (isLocalCloud()) {
				setPublicMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				deployment.scale(new ManualCapacityScaleConfigurer()
						.memoryCapacity(
								dataGridConfig.getSla().getMemoryCapacity(),
								MemoryUnit.MEGABYTES).create());

			} else {
				setSharedMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				// eager scaling. 1 container per machine
				deployment.scale(ElasticScaleConfigFactory
						.createEagerScaleConfig());
			}

		} else {

			final CloudTemplate template = getComputeTemplate(cloud,
					templateName);

			validateAndPrepareStatefulSla(serviceName, dataGridConfig.getSla(),
					cloud, template);

			final long cloudExternalProcessMemoryInMB = calculateExternalProcessMemory(
					cloud, template);

			final CloudifyMachineProvisioningConfig config = new CloudifyMachineProvisioningConfig(
					cloud, template, templateName,
					this.managementTemplate.getRemoteDirectory());
			config.setAuthGroups(authGroups);

			if (cloudOverrides != null) {
				config.setCloudOverridesPerService(cloudOverrides);
			}

			final String locators = extractLocators(admin);
			config.setLocator(locators);

			setDedicatedMachineProvisioning(deployment, config);
			deployment.memoryCapacityPerContainer(
					(int) cloudExternalProcessMemoryInMB, MemoryUnit.MEGABYTES);

			// TODO: [itaif] Why only capacity of one container ?
			deployment.scale(ElasticScaleConfigFactory
					.createManualCapacityScaleConfig(
							(int) cloudExternalProcessMemoryInMB, 0,
							locationAware, true));
		}

		deployAndWait(serviceName, deployment);

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883838/fstmerge_var2_2181223032310117709
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883874/fstmerge_var1_3501258348826873278
private void deployStatelessProcessingUnitAndWait(
			final String applicationName, final String serviceName, final String authGroups,
			final String[] agentZones, final File extractedServiceFolder,
			final Properties contextProperties,
			final StatelessProcessingUnit puConfig, final String templateName,
			final int numberOfInstances, final boolean locationAware,
			final File cloudOverride)
			throws IOException, AdminException, TimeoutException, DSLException, RestErrorException {

		final File jarFile = getJarFileFromDir(
				new File(puConfig.getBinaries()), extractedServiceFolder,
				serviceName);
		// TODO:if not specified use machine memory defined in DSL
		final int containerMemoryInMB = puConfig.getSla()
				.getMemoryCapacityPerContainer();
		// TODO:Read from cloud DSL
		final int reservedMemoryCapacityPerMachineInMB = 256;
		final ElasticStatelessProcessingUnitDeployment deployment = new ElasticStatelessProcessingUnitDeployment(
				jarFile)
				.memoryCapacityPerContainer(containerMemoryInMB,
						MemoryUnit.MEGABYTES)
				.addContextProperty(
						CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME,
						applicationName)
				.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_AUTH_GROUPS, authGroups)
				.name(serviceName);
		// TODO:read from cloud DSL

		setContextProperties(deployment, contextProperties);

		if (cloud == null) {
			verifyEsmExistsInCluster();

			if (isLocalCloud()) {
				setPublicMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				deployment.scale(new ManualCapacityScaleConfigurer()
						.memoryCapacity(
								containerMemoryInMB * numberOfInstances,
								MemoryUnit.MEGABYTES).create());
			} else {
				setSharedMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				// eager scaling. one container per machine
				deployment.scale(ElasticScaleConfigFactory
						.createEagerScaleConfig());
			}
		} else {
			final ComputeTemplate template = getComputeTemplate(cloud,
					templateName);
			validateAndPrepareStatelessSla(puConfig.getSla(), cloud, template);
			final long cloudExternalProcessMemoryInMB = calculateExternalProcessMemory(
					cloud, template);

			final CloudifyMachineProvisioningConfig config = new CloudifyMachineProvisioningConfig(
					cloud, template, templateName,
					this.managementTemplate.getRemoteDirectory(), null);
			config.setAuthGroups(authGroups);
			if (cloudOverride != null) {
				config.setCloudOverridesPerService(cloudOverride);
			}

			final String locators = extractLocators(admin);
			config.setLocator(locators);

			setDedicatedMachineProvisioning(deployment, config);
			deployment.memoryCapacityPerContainer(
					(int) cloudExternalProcessMemoryInMB, MemoryUnit.MEGABYTES);

			deployment.scale(ElasticScaleConfigFactory
					.createManualCapacityScaleConfig(containerMemoryInMB
							* numberOfInstances, 0, locationAware, true));
		}
		deployAndWait(serviceName, deployment);
		jarFile.delete();

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883874/fstmerge_base_589278730448681521
private void deployStatelessProcessingUnitAndWait(
			final String applicationName, final String serviceName, final String authGroups,
			final String[] agentZones, final File extractedServiceFolder,
			final Properties contextProperties,
			final StatelessProcessingUnit puConfig, final String templateName,
			final int numberOfInstances, final boolean locationAware,
			final File cloudOverride)
					throws IOException, AdminException, TimeoutException, DSLException, RestErrorException {

		final File jarFile = getJarFileFromDir(
				new File(puConfig.getBinaries()), extractedServiceFolder,
				serviceName);
		// TODO:if not specified use machine memory defined in DSL
		final int containerMemoryInMB = puConfig.getSla()
				.getMemoryCapacityPerContainer();
		// TODO:Read from cloud DSL
		final int reservedMemoryCapacityPerMachineInMB = 256;
		final ElasticStatelessProcessingUnitDeployment deployment = new ElasticStatelessProcessingUnitDeployment(
				jarFile)
		.memoryCapacityPerContainer(containerMemoryInMB,
				MemoryUnit.MEGABYTES)
				.addContextProperty(
						CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME,
						applicationName)
						.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_AUTH_GROUPS, authGroups)
						.name(serviceName);
		// TODO:read from cloud DSL

		setContextProperties(deployment, contextProperties);

		if (cloud == null) {
			verifyEsmExistsInCluster();

			if (isLocalCloud()) {
				setPublicMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				deployment.scale(new ManualCapacityScaleConfigurer()
				.memoryCapacity(
						containerMemoryInMB * numberOfInstances,
						MemoryUnit.MEGABYTES).create());
			} else {
				setSharedMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				// eager scaling. one container per machine
				deployment.scale(ElasticScaleConfigFactory
						.createEagerScaleConfig());
			}
		} else {
			final CloudTemplate template = getComputeTemplate(cloud,
					templateName);
			validateAndPrepareStatelessSla(puConfig.getSla(), cloud, template);
			final long cloudExternalProcessMemoryInMB = calculateExternalProcessMemory(
					cloud, template);

			final CloudifyMachineProvisioningConfig config = new CloudifyMachineProvisioningConfig(
					cloud, template, templateName,
					this.managementTemplate.getRemoteDirectory());
			config.setAuthGroups(authGroups);
			if (cloudOverride != null) {
				config.setCloudOverridesPerService(cloudOverride);
			}

			final String locators = extractLocators(admin);
			config.setLocator(locators);

			setDedicatedMachineProvisioning(deployment, config);
			deployment.memoryCapacityPerContainer(
					(int) cloudExternalProcessMemoryInMB, MemoryUnit.MEGABYTES);

			deployment.scale(ElasticScaleConfigFactory
					.createManualCapacityScaleConfig(containerMemoryInMB
							* numberOfInstances, 0, locationAware, true));
		}
		deployAndWait(serviceName, deployment);
		jarFile.delete();

=======
private void deployStatelessProcessingUnitAndWait(
			final String applicationName, final String serviceName, final String authGroups,
			final String[] agentZones, final File extractedServiceFolder,
			final Properties contextProperties,
			final StatelessProcessingUnit puConfig, final String templateName,
			final int numberOfInstances, final boolean locationAware,
			final File cloudOverride)
			throws IOException, AdminException, TimeoutException, DSLException, RestErrorException {

		final File jarFile = getJarFileFromDir(
				new File(puConfig.getBinaries()), extractedServiceFolder,
				serviceName);
		// TODO:if not specified use machine memory defined in DSL
		final int containerMemoryInMB = puConfig.getSla()
				.getMemoryCapacityPerContainer();
		// TODO:Read from cloud DSL
		final int reservedMemoryCapacityPerMachineInMB = 256;
		final ElasticStatelessProcessingUnitDeployment deployment = new ElasticStatelessProcessingUnitDeployment(
				jarFile)
				.memoryCapacityPerContainer(containerMemoryInMB,
						MemoryUnit.MEGABYTES)
				.addContextProperty(
						CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME,
						applicationName)
				.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_AUTH_GROUPS, authGroups)
				.name(serviceName);
		// TODO:read from cloud DSL

		setContextProperties(deployment, contextProperties);

		if (cloud == null) {
			verifyEsmExistsInCluster();

			if (isLocalCloud()) {
				setPublicMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				deployment.scale(new ManualCapacityScaleConfigurer()
						.memoryCapacity(
								containerMemoryInMB * numberOfInstances,
								MemoryUnit.MEGABYTES).create());
			} else {
				setSharedMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				// eager scaling. one container per machine
				deployment.scale(ElasticScaleConfigFactory
						.createEagerScaleConfig());
			}
		} else {
			final CloudTemplate template = getComputeTemplate(cloud,
					templateName);
			validateAndPrepareStatelessSla(puConfig.getSla(), cloud, template);
			final long cloudExternalProcessMemoryInMB = calculateExternalProcessMemory(
					cloud, template);

			final CloudifyMachineProvisioningConfig config = new CloudifyMachineProvisioningConfig(
					cloud, template, templateName,
					this.managementTemplate.getRemoteDirectory());
			config.setAuthGroups(authGroups);
			if (cloudOverride != null) {
				config.setCloudOverridesPerService(cloudOverride);
			}

			final String locators = extractLocators(admin);
			config.setLocator(locators);

			setDedicatedMachineProvisioning(deployment, config);
			deployment.memoryCapacityPerContainer(
					(int) cloudExternalProcessMemoryInMB, MemoryUnit.MEGABYTES);

			deployment.scale(ElasticScaleConfigFactory
					.createManualCapacityScaleConfig(containerMemoryInMB
							* numberOfInstances, 0, locationAware, true));
		}
		deployAndWait(serviceName, deployment);
		jarFile.delete();

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883874/fstmerge_var2_3891979161987176882
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883886/fstmerge_var1_8005191130725029925
private void deployStatefulProcessingUnit(final String applicationName,
			final String serviceName, final String authGroups, final String[] agentZones,
			final File extractedServiceFolder,
			final Properties contextProperties,
			final StatefulProcessingUnit puConfig, final String templateName,
			final boolean locationAware,
			final File cloudOverrides) throws IOException, AdminException,
			TimeoutException, DSLException {

		final File jarFile = getJarFileFromDir(
				new File(puConfig.getBinaries()), extractedServiceFolder,
				serviceName);
		final int containerMemoryInMB = puConfig.getSla()
				.getMemoryCapacityPerContainer();
		final int maxMemoryCapacityInMB = puConfig.getSla()
				.getMaxMemoryCapacity();
		final int reservedMemoryCapacityPerMachineInMB = 256;

		final ElasticStatefulProcessingUnitDeployment deployment = new ElasticStatefulProcessingUnitDeployment(
				jarFile)
				.name(serviceName)
				.memoryCapacityPerContainer(containerMemoryInMB,
						MemoryUnit.MEGABYTES)
				.maxMemoryCapacity(maxMemoryCapacityInMB + "m")
				.addContextProperty(
						CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME,
						applicationName)
				.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_AUTH_GROUPS, authGroups)
				.highlyAvailable(puConfig.getSla().getHighlyAvailable())
				.singleMachineDeployment();

		setContextProperties(deployment, contextProperties);

		if (cloud == null) {
			verifyEsmExistsInCluster();
			if (isLocalCloud()) {
				setPublicMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				deployment.scale(new ManualCapacityScaleConfigurer()
						.memoryCapacity(puConfig.getSla().getMemoryCapacity(),
								MemoryUnit.MEGABYTES).create());
			} else {
				setSharedMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				// eager scaling. one container per machine
				deployment.scale(ElasticScaleConfigFactory
						.createEagerScaleConfig());
			}
		} else {

			final ComputeTemplate template = getComputeTemplate(cloud,
					templateName);

			validateAndPrepareStatefulSla(serviceName, puConfig.getSla(),
					cloud, template);

			final CloudifyMachineProvisioningConfig config = new CloudifyMachineProvisioningConfig(
					cloud, template, templateName,
					this.managementTemplate.getRemoteDirectory(), null);
			config.setAuthGroups(authGroups);
			if (cloudOverrides != null) {
				config.setCloudOverridesPerService(cloudOverrides);
			}

			final String locators = extractLocators(admin);
			config.setLocator(locators);

			setDedicatedMachineProvisioning(deployment, config);

			deployment.scale(ElasticScaleConfigFactory
					.createManualCapacityScaleConfig(puConfig.getSla()
							.getMemoryCapacity(), 0, locationAware, true));

		}

		deployAndWait(serviceName, deployment);
		jarFile.delete();

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883886/fstmerge_base_6808226759463070100
private void deployStatefulProcessingUnit(final String applicationName,
			final String serviceName, final String authGroups, final String[] agentZones,
			final File extractedServiceFolder,
			final Properties contextProperties,
			final StatefulProcessingUnit puConfig, final String templateName,
			final boolean locationAware,
			final File cloudOverrides) throws IOException, AdminException,
			TimeoutException, DSLException {

		final File jarFile = getJarFileFromDir(
				new File(puConfig.getBinaries()), extractedServiceFolder,
				serviceName);
		final int containerMemoryInMB = puConfig.getSla()
				.getMemoryCapacityPerContainer();
		final int maxMemoryCapacityInMB = puConfig.getSla()
				.getMaxMemoryCapacity();
		final int reservedMemoryCapacityPerMachineInMB = 256;

		final ElasticStatefulProcessingUnitDeployment deployment = new ElasticStatefulProcessingUnitDeployment(
				jarFile)
		.name(serviceName)
		.memoryCapacityPerContainer(containerMemoryInMB,
				MemoryUnit.MEGABYTES)
				.maxMemoryCapacity(maxMemoryCapacityInMB + "m")
				.addContextProperty(
						CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME,
						applicationName)
						.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_AUTH_GROUPS, authGroups)
						.highlyAvailable(puConfig.getSla().getHighlyAvailable())
						.singleMachineDeployment();

		setContextProperties(deployment, contextProperties);

		if (cloud == null) {
			verifyEsmExistsInCluster();
			if (isLocalCloud()) {
				setPublicMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				deployment.scale(new ManualCapacityScaleConfigurer()
				.memoryCapacity(puConfig.getSla().getMemoryCapacity(),
						MemoryUnit.MEGABYTES).create());
			} else {
				setSharedMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				// eager scaling. one container per machine
				deployment.scale(ElasticScaleConfigFactory
						.createEagerScaleConfig());
			}
		} else {

			final CloudTemplate template = getComputeTemplate(cloud,
					templateName);

			validateAndPrepareStatefulSla(serviceName, puConfig.getSla(),
					cloud, template);

			final CloudifyMachineProvisioningConfig config = new CloudifyMachineProvisioningConfig(
					cloud, template, templateName,
					this.managementTemplate.getRemoteDirectory());
			config.setAuthGroups(authGroups);
			if (cloudOverrides != null) {
				config.setCloudOverridesPerService(cloudOverrides);
			}

			final String locators = extractLocators(admin);
			config.setLocator(locators);

			setDedicatedMachineProvisioning(deployment, config);

			deployment.scale(ElasticScaleConfigFactory
					.createManualCapacityScaleConfig(puConfig.getSla()
							.getMemoryCapacity(), 0, locationAware, true));

		}

		deployAndWait(serviceName, deployment);
		jarFile.delete();

=======
private void deployStatefulProcessingUnit(final String applicationName,
			final String serviceName, final String authGroups, final String[] agentZones,
			final File extractedServiceFolder,
			final Properties contextProperties,
			final StatefulProcessingUnit puConfig, final String templateName,
			final boolean locationAware,
			final File cloudOverrides) throws IOException, AdminException,
			TimeoutException, DSLException {

		final File jarFile = getJarFileFromDir(
				new File(puConfig.getBinaries()), extractedServiceFolder,
				serviceName);
		final int containerMemoryInMB = puConfig.getSla()
				.getMemoryCapacityPerContainer();
		final int maxMemoryCapacityInMB = puConfig.getSla()
				.getMaxMemoryCapacity();
		final int reservedMemoryCapacityPerMachineInMB = 256;

		final ElasticStatefulProcessingUnitDeployment deployment = new ElasticStatefulProcessingUnitDeployment(
				jarFile)
				.name(serviceName)
				.memoryCapacityPerContainer(containerMemoryInMB,
						MemoryUnit.MEGABYTES)
				.maxMemoryCapacity(maxMemoryCapacityInMB + "m")
				.addContextProperty(
						CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME,
						applicationName)
				.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_AUTH_GROUPS, authGroups)
				.highlyAvailable(puConfig.getSla().getHighlyAvailable())
				.singleMachineDeployment();

		setContextProperties(deployment, contextProperties);

		if (cloud == null) {
			verifyEsmExistsInCluster();
			if (isLocalCloud()) {
				setPublicMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				deployment.scale(new ManualCapacityScaleConfigurer()
						.memoryCapacity(puConfig.getSla().getMemoryCapacity(),
								MemoryUnit.MEGABYTES).create());
			} else {
				setSharedMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				// eager scaling. one container per machine
				deployment.scale(ElasticScaleConfigFactory
						.createEagerScaleConfig());
			}
		} else {

			final CloudTemplate template = getComputeTemplate(cloud,
					templateName);

			validateAndPrepareStatefulSla(serviceName, puConfig.getSla(),
					cloud, template);

			final CloudifyMachineProvisioningConfig config = new CloudifyMachineProvisioningConfig(
					cloud, template, templateName,
					this.managementTemplate.getRemoteDirectory());
			config.setAuthGroups(authGroups);
			if (cloudOverrides != null) {
				config.setCloudOverridesPerService(cloudOverrides);
			}

			final String locators = extractLocators(admin);
			config.setLocator(locators);

			setDedicatedMachineProvisioning(deployment, config);

			deployment.scale(ElasticScaleConfigFactory
					.createManualCapacityScaleConfig(puConfig.getSla()
							.getMemoryCapacity(), 0, locationAware, true));

		}

		deployAndWait(serviceName, deployment);
		jarFile.delete();

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883886/fstmerge_var2_2012990813514061238
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883893/fstmerge_var1_2950325806011067969
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883893/fstmerge_base_9071928900364642515
private void validateAndPrepareStatefulSla(final String serviceName,
			final Sla sla, final Cloud cloud, final CloudTemplate template)
					throws DSLException {

		validateMemoryCapacityPerContainer(sla, cloud, template);

		if (sla.getMaxMemoryCapacity() != null
				&& sla.getMemoryCapacity() != null
				&& sla.getMaxMemoryCapacity() < sla.getMemoryCapacity()) {

			throw new DSLException(
					"Max memory capacity is smaller than the memory capacity."
							+ sla.getMaxMemoryCapacity() + " < "
							+ sla.getMemoryCapacity());
		}

		final int minimumNumberOfContainers = sla.getHighlyAvailable() ? 2 : 1;
		final int minMemoryInMB = minimumNumberOfContainers
				* sla.getMemoryCapacityPerContainer();

		if (sla.getMemoryCapacity() == null
				|| sla.getMemoryCapacity() < minMemoryInMB) {

			logger.info("Setting memoryCapacity for service " + serviceName
					+ " to minimum " + minMemoryInMB + "MB");
			sla.setMemoryCapacity(minMemoryInMB);
		}

		if (sla.getMaxMemoryCapacity() == null
				|| sla.getMaxMemoryCapacity() < sla.getMemoryCapacity()) {

			logger.info("Setting maxMemoryCapacity for service " + serviceName
					+ " to memoryCapacity " + sla.getMemoryCapacity() + "MB");
			sla.setMaxMemoryCapacity(sla.getMemoryCapacity());
		}
	}
=======
private void validateAndPrepareStatefulSla(final String serviceName,
			final Sla sla, final Cloud cloud, final CloudTemplate template)
			throws DSLException {

		validateMemoryCapacityPerContainer(sla, cloud, template);

		if (sla.getMaxMemoryCapacity() != null
				&& sla.getMemoryCapacity() != null
				&& sla.getMaxMemoryCapacity() < sla.getMemoryCapacity()) {

			throw new DSLException(
					"Max memory capacity is smaller than the memory capacity."
							+ sla.getMaxMemoryCapacity() + " < "
							+ sla.getMemoryCapacity());
		}

		final int minimumNumberOfContainers = sla.getHighlyAvailable() ? 2 : 1;
		final int minMemoryInMB = minimumNumberOfContainers
				* sla.getMemoryCapacityPerContainer();

		if (sla.getMemoryCapacity() == null
				|| sla.getMemoryCapacity() < minMemoryInMB) {

			logger.info("Setting memoryCapacity for service " + serviceName
					+ " to minimum " + minMemoryInMB + "MB");
			sla.setMemoryCapacity(minMemoryInMB);
		}

		if (sla.getMaxMemoryCapacity() == null
				|| sla.getMaxMemoryCapacity() < sla.getMemoryCapacity()) {

			logger.info("Setting maxMemoryCapacity for service " + serviceName
					+ " to memoryCapacity " + sla.getMemoryCapacity() + "MB");
			sla.setMaxMemoryCapacity(sla.getMemoryCapacity());
		}
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883893/fstmerge_var2_4577534166754916036

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883898/fstmerge_var1_2461175990053398801
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883898/fstmerge_base_7664391751942892158
private void validateAndPrepareStatelessSla(final Sla sla,
			final Cloud cloud, final CloudTemplate template)
					throws DSLException {

		validateMemoryCapacityPerContainer(sla, cloud, template);

		if (sla.getMemoryCapacity() != null) {
			throw new DSLException(
					"memoryCapacity SLA is not supported in this service");
		}

		if (sla.getMaxMemoryCapacity() != null) {
			throw new DSLException(
					"maxMemoryCapacity SLA is not supported in this service");
		}

	}
=======
private void validateAndPrepareStatelessSla(final Sla sla,
			final Cloud cloud, final CloudTemplate template)
			throws DSLException {

		validateMemoryCapacityPerContainer(sla, cloud, template);

		if (sla.getMemoryCapacity() != null) {
			throw new DSLException(
					"memoryCapacity SLA is not supported in this service");
		}

		if (sla.getMaxMemoryCapacity() != null) {
			throw new DSLException(
					"maxMemoryCapacity SLA is not supported in this service");
		}

	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883898/fstmerge_var2_7340955736860781011

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883902/fstmerge_var1_4727285831208361071
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883902/fstmerge_base_6201857614986053263
private void validateMemoryCapacityPerContainer(final Sla sla,
			final Cloud cloud, final CloudTemplate template)
					throws DSLException {
		if (cloud == null) {
			// No cloud, must specify memory capacity per container explicitly
			if (sla.getMemoryCapacityPerContainer() == null) {
				throw new DSLException(
						"Cannot determine memoryCapacityPerContainer SLA");
			}
		} else {
			// Assuming one container per machine then container memory =
			// machine memory
			final int availableMemoryOnMachine = (int) calculateExternalProcessMemory(
					cloud, template);
			if (sla.getMemoryCapacityPerContainer() != null
					&& sla.getMemoryCapacityPerContainer() > availableMemoryOnMachine) {
				throw new DSLException(
						"memoryCapacityPerContainer SLA is larger than available memory on machine\n"
								+ sla.getMemoryCapacityPerContainer() + " > "
								+ availableMemoryOnMachine);
			}

			if (sla.getMemoryCapacityPerContainer() == null) {
				sla.setMemoryCapacityPerContainer(availableMemoryOnMachine);
			}
		}
	}
=======
private void validateMemoryCapacityPerContainer(final Sla sla,
			final Cloud cloud, final CloudTemplate template)
			throws DSLException {
		if (cloud == null) {
			// No cloud, must specify memory capacity per container explicitly
			if (sla.getMemoryCapacityPerContainer() == null) {
				throw new DSLException(
						"Cannot determine memoryCapacityPerContainer SLA");
			}
		} else {
			// Assuming one container per machine then container memory =
			// machine memory
			final int availableMemoryOnMachine = (int) calculateExternalProcessMemory(
					cloud, template);
			if (sla.getMemoryCapacityPerContainer() != null
					&& sla.getMemoryCapacityPerContainer() > availableMemoryOnMachine) {
				throw new DSLException(
						"memoryCapacityPerContainer SLA is larger than available memory on machine\n"
								+ sla.getMemoryCapacityPerContainer() + " > "
								+ availableMemoryOnMachine);
			}

			if (sla.getMemoryCapacityPerContainer() == null) {
				sla.setMemoryCapacityPerContainer(availableMemoryOnMachine);
			}
		}
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883902/fstmerge_var2_6757123572887677157

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883912/fstmerge_var1_8694288782438729314
@JsonRequestExample(requestBody = "{\"count\":1,\"location-aware\":true}")
	@JsonResponseExample(status = "success", responseBody = "{\"lifecycleEventContainerID\":\"eventContainerID\"}")
	@PossibleResponseStatuses(responseStatuses = {
			@PossibleResponseStatus(code = HTTP_OK, description = "success"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR,
					description = ResponseConstants.FAILED_TO_LOCATE_SERVICE),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR,
					description = ResponseConstants.SERVICE_NOT_ELASTIC) })
	@RequestMapping(value = "applications/{applicationName}/services/{serviceName}/timeout/{timeout}/set-instances",
			method = RequestMethod.POST)
	@PreAuthorize("isFullyAuthenticated() and hasPermission(#authGroups, 'deploy')")
	@ResponseBody
	public Map<String, Object> setServiceInstances(
			@PathVariable final String applicationName,
			@PathVariable final String serviceName,
			@PathVariable final int timeout,
			@RequestParam(value = "count", required = true) final int count,
			@RequestParam(value = "location-aware", required = true) final boolean locationAware)
			throws DSLException, RestErrorException {

		final Map<String, Object> returnMap = new HashMap<String, Object>();
		final String puName = ServiceUtils.getAbsolutePUName(applicationName,
				serviceName);
		final ProcessingUnit pu = admin.getProcessingUnits().getProcessingUnit(
				puName);
		if (pu == null) {
			throw new RestErrorException(
					ResponseConstants.FAILED_TO_LOCATE_SERVICE, serviceName);
		}

		if (permissionEvaluator != null) {
			final String puAuthGroups = pu.getBeanLevelProperties().getContextProperties().
					getProperty(CloudifyConstants.CONTEXT_PROPERTY_AUTH_GROUPS);
			final Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
			final CloudifyAuthorizationDetails authDetails = new CloudifyAuthorizationDetails(authentication);
			permissionEvaluator.verifyPermission(authDetails, puAuthGroups, "deploy");
		}

		final Properties contextProperties = pu.getBeanLevelProperties()
				.getContextProperties();
		final String elasticProp = contextProperties
				.getProperty(CloudifyConstants.CONTEXT_PROPERTY_ELASTIC);
		final String templateName = contextProperties
				.getProperty(CloudifyConstants.CONTEXT_PROPERTY_TEMPLATE);

		if (elasticProp == null || !Boolean.parseBoolean(elasticProp)) {
			throw new RestErrorException(ResponseConstants.SERVICE_NOT_ELASTIC,
					serviceName);
		}

		logger.info("Scaling " + puName + " to " + count + " instances");

		UUID eventContainerID;
		if (cloud == null) {
			if (isLocalCloud()) {
				// Manual scale by number of instances
				pu.scale(new ManualCapacityScaleConfigurer().memoryCapacity(
						512 * count, MemoryUnit.MEGABYTES).create());
			} else {
				// Eager scale (1 container per machine per PU)
				throw new RestErrorException(
						ResponseConstants.SET_INSTANCES_NOT_SUPPORTED_IN_EAGER);
			}
		} else {

			final Map<String, String> properties = ((InternalProcessingUnit) pu).getElasticProperties();
			final GridServiceContainerConfig gscConfig = new GridServiceContainerConfig(properties);
			final long cloudExternalProcessMemoryInMB = gscConfig.getMaximumMemoryCapacityInMB();

			// final CloudTemplate template = getComputeTemplate(cloud,
			// templateName);
			// final long cloudExternalProcessMemoryInMB = calculateExternalProcessMemory(
			// cloud, template);
			// TODO - set-instances is not supported when the "shared" flag is
			// (CLOUDIFY-1158)
			// currently we fall back to the previous impl
			// CPU = 0 , memoery is calculated as usual. shared = false
			pu.scale(ElasticScaleConfigFactory.createManualCapacityScaleConfig(
					(int) (cloudExternalProcessMemoryInMB * count), 0,
					locationAware, true));
		}

		logger.log(Level.INFO, "Starting to poll for lifecycle events.");
		eventContainerID = startPollingForLifecycleEvents(serviceName,
				applicationName, count, false, timeout, TimeUnit.MINUTES);
		returnMap.put(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID,
				eventContainerID);

		return successStatus(returnMap);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883912/fstmerge_base_5087756000419887159
@JsonRequestExample(requestBody = "{\"count\":1,\"location-aware\":true}")
	@JsonResponseExample(status = "success", responseBody = "{\"lifecycleEventContainerID\":\"eventContainerID\"}")
	@PossibleResponseStatuses(responseStatuses = {
			@PossibleResponseStatus(code = HTTP_OK, description = "success"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR,
			description = ResponseConstants.FAILED_TO_LOCATE_SERVICE),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR,
			description = ResponseConstants.SERVICE_NOT_ELASTIC) })
	@RequestMapping(value = "applications/{applicationName}/services/{serviceName}/timeout/{timeout}/set-instances",
	method = RequestMethod.POST)
	@PreAuthorize("isFullyAuthenticated() and hasPermission(#authGroups, 'deploy')")
	@ResponseBody
	public Map<String, Object> setServiceInstances(
			@PathVariable final String applicationName,
			@PathVariable final String serviceName,
			@PathVariable final int timeout,
			@RequestParam(value = "count", required = true) final int count,
			@RequestParam(value = "location-aware", required = true) final boolean locationAware)
					throws DSLException, RestErrorException {

		final Map<String, Object> returnMap = new HashMap<String, Object>();
		final String puName = ServiceUtils.getAbsolutePUName(applicationName,
				serviceName);
		final ProcessingUnit pu = admin.getProcessingUnits().getProcessingUnit(
				puName);
		if (pu == null) {
			throw new RestErrorException(
					ResponseConstants.FAILED_TO_LOCATE_SERVICE, serviceName);
		}

		if (permissionEvaluator != null) {
			String puAuthGroups = pu.getBeanLevelProperties().getContextProperties().
					getProperty(CloudifyConstants.CONTEXT_PROPERTY_AUTH_GROUPS);
			Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
			CloudifyAuthorizationDetails authDetails = new CloudifyAuthorizationDetails(authentication);
			permissionEvaluator.verifyPermission(authDetails, puAuthGroups, "deploy");
		}

		final Properties contextProperties = pu.getBeanLevelProperties()
				.getContextProperties();
		final String elasticProp = contextProperties
				.getProperty(CloudifyConstants.CONTEXT_PROPERTY_ELASTIC);
		final String templateName = contextProperties
				.getProperty(CloudifyConstants.CONTEXT_PROPERTY_TEMPLATE);

		if (elasticProp == null || !Boolean.parseBoolean(elasticProp)) {
			throw new RestErrorException(ResponseConstants.SERVICE_NOT_ELASTIC,
					serviceName);
		}

		logger.info("Scaling " + puName + " to " + count + " instances");

		UUID eventContainerID;
		if (cloud == null) {
			if (isLocalCloud()) {
				// Manual scale by number of instances
				pu.scale(new ManualCapacityScaleConfigurer().memoryCapacity(
						512 * count, MemoryUnit.MEGABYTES).create());
			} else {
				// Eager scale (1 container per machine per PU)
				throw new RestErrorException(
						ResponseConstants.SET_INSTANCES_NOT_SUPPORTED_IN_EAGER);
			}
		} else {

			final CloudTemplate template = getComputeTemplate(cloud,
					templateName);
			final long cloudExternalProcessMemoryInMB = calculateExternalProcessMemory(
					cloud, template);
			// TODO - set-instances is not supported when the "shared" flag is
			// (CLOUDIFY-1158)
			// currently we fall back to the previous impl
			// CPU = 0 , memoery is calculated as usual. shared = false
			pu.scale(ElasticScaleConfigFactory.createManualCapacityScaleConfig(
					(int) (cloudExternalProcessMemoryInMB * count), 0,
					locationAware, true));
		}

		logger.log(Level.INFO, "Starting to poll for lifecycle events.");
		eventContainerID = startPollingForLifecycleEvents(serviceName,
				applicationName, count, false, timeout, TimeUnit.MINUTES);
		returnMap.put(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID,
				eventContainerID);

		return successStatus(returnMap);
=======
@JsonRequestExample(requestBody = "{\"count\":1,\"location-aware\":true}")
	@JsonResponseExample(status = "success", responseBody = "{\"lifecycleEventContainerID\":\"eventContainerID\"}")
	@PossibleResponseStatuses(responseStatuses = {
			@PossibleResponseStatus(code = HTTP_OK, description = "success"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR,
					description = ResponseConstants.FAILED_TO_LOCATE_SERVICE),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR,
					description = ResponseConstants.SERVICE_NOT_ELASTIC) })
	@RequestMapping(value = "applications/{applicationName}/services/{serviceName}/timeout/{timeout}/set-instances",
			method = RequestMethod.POST)
	@PreAuthorize("isFullyAuthenticated() and hasPermission(#authGroups, 'deploy')")
	@ResponseBody
	public Map<String, Object> setServiceInstances(
			@PathVariable final String applicationName,
			@PathVariable final String serviceName,
			@PathVariable final int timeout,
			@RequestParam(value = "count", required = true) final int count,
			@RequestParam(value = "location-aware", required = true) final boolean locationAware)
			throws DSLException, RestErrorException {

		final Map<String, Object> returnMap = new HashMap<String, Object>();
		final String puName = ServiceUtils.getAbsolutePUName(applicationName,
				serviceName);
		final ProcessingUnit pu = admin.getProcessingUnits().getProcessingUnit(
				puName);
		if (pu == null) {
			throw new RestErrorException(
					ResponseConstants.FAILED_TO_LOCATE_SERVICE, serviceName);
		}

		if (permissionEvaluator != null) {
			final String puAuthGroups = pu.getBeanLevelProperties().getContextProperties().
					getProperty(CloudifyConstants.CONTEXT_PROPERTY_AUTH_GROUPS);
			final Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
			final CloudifyAuthorizationDetails authDetails = new CloudifyAuthorizationDetails(authentication);
			permissionEvaluator.verifyPermission(authDetails, puAuthGroups, "deploy");
		}

		final Properties contextProperties = pu.getBeanLevelProperties()
				.getContextProperties();
		final String elasticProp = contextProperties
				.getProperty(CloudifyConstants.CONTEXT_PROPERTY_ELASTIC);
		final String templateName = contextProperties
				.getProperty(CloudifyConstants.CONTEXT_PROPERTY_TEMPLATE);

		if (elasticProp == null || !Boolean.parseBoolean(elasticProp)) {
			throw new RestErrorException(ResponseConstants.SERVICE_NOT_ELASTIC,
					serviceName);
		}

		logger.info("Scaling " + puName + " to " + count + " instances");

		UUID eventContainerID;
		if (cloud == null) {
			if (isLocalCloud()) {
				// Manual scale by number of instances
				pu.scale(new ManualCapacityScaleConfigurer().memoryCapacity(
						512 * count, MemoryUnit.MEGABYTES).create());
			} else {
				// Eager scale (1 container per machine per PU)
				throw new RestErrorException(
						ResponseConstants.SET_INSTANCES_NOT_SUPPORTED_IN_EAGER);
			}
		} else {

			final Map<String, String> properties = ((InternalProcessingUnit) pu).getElasticProperties();
			final GridServiceContainerConfig gscConfig = new GridServiceContainerConfig(properties);
			final long cloudExternalProcessMemoryInMB = gscConfig.getMaximumMemoryCapacityInMB();

			// final CloudTemplate template = getComputeTemplate(cloud,
			// templateName);
			// final long cloudExternalProcessMemoryInMB = calculateExternalProcessMemory(
			// cloud, template);

			pu.scale(ElasticScaleConfigFactory.createManualCapacityScaleConfig(
					(int) (cloudExternalProcessMemoryInMB * count), 0,
					locationAware, true));
		}

		logger.log(Level.INFO, "Starting to poll for lifecycle events.");
		eventContainerID = startPollingForLifecycleEvents(serviceName,
				applicationName, count, false, timeout, TimeUnit.MINUTES);
		returnMap.put(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID,
				eventContainerID);

		return successStatus(returnMap);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883912/fstmerge_var2_4837359416035886988
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883964/fstmerge_var1_8793833665668220931
@JsonRequestExample(requestBody = "{\"templatesFolder\" : \"templates folder\"}")
	@JsonResponseExample(status = "success", responseBody = "[\"template1\", \"template2\", \"template3\"]",
			comments = "In case of failure a RestErrorException will be thrown and its args will contain two maps: "
					+ "a map of hosts and foreach host its failed to add templates with their error reasons "
					+ "(which is a map of template name and error description) "
					+ "and a map of hosts and for each host its list of successfuly added templates.")
	@PossibleResponseStatuses(responseStatuses = {
			@PossibleResponseStatus(code = HTTP_OK, description = "success"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR,
					description = "Failed to add all the templates to all the REST instances.") })
	@PreAuthorize("isFullyAuthenticated() and hasAnyRole('ROLE_CLOUDADMINS')")
	@RequestMapping(value = "templates", method = RequestMethod.POST)
	public @ResponseBody
	Map<String, Object> addTemplates(
			@RequestParam
			(value = TEMPLATES_DIR_PARAM_NAME, required = true) final MultipartFile templatesFolder)
			throws IOException, DSLException, RestErrorException {
		if (cloud == null) {
			throw new RestErrorException("local_cloud_not_support_templates_operations", "add-templates");
		}
		logger.log(Level.INFO, "[addTemplates] - starting add templates.");
		File loaclTemplatesZipFile = null;
		File unzippedTemplatesFolder = null;
		try {
			loaclTemplatesZipFile = copyMultipartFileToLocalFile(templatesFolder);
			unzippedTemplatesFolder = new ComputeTemplatesReader().unzipCloudTemplatesFolder(loaclTemplatesZipFile);
			final List<String> expectedTemplates = readCloudTemplatesNames(unzippedTemplatesFolder);

			final Map<String, Map<String, String>> failedToAddTemplatesByHost =
					new HashMap<String, Map<String, String>>();
			final Map<String, List<String>> addedTemplatesByHost = new HashMap<String, List<String>>();
			// add the templates to the remote PUs, update addedTemplatesByHost
			// and missingTemplatesByHost.
			sendAddTemplatesToRestInstances(loaclTemplatesZipFile, expectedTemplates,
					addedTemplatesByHost, failedToAddTemplatesByHost);

			// If some templates failed to be added, throw an exception
			if (!failedToAddTemplatesByHost.isEmpty()) {
				if (addedTemplatesByHost.isEmpty()) {
					logger.log(Level.WARNING, "[addTemplates] - Failed to add the following templates (by host): "
							+ failedToAddTemplatesByHost);
					throw new RestErrorException(CloudifyErrorMessages.FAILED_TO_ADD_TEMPLATES.getName(),
							failedToAddTemplatesByHost);

				} else {
					logger.log(Level.WARNING, "[addTemplates] - Failed to add the following templates (by host): "
							+ failedToAddTemplatesByHost + ".\nSuccessfully added templates (by host): "
							+ addedTemplatesByHost);
					throw new RestErrorException(CloudifyErrorMessages.PARTLY_FAILED_TO_ADD_TEMPLATES.getName(),
							failedToAddTemplatesByHost, addedTemplatesByHost);
				}
			}

			logger.log(Level.INFO, "[addTemplates] - Successfully added templates: " + addedTemplatesByHost.toString());
			return successStatus(expectedTemplates);

		} finally {
			FileUtils.deleteQuietly(unzippedTemplatesFolder);
			FileUtils.deleteQuietly(loaclTemplatesZipFile);
		}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883964/fstmerge_base_7452561255688234007
@JsonRequestExample(requestBody = "{\"templatesFolder\" : \"templates folder\"}")
	@JsonResponseExample(status = "success", responseBody = "[\"template1\", \"template2\", \"template3\"]", 
	comments = "In case of failure a RestErrorException will be thrown and its args will contain two maps: " 
			+ "a map of hosts and foreach host its failed to add templates with their error reasons " 
			+ "(which is a map of template name and error description) " 
			+ "and a map of hosts and for each host its list of successfuly added templates.")
	@PossibleResponseStatuses(responseStatuses = {
			@PossibleResponseStatus(code = HTTP_OK, description = "success"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR, 
			description = "Failed to add all the templates to all the REST instances.") })
	@PreAuthorize("isFullyAuthenticated() and hasAnyRole('ROLE_CLOUDADMINS')")
	@RequestMapping(value = "templates", method = RequestMethod.POST)
	public @ResponseBody
	Map<String, Object> addTemplates(
			@RequestParam
			(value = TEMPLATES_DIR_PARAM_NAME, required = true) final MultipartFile templatesFolder)
					throws IOException, DSLException, RestErrorException {
		if (cloud == null) {
			throw new RestErrorException("local_cloud_not_support_templates_operations", "add-templates");
		}
		logger.log(Level.INFO, "[addTemplates] - starting add templates.");
		File loaclTemplatesZipFile = null;
		File unzippedTemplatesFolder = null;
		try {
			loaclTemplatesZipFile = copyMultipartFileToLocalFile(templatesFolder);
			unzippedTemplatesFolder = new CloudTemplatesReader().unzipCloudTemplatesFolder(loaclTemplatesZipFile);
			List<String> expectedTemplates = readCloudTemplatesNames(unzippedTemplatesFolder);

			Map<String, Map<String, String>> failedToAddTemplatesByHost = new HashMap<String, Map<String, String>>();
			Map<String, List<String>> addedTemplatesByHost = new HashMap<String, List<String>>();
			// add the templates to the remote PUs, update addedTemplatesByHost
			// and missingTemplatesByHost.
			sendAddTemplatesToRestInstances(loaclTemplatesZipFile, expectedTemplates,
					addedTemplatesByHost, failedToAddTemplatesByHost);

			// If some templates failed to be added, throw an exception
			if (!failedToAddTemplatesByHost.isEmpty()) {
				if (addedTemplatesByHost.isEmpty()) {
					logger.log(Level.WARNING, "[addTemplates] - Failed to add the following templates (by host): "
							+ failedToAddTemplatesByHost);
					throw new RestErrorException(CloudifyErrorMessages.FAILED_TO_ADD_TEMPLATES.getName(),
							failedToAddTemplatesByHost);
					
				} else {
					logger.log(Level.WARNING, "[addTemplates] - Failed to add the following templates (by host): "
							+ failedToAddTemplatesByHost + ".\nSuccessfully added templates (by host): " 
							+ addedTemplatesByHost);
					throw new RestErrorException(CloudifyErrorMessages.PARTLY_FAILED_TO_ADD_TEMPLATES.getName(),
							failedToAddTemplatesByHost, addedTemplatesByHost);
				}
			}

			logger.log(Level.INFO, "[addTemplates] - Successfully added templates: " + addedTemplatesByHost.toString());
			return successStatus(expectedTemplates);

		} finally {
			FileUtils.deleteQuietly(unzippedTemplatesFolder);
			FileUtils.deleteQuietly(loaclTemplatesZipFile);
		}
=======
@JsonRequestExample(requestBody = "{\"templatesFolder\" : \"templates folder\"}")
	@JsonResponseExample(status = "success", responseBody = "[\"template1\", \"template2\", \"template3\"]",
			comments = "In case of failure a RestErrorException will be thrown and its args will contain two maps: "
					+ "a map of hosts and foreach host its failed to add templates with their error reasons "
					+ "(which is a map of template name and error description) "
					+ "and a map of hosts and for each host its list of successfuly added templates.")
	@PossibleResponseStatuses(responseStatuses = {
			@PossibleResponseStatus(code = HTTP_OK, description = "success"),
			@PossibleResponseStatus(code = HTTP_INTERNAL_SERVER_ERROR,
					description = "Failed to add all the templates to all the REST instances.") })
	@PreAuthorize("isFullyAuthenticated() and hasAnyRole('ROLE_CLOUDADMINS')")
	@RequestMapping(value = "templates", method = RequestMethod.POST)
	public @ResponseBody
	Map<String, Object> addTemplates(
			@RequestParam
			(value = TEMPLATES_DIR_PARAM_NAME, required = true) final MultipartFile templatesFolder)
			throws IOException, DSLException, RestErrorException {
		if (cloud == null) {
			throw new RestErrorException("local_cloud_not_support_templates_operations", "add-templates");
		}
		logger.log(Level.INFO, "[addTemplates] - starting add templates.");
		File loaclTemplatesZipFile = null;
		File unzippedTemplatesFolder = null;
		try {
			loaclTemplatesZipFile = copyMultipartFileToLocalFile(templatesFolder);
			unzippedTemplatesFolder = new CloudTemplatesReader().unzipCloudTemplatesFolder(loaclTemplatesZipFile);
			final List<String> expectedTemplates = readCloudTemplatesNames(unzippedTemplatesFolder);

			final Map<String, Map<String, String>> failedToAddTemplatesByHost =
					new HashMap<String, Map<String, String>>();
			final Map<String, List<String>> addedTemplatesByHost = new HashMap<String, List<String>>();
			// add the templates to the remote PUs, update addedTemplatesByHost
			// and missingTemplatesByHost.
			sendAddTemplatesToRestInstances(loaclTemplatesZipFile, expectedTemplates,
					addedTemplatesByHost, failedToAddTemplatesByHost);

			// If some templates failed to be added, throw an exception
			if (!failedToAddTemplatesByHost.isEmpty()) {
				if (addedTemplatesByHost.isEmpty()) {
					logger.log(Level.WARNING, "[addTemplates] - Failed to add the following templates (by host): "
							+ failedToAddTemplatesByHost);
					throw new RestErrorException(CloudifyErrorMessages.FAILED_TO_ADD_TEMPLATES.getName(),
							failedToAddTemplatesByHost);

				} else {
					logger.log(Level.WARNING, "[addTemplates] - Failed to add the following templates (by host): "
							+ failedToAddTemplatesByHost + ".\nSuccessfully added templates (by host): "
							+ addedTemplatesByHost);
					throw new RestErrorException(CloudifyErrorMessages.PARTLY_FAILED_TO_ADD_TEMPLATES.getName(),
							failedToAddTemplatesByHost, addedTemplatesByHost);
				}
			}

			logger.log(Level.INFO, "[addTemplates] - Successfully added templates: " + addedTemplatesByHost.toString());
			return successStatus(expectedTemplates);

		} finally {
			FileUtils.deleteQuietly(unzippedTemplatesFolder);
			FileUtils.deleteQuietly(loaclTemplatesZipFile);
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883964/fstmerge_var2_1076547833789571984
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883986/fstmerge_var1_4825841428474067708
@InternalMethod
	// @PreAuthorize("isFullyAuthenticated() and hasAnyRole('ROLE_CLOUDADMINS')")
	@RequestMapping(value = "templates/internal", method = RequestMethod.POST)
	public @ResponseBody
	Map<String, Object>
			addTemplatesInternal(
					@RequestParam
					(value = CloudifyConstants.TEMPLATES_DIR_PARAM_NAME, required = true) final MultipartFile templatesFolder)
					throws IOException, DSLException, RestErrorException {
		ComputeTemplatesReader reader = new ComputeTemplatesReader();
		File localTemplatesFolder = reader.unzipCloudTemplatesFolder(copyMultipartFileToLocalFile(templatesFolder));
		try {
			logger.log(Level.INFO, "[addTemplatesInternal] - adding templates from templates folder: "
					+ localTemplatesFolder.getAbsolutePath());
			// add templates to the cloud and return the added templates.
			return successStatus(addTemplatesToCloud(localTemplatesFolder));
		} finally {
			FileUtils.deleteQuietly(localTemplatesFolder);
		}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883986/fstmerge_base_6499283461760894859
@InternalMethod
	//@PreAuthorize("isFullyAuthenticated() and hasAnyRole('ROLE_CLOUDADMINS')")
	@RequestMapping(value = "templates/internal", method = RequestMethod.POST)
	public @ResponseBody
	Map<String, Object>
	addTemplatesInternal(
			@RequestParam
			(value = CloudifyConstants.TEMPLATES_DIR_PARAM_NAME, required = true) final MultipartFile templatesFolder)
					throws IOException, DSLException, RestErrorException {
		CloudTemplatesReader reader = new CloudTemplatesReader();
		File localTemplatesFolder = reader.unzipCloudTemplatesFolder(copyMultipartFileToLocalFile(templatesFolder));
		try {
			logger.log(Level.INFO, "[addTemplatesInternal] - adding templates from templates folder: "
					+ localTemplatesFolder.getAbsolutePath());
			// add templates to the cloud and return the added templates.
			return successStatus(addTemplatesToCloud(localTemplatesFolder));
		} finally {
			FileUtils.deleteQuietly(localTemplatesFolder);
		}
=======
@InternalMethod
	// @PreAuthorize("isFullyAuthenticated() and hasAnyRole('ROLE_CLOUDADMINS')")
	@RequestMapping(value = "templates/internal", method = RequestMethod.POST)
	public @ResponseBody
	Map<String, Object>
			addTemplatesInternal(
					@RequestParam
					(value = CloudifyConstants.TEMPLATES_DIR_PARAM_NAME, required = true) final MultipartFile templatesFolder)
					throws IOException, DSLException, RestErrorException {
		final CloudTemplatesReader reader = new CloudTemplatesReader();
		final File localTemplatesFolder =
				reader.unzipCloudTemplatesFolder(copyMultipartFileToLocalFile(templatesFolder));
		try {
			logger.log(Level.INFO, "[addTemplatesInternal] - adding templates from templates folder: "
					+ localTemplatesFolder.getAbsolutePath());
			// add templates to the cloud and return the added templates.
			return successStatus(addTemplatesToCloud(localTemplatesFolder));
		} finally {
			FileUtils.deleteQuietly(localTemplatesFolder);
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883986/fstmerge_var2_625943911602114383
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883992/fstmerge_var1_3377258576056340030
private Map<String, Object> addTemplatesToCloud(final File templatesFolder)
			throws RestErrorException, DSLException {

		logger.log(Level.FINE, "[addTemplatesToCloud] - Adding templates to cloud.");

		// read cloud templates from templates folder
		List<ComputeTemplateHolder> cloudTemplatesHolders = readCloudTemplates(templatesFolder);
		logger.log(Level.FINE, "[addTemplatesToCloud] - Successfully read " + cloudTemplatesHolders.size()
				+ " templates from folder - " + templatesFolder);

		// adds the templates to the cloud's templates list, deletes the failed to added templates from the folder.
		final Map<String, String> failedToAddTemplates = new HashMap<String, String>();
		final List<String> addedTemplates = new LinkedList<String>();
		addTemplatesToCloudList(templatesFolder, cloudTemplatesHolders, addedTemplates, failedToAddTemplates);
		// if no templates were added, throw an exception
		if (addedTemplates.isEmpty()) {
			logger.log(Level.WARNING, "[addTemplatesToCloud] - Failed to add templates files from "
					+ templatesFolder.getAbsolutePath());
		} else {
			// at least one template was added, copy files from template folder to cloudTemplateFolder
			logger.log(Level.FINE, "[addTemplatesToCloud] - Coping templates files from "
					+ templatesFolder.getAbsolutePath() + " to " + cloudConfigurationDir.getAbsolutePath());
			try {
				final File localTemplatesDir = copyTemplateFilesToCloudConfigDir(templatesFolder);
				updateCloudTemplatesUploadPath(addedTemplates, localTemplatesDir);
			} catch (final IOException e) {
				// failed to copy files - remove all added templates from cloud and them to the failed map.
				logger.log(Level.WARNING, "[addTemplatesToCloud] - Failed to copy templates files, error: "
						+ e.getMessage(), e);
				for (final String templateName : addedTemplates) {
					cloud.getCloudCompute().getTemplates().remove(templateName);
					failedToAddTemplates.put(templateName, e.getMessage());
				}
			}
		}

		// return the added templates and the failed to add templates lists.
		final Map<String, Object> resultMap = new HashMap<String, Object>();
		resultMap.put(FAILED_TO_ADD_TEMPLATES_KEY, failedToAddTemplates);
		resultMap.put(SUCCESSFULLY_ADDED_TEMPLATES_KEY, addedTemplates);
		if (!failedToAddTemplates.isEmpty()) {
			logger.log(Level.INFO, "[addTemplatesToCloud] - Failed to add the following templates: "
					+ failedToAddTemplates.toString());
		}
		return resultMap;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883992/fstmerge_base_8454979213495696773
private Map<String, Object> addTemplatesToCloud(final File templatesFolder)
			throws RestErrorException, DSLException {

		logger.log(Level.FINE, "[addTemplatesToCloud] - Adding templates to cloud.");

		// read cloud templates from templates folder
		List<CloudTemplateHolder> cloudTemplatesHolders = readCloudTemplates(templatesFolder);
		logger.log(Level.FINE, "[addTemplatesToCloud] - Successfully read " + cloudTemplatesHolders.size()
				+ " templates from folder - " + templatesFolder);

		// adds the templates to the cloud's templates list, deletes the failed to added templates from the folder.
		Map<String, String> failedToAddTemplates = new HashMap<String, String>();
		List<String> addedTemplates = new LinkedList<String>();
		addTemplatesToCloudList(templatesFolder, cloudTemplatesHolders, addedTemplates, failedToAddTemplates);
		// if no templates were added, throw an exception
		if (addedTemplates.isEmpty()) {
			logger.log(Level.WARNING, "[addTemplatesToCloud] - Failed to add templates files from "
					+ templatesFolder.getAbsolutePath());
		} else {
			// at least one template was added, copy files from template folder to cloudTemplateFolder
			logger.log(Level.FINE, "[addTemplatesToCloud] - Coping templates files from " 
					+ templatesFolder.getAbsolutePath() + " to " + cloudConfigurationDir.getAbsolutePath());
			try {
				File localTemplatesDir = copyTemplateFilesToCloudConfigDir(templatesFolder);
				updateCloudTemplatesUploadPath(addedTemplates, localTemplatesDir);
			} catch (IOException e) {
				// failed to copy files - remove all added templates from cloud and them to the failed map.
				logger.log(Level.WARNING, "[addTemplatesToCloud] - Failed to copy templates files, error: " 
						+ e.getMessage(), e);
				for (String templateName : addedTemplates) {
					cloud.getTemplates().remove(templateName);
					failedToAddTemplates.put(templateName, e.getMessage());
				}
			}
		}

		// return the added templates and the failed to add templates lists.
		Map<String, Object> resultMap = new HashMap<String, Object>();
		resultMap.put(FAILED_TO_ADD_TEMPLATES_KEY, failedToAddTemplates);
		resultMap.put(SUCCESSFULLY_ADDED_TEMPLATES_KEY, addedTemplates);
		if (!failedToAddTemplates.isEmpty()) {
			logger.log(Level.INFO, "[addTemplatesToCloud] - Failed to add the following templates: "
					+ failedToAddTemplates.toString());
		}
		return resultMap;
=======
private Map<String, Object> addTemplatesToCloud(final File templatesFolder)
			throws RestErrorException, DSLException {

		logger.log(Level.FINE, "[addTemplatesToCloud] - Adding templates to cloud.");

		// read cloud templates from templates folder
		final List<CloudTemplateHolder> cloudTemplatesHolders = readCloudTemplates(templatesFolder);
		logger.log(Level.FINE, "[addTemplatesToCloud] - Successfully read " + cloudTemplatesHolders.size()
				+ " templates from folder - " + templatesFolder);

		// adds the templates to the cloud's templates list, deletes the failed to added templates from the folder.
		final Map<String, String> failedToAddTemplates = new HashMap<String, String>();
		final List<String> addedTemplates = new LinkedList<String>();
		addTemplatesToCloudList(templatesFolder, cloudTemplatesHolders, addedTemplates, failedToAddTemplates);
		// if no templates were added, throw an exception
		if (addedTemplates.isEmpty()) {
			logger.log(Level.WARNING, "[addTemplatesToCloud] - Failed to add templates files from "
					+ templatesFolder.getAbsolutePath());
		} else {
			// at least one template was added, copy files from template folder to cloudTemplateFolder
			logger.log(Level.FINE, "[addTemplatesToCloud] - Coping templates files from "
					+ templatesFolder.getAbsolutePath() + " to " + cloudConfigurationDir.getAbsolutePath());
			try {
				final File localTemplatesDir = copyTemplateFilesToCloudConfigDir(templatesFolder);
				updateCloudTemplatesUploadPath(addedTemplates, localTemplatesDir);
			} catch (final IOException e) {
				// failed to copy files - remove all added templates from cloud and them to the failed map.
				logger.log(Level.WARNING, "[addTemplatesToCloud] - Failed to copy templates files, error: "
						+ e.getMessage(), e);
				for (final String templateName : addedTemplates) {
					cloud.getTemplates().remove(templateName);
					failedToAddTemplates.put(templateName, e.getMessage());
				}
			}
		}

		// return the added templates and the failed to add templates lists.
		final Map<String, Object> resultMap = new HashMap<String, Object>();
		resultMap.put(FAILED_TO_ADD_TEMPLATES_KEY, failedToAddTemplates);
		resultMap.put(SUCCESSFULLY_ADDED_TEMPLATES_KEY, addedTemplates);
		if (!failedToAddTemplates.isEmpty()) {
			logger.log(Level.INFO, "[addTemplatesToCloud] - Failed to add the following templates: "
					+ failedToAddTemplates.toString());
		}
		return resultMap;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883992/fstmerge_var2_2904599238503345483
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883998/fstmerge_var1_2217766960049659848
private void updateCloudTemplatesUploadPath(final List<String> addedTemplates, final File localTemplatesDir) {
		for (String templateName : addedTemplates) {
			ComputeTemplate cloudTemplate = cloud.getCloudCompute().getTemplates().get(templateName);
			String localUploadPath = new File(localTemplatesDir, cloudTemplate.getLocalDirectory()).getAbsolutePath();
			cloudTemplate.setAbsoluteUploadDir(localUploadPath);
		}

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883998/fstmerge_base_2853486199315839776
private void updateCloudTemplatesUploadPath(final List<String> addedTemplates, final File localTemplatesDir) {
		for (String templateName : addedTemplates) {
			CloudTemplate cloudTemplate = cloud.getTemplates().get(templateName);
			String localUploadPath = new File(localTemplatesDir, cloudTemplate.getLocalDirectory()).getAbsolutePath();
			cloudTemplate.setAbsoluteUploadDir(localUploadPath);
		}

=======
private void updateCloudTemplatesUploadPath(final List<String> addedTemplates, final File localTemplatesDir) {
		for (final String templateName : addedTemplates) {
			final CloudTemplate cloudTemplate = cloud.getTemplates().get(templateName);
			final String localUploadPath =
					new File(localTemplatesDir, cloudTemplate.getLocalDirectory()).getAbsolutePath();
			cloudTemplate.setAbsoluteUploadDir(localUploadPath);
		}

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617883998/fstmerge_var2_504699217699763485
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884002/fstmerge_var1_4626903605003417551
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884002/fstmerge_base_7457832411804084731
private void addTemplatesToCloudList(final File templatesFolder, final List<CloudTemplateHolder> cloudTemplates,
			final List<String> addedTemplates, final Map<String, String> failedToAddTemplates) {
		for (CloudTemplateHolder holder : cloudTemplates) {
			String templateName = holder.getName();
			String originalTemplateFileName = holder.getTemplateFileName();
			// check if template already exist
			if (cloud.getTemplates().containsKey(templateName)) {
				logger.log(Level.WARNING, "[addTemplatesToCloudList] - Template already exists: " + templateName);
				failedToAddTemplates.put(templateName, "template already exists");
				new File(templatesFolder, originalTemplateFileName).delete();
				continue;
			}
			// rename template file to <templateName>-template.groovy if needed
			// rename the proeprties and overrides files as well.
			try {
				renameTemplateFileIfNeeded(templatesFolder, holder);
			} catch (IOException e) {
				logger.log(Level.WARNING, "[addTemplatesToCloudList] - Failed to rename template's file, template: "
						+ templateName + ", error: " + e.getMessage(), e);
				failedToAddTemplates.put(templateName, "failed to rename template's file. error: " + e.getMessage());
				new File(templatesFolder, originalTemplateFileName).delete();
				continue;
			}
			// add template to cloud templates list
			CloudTemplate cloudTemplate = holder.getCloudTemplate();
			cloud.getTemplates().put(templateName, cloudTemplate);
			addedTemplates.add(templateName);
		}
	}
=======
private void addTemplatesToCloudList(final File templatesFolder, final List<CloudTemplateHolder> cloudTemplates,
			final List<String> addedTemplates, final Map<String, String> failedToAddTemplates) {
		for (final CloudTemplateHolder holder : cloudTemplates) {
			final String templateName = holder.getName();
			final String originalTemplateFileName = holder.getTemplateFileName();
			// check if template already exist
			if (cloud.getTemplates().containsKey(templateName)) {
				logger.log(Level.WARNING, "[addTemplatesToCloudList] - Template already exists: " + templateName);
				failedToAddTemplates.put(templateName, "template already exists");
				new File(templatesFolder, originalTemplateFileName).delete();
				continue;
			}
			// rename template file to <templateName>-template.groovy if needed
			// rename the proeprties and overrides files as well.
			try {
				renameTemplateFileIfNeeded(templatesFolder, holder);
			} catch (final IOException e) {
				logger.log(Level.WARNING, "[addTemplatesToCloudList] - Failed to rename template's file, template: "
						+ templateName + ", error: " + e.getMessage(), e);
				failedToAddTemplates.put(templateName, "failed to rename template's file. error: " + e.getMessage());
				new File(templatesFolder, originalTemplateFileName).delete();
				continue;
			}
			// add template to cloud templates list
			final CloudTemplate cloudTemplate = holder.getCloudTemplate();
			cloud.getTemplates().put(templateName, cloudTemplate);
			addedTemplates.add(templateName);
		}
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884002/fstmerge_var2_238965011963334205

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884007/fstmerge_var1_7081905881197705520
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884007/fstmerge_base_5242859230295234565
private void renameTemplateFileIfNeeded(final File templatesFolder, final CloudTemplateHolder holder) 
			throws IOException {
		String templateName = holder.getName();

		String templateFileName = holder.getTemplateFileName();
		File templateFile = new File(templatesFolder, templateFileName);
		String propertiesFileName = holder.getPropertiesFileName();
		String overridesFileName = holder.getOverridesFileName();

		try {
			String newName = DSLUtils.renameCloudTemplateFileNameIfNeeded(templateFile, templateName, 
					DSLUtils.TEMPLATE_DSL_FILE_NAME_SUFFIX);
			if (newName != null) {
				logger.log(Level.INFO, "[renameTemplateFileIfNeeded] - Renamed template file name from "
						+ templateFileName + " to " + newName + ".");
			}
			if (propertiesFileName != null) {
				File propertiesFile = new File(templatesFolder, propertiesFileName);
				newName = DSLUtils.renameCloudTemplateFileNameIfNeeded(propertiesFile, templateName, 
						DSLUtils.TEMPLATES_PROPERTIES_FILE_NAME_SUFFIX);
				if (newName != null) {
					logger.log(Level.INFO, "[renameTemplateFileIfNeeded] - Renamed template's properties file name from"
							+ " " + propertiesFileName + " to " + newName + ".");
				}
			}
			if (overridesFileName != null) {
				File overridesFile = new File(templatesFolder, overridesFileName);		
				newName = DSLUtils.renameCloudTemplateFileNameIfNeeded(overridesFile, templateName, 
						DSLUtils.TEMPLATES_OVERRIDES_FILE_NAME_SUFFIX);
				if (newName != null) {
					logger.log(Level.INFO, "[renameTemplateFileIfNeeded] - Renamed template's overrides file name from "
							+ overridesFileName + " to " + newName + ".");
				}
			}
		} catch (IOException e) {
			logger.log(Level.WARNING, "[renameTemplateFileIfNeeded] - Failed to rename template file name ["
					+ templateFile.getName() + "] to "
					+ templateName + DSLUtils.TEMPLATE_DSL_FILE_NAME_SUFFIX
					+ ". The file will be deleted. Error:" + e);
			// delete the groovy file to ensure the template file wont be
			// copied.
			templateFile.delete();
			throw e;
		}
	}
=======
private void renameTemplateFileIfNeeded(final File templatesFolder, final CloudTemplateHolder holder)
			throws IOException {
		final String templateName = holder.getName();

		final String templateFileName = holder.getTemplateFileName();
		final File templateFile = new File(templatesFolder, templateFileName);
		final String propertiesFileName = holder.getPropertiesFileName();
		final String overridesFileName = holder.getOverridesFileName();

		try {
			String newName = DSLUtils.renameCloudTemplateFileNameIfNeeded(templateFile, templateName,
					DSLUtils.TEMPLATE_DSL_FILE_NAME_SUFFIX);
			if (newName != null) {
				logger.log(Level.INFO, "[renameTemplateFileIfNeeded] - Renamed template file name from "
						+ templateFileName + " to " + newName + ".");
			}
			if (propertiesFileName != null) {
				final File propertiesFile = new File(templatesFolder, propertiesFileName);
				newName = DSLUtils.renameCloudTemplateFileNameIfNeeded(propertiesFile, templateName,
						DSLUtils.TEMPLATES_PROPERTIES_FILE_NAME_SUFFIX);
				if (newName != null) {
					logger.log(Level.INFO,
							"[renameTemplateFileIfNeeded] - Renamed template's properties file name from"
									+ " " + propertiesFileName + " to " + newName + ".");
				}
			}
			if (overridesFileName != null) {
				final File overridesFile = new File(templatesFolder, overridesFileName);
				newName = DSLUtils.renameCloudTemplateFileNameIfNeeded(overridesFile, templateName,
						DSLUtils.TEMPLATES_OVERRIDES_FILE_NAME_SUFFIX);
				if (newName != null) {
					logger.log(Level.INFO,
							"[renameTemplateFileIfNeeded] - Renamed template's overrides file name from "
									+ overridesFileName + " to " + newName + ".");
				}
			}
		} catch (final IOException e) {
			logger.log(Level.WARNING, "[renameTemplateFileIfNeeded] - Failed to rename template file name ["
					+ templateFile.getName() + "] to "
					+ templateName + DSLUtils.TEMPLATE_DSL_FILE_NAME_SUFFIX
					+ ". The file will be deleted. Error:" + e);
			// delete the groovy file to ensure the template file wont be
			// copied.
			templateFile.delete();
			throw e;
		}
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884007/fstmerge_var2_2667814596390937342

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884016/fstmerge_var1_6674243830510048362
private List<ComputeTemplateHolder> readCloudTemplates(final File templatesFolder)
			throws RestErrorException, DSLException {
		List<ComputeTemplateHolder> cloudTemplatesHolders;
		ComputeTemplatesReader reader = new ComputeTemplatesReader();
		cloudTemplatesHolders = reader.readCloudTemplatesFromDirectory(templatesFolder);
		if (cloudTemplatesHolders.isEmpty()) {
			throw new RestErrorException("no_template_files", "templates folder missing templates files.",
					templatesFolder.getAbsolutePath());
		}
		return cloudTemplatesHolders;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884016/fstmerge_base_7682023536934415503
private List<CloudTemplateHolder> readCloudTemplates(final File templatesFolder)
			throws RestErrorException, DSLException {
		List<CloudTemplateHolder> cloudTemplatesHolders;
		CloudTemplatesReader reader = new CloudTemplatesReader();
		cloudTemplatesHolders = reader.readCloudTemplatesFromDirectory(templatesFolder);
		if (cloudTemplatesHolders.isEmpty()) {
			throw new RestErrorException("no_template_files", "templates folder missing templates files." , 
					templatesFolder.getAbsolutePath());
		}
		return cloudTemplatesHolders;
=======
private List<CloudTemplateHolder> readCloudTemplates(final File templatesFolder)
			throws RestErrorException, DSLException {
		List<CloudTemplateHolder> cloudTemplatesHolders;
		final CloudTemplatesReader reader = new CloudTemplatesReader();
		cloudTemplatesHolders = reader.readCloudTemplatesFromDirectory(templatesFolder);
		if (cloudTemplatesHolders.isEmpty()) {
			throw new RestErrorException("no_template_files", "templates folder missing templates files.",
					templatesFolder.getAbsolutePath());
		}
		return cloudTemplatesHolders;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884016/fstmerge_var2_200546851156823181
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884021/fstmerge_var1_3416505618275343205
private List<String> readCloudTemplatesNames(final File templatesFolder)
			throws RestErrorException, DSLException {
		List<ComputeTemplateHolder> cloudTemplatesHolders = readCloudTemplates(templatesFolder);
		List<String> cloudTemplateNames = new LinkedList<String>();
		for (ComputeTemplateHolder cloudTemplateHolder : cloudTemplatesHolders) {
			cloudTemplateNames.add(cloudTemplateHolder.getName());
		}
		return cloudTemplateNames;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884021/fstmerge_base_7899187522372407427
private List<String> readCloudTemplatesNames(final File templatesFolder)
			throws RestErrorException, DSLException {
		List<CloudTemplateHolder> cloudTemplatesHolders = readCloudTemplates(templatesFolder);
		List<String> cloudTemplateNames = new LinkedList<String>();
		for (CloudTemplateHolder cloudTemplateHolder : cloudTemplatesHolders) {
			cloudTemplateNames.add(cloudTemplateHolder.getName());
		}
		return cloudTemplateNames;
=======
private List<String> readCloudTemplatesNames(final File templatesFolder)
			throws RestErrorException, DSLException {
		final List<CloudTemplateHolder> cloudTemplatesHolders = readCloudTemplates(templatesFolder);
		final List<String> cloudTemplateNames = new LinkedList<String>();
		for (final CloudTemplateHolder cloudTemplateHolder : cloudTemplatesHolders) {
			cloudTemplateNames.add(cloudTemplateHolder.getName());
		}
		return cloudTemplateNames;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884021/fstmerge_var2_7345727544719550292
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884031/fstmerge_var1_8143020519150508067
@RequestMapping(value = "templates", method = RequestMethod.GET)
	@PreAuthorize("isFullyAuthenticated() and hasAnyRole('ROLE_CLOUDADMINS', 'ROLE_APPMANAGERS')")
	public @ResponseBody
	Map<String, Object>
			listTemplates() throws RestErrorException {
		if (cloud == null) {
			throw new RestErrorException("local_cloud_not_support_templates_operations", "list-templates");
		}
		return successStatus(cloud.getCloudCompute().getTemplates());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884031/fstmerge_base_4300176325529492240
@RequestMapping(value = "templates", method = RequestMethod.GET)
	@PreAuthorize("isFullyAuthenticated() and hasAnyRole('ROLE_CLOUDADMINS', 'ROLE_APPMANAGERS')")
	public @ResponseBody
	Map<String, Object>
	listTemplates() throws RestErrorException {
		if (cloud == null) {
			throw new RestErrorException("local_cloud_not_support_templates_operations", "list-templates");
		}
		return successStatus(cloud.getTemplates());
=======
@RequestMapping(value = "templates", method = RequestMethod.GET)
	@PreAuthorize("isFullyAuthenticated() and hasAnyRole('ROLE_CLOUDADMINS', 'ROLE_APPMANAGERS')")
	public @ResponseBody
	Map<String, Object>
			listTemplates() throws RestErrorException {
		if (cloud == null) {
			throw new RestErrorException("local_cloud_not_support_templates_operations", "list-templates");
		}
		return successStatus(cloud.getTemplates());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884031/fstmerge_var2_578824003074242993
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884036/fstmerge_var1_4717974486863240570
@RequestMapping(value = "templates/{templateName}", method = RequestMethod.GET)
	@PreAuthorize("isFullyAuthenticated() and hasAnyRole('ROLE_CLOUDADMINS', 'ROLE_APPMANAGERS')")
	public @ResponseBody
	Map<String, Object>
			getTemplate(@PathVariable final String templateName)
					throws RestErrorException {

		if (cloud == null) {
			throw new RestErrorException("local_cloud_not_support_templates_operations", "get-template");
		}

		// get template from cloud
		ComputeTemplate cloudTemplate = cloud.getCloudCompute().getTemplates().get(templateName);

		if (cloudTemplate == null) {
			logger.log(Level.WARNING, "[getTemplate] - template [" + templateName
					+ "] not found. cloud templates list: " + cloud.getCloudCompute().getTemplates());
			throw new RestErrorException("template_not_exist", templateName);
		}
		return successStatus(cloudTemplate);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884036/fstmerge_base_3445867736048899625
@RequestMapping(value = "templates/{templateName}", method = RequestMethod.GET)
	@PreAuthorize("isFullyAuthenticated() and hasAnyRole('ROLE_CLOUDADMINS', 'ROLE_APPMANAGERS')")
	public @ResponseBody
	Map<String, Object>
	getTemplate(@PathVariable final String templateName)
			throws RestErrorException {

		if (cloud == null) {
			throw new RestErrorException("local_cloud_not_support_templates_operations", "get-template");
		}

		// get template from cloud
		CloudTemplate cloudTemplate = cloud.getTemplates().get(templateName);

		if (cloudTemplate == null) {
			logger.log(Level.WARNING, "[getTemplate] - template [" + templateName 
					+ "] not found. cloud templates list: " + cloud.getTemplates());
			throw new RestErrorException("template_not_exist", templateName);
		}
		return successStatus(cloudTemplate);
=======
@RequestMapping(value = "templates/{templateName}", method = RequestMethod.GET)
	@PreAuthorize("isFullyAuthenticated() and hasAnyRole('ROLE_CLOUDADMINS', 'ROLE_APPMANAGERS')")
	public @ResponseBody
	Map<String, Object>
			getTemplate(@PathVariable final String templateName)
					throws RestErrorException {

		if (cloud == null) {
			throw new RestErrorException("local_cloud_not_support_templates_operations", "get-template");
		}

		// get template from cloud
		final CloudTemplate cloudTemplate = cloud.getTemplates().get(templateName);

		if (cloudTemplate == null) {
			logger.log(Level.WARNING, "[getTemplate] - template [" + templateName
					+ "] not found. cloud templates list: " + cloud.getTemplates());
			throw new RestErrorException("template_not_exist", templateName);
		}
		return successStatus(cloudTemplate);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884036/fstmerge_var2_1304673345724292078
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884056/fstmerge_var1_1569318006700874561
private void removeTemplateFromCloud(final String templateName)
			throws RestErrorException {

		logger.log(Level.INFO, "[removeTemplateFromCloud] - removing template [" + templateName + "] from cloud.");

		// delete template's file from the cloud configuration directory.
		deleteTemplateFile(templateName);

		// remove template from cloud
		Map<String, ComputeTemplate> cloudTemplates = cloud.getCloudCompute().getTemplates();
		if (!cloudTemplates.containsKey(templateName)) {
			throw new RestErrorException("template_not_exist", templateName);
		}
		cloudTemplates.remove(templateName);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884056/fstmerge_base_6915931659893819467
private void removeTemplateFromCloud(final String templateName)
			throws RestErrorException {

		logger.log(Level.INFO, "[removeTemplateFromCloud] - removing template [" + templateName + "] from cloud.");

		// delete template's file from the cloud configuration directory.
		deleteTemplateFile(templateName);

		// remove template from cloud
		Map<String, CloudTemplate> cloudTemplates = cloud.getTemplates();
		if (!cloudTemplates.containsKey(templateName)) {
			throw new RestErrorException("template_not_exist", templateName);
		}
		cloudTemplates.remove(templateName);
=======
private void removeTemplateFromCloud(final String templateName)
			throws RestErrorException {

		logger.log(Level.INFO, "[removeTemplateFromCloud] - removing template [" + templateName + "] from cloud.");

		// delete template's file from the cloud configuration directory.
		deleteTemplateFile(templateName);

		// remove template from cloud
		final Map<String, CloudTemplate> cloudTemplates = cloud.getTemplates();
		if (!cloudTemplates.containsKey(templateName)) {
			throw new RestErrorException("template_not_exist", templateName);
		}
		cloudTemplates.remove(templateName);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884056/fstmerge_var2_8709569197882232248
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884060/fstmerge_var1_3284288396679377961
private void deleteTemplateFile(final String templateName) throws RestErrorException {
		final File templateFile = getTemplateFile(templateName);
		if (templateFile == null) {
			throw new RestErrorException("failed_to_remove_template_file", templateName,
					"template file doesn't exist");
		}
		// delete the file from the directory.
		final String templatesPath = templateFile.getAbsolutePath();
		logger.log(Level.FINE, "[deleteTemplateFile] - removing template file " + templatesPath);
		boolean deleted = false;
		try {
			deleted = templateFile.delete();
		} catch (final SecurityException e) {
			logger.log(Level.WARNING, "[deleteTemplateFile] - Failed to deleted template file " + templatesPath
					+ ", Error: " + e.getMessage(), e);
			throw new RestErrorException("failed_to_remove_template_file", templatesPath, e.getMessage());
		}
		if (!deleted) {
			throw new RestErrorException("failed_to_remove_template_file", templatesPath,
					"template file was not deleted.");
		}
		logger.log(Level.FINE, "[deleteTemplateFile] - Successfully deleted template file [" + templatesPath + "].");
		final File templateFolder = templateFile.getParentFile();
		final File[] templatesFiles =
				DSLReader.findDefaultDSLFiles(DSLUtils.TEMPLATE_DSL_FILE_NAME_SUFFIX, templateFolder);
		if (templatesFiles == null || templatesFiles.length == 0) {
			try {
				logger.log(Level.FINE, "[deleteTemplateFile] - templates folder is empty, deleting the folder ["
						+ templatesPath + "].");
				FileUtils.deleteDirectory(templateFolder);
			} catch (final IOException e) {
				logger.log(Level.WARNING, "[deleteTemplateFile] - Failed to delete templates folder"
						+ templateFolder, e);
			}
		} else {
			// delete properties and overrides files if exist.
			ComputeTemplatesReader.removeTemplateFiles(templateFolder, templateName);
		}
		final File templatesFolder = getTemplatesFolder();
		if (templatesFolder.list().length == 0) {
			templateFolder.delete();
		}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884060/fstmerge_base_4082337430479625095
private void deleteTemplateFile(final String templateName) throws RestErrorException {
		File templateFile = getTemplateFile(templateName);
		if (templateFile == null) {
			throw new RestErrorException("failed_to_remove_template_file", templateName,
					"template file doesn't exist");
		}
		// delete the file from the directory.
		String templatesPath = templateFile.getAbsolutePath();
		logger.log(Level.FINE, "[deleteTemplateFile] - removing template file " + templatesPath);
		boolean deleted = false;
		try {
			deleted = templateFile.delete();
		} catch (SecurityException e) {
			logger.log(Level.WARNING, "[deleteTemplateFile] - Failed to deleted template file " + templatesPath
					+ ", Error: " + e.getMessage(), e);
			throw new RestErrorException("failed_to_remove_template_file", templatesPath, e.getMessage());
		}
		if (!deleted) {
			throw new RestErrorException("failed_to_remove_template_file", templatesPath,
					"template file was not deleted.");
		}
		logger.log(Level.FINE, "[deleteTemplateFile] - Successfully deleted template file [" + templatesPath + "].");
		File templateFolder = templateFile.getParentFile();
		File[] templatesFiles = DSLReader.findDefaultDSLFiles(DSLUtils.TEMPLATE_DSL_FILE_NAME_SUFFIX, templateFolder);
		if (templatesFiles == null || templatesFiles.length == 0) {
			try {
				logger.log(Level.FINE, "[deleteTemplateFile] - templates folder is empty, deleting the folder [" 
						+ templatesPath + "].");
				FileUtils.deleteDirectory(templateFolder);
			} catch (IOException e) {
				logger.log(Level.WARNING, "[deleteTemplateFile] - Failed to delete templates folder" 
						+ templateFolder, e);
			}
		} else {
			// delete properties and overrides files if exist.
			CloudTemplatesReader.removeTemplateFiles(templateFolder, templateName);
		}
		File templatesFolder = getTemplatesFolder();
		if (templatesFolder.list().length == 0) {
			templateFolder.delete();
		}
=======
private void deleteTemplateFile(final String templateName) throws RestErrorException {
		final File templateFile = getTemplateFile(templateName);
		if (templateFile == null) {
			throw new RestErrorException("failed_to_remove_template_file", templateName,
					"template file doesn't exist");
		}
		// delete the file from the directory.
		final String templatesPath = templateFile.getAbsolutePath();
		logger.log(Level.FINE, "[deleteTemplateFile] - removing template file " + templatesPath);
		boolean deleted = false;
		try {
			deleted = templateFile.delete();
		} catch (final SecurityException e) {
			logger.log(Level.WARNING, "[deleteTemplateFile] - Failed to deleted template file " + templatesPath
					+ ", Error: " + e.getMessage(), e);
			throw new RestErrorException("failed_to_remove_template_file", templatesPath, e.getMessage());
		}
		if (!deleted) {
			throw new RestErrorException("failed_to_remove_template_file", templatesPath,
					"template file was not deleted.");
		}
		logger.log(Level.FINE, "[deleteTemplateFile] - Successfully deleted template file [" + templatesPath + "].");
		final File templateFolder = templateFile.getParentFile();
		final File[] templatesFiles =
				DSLReader.findDefaultDSLFiles(DSLUtils.TEMPLATE_DSL_FILE_NAME_SUFFIX, templateFolder);
		if (templatesFiles == null || templatesFiles.length == 0) {
			try {
				logger.log(Level.FINE, "[deleteTemplateFile] - templates folder is empty, deleting the folder ["
						+ templatesPath + "].");
				FileUtils.deleteDirectory(templateFolder);
			} catch (final IOException e) {
				logger.log(Level.WARNING, "[deleteTemplateFile] - Failed to delete templates folder"
						+ templateFolder, e);
			}
		} else {
			// delete properties and overrides files if exist.
			CloudTemplatesReader.removeTemplateFiles(templateFolder, templateName);
		}
		final File templatesFolder = getTemplatesFolder();
		if (templatesFolder.list().length == 0) {
			templateFolder.delete();
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884060/fstmerge_var2_8104770301900290279
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884089/fstmerge_var1_7943574672569628498
@RequestMapping(value = "/controllers", method = RequestMethod.GET)
	@PreAuthorize("isFullyAuthenticated() and hasAnyRole('ROLE_CLOUDADMINS')")
	@ResponseBody
	public Map<String, Object> getManagers() throws RestErrorException {
		final ProcessingUnitInstance[] instances = getManagementInstances();
		final ControllerDetails[] controllers = createControllerDetails(instances);
		return successStatus(controllers);

	}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884089/fstmerge_base_959084918552208865
=======
@RequestMapping(value = "/controllers", method = RequestMethod.GET)
	@PreAuthorize("isFullyAuthenticated() and hasAnyRole('ROLE_CLOUDADMINS)")
	@ResponseBody
	public Map<String, Object> getManagers() throws RestErrorException {
		final ProcessingUnitInstance[] instances = getManagementInstances();
		final ControllerDetails[] controllers = createControllerDetails(instances);
		return successStatus(controllers);

	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884089/fstmerge_var2_1817573858600915936

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884097/fstmerge_var1_8934428892058696899
@RequestMapping(value = "controllers", method = RequestMethod.DELETE)
	@PreAuthorize("isFullyAuthenticated() and hasAnyRole('ROLE_CLOUDADMINS')")
	@ResponseBody
	public Map<String, Object> shutdownManagers() throws RestErrorException {

		if (this.cloud == null) {
			throw new RestErrorException(
					CloudifyErrorMessages.MANAGEMENT_SERVERS_SHUTDOWN_NOT_ALLOWED_ON_LOCALCLOUD.getName());
		}

		final ProcessingUnitInstance[] instances = getManagementInstances();
		final ControllerDetails[] controllers = createControllerDetails(instances);

		final GridServiceAgent[] agents = new GridServiceAgent[instances.length];
		for (int i = 0; i < instances.length; i++) {
			final ProcessingUnitInstance instance = instances[i];
			final GridServiceAgent agent = instance.getGridServiceContainer().getGridServiceAgent();
			if (agent == null) {
				throw new IllegalStateException("Failed to find agent for management instance: "
						+ instance.getProcessingUnitInstanceName());
			}
			agents[i] = agent;
		}

		final Map<String, Object> map = successStatus(controllers);

		// IMPORTANT: we are using a new thread and not the thread pool so that in case
		// of the thread pool being overtaxed, this action will still be executed.
		new Thread(new Runnable() {

			@Override
			public void run() {
				logger.info("Shutdown of management agent will commence in: "
						+ MANAGEMENT_AGENT_SHUTDOWN_INTERNAL_SECONDS + " seconds");
				try {
					Thread.sleep(TimeUnit.SECONDS.toMillis(MANAGEMENT_AGENT_SHUTDOWN_INTERNAL_SECONDS));
				} catch (final InterruptedException e) {
					// ignore
				}

				logger.info("Initiating shutdown of management agents");
				for (final GridServiceAgent agent : agents) {
					logger.info("Shutting down agent: " + getAgentDescription(agent));
					try {
						agent.shutdown();
					} catch (final Exception e) {
						logger.log(Level.WARNING, "Attempt to shutdown management agent failed: " + e.getMessage(), e);
					}
				}

			}

		}).start();

		return map;
	}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884097/fstmerge_base_9128071206097457339
=======
@RequestMapping(value = "controllers", method = RequestMethod.DELETE)
	@PreAuthorize("isFullyAuthenticated() and hasAnyRole('ROLE_CLOUDADMINS)")
	@ResponseBody
	public Map<String, Object> shutdownManagers() throws RestErrorException {

		if (this.cloud == null) {
			throw new RestErrorException(
					CloudifyErrorMessages.MANAGEMENT_SERVERS_SHUTDOWN_NOT_ALLOWED_ON_LOCALCLOUD.getName());
		}

		final ProcessingUnitInstance[] instances = getManagementInstances();
		final ControllerDetails[] controllers = createControllerDetails(instances);

		final GridServiceAgent[] agents = new GridServiceAgent[instances.length];
		for (int i = 0; i < instances.length; i++) {
			final ProcessingUnitInstance instance = instances[i];
			final GridServiceAgent agent = instance.getGridServiceContainer().getGridServiceAgent();
			if (agent == null) {
				throw new IllegalStateException("Failed to find agent for management instance: "
						+ instance.getProcessingUnitInstanceName());
			}
			agents[i] = agent;
		}

		final Map<String, Object> map = successStatus(controllers);

		// IMPORTANT: we are using a new thread and not the thread pool so that in case
		// of the thread pool being overtaxed, this action will still be executed.
		new Thread(new Runnable() {

			@Override
			public void run() {
				logger.info("Shutdown of management agent will commence in: "
						+ MANAGEMENT_AGENT_SHUTDOWN_INTERNAL_SECONDS + " seconds");
				try {
					Thread.sleep(TimeUnit.SECONDS.toMillis(MANAGEMENT_AGENT_SHUTDOWN_INTERNAL_SECONDS));
				} catch (final InterruptedException e) {
					// ignore
				}

				logger.info("Initiating shutdown of management agents");
				for (final GridServiceAgent agent : agents) {
					logger.info("Shutting down agent: " + getAgentDescription(agent));
					try {
						agent.shutdown();
					} catch (final Exception e) {
						logger.log(Level.WARNING, "Attempt to shutdown management agent failed: " + e.getMessage(), e);
					}
				}

			}

		}).start();

		return map;
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617884097/fstmerge_var2_961227697055474439

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617886560/fstmerge_var1_3410798132374694141
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617886560/fstmerge_base_8517427564280492146
public static InstallationDetails createInstallationDetails(final MachineDetails md,
			final Cloud cloud, final CloudTemplate template, final ExactZonesConfig zones,
			final String lookupLocatorsString, final Admin admin,
			final boolean isManagement,
			final File cloudFile,
			final GSAReservationId reservationId,
			final String templateName,
			final String securityProfile,
			final String keystorePassword,
			final String authGroups)
					throws FileNotFoundException {

		final InstallationDetails details = new InstallationDetails();

		details.setBindToPrivateIp(cloud.getConfiguration().isConnectToPrivateIp());
		details.setLocalDir(template.getAbsoluteUploadDir());
		details.setRelativeLocalDir(template.getLocalDirectory());

		final String remoteDir = template.getRemoteDirectory();
		details.setRemoteDir(remoteDir);

		// Create a copy of managementOnly files and mutate
		final List<String> managementOnlyFiles = new ArrayList<String>(cloud.getProvider().getManagementOnlyFiles());
		if (template.getKeyFile() != null && isManagement) {
			// keyFile, if used, is always a management file.
			managementOnlyFiles.add(template.getKeyFile());
		}
		details.setManagementOnlyFiles(managementOnlyFiles);

		details.setZones(StringUtils.collectionToCommaDelimitedString(zones.getZones()));

		details.setPrivateIp(md.getPrivateAddress());
		details.setPublicIp(md.getPublicAddress());

		details.setLocator(lookupLocatorsString);

		details.setCloudifyUrl(cloud.getProvider().getCloudifyUrl());
		details.setOverridesUrl(cloud.getProvider().getCloudifyOverridesUrl());

		details.setConnectedToPrivateIp(cloud.getConfiguration().isConnectToPrivateIp());
		details.setAdmin(admin);

		details.setUsername(md.getRemoteUsername());
		details.setPassword(md.getRemotePassword());
		details.setRemoteExecutionMode(md.getRemoteExecutionMode());
		details.setFileTransferMode(md.getFileTransferMode());
		details.setScriptLanguage(md.getScriptLangeuage());

		details.setCloudFile(cloudFile);
		details.setManagement(isManagement);
		if (isManagement) {
			details.setConnectedToPrivateIp(!cloud.getConfiguration().isBootstrapManagementOnPublicIp());
			details.setSecurityProfile(securityProfile);
			details.setKeystorePassword(keystorePassword);

			//setting management grid components command-line arguments
			GridComponents componentsConfig = cloud.getConfiguration().getComponents();
			details.setEsmCommandlineArgs(Utils.getGridComponentCommandlineArgs(componentsConfig.getOrchestrator()));
			details.setGsmCommandlineArgs(Utils.getGridComponentCommandlineArgs(componentsConfig.getDeployer()));
			details.setLusCommandlineArgs(Utils.getGridComponentCommandlineArgs(componentsConfig.getDiscovery()));
			details.setGsaCommandlineArgs(Utils.getGridComponentCommandlineArgs(componentsConfig.getAgent()));
			details.setGscCommandlineArgs(Utils.getGridComponentCommandlineArgs(componentsConfig.getUsm()));

			//setting web service ports and memory allocation
			details.setRestPort(componentsConfig.getRest().getPort());
			details.setWebuiPort(componentsConfig.getWebui().getPort());
			details.setRestMaxMemory(componentsConfig.getRest().getMaxMemory());
			details.setWebuiMaxMemory(componentsConfig.getWebui().getMaxMemory());

		} else {
			details.setConnectedToPrivateIp(cloud.getConfiguration().isConnectToPrivateIp());
		}

		// Add all template custom data fields starting with 'installer.' to the
		// installation details
		final Set<Entry<String, Object>> customEntries = template.getCustom().entrySet();
		for (final Entry<String, Object> entry : customEntries) {
			if (entry.getKey().startsWith("installer.")) {
				details.getCustomData().put(entry.getKey(), entry.getValue());
			}
		}

		final String keyFileName = template.getKeyFile();
		if (keyFileName != null && !keyFileName.isEmpty()) {
			File keyFile = new File(keyFileName);
			if (!keyFile.isAbsolute()) {
				keyFile = new File(details.getLocalDir(), keyFileName);
			}
			if (!keyFile.isFile()) {
				throw new FileNotFoundException(
						"Could not find key file matching specified cloud configuration key file: "
								+ template.getKeyFile() + ". Tried: " + keyFile + " but file does not exist");
			}
			details.setKeyFile(keyFile.getAbsolutePath());
		}

		if (template.getHardwareId() != null) {
			details.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.GIGASPACES_CLOUD_HARDWARE_ID,
					template.getHardwareId());
			// maintain backwards for pre 2.3.0
			details.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.CLOUDIFY_CLOUD_HARDWARE_ID,
					template.getHardwareId());

		}

		if (template.getImageId() != null) {
			details.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.GIGASPACES_CLOUD_IMAGE_ID,
					template.getImageId());
			// maintain backwards for pre 2.3.0
			details.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.CLOUDIFY_CLOUD_IMAGE_ID,
					template.getImageId());
		}

		// Add the template privileged mode flag
		details.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.GIGASPACES_AGENT_ENV_PRIVILEGED,
				Boolean.toString(template.isPrivileged()));

		// Add the template initialization command
		if (!org.apache.commons.lang.StringUtils.isBlank(template.getInitializationCommand())) {
			// the initialization command may include command separators (like
			// ';') so quote it
			final String command = template.getInitializationCommand();
			final String quotedCommand = "\"" + command + "\"";

			details.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.GIGASPACES_AGENT_ENV_INIT_COMMAND,
					quotedCommand);
		}

		// Add the template custom environment
		final Set<Entry<String, String>> entries = template.getEnv().entrySet();
		for (final Entry<String, String> entry : entries) {
			details.getExtraRemoteEnvironmentVariables().put(entry.getKey(), entry.getValue());
		}

		if (!org.apache.commons.lang.StringUtils.isBlank(template.getJavaUrl())) {
			details.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.GIGASPACES_AGENT_ENV_JAVA_URL,
					template.getJavaUrl());
		}

		details.setReservationId(reservationId);
		details.setTemplateName(templateName);

		details.setMachineId(md.getMachineId());

		if (authGroups != null) {
			details.setAuthGroups(authGroups);
		}

		details.setDeleteRemoteDirectoryContents(md.isCleanRemoteDirectoryOnStart());
		logger.fine("Created InstallationDetails: " + details);
		return details;
	}
=======
public static InstallationDetails createInstallationDetails(final MachineDetails md,
			final Cloud cloud, final CloudTemplate template, final ExactZonesConfig zones,
			final String lookupLocatorsString, final Admin admin,
			final boolean isManagement,
			final File cloudFile,
			final GSAReservationId reservationId,
			final String templateName,
			final String securityProfile,
			final String keystorePassword,
			final String authGroups)
			throws FileNotFoundException {

		final InstallationDetails details = new InstallationDetails();

		details.setBindToPrivateIp(cloud.getConfiguration().isConnectToPrivateIp());
		details.setLocalDir(template.getAbsoluteUploadDir());
		details.setRelativeLocalDir(template.getLocalDirectory());

		final String remoteDir = template.getRemoteDirectory();
		details.setRemoteDir(remoteDir);

		// Create a copy of managementOnly files and mutate
		final List<String> managementOnlyFiles = new ArrayList<String>(cloud.getProvider().getManagementOnlyFiles());
		if (template.getKeyFile() != null && isManagement) {
			// keyFile, if used, is always a management file.
			managementOnlyFiles.add(template.getKeyFile());
		}
		details.setManagementOnlyFiles(managementOnlyFiles);

		details.setZones(StringUtils.collectionToCommaDelimitedString(zones.getZones()));

		details.setPrivateIp(md.getPrivateAddress());
		details.setPublicIp(md.getPublicAddress());

		details.setLocator(lookupLocatorsString);

		details.setCloudifyUrl(cloud.getProvider().getCloudifyUrl());
		details.setOverridesUrl(cloud.getProvider().getCloudifyOverridesUrl());

		details.setConnectedToPrivateIp(cloud.getConfiguration().isConnectToPrivateIp());
		details.setAdmin(admin);

		details.setUsername(md.getRemoteUsername());
		details.setPassword(md.getRemotePassword());
		details.setRemoteExecutionMode(md.getRemoteExecutionMode());
		details.setFileTransferMode(md.getFileTransferMode());
		details.setScriptLanguage(md.getScriptLangeuage());

		details.setCloudFile(cloudFile);
		details.setManagement(isManagement);
		final GridComponents componentsConfig = cloud.getConfiguration().getComponents();
		if (isManagement) {
			details.setConnectedToPrivateIp(!cloud.getConfiguration().isBootstrapManagementOnPublicIp());
			details.setSecurityProfile(securityProfile);
			details.setKeystorePassword(keystorePassword);

			// setting management grid components command-line arguments
			final String esmCommandlineArgs = ConfigUtils.getEsmCommandlineArgs(componentsConfig.getOrchestrator());
			final String lusCommandlineArgs = ConfigUtils.getLusCommandlineArgs(componentsConfig.getDiscovery());
			final String gsmCommandlineArgs = ConfigUtils.getGsmCommandlineArgs(componentsConfig.getDeployer(),
					componentsConfig.getDiscovery());
			details.setEsmCommandlineArgs('"' + esmCommandlineArgs + '"');
			details.setLusCommandlineArgs('"' + lusCommandlineArgs + '"');
			details.setGsmCommandlineArgs('"' + gsmCommandlineArgs + '"');

			// setting management services LRMI port range.
			details.setGscLrmiPortRange(componentsConfig.getUsm().getPortRange());
			// setting web service ports and memory allocation
			details.setRestPort(componentsConfig.getRest().getPort());
			details.setWebuiPort(componentsConfig.getWebui().getPort());
			details.setRestMaxMemory(componentsConfig.getRest().getMaxMemory());
			details.setWebuiMaxMemory(componentsConfig.getWebui().getMaxMemory());

		} else {
			details.setConnectedToPrivateIp(cloud.getConfiguration().isConnectToPrivateIp());
		}
		details.setGsaCommandlineArgs('"' + ConfigUtils.getAgentCommandlineArgs(componentsConfig.getAgent()) + '"');

		// Add all template custom data fields starting with 'installer.' to the
		// installation details
		final Set<Entry<String, Object>> customEntries = template.getCustom().entrySet();
		for (final Entry<String, Object> entry : customEntries) {
			if (entry.getKey().startsWith("installer.")) {
				details.getCustomData().put(entry.getKey(), entry.getValue());
			}
		}


		// Handle key file
		if (md.getKeyFile() != null) {
			details.setKeyFile(md.getKeyFile().getAbsolutePath());
		} else {
			final String keyFileName = template.getKeyFile();
			if (!org.apache.commons.lang.StringUtils.isBlank(keyFileName)) {
				File keyFile = new File(keyFileName);
				if (!keyFile.isAbsolute()) {
					keyFile = new File(details.getLocalDir(), keyFileName);
				}
				if (!keyFile.isFile()) {
					throw new FileNotFoundException(
							"Could not find key file matching specified cloud configuration key file: "
									+ template.getKeyFile() + ". Tried: " + keyFile + " but file does not exist");
				}
				details.setKeyFile(keyFile.getAbsolutePath());
			}
		}

		if (template.getHardwareId() != null) {
			details.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.GIGASPACES_CLOUD_HARDWARE_ID,
					template.getHardwareId());
			// maintain backwards for pre 2.3.0
			details.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.CLOUDIFY_CLOUD_HARDWARE_ID,
					template.getHardwareId());

		}

		if (template.getImageId() != null) {
			details.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.GIGASPACES_CLOUD_IMAGE_ID,
					template.getImageId());
			// maintain backwards for pre 2.3.0
			details.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.CLOUDIFY_CLOUD_IMAGE_ID,
					template.getImageId());
		}

		// Add the template privileged mode flag
		details.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.GIGASPACES_AGENT_ENV_PRIVILEGED,
				Boolean.toString(template.isPrivileged()));

		// Add the template initialization command
		if (!org.apache.commons.lang.StringUtils.isBlank(template.getInitializationCommand())) {
			// the initialization command may include command separators (like
			// ';') so quote it
			final String command = template.getInitializationCommand();
			final String quotedCommand = "\"" + command + "\"";

			details.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.GIGASPACES_AGENT_ENV_INIT_COMMAND,
					quotedCommand);
		}

		// Add the template custom environment
		final Set<Entry<String, String>> entries = template.getEnv().entrySet();
		for (final Entry<String, String> entry : entries) {
			details.getExtraRemoteEnvironmentVariables().put(entry.getKey(), entry.getValue());
		}

		if (!org.apache.commons.lang.StringUtils.isBlank(template.getJavaUrl())) {
			details.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.GIGASPACES_AGENT_ENV_JAVA_URL,
					template.getJavaUrl());
		}

		details.setReservationId(reservationId);
		details.setTemplateName(templateName);

		details.setMachineId(md.getMachineId());

		if (authGroups != null) {
			details.setAuthGroups(authGroups);
		}

		details.setDeleteRemoteDirectoryContents(md.isCleanRemoteDirectoryOnStart());
		details.setInstallerConfiguration(md.getInstallerConfigutation());
		logger.fine("Created InstallationDetails: " + details);
		return details;
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617886560/fstmerge_var2_4016047357220155675

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/util/Utils.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617886977/fstmerge_var1_2355186763241085400
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617886977/fstmerge_base_7696716100053855316
public synchronized void addNodesList(final String templateName,
			final CloudTemplate template,
			final List<Map<String, String>> nodesList) throws Exception {
		final List<CustomNode> resolvedNodes = new ArrayList<CustomNode>();
		final List<CustomNode> unresolvedNodes = new ArrayList<CustomNode>();
		logger.info("addNodesList: adding node list of " + templateName 
				+ " to ByonDeployer, node list: " + nodesList);

		// parse the given nodes list
		List<CustomNode> parsedNodes = parseCloudNodes(nodesList);
		parsedNodes = removeDuplicates(parsedNodes);

		// the infrastructure is based on machine IPs, they need to be unique.
		// we set the resolved IP address on each node for an easy machine
		// comparison from this point on
		for (CustomNode node : parsedNodes) {
			try {
				node.setResolvedIP(IPUtils.resolveHostName(node.getPrivateIP()));
				if (template.getRemoteExecution() == RemoteExecutionModes.WINRM) {
					node.setLoginPort(RemoteExecutionModes.WINRM.getPort());
				}
				IPUtils.validateConnection(node.getResolvedIP(),
						node.getLoginPort());
				resolvedNodes.add(node);
			} catch (final Exception ex) {
				// this node is not reachable - add it to the invalid nodes pool
				unresolvedNodes.add(node);
			}
		}

		// avoid duplicate machines in different templates (compare by IP)
		final Set<String> duplicateNodes = getDuplicateIPs(getAllNodes(),
				parsedNodes);
		if (duplicateNodes.size() > 0) {
			throw new CloudProvisioningException(
					"Failed to add nodes for template \""
							+ templateName
							+ "\","
							+ " some IP addresses were already defined by a different template: "
							+ Arrays.toString(duplicateNodes.toArray()));
		}
		
		setInitialPoolsForTemplate(templateName, resolvedNodes, unresolvedNodes);
	}
=======
public synchronized void addNodesList(final String templateName,
			final CloudTemplate template,
			final List<Map<String, String>> nodesList) throws Exception {
		final List<CustomNode> resolvedNodes = new ArrayList<CustomNode>();
		final List<CustomNode> unresolvedNodes = new ArrayList<CustomNode>();
		logger.info("addNodesList: adding node list of " + templateName
				+ " to ByonDeployer, node list: " + nodesList);

		// parse the given nodes list
		List<CustomNode> parsedNodes = parseCloudNodes(nodesList);
		parsedNodes = removeDuplicates(parsedNodes);

		// the infrastructure is based on machine IPs, they need to be unique.
		// we set the resolved IP address on each node for an easy machine
		// comparison from this point on
		for (CustomNode node : parsedNodes) {
			try {
				node.setResolvedIP(IPUtils.resolveHostName(node.getPrivateIP()));
				if (template.getRemoteExecution() == RemoteExecutionModes.WINRM) {
					node.setLoginPort(RemoteExecutionModes.WINRM.getDefaultPort());
				}
				IPUtils.validateConnection(node.getResolvedIP(),
						node.getLoginPort());
				resolvedNodes.add(node);
			} catch (final Exception ex) {
				// this node is not reachable - add it to the invalid nodes pool
				unresolvedNodes.add(node);
			}
		}

		// avoid duplicate machines in different templates (compare by IP)
		final Set<String> duplicateNodes = getDuplicateIPs(getAllNodes(),
				parsedNodes);
		if (duplicateNodes.size() > 0) {
			throw new CloudProvisioningException(
					"Failed to add nodes for template \""
							+ templateName
							+ "\","
							+ " some IP addresses were already defined by a different template: "
							+ Arrays.toString(duplicateNodes.toArray()));
		}

		setInitialPoolsForTemplate(templateName, resolvedNodes, unresolvedNodes);
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617886977/fstmerge_var2_5878434978572369626

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/byon/ByonDeployer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887277/fstmerge_var1_3335544080913369640
@Override
	public void setConfig(final Cloud cloud, final String templateName, final boolean management, final String serviceName) {
		
		this.cloud = cloud;
		this.management = management;
		this.templateName = templateName;
		
		if (this.cloud.getCloudCompute().getTemplates().isEmpty()) {
			throw new IllegalArgumentException("No templates defined for this cloud");
		}

		// TODO - add automatic validation rules to the DSL Pojos!
		if (StringUtils.isBlank(this.templateName)) {
			this.template = this.cloud.getCloudCompute().getTemplates().values().iterator().next();
		} else {
			this.template = this.cloud.getCloudCompute().getTemplates().get(this.templateName);
		}

		if (this.template == null) {
			throw new IllegalArgumentException("Could not find required template: " + this.templateName
					+ " in templates list");
		}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887277/fstmerge_base_4044912378616584065
@Override
	public void setConfig(final Cloud cloud, final String templateName, final boolean management, final String serviceName) {
		
		this.cloud = cloud;
		this.management = management;
		this.templateName = templateName;
		
		if (this.cloud.getTemplates().isEmpty()) {
			throw new IllegalArgumentException("No templates defined for this cloud");
		}

		// TODO - add automatic validation rules to the DSL Pojos!
		if (StringUtils.isBlank(this.templateName)) {
			this.template = this.cloud.getTemplates().values().iterator().next();
		} else {
			this.template = this.cloud.getTemplates().get(this.templateName);
		}

		if (this.template == null) {
			throw new IllegalArgumentException("Could not find required template: " + this.templateName
					+ " in templates list");
		}
=======
@Override
	public void setConfig(final Cloud cloud, final String templateName, final boolean management, final String serviceName) {
		
		this.cloud = cloud;
		this.management = management;
		this.templateName = templateName;
		
		if (this.cloud.getTemplates().isEmpty()) {
			throw new IllegalArgumentException("No templates defined for this cloud");
		}

		// TODO - add automatic validation rules to the DSL Pojos!
		if (StringUtils.isBlank(this.templateName)) {
			this.template = this.cloud.getTemplates().values().iterator().next();
		} else {
			this.template = this.cloud.getTemplates().get(this.templateName);
		}

		if (this.template == null) {
			throw new IllegalArgumentException("Could not find required template: " + this.templateName
					+ " in templates list");
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887277/fstmerge_var2_3244237146061243787
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/CloudDriverSupport.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
	public GridServiceAgent startMachine(final ExactZonesConfig zones, final GSAReservationId reservationId,
			final long duration, final TimeUnit unit)
			throws ElasticMachineProvisioningException,
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_base_5153336453002262130
				ElasticGridServiceAgentProvisioningException, InterruptedException, TimeoutException {
=======
			ElasticGridServiceAgentProvisioningException, InterruptedException, TimeoutException {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_var2_3574952013809061210

		logger.info("Cloudify Adapter is starting a new machine with zones " + zones.getZones());

		// calculate timeout
		final long end = System.currentTimeMillis() + unit.toMillis(duration);

		// provision the machine
		logger.info("Calling provisioning implementation for new machine");
		MachineDetails machineDetails;
		cloudifyProvisioning.setAdmin(getGlobalAdminInstance(originalESMAdmin));

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_base_5153336453002262130
		ZonesConfig defaultZones = config.getGridServiceAgentZones();
=======
		final ZonesConfig defaultZones = config.getGridServiceAgentZones();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_var2_3574952013809061210
		logger.fine("default zones = " + defaultZones.getZones());
		if (!defaultZones.isSatisfiedBy(zones)) {
			throw new IllegalArgumentException("The specified zones " + zones
					+ " does not satisfy the configuration zones " + defaultZones);
		}

		String locationId = null;

		logger.fine("searching for cloud specific zone");
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_base_5153336453002262130
		for (String zone : zones.getZones()) {
=======
		for (final String zone : zones.getZones()) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_var2_3574952013809061210
			logger.fine("current zone = " + zone);
			if (zone.startsWith(CLOUD_ZONE_PREFIX)) {
				logger.fine("found a zone with " + CLOUD_ZONE_PREFIX + " prefix : " + zone);
				if (locationId == null) {
					locationId = zone.substring(CLOUD_ZONE_PREFIX.length());
					logger.fine("passing locationId to machine provisioning as " + locationId);
				} else {
					throw new IllegalArgumentException("The specified zones " + zones
							+ " should include only one zone with the " + CLOUD_ZONE_PREFIX + " prefix:" + locationId);
				}
			}
		}

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_base_5153336453002262130
		MachineStartRequestedCloudifyEvent machineStartEvent = new MachineStartRequestedCloudifyEvent();
=======
		final MachineStartRequestedCloudifyEvent machineStartEvent = new MachineStartRequestedCloudifyEvent();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_var2_3574952013809061210
		machineStartEvent.setTemplateName(cloudTemplateName);
		machineStartEvent.setLocationId(locationId);
		machineEventListener.elasticMachineProvisioningProgressChanged(machineStartEvent);

		try {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_var1_5831732233275123834
			final ComputeTemplate template = cloud.getCloudCompute().getTemplates().get(this.cloudTemplateName);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_base_5153336453002262130
=======
			final CloudTemplate template = cloud.getTemplates().get(this.cloudTemplateName);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_var2_3574952013809061210
			if (locationId == null) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_base_5153336453002262130
				final CloudTemplate template = cloud.getTemplates().get(this.cloudTemplateName);
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_var2_3574952013809061210
				locationId = template.getLocationId();
			}

			// This is the call to the actual cloud driver implementation!
			machineDetails = provisionMachine(locationId, duration, unit);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_base_5153336453002262130
=======
			// Auto populate installer configuration with values set in template if they were not previously set.
			if (machineDetails != null && machineDetails.getInstallerConfigutation() == null) {
				machineDetails.setInstallerConfigutation(template.getInstaller());
			}

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_var2_3574952013809061210
		} catch (final Exception e) {
			throw new ElasticMachineProvisioningException("Failed to provisiong machine: " + e.getMessage(), e);
		}

		logger.info("Machine was provisioned by implementation. Machine is: " + machineDetails);

		// which IP should be used in the cluster
		String machineIp;
		if (cloud.getConfiguration().isConnectToPrivateIp()) {
			machineIp = machineDetails.getPrivateAddress();
		} else {
			machineIp = machineDetails.getPublicAddress();
		}
		if (machineIp == null) {
			throw new IllegalStateException("The IP of the new machine is null! Machine Details are: "
					+ machineDetails + " .");
		}

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_base_5153336453002262130
		MachineStartedCloudifyEvent machineStartedEvent = new MachineStartedCloudifyEvent();
=======
		final MachineStartedCloudifyEvent machineStartedEvent = new MachineStartedCloudifyEvent();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_var2_3574952013809061210
		machineStartedEvent.setMachineDetails(machineDetails);
		machineStartedEvent.setHostAddress(machineIp);
		machineEventListener.elasticMachineProvisioningProgressChanged(machineStartedEvent);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_base_5153336453002262130
		GridServiceAgentStartRequestedEvent agentStartEvent = new GridServiceAgentStartRequestedEvent();
=======
		final GridServiceAgentStartRequestedEvent agentStartEvent = new GridServiceAgentStartRequestedEvent();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_var2_3574952013809061210
		agentStartEvent.setHostAddress(machineIp);
		agentEventListener.elasticGridServiceAgentProvisioningProgressChanged(agentStartEvent);

		try {
			// check for timeout
			checkForProvisioningTimeout(end, machineDetails);
			
			if (isStorageTemplateUsed()) {
				String machineLocation = machineDetails.getLocationId();
				
				VolumeDetails volumeDetails = startNewStorageVolume(machineLocation, end);
				try {
					attachStorageVolumeToMachine(machineIp, volumeDetails , end);
				} catch (Exception e) {
					logger.log(Level.WARNING, "Failed attaching volume. Error was " + e.getMessage(), e);
					handleVolumeAttachException(volumeDetails);
					throw new StorageProvisioningException(e);
				}
				StorageTemplate storageTemplate = this.cloud.getCloudStorage().getTemplates()
								.get(this.storageTemplateName);
				String formatType = storageTemplate.getFileSystemType();
				String mountPath = storageTemplate.getPath();
				String deviceName = storageTemplate.getDeviceName();

				machineDetails.setStorageVolumeAttached(true);
				machineDetails.setStorageDeviceName(deviceName);
				machineDetails.setStorageFormatType(formatType);
				machineDetails.setStorageMountPath(mountPath);
			}
			if (machineDetails.isAgentRunning()) {
				logger.info("Machine provisioning provided a machine and indicated that an agent is already running");
			} else {
				// install gigaspaces and start agent
				logger.info("Cloudify Adapter is installing Cloudify on new machine");
				installAndStartAgent(machineDetails, reservationId, end);
				// check for timeout again - the installation step can also take a
				// while to complete.
				checkForProvisioningTimeout(end, machineDetails);
			}

			// There is another case here, that we do not handle - where the started image
			// has the cloudify distro, but the agent is not running. This means we should
			// run a modified remote execution script. Not sure if we really need this, though,
			// as this scenario really does not offer a better experience. If required, handling will
			// be added here.

			// wait for GSA to become available
			logger.info("Cloudify adapter is waiting for GSA to become available");
			final GridServiceAgent gsa = waitForGsa(machineIp, end);
			if (gsa == null) {
				// GSA did not start correctly or on time - shutdown the machine
				// handleGSANotFound(machineIp);
				throw new TimeoutException("New machine was provisioned and Cloudify was installed, "
						+ "but a GSA was not discovered on the new machine: " + machineDetails);
			}
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_base_5153336453002262130
			//TODO: Derive cloudify specific event and include more event details as specified in CLOUDIFY-10651
=======
			// TODO: Derive cloudify specific event and include more event details as specified in CLOUDIFY-10651
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_var2_3574952013809061210
			agentEventListener.elasticGridServiceAgentProvisioningProgressChanged(
					new GridServiceAgentStartedEvent(machineIp, gsa.getUid()));

			// check that the agent is really started with the expected env variable of the template
			// we inject this variable earlier on to the bootstrap-management.sh script
			if (gsa.getVirtualMachine().getDetails().getEnvironmentVariables().
					get(CloudifyConstants.GIGASPACES_CLOUD_TEMPLATE_NAME) == null) {
				throw new ElasticGridServiceAgentProvisioningException("an agent was started. but the property "
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_base_5153336453002262130
					+ CloudifyConstants.GIGASPACES_CLOUD_TEMPLATE_NAME
					+ " was missing from its environment variables.");
=======
						+ CloudifyConstants.GIGASPACES_CLOUD_TEMPLATE_NAME
						+ " was missing from its environment variables.");
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887371/fstmerge_var2_3574952013809061210
			}

			return gsa;
		} catch (final ElasticMachineProvisioningException e) {
			logger.info("ElasticMachineProvisioningException occurred, " + e.getMessage());
			logger.info(ExceptionUtils.getFullStackTrace(e));
			handleExceptionAfterMachineCreated(machineIp, machineDetails, end);
			throw e;
		} catch (final ElasticGridServiceAgentProvisioningException e) {
			logger.info("ElasticGridServiceAgentProvisioningException occurred, " + e.getMessage());
			logger.info(ExceptionUtils.getFullStackTrace(e));
			handleExceptionAfterMachineCreated(machineIp, machineDetails, end);
			throw e;
		} catch (final TimeoutException e) {
			logger.info("TimeoutException occurred, " + e.getMessage());
			logger.info(ExceptionUtils.getFullStackTrace(e));
			handleExceptionAfterMachineCreated(machineIp, machineDetails, end);
			throw e;
		} catch (final InterruptedException e) {
			logger.info("InterruptedException occurred, " + e.getMessage());
			logger.info(ExceptionUtils.getFullStackTrace(e));
			handleExceptionAfterMachineCreated(machineIp, machineDetails, end);
			throw e;
		} catch (StorageProvisioningException e) {
			logger.info("StorageProvisioningException occurred, " + e.getMessage());
			logger.info(ExceptionUtils.getFullStackTrace(e));
			handleExceptionAfterMachineCreated(machineIp, machineDetails, end);
			//temporary, this will be replaced when a throws is added to the interface on openspaces.
			throw new ElasticMachineProvisioningException("Storage exception thrown", e);
		} 
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/ElasticMachineProvisioningCloudifyAdapter.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
	public boolean stopMachine(final GridServiceAgent agent, final long duration, final TimeUnit unit)
			throws ElasticMachineProvisioningException,
			ElasticGridServiceAgentProvisioningException,
			InterruptedException, TimeoutException {
		
		final long endTime = System.currentTimeMillis() + unit.toMillis(duration);
		final String machineIp = agent.getMachine().getHostAddress();
		try {
			if (isStorageTemplateUsed()) {
				handleVolumeOnStopMachine(machineIp, duration, unit);
			}
		} catch (StorageProvisioningException e) {
			logger.log(Level.SEVERE, "Failed detaching volume from machine with ip: " 
							+ machineIp + ". There may still be leaking volumes.", e);
		}
		
		Exception failedToShutdownAgentException = null;
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887410/fstmerge_var1_6464251599189811808
		final GridServiceAgentStopRequestedEvent agentStopEvent = new GridServiceAgentStopRequestedEvent();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887410/fstmerge_base_1652945083776294350
		final long endTime = System.currentTimeMillis() + unit.toMillis(duration);
		GridServiceAgentStopRequestedEvent agentStopEvent = new GridServiceAgentStopRequestedEvent();
=======
		final long endTime = System.currentTimeMillis() + unit.toMillis(duration);
		final GridServiceAgentStopRequestedEvent agentStopEvent = new GridServiceAgentStopRequestedEvent();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887410/fstmerge_var2_5216748137827457954
		agentStopEvent.setHostAddress(machineIp);
		agentStopEvent.setAgentUid(agent.getUid());
		agentEventListener.elasticGridServiceAgentProvisioningProgressChanged(agentStopEvent);

		logger.fine("Shutting down agent: " + agent + " on host: " + machineIp);
		try {
			agent.shutdown();
			logger.fine("Agent on host: " + machineIp + " successfully shut down");

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887410/fstmerge_base_1652945083776294350
			GridServiceAgentStoppedEvent agentStoppedEvent = new GridServiceAgentStoppedEvent();
=======
			final GridServiceAgentStoppedEvent agentStoppedEvent = new GridServiceAgentStoppedEvent();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887410/fstmerge_var2_5216748137827457954
			agentStoppedEvent.setHostAddress(machineIp);
			agentStoppedEvent.setAgentUid(agent.getUid());
			agentEventListener.elasticGridServiceAgentProvisioningProgressChanged(agentStoppedEvent);
		} catch (final Exception e) {
			failedToShutdownAgentException = e;
			logger.log(Level.FINE, "Failed to shutdown agent on host: " + machineIp
					+ ". Continuing with shutdown of machine.", e);
		}

		try {

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887410/fstmerge_base_1652945083776294350
			MachineStopRequestedEvent machineStopEvent = new MachineStopRequestedEvent();
=======
			final MachineStopRequestedEvent machineStopEvent = new MachineStopRequestedEvent();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887410/fstmerge_var2_5216748137827457954
			machineStopEvent.setHostAddress(machineIp);
			machineEventListener.elasticMachineProvisioningProgressChanged(machineStopEvent);

			logger.fine("Cloudify Adapter is shutting down machine with ip: " + machineIp);
			final boolean shutdownSuccessful = this.cloudifyProvisioning.stopMachine(machineIp, duration, unit);
			logger.fine("Shutdown result of machine: " + machineIp + " was: " + shutdownSuccessful);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887410/fstmerge_var1_6464251599189811808
			if (shutdownSuccessful) {
				final MachineStoppedEvent machineStoppedEvent = new MachineStoppedEvent();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887410/fstmerge_base_1652945083776294350
			if (shutdownSuccesfull) {
				MachineStoppedEvent machineStoppedEvent = new MachineStoppedEvent();
=======
			if (shutdownSuccesfull) {
				final MachineStoppedEvent machineStoppedEvent = new MachineStoppedEvent();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887410/fstmerge_var2_5216748137827457954
				machineStoppedEvent.setHostAddress(machineIp);
				machineEventListener.elasticMachineProvisioningProgressChanged(machineStoppedEvent);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887410/fstmerge_base_1652945083776294350
=======
				// machine was shutdown, but an error happened while shutting down agent.
				// lets wait for the agent to not be discovered until we reach the timeout.
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887410/fstmerge_var2_5216748137827457954

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887410/fstmerge_base_1652945083776294350
					// machine was shutdown, but an error happened while shutting down agent.
					// lets wait for the agent to not be discovered until we reach the timeout.

					while (agent.isDiscovered()) {
						Thread.sleep(DEFAULT_AGENT_DISCOVERY_INTERVAL);
						if (System.currentTimeMillis() > endTime && agent.isDiscovered()) {
							if (failedToShutdownAgentException != null) {
								throw new ElasticGridServiceAgentProvisioningException(
										"Machine is stopped but agent [" + agent.getUid() + "] is still discovered."
										+ "Failed to shutdown agent:" + failedToShutdownAgentException.getMessage(),
										failedToShutdownAgentException);
							}
=======
				while (agent.isDiscovered()) {
					Thread.sleep(DEFAULT_AGENT_DISCOVERY_INTERVAL);
					if (System.currentTimeMillis() > endTime && agent.isDiscovered()) {
						if (failedToShutdownAgentException != null) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887410/fstmerge_var2_5216748137827457954
							throw new ElasticGridServiceAgentProvisioningException(
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887410/fstmerge_base_1652945083776294350
									"Machine is stopped but agent[" + agent.getUid()
									+ "] is still discovered.");
=======
									"Machine is stopped but agent [" + agent.getUid() + "] is still discovered."
											+ "Failed to shutdown agent:" + failedToShutdownAgentException.getMessage(),
									failedToShutdownAgentException);
						}
						throw new ElasticGridServiceAgentProvisioningException(
								"Machine is stopped but agent[" + agent.getUid()
										+ "] is still discovered.");
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887410/fstmerge_var2_5216748137827457954

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887410/fstmerge_base_1652945083776294350
						}
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887410/fstmerge_var2_5216748137827457954
					}
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887410/fstmerge_base_1652945083776294350
=======
				}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887410/fstmerge_var2_5216748137827457954

			}

			return shutdownSuccessful;

		} catch (final CloudProvisioningException e) {
			throw new ElasticMachineProvisioningException("Attempt to shutdown machine with IP: " + machineIp
					+ " for agent with UID: " + agent.getUid() + " has failed with error: " + e.getMessage(), e);
		}
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/ElasticMachineProvisioningCloudifyAdapter.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
	public void afterPropertiesSet()
			throws Exception {

		logger = java.util.logging.Logger
				.getLogger(ElasticMachineProvisioningCloudifyAdapter.class.getName());

		final String cloudConfigDirectoryPath =
				properties.get(CloudifyConstants.ELASTIC_PROPERTIES_CLOUD_CONFIGURATION_DIRECTORY);
		if (cloudConfigDirectoryPath == null) {
			logger.severe("Missing cloud configuration property. Properties are: " + this.properties);
			throw new IllegalArgumentException("Cloud configuration directory was not set!");
		}

		try {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887434/fstmerge_base_1668643422441087842
			String cloudOverridesPerService = config.getCloudOverridesPerService();
=======
			final String cloudOverridesPerService = config.getCloudOverridesPerService();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887434/fstmerge_var2_3663480182971031742
			this.cloud = ServiceReader.readCloudFromDirectory(cloudConfigDirectoryPath,
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887434/fstmerge_base_1668643422441087842
						cloudOverridesPerService);
=======
					cloudOverridesPerService);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887434/fstmerge_var2_3663480182971031742
			this.cloudTemplateName = properties.get(CloudifyConstants.ELASTIC_PROPERTIES_CLOUD_TEMPLATE_NAME);

			if (this.cloudTemplateName == null) {
				throw new BeanConfigurationException("Cloud template was not set!");
			}
			// add additional templates from cloudConfigDirectory.
			addTemplatesToCloud(new File(cloudConfigDirectoryPath));
			final ComputeTemplate computeTemplate = 
					this.cloud.getCloudCompute().getTemplates().get(this.cloudTemplateName);
			if (computeTemplate == null) {
				throw new BeanConfigurationException("The provided cloud template name: " + this.cloudTemplateName
						+ " was not found in the cloud configuration");
			}

			// This code runs on the ESM in the remote machine,
			// so set the local directory to the value of the remote directory
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887434/fstmerge_var1_3505335846406317815
			logger.info("Remote Directory is: " + computeTemplate.getRemoteDirectory());
			// if running a windows server.
			if (computeTemplate.getFileTransfer() == FileTransferModes.CIFS) {
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887434/fstmerge_base_1668643422441087842
			logger.info("Remote Directory is: " + cloudTemplate.getRemoteDirectory());
			//if running a windows server.
			if (cloudTemplate.getFileTransfer() == FileTransferModes.CIFS) {
=======
			logger.info("Remote Directory is: " + cloudTemplate.getRemoteDirectory());
			// if running a windows server.
			if (cloudTemplate.getFileTransfer() == FileTransferModes.CIFS) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887434/fstmerge_var2_3663480182971031742
				logger.info("Windows machine - modifying local directory location");
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887434/fstmerge_var1_3505335846406317815
				final String remoteDirName = computeTemplate.getRemoteDirectory();
				final String windowsLocalDirPath =
						getWindowsLocalDirPath(remoteDirName, computeTemplate.getLocalDirectory());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887434/fstmerge_base_1668643422441087842
				String remoteDirName = cloudTemplate.getRemoteDirectory();
				String windowsLocalDirPath = getWindowsLocalDirPath(remoteDirName, cloudTemplate.getLocalDirectory());
=======
				final String remoteDirName = cloudTemplate.getRemoteDirectory();
				final String windowsLocalDirPath =
						getWindowsLocalDirPath(remoteDirName, cloudTemplate.getLocalDirectory());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887434/fstmerge_var2_3663480182971031742
				logger.info("Modified local dir name is: " + windowsLocalDirPath);

				computeTemplate.setLocalDirectory(windowsLocalDirPath);
			} else {
				computeTemplate.setLocalDirectory(computeTemplate.getRemoteDirectory());
			}

			// load the provisioning class and set it up
			try {
				this.cloudifyProvisioning =
						(ProvisioningDriver) Class.forName(this.cloud.getConfiguration().getClassName()).newInstance();

				if (cloudifyProvisioning instanceof ProvisioningDriverClassContextAware) {
					final ProvisioningDriverClassContext provisioningDriverContext =
							lazyCreateProvisioningDriverClassContext(cloudifyProvisioning);
					final ProvisioningDriverClassContextAware contextAware =
							(ProvisioningDriverClassContextAware) cloudifyProvisioning;
					contextAware.setProvisioningDriverClassContext(provisioningDriverContext);
				}

				// checks if a service level configuration exists. If so, save the configuration to local file and pass
				// to cloud driver.
				handleServiceCloudConfiguration();
				this.cloudifyProvisioning.setConfig(cloud, cloudTemplateName, false, serviceName);
				this.storageTemplateName = config.getStorageTemplateName();
				if (isStorageTemplateUsed()) {
					boolean privileged = computeTemplate.isPrivileged();
					// mounting the volume will not be possible if not running in privileged mode. 
					if (!privileged) {
						logger.warning("Storage template defined but not running in privileged mode.");
						throw new StorageProvisioningException("Storage mounting requires running in privileged mode."
								+ " This should be defined in the cloud's compute template.");
					}
					logger.info("creating storage provisioning driver.");
					this.storageProvisioning = 
							(StorageProvisioningDriver) Class.forName(this.cloud.getConfiguration()
									.getStorageClassName()).newInstance();
					if (this.storageProvisioning instanceof BaseStorageDriver) {
						((BaseStorageDriver) this.storageProvisioning)
												.setComputeContext(cloudifyProvisioning.getComputeContext());
					}
					this.storageProvisioning.setConfig(cloud, this.cloudTemplateName, this.storageTemplateName);
					logger.info("storage provisioning driver created successfully.");
				}
			} catch (final ClassNotFoundException e) {
				throw new BeanConfigurationException("Failed to load provisioning class for cloud: "
						+ this.cloud.getName() + ". Class not found: " + this.cloud.getConfiguration().getClassName(),
						e);
			} catch (final Exception e) {
				throw new BeanConfigurationException("Failed to load provisioning class for cloud: "
						+ this.cloud.getName(), e);
			}

			this.lookupLocatorsString = createLocatorsString();

			logger.info("Locators string used for new instances will be: " + this.lookupLocatorsString);

		} catch (final DSLException e) {
			logger.severe("Could not parse the provided cloud configuration from : " + cloudConfigDirectoryPath + ": "
					+ e.getMessage());
			throw new BeanConfigurationException("Could not parse the prvided cloud configuration: "
					+ cloudConfigDirectoryPath
					+ ": " + e.getMessage(), e);
		}

	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/ElasticMachineProvisioningCloudifyAdapter.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887440/fstmerge_base_6053752897399513699
private void addTemplatesToCloud(File cloudConfigDirectory) {
=======
private void addTemplatesToCloud(final File cloudConfigDirectory) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887440/fstmerge_var2_924197327924568822
		logger.info("addTemplatesToCloud - adding templates from directory " + cloudConfigDirectory.getAbsolutePath());
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887440/fstmerge_base_6053752897399513699
		File additionalTemplatesFolder = new File(cloudConfigDirectory,
=======
		final File additionalTemplatesFolder = new File(cloudConfigDirectory,
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887440/fstmerge_var2_924197327924568822
				CloudifyConstants.ADDITIONAL_TEMPLATES_FOLDER_NAME);
		if (!additionalTemplatesFolder.exists()) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887440/fstmerge_base_6053752897399513699
			logger.info("addTemplatesToCloud - no additional templates to add from directory " + cloudConfigDirectory.getAbsolutePath());
=======
			logger.info("addTemplatesToCloud - no additional templates to add from directory "
					+ cloudConfigDirectory.getAbsolutePath());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887440/fstmerge_var2_924197327924568822
			return;
		}
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887440/fstmerge_base_6053752897399513699
		File[] listFiles = additionalTemplatesFolder.listFiles();
=======
		final File[] listFiles = additionalTemplatesFolder.listFiles();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887440/fstmerge_var2_924197327924568822
		logger.info("addTemplatesToCloud - found files: " + Arrays.toString(listFiles));
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887440/fstmerge_var1_2851060288703285738
		ComputeTemplatesReader reader = new ComputeTemplatesReader();
		List<ComputeTemplate> addedTemplates = reader.addAdditionalTemplates(cloud, listFiles);
		logger.info("addTemplatesToCloud - Added " + addedTemplates.size() + " templates to the cloud: " + addedTemplates);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887440/fstmerge_base_6053752897399513699
		CloudTemplatesReader reader = new CloudTemplatesReader();
		List<CloudTemplate> addedTemplates = reader.addAdditionalTemplates(cloud, listFiles);
		logger.info("addTemplatesToCloud - Added " + addedTemplates.size() + " templates to the cloud: " + addedTemplates);
=======
		final CloudTemplatesReader reader = new CloudTemplatesReader();
		final List<CloudTemplate> addedTemplates = reader.addAdditionalTemplates(cloud, listFiles);
		logger.info("addTemplatesToCloud - Added " + addedTemplates.size() + " templates to the cloud: "
				+ addedTemplates);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887440/fstmerge_var2_924197327924568822
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/ElasticMachineProvisioningCloudifyAdapter.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887525/fstmerge_var1_7987489935673936854
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887525/fstmerge_base_8617933468361393725
protected void handleServerCredentials(final MachineDetails machineDetails, final CloudTemplate template)
			throws CloudProvisioningException {

		File keyFile = null;
		// using a key (pem) file
		final String keyFileStr = template.getKeyFile();
		if (StringUtils.isNotBlank(keyFileStr)) {
			// fixConfigRelativePaths(cloud, template);
			keyFile = new File(keyFileStr);
			if (!keyFile.isAbsolute()) {
				keyFile = new File(template.getAbsoluteUploadDir(), keyFileStr);
			}
			if (keyFile != null && !keyFile.exists()) {
				throw new CloudProvisioningException("The specified key file could not be found: "
						+ keyFile.getAbsolutePath());
			}
		} else {
			// using a password
			final String remotePassword = machineDetails.getRemotePassword();
			if (StringUtils.isNotBlank(remotePassword)) {
				// is this actually a pem file?
				if (CredentialUtils.isPrivateKeyCredential(remotePassword)) {
					logger.fine("Cloud has provided a key file for connections to new machines");
					try {
						keyFile = File.createTempFile("gs-esm-key", ".pem");
						keyFile.deleteOnExit();
						FileUtils.write(keyFile, remotePassword);
						// TODO : stop settings the machine's private key as the
						// entire cloud's key. This would cause
						// a problem if the cloud (i.e. Rackspace) returns a
						// different key for each machine.
						template.setKeyFile(keyFile.getAbsolutePath());
					} catch (final IOException e) {
						throw new CloudProvisioningException("Failed to create a temporary "
								+ "file for cloud server's key file", e);
					}
				} else {
					// this is a password
					logger.fine("Cloud has provided a password for remote connections to new machines");
				}
			} else {
				// if we got here - there is no key file or password on the
				// cloud or node.
				logger.severe("No Password or key file specified in the cloud configuration file - connection to"
						+ " the new machine is not possible.");
				throw new CloudProvisioningException(
						"No credentials (password or key file) supplied with the cloud configuration file");
			}
		}

		logServerDetails(machineDetails, keyFile);
	}
=======
protected void handleServerCredentials(final MachineDetails machineDetails, final CloudTemplate template)
			throws CloudProvisioningException {

		File keyFile = null;
		// using a key (pem) file
		final String keyFileStr = template.getKeyFile();
		if (StringUtils.isNotBlank(keyFileStr)) {
			// fixConfigRelativePaths(cloud, template);
			keyFile = new File(keyFileStr);
			if (!keyFile.isAbsolute()) {
				keyFile = new File(template.getAbsoluteUploadDir(), keyFileStr);
			}
			if (keyFile != null && !keyFile.exists()) {
				throw new CloudProvisioningException("The specified key file could not be found: "
						+ keyFile.getAbsolutePath());
			}
		} else {
			// using a password
			final String remotePassword = machineDetails.getRemotePassword();
			if (StringUtils.isNotBlank(remotePassword)) {
				// is this actually a pem file?
				if (CredentialUtils.isPrivateKeyCredential(remotePassword)) {
					logger.fine("Cloud has provided a key file for connections to new machines");
					try {
						keyFile = File.createTempFile("gs-esm-key", ".pem");
						keyFile.deleteOnExit();
						FileUtils.write(keyFile, remotePassword);

						// template.setKeyFile(keyFile.getAbsolutePath());
						machineDetails.setKeyFile(keyFile);
					} catch (final IOException e) {
						throw new CloudProvisioningException("Failed to create a temporary "
								+ "file for cloud server's key file", e);
					}
				} else {
					// this is a password
					logger.fine("Cloud has provided a password for remote connections to new machines");
				}
			} else {
				// if we got here - there is no key file or password on the
				// cloud or node.
				logger.severe("No Password or key file specified in the cloud configuration file - connection to"
						+ " the new machine is not possible.");
				throw new CloudProvisioningException(
						"No credentials (password or key file) supplied with the cloud configuration file");
			}
		}

		logServerDetails(machineDetails, keyFile);
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887525/fstmerge_var2_3927850021719343341

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/BaseProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887536/fstmerge_var1_228273991976410916
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887536/fstmerge_base_5211851645198022770
protected MachineDetails createMachineDetailsForTemplate(final CloudTemplate template) {

		final MachineDetails md = new MachineDetails();
		md.setAgentRunning(false);
		md.setCloudifyInstalled(false);
		md.setInstallationDirectory(null);

		md.setRemoteUsername(template.getUsername());
		md.setRemotePassword(template.getPassword());

		md.setRemoteExecutionMode(template.getRemoteExecution());
		md.setFileTransferMode(template.getFileTransfer());
		md.setScriptLangeuage(template.getScriptLanguage());
		return md;

	}
=======
protected MachineDetails createMachineDetailsForTemplate(final CloudTemplate template) {

		final MachineDetails md = new MachineDetails();
		md.setAgentRunning(false);
		md.setCloudifyInstalled(false);
		md.setInstallationDirectory(null);

		md.setRemoteUsername(template.getUsername());
		md.setRemotePassword(template.getPassword());

		md.setRemoteExecutionMode(template.getRemoteExecution());
		md.setFileTransferMode(template.getFileTransfer());
		md.setScriptLangeuage(template.getScriptLanguage());
		return md;

	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887536/fstmerge_var2_7823926340019731009

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/BaseProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887540/fstmerge_var1_9044863943133225342
protected MachineDetails[] doStartManagementMachines(final long endTime, final int numberOfManagementMachines)
			throws TimeoutException, CloudProvisioningException {
		final ExecutorService executors = Executors.newFixedThreadPool(numberOfManagementMachines);

		@SuppressWarnings("unchecked")
		final Future<MachineDetails>[] futures = (Future<MachineDetails>[]) new Future<?>[numberOfManagementMachines];

		final ComputeTemplate managementTemplate =
				this.cloud.getCloudCompute().getTemplates().get(this.cloud.getConfiguration().getManagementMachineTemplate());
		try {
			// Call startMachine asynchronously once for each management
			// machine
			for (int i = 0; i < numberOfManagementMachines; i++) {
				final int index = i + 1;
				futures[i] = executors.submit(new Callable<MachineDetails>() {

					@Override
					public MachineDetails call()
							throws Exception {
						return createServer(serverNamePrefix + index, endTime, managementTemplate);
					}
				});

			}

			// Wait for each of the async calls to terminate.
			int numberOfErrors = 0;
			Exception firstCreationException = null;
			final MachineDetails[] createdManagementMachines = new MachineDetails[numberOfManagementMachines];
			for (int i = 0; i < createdManagementMachines.length; i++) {
				try {
					createdManagementMachines[i] = futures[i].get(endTime - System.currentTimeMillis(),
							TimeUnit.MILLISECONDS);
				} catch (final InterruptedException e) {
					++numberOfErrors;
					publishEvent("failed_to_create_management_vm", e.getMessage());
					logger.log(Level.SEVERE, "Failed to start a management machine", e);
					if (firstCreationException == null) {
						firstCreationException = e;
					}

				} catch (final ExecutionException e) {
					++numberOfErrors;
					publishEvent("failed_to_create_management_vm", e.getMessage());
					logger.log(Level.SEVERE, "Failed to start a management machine", e);
					if (firstCreationException == null) {
						firstCreationException = e;
					}
				}
			}

			// In case of a partial error, shutdown all servers that did start
			// up
			if (numberOfErrors > 0) {
				handleProvisioningFailure(numberOfManagementMachines, numberOfErrors, firstCreationException,
						createdManagementMachines);
			}

			return createdManagementMachines;
		} finally {
			if (executors != null) {
				executors.shutdownNow();
			}
		}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887540/fstmerge_base_6425803521235184869
protected MachineDetails[] doStartManagementMachines(final long endTime, final int numberOfManagementMachines)
			throws TimeoutException, CloudProvisioningException {
		final ExecutorService executors = Executors.newFixedThreadPool(numberOfManagementMachines);

		@SuppressWarnings("unchecked")
		final Future<MachineDetails>[] futures = (Future<MachineDetails>[]) new Future<?>[numberOfManagementMachines];

		final CloudTemplate managementTemplate =
				this.cloud.getTemplates().get(this.cloud.getConfiguration().getManagementMachineTemplate());
		try {
			// Call startMachine asynchronously once for each management
			// machine
			for (int i = 0; i < numberOfManagementMachines; i++) {
				final int index = i + 1;
				futures[i] = executors.submit(new Callable<MachineDetails>() {

					@Override
					public MachineDetails call()
							throws Exception {
						return createServer(serverNamePrefix + index, endTime, managementTemplate);
					}
				});

			}

			// Wait for each of the async calls to terminate.
			int numberOfErrors = 0;
			Exception firstCreationException = null;
			final MachineDetails[] createdManagementMachines = new MachineDetails[numberOfManagementMachines];
			for (int i = 0; i < createdManagementMachines.length; i++) {
				try {
					createdManagementMachines[i] = futures[i].get(endTime - System.currentTimeMillis(),
							TimeUnit.MILLISECONDS);
				} catch (final InterruptedException e) {
					++numberOfErrors;
					publishEvent("failed_to_create_management_vm", e.getMessage());
					logger.log(Level.SEVERE, "Failed to start a management machine", e);
					if (firstCreationException == null) {
						firstCreationException = e;
					}

				} catch (final ExecutionException e) {
					++numberOfErrors;
					publishEvent("failed_to_create_management_vm", e.getMessage());
					logger.log(Level.SEVERE, "Failed to start a management machine", e);
					if (firstCreationException == null) {
						firstCreationException = e;
					}
				}
			}

			// In case of a partial error, shutdown all servers that did start
			// up
			if (numberOfErrors > 0) {
				handleProvisioningFailure(numberOfManagementMachines, numberOfErrors, firstCreationException,
						createdManagementMachines);
			}

			return createdManagementMachines;
		} finally {
			if (executors != null) {
				executors.shutdownNow();
			}
		}
=======
protected MachineDetails[] doStartManagementMachines(final long endTime, final int numberOfManagementMachines)
			throws TimeoutException, CloudProvisioningException {
		final ExecutorService executors = Executors.newFixedThreadPool(numberOfManagementMachines);

		@SuppressWarnings("unchecked")
		final Future<MachineDetails>[] futures = (Future<MachineDetails>[]) new Future<?>[numberOfManagementMachines];

		final CloudTemplate managementTemplate =
				this.cloud.getTemplates().get(this.cloud.getConfiguration().getManagementMachineTemplate());
		try {
			// Call startMachine asynchronously once for each management
			// machine
			for (int i = 0; i < numberOfManagementMachines; i++) {
				final int index = i + 1;
				futures[i] = executors.submit(new Callable<MachineDetails>() {

					@Override
					public MachineDetails call()
							throws Exception {
						return createServer(serverNamePrefix + index, endTime, managementTemplate);
					}
				});

			}

			// Wait for each of the async calls to terminate.
			int numberOfErrors = 0;
			Exception firstCreationException = null;
			final MachineDetails[] createdManagementMachines = new MachineDetails[numberOfManagementMachines];
			for (int i = 0; i < createdManagementMachines.length; i++) {
				try {
					createdManagementMachines[i] = futures[i].get(endTime - System.currentTimeMillis(),
							TimeUnit.MILLISECONDS);
				} catch (final InterruptedException e) {
					++numberOfErrors;
					publishEvent("failed_to_create_management_vm", e.getMessage());
					logger.log(Level.SEVERE, "Failed to start a management machine", e);
					if (firstCreationException == null) {
						firstCreationException = e;
					}

				} catch (final ExecutionException e) {
					++numberOfErrors;
					publishEvent("failed_to_create_management_vm", e.getMessage());
					logger.log(Level.SEVERE, "Failed to start a management machine", e);
					if (firstCreationException == null) {
						firstCreationException = e;
					}
				}
			}

			// In case of a partial error, shutdown all servers that did start
			// up
			if (numberOfErrors > 0) {
				handleProvisioningFailure(numberOfManagementMachines, numberOfErrors, firstCreationException,
						createdManagementMachines);
			}

			return createdManagementMachines;
		} finally {
			if (executors != null) {
				executors.shutdownNow();
			}
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887540/fstmerge_var2_9060706876302438083
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/BaseProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887547/fstmerge_var1_5097906445258307166
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887547/fstmerge_base_2383477941418294938
protected abstract MachineDetails createServer(String serverName, long endTime,
			CloudTemplate template) throws CloudProvisioningException, TimeoutException;
=======
protected abstract MachineDetails createServer(String serverName, long endTime,
			CloudTemplate template) throws CloudProvisioningException, TimeoutException;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887547/fstmerge_var2_3964396700934468761

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/BaseProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887874/fstmerge_var1_8854125982714650404
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887874/fstmerge_base_2071321423918435094
@Override
	protected MachineDetails createServer(String serverName, long endTime,
			CloudTemplate template) throws CloudProvisioningException,
			TimeoutException {
		return createServer(endTime, serverName, null);
	}
=======
@Override
	protected MachineDetails createServer(final String serverName, final long endTime,
			final CloudTemplate template) throws CloudProvisioningException,
			TimeoutException {
		return createServer(endTime, serverName, null);
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887874/fstmerge_var2_3865694384606606590

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/jclouds/DefaultProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887879/fstmerge_var1_5092005042050743170
private MachineDetails createServer(final long end, final String groupName,
			final String locationIdOverride) throws CloudProvisioningException {

		final ComputeTemplate cloudTemplate = this.cloud.getCloudCompute().getTemplates().get(
				this.cloudTemplateName);
		String locationId;
		if (locationIdOverride == null) {
			locationId = cloudTemplate.getLocationId();
		} else {
			locationId = locationIdOverride;
		}

		NodeMetadata node;
		final MachineDetails machineDetails;

		try {
			logger.fine("Cloudify Deployer is creating a new server with tag: "
					+ groupName + ". This may take a few minutes");
			node = deployer.createServer(groupName, locationId);
		} catch (final InstallerException e) {
			throw new CloudProvisioningException(
					"Failed to create cloud server", e);
		}
		logger.fine("New node is allocated, group name: " + groupName);

		final String nodeId = node.getId();

		// At this point the machine is starting. Any error beyond this point
		// must clean up the machine

		try {
			// wait for node to reach RUNNING state
			node = waitForNodeToBecomeReady(nodeId, end);

			// Create MachineDetails for the node metadata.
			machineDetails = createMachineDetailsFromNode(node);

			final FileTransferModes fileTransfer = cloudTemplate
					.getFileTransfer();

			if (this.cloud.getProvider().getProvider().equals("aws-ec2")
					&& fileTransfer == FileTransferModes.CIFS) {
				// Special password handling for windows on EC2
				if (machineDetails.getRemotePassword() == null) {
					// The template did not specify a password, so we must be
					// using the aws windows password mechanism.
					handleEC2WindowsCredentials(end, node, machineDetails,
							cloudTemplate);
				}

			} else {
				// Credentials required special handling.
				handleServerCredentials(machineDetails, cloudTemplate);
			}

		} catch (final Exception e) {
			// catch any exception - to prevent a cloud machine leaking.
			logger.log(
					Level.SEVERE,
					"Cloud machine was started but an error occured during initialization. Shutting down machine",
					e);
			deployer.shutdownMachine(nodeId);
			throw new CloudProvisioningException(e);
		}

		return machineDetails;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887879/fstmerge_base_8966832811587920214
private MachineDetails createServer(final long end, final String groupName,
			final String locationIdOverride) throws CloudProvisioningException {

		final CloudTemplate cloudTemplate = this.cloud.getTemplates().get(
				this.cloudTemplateName);
		String locationId;
		if (locationIdOverride == null) {
			locationId = cloudTemplate.getLocationId();
		} else {
			locationId = locationIdOverride;
		}

		NodeMetadata node;
		final MachineDetails machineDetails;

		try {
			logger.fine("Cloudify Deployer is creating a new server with tag: "
					+ groupName + ". This may take a few minutes");
			node = deployer.createServer(groupName, locationId);
		} catch (final InstallerException e) {
			throw new CloudProvisioningException(
					"Failed to create cloud server", e);
		}
		logger.fine("New node is allocated, group name: " + groupName);

		final String nodeId = node.getId();

		// At this point the machine is starting. Any error beyond this point
		// must clean up the machine

		try {
			// wait for node to reach RUNNING state
			node = waitForNodeToBecomeReady(nodeId, end);

			// Create MachineDetails for the node metadata.
			machineDetails = createMachineDetailsFromNode(node);

			final FileTransferModes fileTransfer = cloudTemplate
					.getFileTransfer();

			if (this.cloud.getProvider().getProvider().equals("aws-ec2")
					&& fileTransfer == FileTransferModes.CIFS) {
				// Special password handling for windows on EC2
				if (machineDetails.getRemotePassword() == null) {
					// The template did not specify a password, so we must be
					// using the aws windows password mechanism.
					handleEC2WindowsCredentials(end, node, machineDetails,
							cloudTemplate);
				}

			} else {
				// Credentials required special handling.
				handleServerCredentials(machineDetails, cloudTemplate);
			}

		} catch (final Exception e) {
			// catch any exception - to prevent a cloud machine leaking.
			logger.log(
					Level.SEVERE,
					"Cloud machine was started but an error occured during initialization. Shutting down machine",
					e);
			deployer.shutdownMachine(nodeId);
			throw new CloudProvisioningException(e);
		}

		return machineDetails;
=======
private MachineDetails createServer(final long end, final String groupName,
			final String locationIdOverride) throws CloudProvisioningException {

		final CloudTemplate cloudTemplate = this.cloud.getTemplates().get(
				this.cloudTemplateName);
		String locationId;
		if (locationIdOverride == null) {
			locationId = cloudTemplate.getLocationId();
		} else {
			locationId = locationIdOverride;
		}

		NodeMetadata node;
		final MachineDetails machineDetails;

		try {
			logger.fine("Cloudify Deployer is creating a new server with tag: "
					+ groupName + ". This may take a few minutes");
			node = deployer.createServer(groupName, locationId);
		} catch (final InstallerException e) {
			throw new CloudProvisioningException(
					"Failed to create cloud server", e);
		}
		logger.fine("New node is allocated, group name: " + groupName);

		final String nodeId = node.getId();

		// At this point the machine is starting. Any error beyond this point
		// must clean up the machine

		try {
			// wait for node to reach RUNNING state
			node = waitForNodeToBecomeReady(nodeId, end);

			// Create MachineDetails for the node metadata.
			machineDetails = createMachineDetailsFromNode(node);

			final FileTransferModes fileTransfer = cloudTemplate
					.getFileTransfer();

			if (this.cloud.getProvider().getProvider().equals("aws-ec2")
					&& fileTransfer == FileTransferModes.CIFS) {
				// Special password handling for windows on EC2
				if (machineDetails.getRemotePassword() == null) {
					// The template did not specify a password, so we must be
					// using the aws windows password mechanism.
					handleEC2WindowsCredentials(end, node, machineDetails,
							cloudTemplate);
				}

			} else {
				// Credentials required special handling.
				handleServerCredentials(machineDetails, cloudTemplate);
			}

		} catch (final Exception e) {
			// catch any exception - to prevent a cloud machine leaking.
			logger.log(
					Level.SEVERE,
					"Cloud machine was started but an error occured during initialization. Shutting down machine",
					e);
			deployer.shutdownMachine(nodeId);
			throw new CloudProvisioningException(e);
		}

		return machineDetails;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887879/fstmerge_var2_8906856996699891338
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/jclouds/DefaultProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887884/fstmerge_var1_6804550819846650263
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887884/fstmerge_base_4911960987394145567
private void handleEC2WindowsCredentials(final long end,
			final NodeMetadata node, final MachineDetails machineDetails,
			final CloudTemplate cloudTemplate) throws FileNotFoundException,
			InterruptedException, TimeoutException, CloudProvisioningException {
		File pemFile = null;

		if (this.management) {
			final File localDirectory = new File(cloudTemplate.getAbsoluteUploadDir());

			pemFile = new File(localDirectory, cloudTemplate.getKeyFile());
		} else {
			final String localDirectoryName = cloudTemplate.getLocalDirectory();
			logger.fine("local dir name is: " + localDirectoryName);
			final File localDirectory = new File(localDirectoryName);

			pemFile = new File(localDirectory, cloudTemplate.getKeyFile());
		}

		if (!pemFile.exists()) {
			logger.severe("Could not find pem file: " + pemFile);
			throw new FileNotFoundException("Could not find key file: "
					+ pemFile);
		}

		String password;
		if (cloudTemplate.getPassword() == null) {
			// get the password using Amazon API
			this.publishEvent("waiting_for_ec2_windows_password", node.getId());

			final LoginCredentials credentials = new EC2WindowsPasswordHandler()
					.getPassword(node, this.deployer.getContext(), end, pemFile);
			password = credentials.getPassword();

			this.publishEvent("ec2_windows_password_retrieved", node.getId());

		} else {
			password = cloudTemplate.getPassword();
		}

		String username = cloudTemplate.getUsername();

		if (username == null) {
			username = DEFAULT_EC2_WINDOWS_USERNAME;
		}
		machineDetails.setRemoteUsername(username);
		machineDetails.setRemotePassword(password);
		machineDetails.setFileTransferMode(cloudTemplate.getFileTransfer());
		machineDetails.setRemoteExecutionMode(cloudTemplate
				.getRemoteExecution());
	}
=======
private void handleEC2WindowsCredentials(final long end,
			final NodeMetadata node, final MachineDetails machineDetails,
			final CloudTemplate cloudTemplate) throws FileNotFoundException,
			InterruptedException, TimeoutException, CloudProvisioningException {
		File pemFile = null;

		if (this.management) {
			final File localDirectory = new File(cloudTemplate.getAbsoluteUploadDir());

			pemFile = new File(localDirectory, cloudTemplate.getKeyFile());
		} else {
			final String localDirectoryName = cloudTemplate.getLocalDirectory();
			logger.fine("local dir name is: " + localDirectoryName);
			final File localDirectory = new File(localDirectoryName);

			pemFile = new File(localDirectory, cloudTemplate.getKeyFile());
		}

		if (!pemFile.exists()) {
			logger.severe("Could not find pem file: " + pemFile);
			throw new FileNotFoundException("Could not find key file: "
					+ pemFile);
		}

		String password;
		if (cloudTemplate.getPassword() == null) {
			// get the password using Amazon API
			this.publishEvent("waiting_for_ec2_windows_password", node.getId());

			final LoginCredentials credentials = new EC2WindowsPasswordHandler()
					.getPassword(node, this.deployer.getContext(), end, pemFile);
			password = credentials.getPassword();

			this.publishEvent("ec2_windows_password_retrieved", node.getId());

		} else {
			password = cloudTemplate.getPassword();
		}

		String username = cloudTemplate.getUsername();

		if (username == null) {
			username = DEFAULT_EC2_WINDOWS_USERNAME;
		}
		machineDetails.setRemoteUsername(username);
		machineDetails.setRemotePassword(password);
		machineDetails.setFileTransferMode(cloudTemplate.getFileTransfer());
		machineDetails.setRemoteExecutionMode(cloudTemplate
				.getRemoteExecution());
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887884/fstmerge_var2_4863324035828150577

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/jclouds/DefaultProvisioningDriver.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887924/fstmerge_var1_1727370556919842737
@Override
	public MachineDetails[] getExistingManagementServers() throws CloudProvisioningException {
		final String managementMachinePrefix = this.serverNamePrefix;
		Set<? extends NodeMetadata> existingManagementServers = null;
		try {
			existingManagementServers = this.deployer
					.getServers(new Predicate<ComputeMetadata>() {

						@Override
						public boolean apply(final ComputeMetadata input) {
							final NodeMetadata node = (NodeMetadata) input;
							if (node.getGroup() == null) {
								return false;
							}
							// only running or pending nodes are interesting
							if (node.getStatus() == NodeMetadata.Status.RUNNING
									|| node.getStatus() == NodeMetadata.Status.PENDING) {
								return node
										.getGroup()
										.toLowerCase()
										.startsWith(
												managementMachinePrefix
														.toLowerCase());
							}
							return false;
						}
					});

		} catch (final Exception e) {
			throw new CloudProvisioningException("Failed to read existing management servers: " + e.getMessage(), e);
		}

		final MachineDetails[] result = new MachineDetails[existingManagementServers
				.size()];
		int i = 0;
		for (final NodeMetadata node : existingManagementServers) {
			result[i] = createMachineDetailsFromNode(node);
			result[i].setAgentRunning(true);
			result[i].setCloudifyInstalled(true);
			i++;

		}
		return result;
	}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887924/fstmerge_base_3087654939221498484
=======
@Override
	public MachineDetails[] getExistingManagementServers() throws CloudProvisioningException {
		final String managementMachinePrefix = this.serverNamePrefix;
		Set<? extends NodeMetadata> existingManagementServers = null;
		try {
			existingManagementServers = this.deployer
					.getServers(new Predicate<ComputeMetadata>() {

						@Override
						public boolean apply(final ComputeMetadata input) {
							final NodeMetadata node = (NodeMetadata) input;
							if (node.getGroup() == null) {
								return false;
							}
							// only running or pending nodes are interesting
							if (node.getStatus() == NodeMetadata.Status.RUNNING
									|| node.getStatus() == NodeMetadata.Status.PENDING) {
								return node
										.getGroup()
										.toLowerCase()
										.startsWith(
												managementMachinePrefix
														.toLowerCase());
							}
							return false;
						}
					});

		} catch (final Exception e) {
			throw new CloudProvisioningException("Failed to read existing management servers: " + e.getMessage(), e);
		}

		final MachineDetails[] result = new MachineDetails[existingManagementServers
				.size()];
		int i = 0;
		for (final NodeMetadata node : existingManagementServers) {
			result[i] = createMachineDetailsFromNode(node);
//			result[i].setAgentRunning(true);
//			result[i].setCloudifyInstalled(true);
			i++;

		}
		return result;
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887924/fstmerge_var2_9190157250903129410

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/jclouds/DefaultProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887933/fstmerge_var1_6662869131534287825
private MachineDetails createMachineDetailsFromNode(final NodeMetadata node) {
		final ComputeTemplate template = this.cloud.getCloudCompute().getTemplates().get(
				this.cloudTemplateName);

		final MachineDetails md = createMachineDetailsForTemplate(template);

		md.setCloudifyInstalled(false);
		md.setInstallationDirectory(null);
		md.setMachineId(node.getId());
		if (node.getPrivateAddresses().size() > 0) {
			md.setPrivateAddress(node.getPrivateAddresses().iterator().next());
		}
		if (node.getPublicAddresses().size() > 0) {
			md.setPublicAddress(node.getPublicAddresses().iterator().next());
		}

		final String username = createMachineUsername(node, template);
		final String password = createMachinePassword(node, template);

		md.setRemoteUsername(username);
		md.setRemotePassword(password);

		// this will ensure that the availability zone is added to GSA that
		// starts on this machine.
		final String locationId = node.getLocation().getId();
		md.setLocationId(locationId);

		return md;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887933/fstmerge_base_1360734288500521893
private MachineDetails createMachineDetailsFromNode(final NodeMetadata node) {
		final CloudTemplate template = this.cloud.getTemplates().get(
				this.cloudTemplateName);

		final MachineDetails md = createMachineDetailsForTemplate(template);

		md.setCloudifyInstalled(false);
		md.setInstallationDirectory(null);
		md.setMachineId(node.getId());
		if (node.getPrivateAddresses().size() > 0) {
			md.setPrivateAddress(node.getPrivateAddresses().iterator().next());
		}
		if (node.getPublicAddresses().size() > 0) {
			md.setPublicAddress(node.getPublicAddresses().iterator().next());
		}

		final String username = createMachineUsername(node, template);
		final String password = createMachinePassword(node, template);

		md.setRemoteUsername(username);
		md.setRemotePassword(password);

		// this will ensure that the availability zone is added to GSA that
		// starts on this machine.
		final String locationId = node.getLocation().getId();
		md.setLocationId(locationId);

		return md;
=======
private MachineDetails createMachineDetailsFromNode(final NodeMetadata node) {
		final CloudTemplate template = this.cloud.getTemplates().get(
				this.cloudTemplateName);

		final MachineDetails md = createMachineDetailsForTemplate(template);

		md.setCloudifyInstalled(false);
		md.setInstallationDirectory(null);
		md.setMachineId(node.getId());
		if (node.getPrivateAddresses().size() > 0) {
			md.setPrivateAddress(node.getPrivateAddresses().iterator().next());
		}
		if (node.getPublicAddresses().size() > 0) {
			md.setPublicAddress(node.getPublicAddresses().iterator().next());
		}

		final String username = createMachineUsername(node, template);
		final String password = createMachinePassword(node, template);

		md.setRemoteUsername(username);
		md.setRemotePassword(password);

		// this will ensure that the availability zone is added to GSA that
		// starts on this machine.
		final String locationId = node.getLocation().getId();
		md.setLocationId(locationId);

		return md;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887933/fstmerge_var2_1173773503389475495
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/jclouds/DefaultProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887938/fstmerge_var1_6148862145740095339
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887938/fstmerge_base_7983747863898942283
private String createMachineUsername(final NodeMetadata node,
			final CloudTemplate template) {

		// Template configuration takes precedence.
		if (template.getUsername() != null) {
			return template.getUsername();
		}

		// Check if node returned a username
		if (node.getCredentials() != null) {
			final String serverIdentity = node.getCredentials().identity;
			if (serverIdentity != null) {
				return serverIdentity;
			}
		}

		return null;
	}
=======
private String createMachineUsername(final NodeMetadata node,
			final CloudTemplate template) {

		// Template configuration takes precedence.
		if (template.getUsername() != null) {
			return template.getUsername();
		}

		// Check if node returned a username
		if (node.getCredentials() != null) {
			final String serverIdentity = node.getCredentials().identity;
			if (serverIdentity != null) {
				return serverIdentity;
			}
		}

		return null;
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887938/fstmerge_var2_2469209990268780692

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/jclouds/DefaultProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887944/fstmerge_var1_8442251746086253037
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887944/fstmerge_base_5124745999259467522
private String createMachinePassword(final NodeMetadata node,
			final CloudTemplate template) {

		// Template configuration takes precedence.
		if (template.getPassword() != null) {
			return template.getPassword();
		}

		// Check if node returned a username - some clouds support this
		// (Rackspace, for instance)
		if (node.getCredentials() != null
				&& node.getCredentials().getOptionalPassword() != null) {
			if (node.getCredentials().getOptionalPassword().isPresent()) {
				return node.getCredentials().getPassword();
			}
		}

		return null;
	}
=======
private String createMachinePassword(final NodeMetadata node,
			final CloudTemplate template) {

		// Template configuration takes precedence.
		if (template.getPassword() != null) {
			return template.getPassword();
		}

		// Check if node returned a username - some clouds support this
		// (Rackspace, for instance)
		if (node.getCredentials() != null
				&& node.getCredentials().getOptionalPassword() != null) {
			if (node.getCredentials().getOptionalPassword().isPresent()) {
				return node.getCredentials().getPassword();
			}
		}

		return null;
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887944/fstmerge_var2_7732163421713329056

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/jclouds/DefaultProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887953/fstmerge_var1_4708655282346660803
private JCloudsDeployer createDeployer(final Cloud cloud)
			throws IOException {
		logger.fine("Creating JClouds context deployer with user: "
				+ cloud.getUser().getUser());
		final ComputeTemplate cloudTemplate = cloud.getCloudCompute().getTemplates().get(
				cloudTemplateName);

		logger.fine("Cloud Template: " + cloudTemplateName + ". Details: "
				+ cloudTemplate);
		final Properties props = new Properties();
		props.putAll(cloudTemplate.getOverrides());

		deployer = new JCloudsDeployer(cloud.getProvider().getProvider(), cloud
				.getUser().getUser(), cloud.getUser().getApiKey(), props);

		deployer.setImageId(cloudTemplate.getImageId());
		deployer.setMinRamMegabytes(cloudTemplate.getMachineMemoryMB());
		deployer.setHardwareId(cloudTemplate.getHardwareId());
		deployer.setExtraOptions(cloudTemplate.getOptions());
		return deployer;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887953/fstmerge_base_3503220436882099814
private JCloudsDeployer createDeployer(final Cloud cloud)
			throws IOException {
		logger.fine("Creating JClouds context deployer with user: "
				+ cloud.getUser().getUser());
		final CloudTemplate cloudTemplate = cloud.getTemplates().get(
				cloudTemplateName);

		logger.fine("Cloud Template: " + cloudTemplateName + ". Details: "
				+ cloudTemplate);
		final Properties props = new Properties();
		props.putAll(cloudTemplate.getOverrides());

		deployer = new JCloudsDeployer(cloud.getProvider().getProvider(), cloud
				.getUser().getUser(), cloud.getUser().getApiKey(), props);

		deployer.setImageId(cloudTemplate.getImageId());
		deployer.setMinRamMegabytes(cloudTemplate.getMachineMemoryMB());
		deployer.setHardwareId(cloudTemplate.getHardwareId());
		deployer.setExtraOptions(cloudTemplate.getOptions());
		return deployer;
=======
private JCloudsDeployer createDeployer(final Cloud cloud)
			throws IOException {
		logger.fine("Creating JClouds context deployer with user: "
				+ cloud.getUser().getUser());
		final CloudTemplate cloudTemplate = cloud.getTemplates().get(
				cloudTemplateName);

		logger.fine("Cloud Template: " + cloudTemplateName + ". Details: "
				+ cloudTemplate);
		final Properties props = new Properties();
		props.putAll(cloudTemplate.getOverrides());

		deployer = new JCloudsDeployer(cloud.getProvider().getProvider(), cloud
				.getUser().getUser(), cloud.getUser().getApiKey(), props);

		deployer.setImageId(cloudTemplate.getImageId());
		deployer.setMinRamMegabytes(cloudTemplate.getMachineMemoryMB());
		deployer.setHardwareId(cloudTemplate.getHardwareId());
		deployer.setExtraOptions(cloudTemplate.getOptions());
		return deployer;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617887953/fstmerge_var2_6979030466923917551
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/jclouds/DefaultProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889560/fstmerge_var1_6028259299264848022
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889560/fstmerge_base_3308184114937696474
@SuppressWarnings("unchecked")
	private void addTemplatesToDeployer(final ByonDeployer deployer, final Map<String, CloudTemplate> templatesMap)
			throws Exception {
		logger.info("addTempaltesToDeployer - adding the following tempaltes to the deployer: "
				+ templatesMap.keySet());

		List<Map<String, String>> nodesList = null;
		for (final String templateName : templatesMap.keySet()) {
			final Map<String, Object> customSettings = cloud.getTemplates().get(templateName).getCustom();
			if (customSettings != null) {
				final List<Map<Object, Object>> originalNodesList =
						(List<Map<Object, Object>>) customSettings.get(CLOUD_NODES_LIST);

				nodesList = convertToStringMap(originalNodesList);

			}
			if (nodesList == null) {
				publishEvent(CloudifyErrorMessages.MISSING_NODES_LIST.getName(), templateName);
				throw new CloudProvisioningException(
						"Failed to create BYON cloud deployer, invalid configuration for tempalte "
								+ templateName + " - missing nodes list.");
			}
			deployer.addNodesList(templateName, templatesMap.get(templateName), nodesList);
		}
	}
=======
@SuppressWarnings("unchecked")
	private void addTemplatesToDeployer(final ByonDeployer deployer, final Map<String, CloudTemplate> templatesMap)
			throws Exception {
		logger.info("addTempaltesToDeployer - adding the following tempaltes to the deployer: "
				+ templatesMap.keySet());

		List<Map<String, String>> nodesList = null;
		for (final String templateName : templatesMap.keySet()) {
			final Map<String, Object> customSettings = cloud.getTemplates().get(templateName).getCustom();
			if (customSettings != null) {
				final List<Map<Object, Object>> originalNodesList =
						(List<Map<Object, Object>>) customSettings.get(CLOUD_NODES_LIST);

				nodesList = convertToStringMap(originalNodesList);

			}
			if (nodesList == null) {
				publishEvent(CloudifyErrorMessages.MISSING_NODES_LIST.getName(), templateName);
				throw new CloudProvisioningException(
						"Failed to create BYON cloud deployer, invalid configuration for tempalte "
								+ templateName + " - missing nodes list.");
			}
			deployer.addNodesList(templateName, templatesMap.get(templateName), nodesList);
		}
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889560/fstmerge_var2_7822816159096900796

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/byon/ByonProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889567/fstmerge_var1_8161743785843721059
@Override
	protected void initDeployer(final Cloud cloud) {
		try {
			deployer = (ByonDeployer) context.getOrCreate("UNIQUE_BYON_DEPLOYER_ID", new Callable<Object>() {

				@Override
				public Object call()
						throws Exception {
					logger.info("Creating BYON context deployer for cloud: " + cloud.getName());
					final ByonDeployer newDeployer = new ByonDeployer();
					addTemplatesToDeployer(newDeployer, cloud.getCloudCompute().getTemplates());
					return newDeployer;
				}
			});
		} catch (final Exception e) {
			publishEvent("connection_to_cloud_api_failed", cloud.getProvider().getProvider());
			throw new IllegalStateException("Failed to create cloud deployer", e);
		}
		try {
			updateDeployerTemplates(cloud);
		} catch (final Exception e) {
			logger.log(Level.WARNING, "initDeployer - fialed to add tempaltes to deployer", e);
			throw new IllegalStateException("Failed to update templates", e);
		}
		setCustomSettings(cloud);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889567/fstmerge_base_3517393788414554083
@Override
	protected void initDeployer(final Cloud cloud) {
		try {
			deployer = (ByonDeployer) context.getOrCreate("UNIQUE_BYON_DEPLOYER_ID", new Callable<Object>() {

				@Override
				public Object call()
						throws Exception {
					logger.info("Creating BYON context deployer for cloud: " + cloud.getName());
					final ByonDeployer newDeployer = new ByonDeployer();
					addTemplatesToDeployer(newDeployer, cloud.getTemplates());
					return newDeployer;
				}
			});
		} catch (final Exception e) {
			publishEvent("connection_to_cloud_api_failed", cloud.getProvider().getProvider());
			throw new IllegalStateException("Failed to create cloud deployer", e);
		}
		try {
			updateDeployerTemplates(cloud);
		} catch (final Exception e) {
			logger.log(Level.WARNING, "initDeployer - fialed to add tempaltes to deployer", e);
			throw new IllegalStateException("Failed to update templates", e);
		}
		setCustomSettings(cloud);
=======
@Override
	protected void initDeployer(final Cloud cloud) {
		try {
			deployer = (ByonDeployer) context.getOrCreate("UNIQUE_BYON_DEPLOYER_ID", new Callable<Object>() {

				@Override
				public Object call()
						throws Exception {
					logger.info("Creating BYON context deployer for cloud: " + cloud.getName());
					final ByonDeployer newDeployer = new ByonDeployer();
					addTemplatesToDeployer(newDeployer, cloud.getTemplates());
					return newDeployer;
				}
			});
		} catch (final Exception e) {
			publishEvent("connection_to_cloud_api_failed", cloud.getProvider().getProvider());
			throw new IllegalStateException("Failed to create cloud deployer", e);
		}
		try {
			updateDeployerTemplates(cloud);
		} catch (final Exception e) {
			logger.log(Level.WARNING, "initDeployer - fialed to add tempaltes to deployer", e);
			throw new IllegalStateException("Failed to update templates", e);
		}
		setCustomSettings(cloud);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889567/fstmerge_var2_4603935812901427889
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/byon/ByonProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889571/fstmerge_var1_4652007454753686991
public void updateDeployerTemplates(final Cloud cloud) throws Exception {
		final Map<String, ComputeTemplate> cloudTemplatesMap = cloud.getCloudCompute().getTemplates();
		final List<String> cloudTemplateNames = new LinkedList<String>(cloudTemplatesMap.keySet());
		final List<String> deployerTemplateNames = deployer.getTemplatesList();

		final List<String> redundantTemplates = new LinkedList<String>(deployerTemplateNames);
		redundantTemplates.removeAll(cloudTemplateNames);
		if (!redundantTemplates.isEmpty()) {
			logger.info("initDeployer - found redundant templates: " + redundantTemplates);
			deployer.removeTemplates(redundantTemplates);
		}
		final List<String> missingTemplates = new LinkedList<String>(cloudTemplateNames);
		missingTemplates.removeAll(deployerTemplateNames);
		if (!missingTemplates.isEmpty()) {
			logger.info("initDeployer - found missing templates: " + missingTemplates);
			final Map<String, ComputeTemplate> templatesMap = new HashMap<String, ComputeTemplate>();
			for (final String templateName : missingTemplates) {
				final ComputeTemplate cloudTemplate = cloudTemplatesMap.get(templateName);
				templatesMap.put(templateName, cloudTemplate);
			}
			addTemplatesToDeployer(deployer, templatesMap);
		}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889571/fstmerge_base_7504076017885684549
public void updateDeployerTemplates(final Cloud cloud) throws Exception {
		final Map<String, CloudTemplate> cloudTemplatesMap = cloud.getTemplates();
		final List<String> cloudTemplateNames = new LinkedList<String>(cloudTemplatesMap.keySet());
		final List<String> deployerTemplateNames = deployer.getTemplatesList();

		final List<String> redundantTemplates = new LinkedList<String>(deployerTemplateNames);
		redundantTemplates.removeAll(cloudTemplateNames);
		if (!redundantTemplates.isEmpty()) {
			logger.info("initDeployer - found redundant templates: " + redundantTemplates);
			deployer.removeTemplates(redundantTemplates);
		}
		final List<String> missingTemplates = new LinkedList<String>(cloudTemplateNames);
		missingTemplates.removeAll(deployerTemplateNames);
		if (!missingTemplates.isEmpty()) {
			logger.info("initDeployer - found missing templates: " + missingTemplates);
			final Map<String, CloudTemplate> templatesMap = new HashMap<String, CloudTemplate>();
			for (final String templateName : missingTemplates) {
				final CloudTemplate cloudTemplate = cloudTemplatesMap.get(templateName);
				templatesMap.put(templateName, cloudTemplate);
			}
			addTemplatesToDeployer(deployer, templatesMap);
		}
=======
public void updateDeployerTemplates(final Cloud cloud) throws Exception {
		final Map<String, CloudTemplate> cloudTemplatesMap = cloud.getTemplates();
		final List<String> cloudTemplateNames = new LinkedList<String>(cloudTemplatesMap.keySet());
		final List<String> deployerTemplateNames = deployer.getTemplatesList();

		final List<String> redundantTemplates = new LinkedList<String>(deployerTemplateNames);
		redundantTemplates.removeAll(cloudTemplateNames);
		if (!redundantTemplates.isEmpty()) {
			logger.info("initDeployer - found redundant templates: " + redundantTemplates);
			deployer.removeTemplates(redundantTemplates);
		}
		final List<String> missingTemplates = new LinkedList<String>(cloudTemplateNames);
		missingTemplates.removeAll(deployerTemplateNames);
		if (!missingTemplates.isEmpty()) {
			logger.info("initDeployer - found missing templates: " + missingTemplates);
			final Map<String, CloudTemplate> templatesMap = new HashMap<String, CloudTemplate>();
			for (final String templateName : missingTemplates) {
				final CloudTemplate cloudTemplate = cloudTemplatesMap.get(templateName);
				templatesMap.put(templateName, cloudTemplate);
			}
			addTemplatesToDeployer(deployer, templatesMap);
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889571/fstmerge_var2_8842580498256537629
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/byon/ByonProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889581/fstmerge_var1_4175184285409464061
@Override
	public MachineDetails startMachine(final String locationId, final long timeout, final TimeUnit timeUnit)
			throws TimeoutException,
			CloudProvisioningException {

		final long endTime = System.currentTimeMillis() + timeUnit.toMillis(timeout);

		logger.info(this.getClass().getName() + ": startMachine, management mode: " + management);

		final Set<String> activeMachinesIPs = admin.getMachines().getHostsByAddress().keySet();
		deployer.setAllocated(cloudTemplateName, activeMachinesIPs);
		if (logger.isLoggable(Level.INFO)) {
			logger.info("Verifying the active machines are not in the free pool: "
					+ "\n Admin reports the currently used machines are: "
					+ Arrays.toString(activeMachinesIPs.toArray())
					+ "\n Byon deployer reports the free machines for template " + cloudTemplateName + " are: "
					+ Arrays.toString(deployer.getFreeNodesByTemplateName(cloudTemplateName).toArray())
					+ "\n Byon deployer reports the currently used machines for template " + cloudTemplateName
					+ " are:"
					+ Arrays.toString(deployer.getAllocatedNodesByTemplateName(cloudTemplateName).toArray())
					+ "\n Byon deployer reports the invalid used machines for template " + cloudTemplateName + " are: "
					+ Arrays.toString(deployer.getInvalidNodesByTemplateName(cloudTemplateName).toArray()) + ")");
		}
		final String newServerName = createNewServerName();
		logger.info("Attempting to start a new cloud machine");
		final ComputeTemplate template = this.cloud.getCloudCompute().getTemplates().get(cloudTemplateName);

		return createServer(newServerName, endTime, template);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889581/fstmerge_base_7040020697148058936
@Override
	public MachineDetails startMachine(final String locationId, final long timeout, final TimeUnit timeUnit)
			throws TimeoutException,
			CloudProvisioningException {

		final long endTime = System.currentTimeMillis() + timeUnit.toMillis(timeout);

		logger.info(this.getClass().getName() + ": startMachine, management mode: " + management);

		final Set<String> activeMachinesIPs = admin.getMachines().getHostsByAddress().keySet();
		deployer.setAllocated(cloudTemplateName, activeMachinesIPs);
		if (logger.isLoggable(Level.INFO)) {
			logger.info("Verifying the active machines are not in the free pool: "
					+ "\n Admin reports the currently used machines are: "
					+ Arrays.toString(activeMachinesIPs.toArray())
					+ "\n Byon deployer reports the free machines for template " + cloudTemplateName + " are: "
					+ Arrays.toString(deployer.getFreeNodesByTemplateName(cloudTemplateName).toArray())
					+ "\n Byon deployer reports the currently used machines for template " + cloudTemplateName
					+ " are:"
					+ Arrays.toString(deployer.getAllocatedNodesByTemplateName(cloudTemplateName).toArray())
					+ "\n Byon deployer reports the invalid used machines for template " + cloudTemplateName + " are: "
					+ Arrays.toString(deployer.getInvalidNodesByTemplateName(cloudTemplateName).toArray()) + ")");
		}
		final String newServerName = createNewServerName();
		logger.info("Attempting to start a new cloud machine");
		final CloudTemplate template = this.cloud.getTemplates().get(cloudTemplateName);

		return createServer(newServerName, endTime, template);
=======
@Override
	public MachineDetails startMachine(final String locationId, final long timeout, final TimeUnit timeUnit)
			throws TimeoutException,
			CloudProvisioningException {

		final long endTime = System.currentTimeMillis() + timeUnit.toMillis(timeout);

		logger.info(this.getClass().getName() + ": startMachine, management mode: " + management);

		final Set<String> activeMachinesIPs = admin.getMachines().getHostsByAddress().keySet();
		deployer.setAllocated(cloudTemplateName, activeMachinesIPs);
		if (logger.isLoggable(Level.INFO)) {
			logger.info("Verifying the active machines are not in the free pool: "
					+ "\n Admin reports the currently used machines are: "
					+ Arrays.toString(activeMachinesIPs.toArray())
					+ "\n Byon deployer reports the free machines for template " + cloudTemplateName + " are: "
					+ Arrays.toString(deployer.getFreeNodesByTemplateName(cloudTemplateName).toArray())
					+ "\n Byon deployer reports the currently used machines for template " + cloudTemplateName
					+ " are:"
					+ Arrays.toString(deployer.getAllocatedNodesByTemplateName(cloudTemplateName).toArray())
					+ "\n Byon deployer reports the invalid used machines for template " + cloudTemplateName + " are: "
					+ Arrays.toString(deployer.getInvalidNodesByTemplateName(cloudTemplateName).toArray()) + ")");
		}
		final String newServerName = createNewServerName();
		logger.info("Attempting to start a new cloud machine");
		final CloudTemplate template = this.cloud.getTemplates().get(cloudTemplateName);

		return createServer(newServerName, endTime, template);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889581/fstmerge_var2_6844359481436555038
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/byon/ByonProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889584/fstmerge_var1_1844991606672708864
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889584/fstmerge_base_2928429207031860163
@Override
	protected MachineDetails createServer(final String serverName, final long endTime, final CloudTemplate template)
			throws CloudProvisioningException, TimeoutException {

		final CustomNode node;
		final MachineDetails machineDetails;
		logger.info("Cloudify Deployer is creating a machine named: " + serverName + ". This may take a few minutes");
		node = deployer.createServer(cloudTemplateName, serverName);

		machineDetails = createMachineDetailsFromNode(node);

		// At this point the machine is starting. Any error beyond this point
		// must clean up the machine.
		try {
			handleServerCredentials(machineDetails, template);
		} catch (final CloudProvisioningException e) {
			try {
				deployer.invalidateServer(cloudTemplateName, node);
			} catch (final CloudProvisioningException ie) {
				logger.log(Level.SEVERE, "Failed to mark machine [" + machineDetails.getPublicAddress() + "/"
						+ machineDetails.getPrivateAddress() + "] as Invalid.", ie);
			}
			throw new CloudProvisioningException(e);
		}

		if (System.currentTimeMillis() > endTime) {
			throw new TimeoutException();
		}

		logger.info("Machine successfully allocated");
		return machineDetails;
	}
=======
@Override
	protected MachineDetails createServer(final String serverName, final long endTime, final CloudTemplate template)
			throws CloudProvisioningException, TimeoutException {

		final CustomNode node;
		final MachineDetails machineDetails;
		logger.info("Cloudify Deployer is creating a machine named: " + serverName + ". This may take a few minutes");
		node = deployer.createServer(cloudTemplateName, serverName);

		machineDetails = createMachineDetailsFromNode(node);

		// At this point the machine is starting. Any error beyond this point
		// must clean up the machine.
		try {
			handleServerCredentials(machineDetails, template);
		} catch (final CloudProvisioningException e) {
			try {
				deployer.invalidateServer(cloudTemplateName, node);
			} catch (final CloudProvisioningException ie) {
				logger.log(Level.SEVERE, "Failed to mark machine [" + machineDetails.getPublicAddress() + "/"
						+ machineDetails.getPrivateAddress() + "] as Invalid.", ie);
			}
			throw new CloudProvisioningException(e);
		}

		if (System.currentTimeMillis() > endTime) {
			throw new TimeoutException();
		}

		logger.info("Machine successfully allocated");
		return machineDetails;
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889584/fstmerge_var2_3727251612430217649

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/byon/ByonProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889631/fstmerge_var1_7836934818356171657
private MachineDetails createMachineDetailsFromNode(final CustomNode node)
			throws CloudProvisioningException {
		final ComputeTemplate template = this.cloud.getCloudCompute().getTemplates().get(this.cloudTemplateName);

		final MachineDetails md = createMachineDetailsForTemplate(template);

		md.setMachineId(node.getId());
		md.setPrivateAddress(node.getPrivateIP());
		md.setPublicAddress(node.getPublicIP());
		md.setCleanRemoteDirectoryOnStart(this.cleanRemoteDirectoryOnStart);
		// if the node has user/pwd - use it. Otherwise - take the use/password
		// from the template's settings.

		if (!StringUtils.isBlank(node.getUsername()) && !StringUtils.isBlank(node.getCredential())) {
			md.setRemoteUsername(node.getUsername());
			md.setRemotePassword(node.getCredential());
		} else if (!StringUtils.isBlank(template.getUsername())
				&& !StringUtils.isBlank(template.getPassword())) {
			md.setRemoteUsername(template.getUsername());
			md.setRemotePassword(template.getPassword());
		} else {
			final String nodeStr = node.toString();
			logger.severe("Cloud node loading failed, missing credentials for server: " + nodeStr);
			publishEvent("prov_node_loading_failed", nodeStr);
			throw new CloudProvisioningException("Cloud node loading failed, missing credentials for server: "
					+ nodeStr);
		}

		return md;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889631/fstmerge_base_2606410003180268613
private MachineDetails createMachineDetailsFromNode(final CustomNode node)
			throws CloudProvisioningException {
		final CloudTemplate template = this.cloud.getTemplates().get(this.cloudTemplateName);

		final MachineDetails md = createMachineDetailsForTemplate(template);

		md.setMachineId(node.getId());
		md.setPrivateAddress(node.getPrivateIP());
		md.setPublicAddress(node.getPublicIP());
		md.setCleanRemoteDirectoryOnStart(this.cleanRemoteDirectoryOnStart);
		// if the node has user/pwd - use it. Otherwise - take the use/password
		// from the template's settings.

		if (!StringUtils.isBlank(node.getUsername()) && !StringUtils.isBlank(node.getCredential())) {
			md.setRemoteUsername(node.getUsername());
			md.setRemotePassword(node.getCredential());
		} else if (!StringUtils.isBlank(template.getUsername())
				&& !StringUtils.isBlank(template.getPassword())) {
			md.setRemoteUsername(template.getUsername());
			md.setRemotePassword(template.getPassword());
		} else {
			final String nodeStr = node.toString();
			logger.severe("Cloud node loading failed, missing credentials for server: " + nodeStr);
			publishEvent("prov_node_loading_failed", nodeStr);
			throw new CloudProvisioningException("Cloud node loading failed, missing credentials for server: "
					+ nodeStr);
		}

		return md;
=======
private MachineDetails createMachineDetailsFromNode(final CustomNode node)
			throws CloudProvisioningException {
		final CloudTemplate template = this.cloud.getTemplates().get(this.cloudTemplateName);

		final MachineDetails md = createMachineDetailsForTemplate(template);

		md.setMachineId(node.getId());
		md.setPrivateAddress(node.getPrivateIP());
		md.setPublicAddress(node.getPublicIP());
		md.setCleanRemoteDirectoryOnStart(this.cleanRemoteDirectoryOnStart);
		// if the node has user/pwd - use it. Otherwise - take the use/password
		// from the template's settings.

		if (!StringUtils.isBlank(node.getUsername()) && !StringUtils.isBlank(node.getCredential())) {
			md.setRemoteUsername(node.getUsername());
			md.setRemotePassword(node.getCredential());
		} else if (!StringUtils.isBlank(template.getUsername())
				&& !StringUtils.isBlank(template.getPassword())) {
			md.setRemoteUsername(template.getUsername());
			md.setRemotePassword(template.getPassword());
		} else {
			final String nodeStr = node.toString();
			logger.severe("Cloud node loading failed, missing credentials for server: " + nodeStr);
			publishEvent("prov_node_loading_failed", nodeStr);
			throw new CloudProvisioningException("Cloud node loading failed, missing credentials for server: "
					+ nodeStr);
		}

		return md;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889631/fstmerge_var2_680531140293445791
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/byon/ByonProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889665/fstmerge_base_5058824139758750782
	public MachineDetails startMachine(String locationId, long duration, TimeUnit unit) 
=======
	public MachineDetails startMachine(String locationId, long duration, TimeUnit unit)
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889665/fstmerge_var2_7699311372356543346
			throws TimeoutException, CloudProvisioningException {
		String currnentId = PROVIDER_ID + "{" + idCounter.getAndIncrement() + "}";
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889665/fstmerge_var1_2545985988178120970
		final ComputeTemplate template = cloud.getCloudCompute().getTemplates().get(cloudTemplateName);

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889665/fstmerge_base_5058824139758750782
		final CloudTemplate template = cloud.getTemplates().get(cloudTemplateName);
		
=======
		final CloudTemplate template = cloud.getTemplates().get(cloudTemplateName);

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889665/fstmerge_var2_7699311372356543346
		Map<String, Object> custom = template.getCustom();
		Closure<String> getNodeClosure =  (Closure<String>) custom.get(CloudifyConstants.DYNAMIC_BYON_START_MACHINE_KEY);
		String ip = getNodeClosure.call();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889665/fstmerge_base_5058824139758750782
		
=======

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889665/fstmerge_var2_7699311372356543346
		return createMachine(currnentId, template, ip);
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/byon/DynamicByonProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
	public MachineDetails[] startManagementMachines(long duration, TimeUnit unit)
			throws TimeoutException, CloudProvisioningException {
		publishEvent(EVENT_ATTEMPT_START_MGMT_VMS);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889670/fstmerge_var1_2657336552713788314

		final ComputeTemplate managementTemplate =
				this.cloud.getCloudCompute().getTemplates().get(this.cloud.getConfiguration().getManagementMachineTemplate());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889670/fstmerge_base_1019523020875387386
		
		final CloudTemplate managementTemplate =
				this.cloud.getTemplates().get(this.cloud.getConfiguration().getManagementMachineTemplate());
=======

		final CloudTemplate managementTemplate =
				this.cloud.getTemplates().get(this.cloud.getConfiguration().getManagementMachineTemplate());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889670/fstmerge_var2_7140916958272230332
		Map<String, Object> custom = managementTemplate.getCustom();
		@SuppressWarnings("unchecked")
		Closure<List<String>> getNodesClosure =  (Closure<List<String>>) custom.get(CloudifyConstants.DYNAMIC_BYON_START_MNG_MACHINES_KEY);
		List<String> ips = getNodesClosure.call();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889670/fstmerge_base_1019523020875387386
		
=======

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889670/fstmerge_var2_7140916958272230332
		final int numberOfManagementMachines = this.cloud.getProvider().getNumberOfManagementMachines();
		final int size = ips.size();
		if (size != numberOfManagementMachines) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889670/fstmerge_base_1019523020875387386
			throw new CloudProvisioningException("DynamicByonProvisioningDriver [startManagementMachines] - expected " 
=======
			throw new CloudProvisioningException("DynamicByonProvisioningDriver [startManagementMachines] - expected "
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889670/fstmerge_var2_7140916958272230332
					+ numberOfManagementMachines + " management machines, but got " + size + " machines.");
		}
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889670/fstmerge_base_1019523020875387386
		synchronized (mutex) {			
=======
		synchronized (mutex) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889670/fstmerge_var2_7140916958272230332
			managementMachines.addAll(ips);
		}
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889670/fstmerge_base_1019523020875387386
		
=======

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889670/fstmerge_var2_7140916958272230332
		logger.info("Starting " + numberOfManagementMachines + " management machines.");
		final long endTime = System.currentTimeMillis() + unit.toMillis(duration);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889670/fstmerge_base_1019523020875387386
		final MachineDetails[] createdMachines = doStartManagementMachines(endTime, numberOfManagementMachines);		
=======
		final MachineDetails[] createdMachines = doStartManagementMachines(endTime, numberOfManagementMachines);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889670/fstmerge_var2_7140916958272230332
		publishEvent(EVENT_MGMT_VMS_STARTED);
		logger.info("Successfully added " + numberOfManagementMachines + " management machines: " + ips);
		return createdMachines;
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/byon/DynamicByonProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889692/fstmerge_var1_8311841141493321223
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889692/fstmerge_base_3014898879642856848
@Override
	protected MachineDetails createServer(String serverName, long endTime, CloudTemplate template) 
			throws CloudProvisioningException, TimeoutException {
		
		String ip;
		synchronized (mutex) {
			ip = managementMachines.removeFirst();
		}

		MachineDetails machine = createMachine(serverName, template, ip);

		if (System.currentTimeMillis() > endTime) {
			throw new TimeoutException();
		}
		logger.info("Successfully started machine [" + ip + "]");
		
		return machine;
	}
=======
@Override
	protected MachineDetails createServer(String serverName, long endTime, CloudTemplate template)
			throws CloudProvisioningException, TimeoutException {

		String ip;
		synchronized (mutex) {
			ip = managementMachines.removeFirst();
		}

		MachineDetails machine = createMachine(serverName, template, ip);

		if (System.currentTimeMillis() > endTime) {
			throw new TimeoutException();
		}
		logger.info("Successfully started machine [" + ip + "]");

		return machine;
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889692/fstmerge_var2_9164701274303254545

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/byon/DynamicByonProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889697/fstmerge_var1_4575012253664241792
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889697/fstmerge_base_8934703491109203288
private MachineDetails createMachine(String serverName,
			CloudTemplate template, String ip) throws CloudProvisioningException {
		final CustomNodeImpl customNode = new CustomNodeImpl(PROVIDER_ID, serverName, ip,
				template.getUsername(), template.getPassword(), serverName);

		try {
			String resolvedIP = IPUtils.resolveHostName(customNode.getPrivateIP());
			customNode.setResolvedIP(resolvedIP);
			if (template.getRemoteExecution() == RemoteExecutionModes.WINRM) {
				customNode.setLoginPort(RemoteExecutionModes.WINRM.getPort());
			}
			IPUtils.validateConnection(customNode.getResolvedIP(), customNode.getLoginPort());
		} catch (Exception e) {
			logger.log(
					Level.INFO,
					"Failed to create server on " + customNode.getPrivateIP()
					+ ", connection failed on port "
					+ customNode.getLoginPort(), e);
			throw new CloudProvisioningException(e);
		} 
		return createMachineDetails(customNode, template);
	}
=======
private MachineDetails createMachine(String serverName,
			CloudTemplate template, String ip) throws CloudProvisioningException {
		final CustomNodeImpl customNode = new CustomNodeImpl(PROVIDER_ID, serverName, ip,
				template.getUsername(), template.getPassword(), serverName);

		try {
			String resolvedIP = IPUtils.resolveHostName(customNode.getPrivateIP());
			customNode.setResolvedIP(resolvedIP);
			if (template.getRemoteExecution() == RemoteExecutionModes.WINRM) {
				customNode.setLoginPort(RemoteExecutionModes.WINRM.getDefaultPort());
			}
			IPUtils.validateConnection(customNode.getResolvedIP(), customNode.getLoginPort());
		} catch (Exception e) {
			logger.log(
					Level.INFO,
					"Failed to create server on " + customNode.getPrivateIP()
					+ ", connection failed on port "
					+ customNode.getLoginPort(), e);
			throw new CloudProvisioningException(e);
		}
		return createMachineDetails(customNode, template);
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889697/fstmerge_var2_9060164280811657692

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/byon/DynamicByonProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889941/fstmerge_var1_4518317518403701930
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889941/fstmerge_base_1253719264696697994
private MachineDetails newServer(final String token, final long endTime, final CloudTemplate serverTemplate)
			throws Exception {

		final String serverId = createServer(token, serverTemplate);

		try {
			final MachineDetails md = new MachineDetails();
			// wait until complete
			waitForServerToReachStatus(md, endTime, serverId, token, MACHINE_STATUS_ACTIVE);

			// if here, we have a node with a private and public ip.
			final Node node = this.getNode(serverId, token);

			md.setPublicAddress(node.getPublicIp());
			md.setMachineId(serverId);
			md.setAgentRunning(false);
			md.setCloudifyInstalled(false);
			md.setInstallationDirectory(serverTemplate.getRemoteDirectory());

			md.setRemoteUsername(serverTemplate.getUsername());

			return md;
		} catch (final Exception e) {
			logger.log(Level.WARNING, "server: " + serverId + " failed to start up correctly. "
					+ "Shutting it down. Error was: " + e.getMessage(), e);
			try {
				terminateServer(serverId, token, endTime);
			} catch (final Exception e2) {
				logger.log(Level.WARNING,
						"Error while shutting down failed machine: " + serverId + ". Error was: " + e.getMessage()
								+ ".It may be leaking.", e);
			}
			throw e;
		}

	}
=======
private MachineDetails newServer(final String token, final long endTime, final CloudTemplate serverTemplate)
			throws Exception {

		final String serverId = createServer(token, serverTemplate);

		try {
			final MachineDetails md = new MachineDetails();
			// wait until complete
			waitForServerToReachStatus(md, endTime, serverId, token, MACHINE_STATUS_ACTIVE);

			// if here, we have a node with a private and public ip.
			final Node node = this.getNode(serverId, token);

			md.setPublicAddress(node.getPublicIp());
			md.setMachineId(serverId);
			md.setAgentRunning(false);
			md.setCloudifyInstalled(false);
			md.setInstallationDirectory(serverTemplate.getRemoteDirectory());

			md.setRemoteUsername(serverTemplate.getUsername());

			return md;
		} catch (final Exception e) {
			logger.log(Level.WARNING, "server: " + serverId + " failed to start up correctly. "
					+ "Shutting it down. Error was: " + e.getMessage(), e);
			try {
				terminateServer(serverId, token, endTime);
			} catch (final Exception e2) {
				logger.log(Level.WARNING,
						"Error while shutting down failed machine: " + serverId + ". Error was: " + e.getMessage()
								+ ".It may be leaking.", e);
			}
			throw e;
		}

	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889941/fstmerge_var2_5248861765923465355

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/openstack/OpenstackCloudDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889946/fstmerge_var1_2731899609805266715
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889946/fstmerge_base_4008597109164761838
private String createServer(final String token, final CloudTemplate serverTemplate)
			throws OpenstackException {
		final String serverName = this.serverNamePrefix + System.currentTimeMillis();
		final String securityGroup = getCustomTemplateValue(serverTemplate, OPENSTACK_SECURITYGROUP, null, false);
		final String keyPairName = getCustomTemplateValue(serverTemplate, OPENSTACK_KEY_PAIR, null, false);

		// Start the machine!
		final String json =
				"{\"server\":{ \"name\":\"" + serverName + "\",\"imageRef\":\"" + serverTemplate.getImageId()
						+ "\",\"flavorRef\":\"" + serverTemplate.getHardwareId() + "\",\"key_name\":\"" + keyPairName
						+ "\",\"security_groups\":[{\"name\":\"" + securityGroup + "\"}]}}";

		String serverBootResponse = null;
		try {
			serverBootResponse =
					service.path(this.pathPrefix + "servers").header("Content-Type", "application/json")
							.header("X-Auth-Token", token).accept(MediaType.APPLICATION_XML).post(String.class, json);
		} catch (final UniformInterfaceException e) {
			final String responseEntity = e.getResponse().getEntity(String.class);
			throw new OpenstackException(e + " Response entity: " + responseEntity, e);
		}

		try {
			// if we are here, the machine started!
			final DocumentBuilder documentBuilder = createDocumentBuilder();
			final Document doc = documentBuilder.parse(new InputSource(new StringReader(serverBootResponse)));

			final String status = xpath.evaluate("/server/@status", doc);
			if (!status.startsWith("BUILD")) {
				throw new IllegalStateException("Expected server status of BUILD(*), got: " + status);
			}

			final String serverId = xpath.evaluate("/server/@id", doc);
			return serverId;
		} catch (final XPathExpressionException e) {
			throw new OpenstackException("Failed to parse XML Response from server. Response was: "
					+ serverBootResponse + ", Error was: " + e.getMessage(), e);
		} catch (final SAXException e) {
			throw new OpenstackException("Failed to parse XML Response from server. Response was: "
					+ serverBootResponse + ", Error was: " + e.getMessage(), e);
		} catch (final IOException e) {
			throw new OpenstackException("Failed to send request to server. Response was: " + serverBootResponse
					+ ", Error was: " + e.getMessage(), e);
		}
	}
=======
private String createServer(final String token, final CloudTemplate serverTemplate)
			throws OpenstackException {
		final String serverName = this.serverNamePrefix + System.currentTimeMillis();
		final String securityGroup = getCustomTemplateValue(serverTemplate, OPENSTACK_SECURITYGROUP, null, false);
		final String keyPairName = getCustomTemplateValue(serverTemplate, OPENSTACK_KEY_PAIR, null, false);

		// Start the machine!
		final String json =
				"{\"server\":{ \"name\":\"" + serverName + "\",\"imageRef\":\"" + serverTemplate.getImageId()
						+ "\",\"flavorRef\":\"" + serverTemplate.getHardwareId() + "\",\"key_name\":\"" + keyPairName
						+ "\",\"security_groups\":[{\"name\":\"" + securityGroup + "\"}]}}";

		String serverBootResponse = null;
		try {
			serverBootResponse =
					service.path(this.pathPrefix + "servers").header("Content-Type", "application/json")
							.header("X-Auth-Token", token).accept(MediaType.APPLICATION_XML).post(String.class, json);
		} catch (final UniformInterfaceException e) {
			final String responseEntity = e.getResponse().getEntity(String.class);
			throw new OpenstackException(e + " Response entity: " + responseEntity, e);
		}

		try {
			// if we are here, the machine started!
			final DocumentBuilder documentBuilder = createDocumentBuilder();
			final Document doc = documentBuilder.parse(new InputSource(new StringReader(serverBootResponse)));

			final String status = xpath.evaluate("/server/@status", doc);
			if (!status.startsWith("BUILD")) {
				throw new IllegalStateException("Expected server status of BUILD(*), got: " + status);
			}

			final String serverId = xpath.evaluate("/server/@id", doc);
			return serverId;
		} catch (final XPathExpressionException e) {
			throw new OpenstackException("Failed to parse XML Response from server. Response was: "
					+ serverBootResponse + ", Error was: " + e.getMessage(), e);
		} catch (final SAXException e) {
			throw new OpenstackException("Failed to parse XML Response from server. Response was: "
					+ serverBootResponse + ", Error was: " + e.getMessage(), e);
		} catch (final IOException e) {
			throw new OpenstackException("Failed to send request to server. Response was: " + serverBootResponse
					+ ", Error was: " + e.getMessage(), e);
		}
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889946/fstmerge_var2_5725116393239771954

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/openstack/OpenstackCloudDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889951/fstmerge_var1_7171174238288436432
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889951/fstmerge_base_3158950549594102392
private String getCustomTemplateValue(final CloudTemplate serverTemplate, final String key,
			final String defaultValue, final boolean allowNull) {
		final String value = (String) serverTemplate.getOptions().get(key);
		if (value == null) {
			if (allowNull) {
				return defaultValue;
			}
			throw new IllegalArgumentException("Template option '" + key + "' must be set");
		}
		return value;

	}
=======
private String getCustomTemplateValue(final CloudTemplate serverTemplate, final String key,
			final String defaultValue, final boolean allowNull) {
		final String value = (String) serverTemplate.getOptions().get(key);
		if (value == null) {
			if (allowNull) {
				return defaultValue;
			}
			throw new IllegalArgumentException("Template option '" + key + "' must be set");
		}
		return value;

	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617889951/fstmerge_var2_412200554254484609

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/openstack/OpenstackCloudDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617890097/fstmerge_var1_1633603572982810205
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617890097/fstmerge_base_7346886131176018715
private MachineDetails newServer(final String token, final long endTime, final CloudTemplate serverTemplate)
			throws Exception {

		final MachineDetails md = createServer(
				token, serverTemplate);

		try {
			// wait until complete
			waitForServerToReachStatus(
					md, endTime, md.getMachineId(), token, "ACTIVE");

			md.setAgentRunning(false);
			md.setCloudifyInstalled(false);
			md.setInstallationDirectory(serverTemplate.getRemoteDirectory());

			return md;
		} catch (final Exception e) {
			logger.log(
					Level.WARNING, "server: " + md.getMachineId() + " failed to start up correctly. "
							+ "Shutting it down. Error was: " + e.getMessage(), e);
			try {
				terminateServer(
						md.getMachineId(), token, endTime);
			} catch (final Exception e2) {
				logger.log(
						Level.WARNING,
						"Error while shutting down failed machine: " + md.getMachineId()
								+ ". Error was: " + e.getMessage()
								+ ".It may be leaking.", e);
			}
			throw e;
		}

	}
=======
private MachineDetails newServer(final String token, final long endTime, final CloudTemplate serverTemplate)
			throws Exception {

		final MachineDetails md = createServer(
				token, serverTemplate);

		try {
			// wait until complete
			waitForServerToReachStatus(
					md, endTime, md.getMachineId(), token, "ACTIVE");

			md.setAgentRunning(false);
			md.setCloudifyInstalled(false);
			md.setInstallationDirectory(serverTemplate.getRemoteDirectory());

			return md;
		} catch (final Exception e) {
			logger.log(
					Level.WARNING, "server: " + md.getMachineId() + " failed to start up correctly. "
							+ "Shutting it down. Error was: " + e.getMessage(), e);
			try {
				terminateServer(
						md.getMachineId(), token, endTime);
			} catch (final Exception e2) {
				logger.log(
						Level.WARNING,
						"Error while shutting down failed machine: " + md.getMachineId()
								+ ". Error was: " + e.getMessage()
								+ ".It may be leaking.", e);
			}
			throw e;
		}

	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617890097/fstmerge_var2_8118982170707133455

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/openstack/RSCloudDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617890103/fstmerge_var1_8779786715103600269
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617890103/fstmerge_base_4929858100206083720
private MachineDetails createServer(final String token, final CloudTemplate serverTemplate)
			throws OpenstackException {
		final String serverName = this.serverNamePrefix + System.currentTimeMillis();
		// Start the machine!
		final String json =
				"{\"server\":{ \"name\":\"" + serverName + "\",\"imageId\":" + serverTemplate.getImageId()
						+ ",\"flavorId\":" + serverTemplate.getHardwareId() + "}}";

		String serverBootResponse = null;
		try {
			serverBootResponse = service.path(
					this.pathPrefix + "servers")
					.header(
							"Content-Type", "application/json").header(
							"X-Auth-Token", token).accept(
							MediaType.APPLICATION_XML).post(
							String.class, json);
		} catch (final UniformInterfaceException e) {
			final String responseEntity = e.getResponse().getEntity(String.class);
			throw new OpenstackException(e + " Response entity: " + responseEntity);
		}

		try {
			// if we are here, the machine started!
			final DocumentBuilder documentBuilder = createDocumentBuilder();
			final Document doc = documentBuilder.parse(new InputSource(new StringReader(serverBootResponse)));

			final String status = xpath.evaluate(
					"/server/@status", doc);
			if (!status.startsWith("BUILD")) {
				throw new IllegalStateException("Expected server status of BUILD(*), got: " + status);
			}

			final String serverId = xpath.evaluate(
					"/server/@id", doc);
			final String rootPassword = xpath.evaluate(
					"/server/@adminPass", doc);
			MachineDetails md = new MachineDetails();
			md.setMachineId(serverId);
			md.setRemoteUsername(serverTemplate.getUsername());
			md.setRemotePassword(rootPassword);
			return md;
		} catch (XPathExpressionException e) {
			throw new OpenstackException("Failed to parse XML Response from server. Response was: "
					+ serverBootResponse + ", Error was: " + e.getMessage(), e);
		} catch (SAXException e) {
			throw new OpenstackException("Failed to parse XML Response from server. Response was: "
					+ serverBootResponse + ", Error was: " + e.getMessage(), e);
		} catch (IOException e) {
			throw new OpenstackException("Failed to send request to server. Response was: " + serverBootResponse
					+ ", Error was: " + e.getMessage(), e);
		}
	}
=======
private MachineDetails createServer(final String token, final CloudTemplate serverTemplate)
			throws OpenstackException {
		final String serverName = this.serverNamePrefix + System.currentTimeMillis();
		// Start the machine!
		final String json =
				"{\"server\":{ \"name\":\"" + serverName + "\",\"imageId\":" + serverTemplate.getImageId()
						+ ",\"flavorId\":" + serverTemplate.getHardwareId() + "}}";

		String serverBootResponse = null;
		try {
			serverBootResponse = service.path(
					this.pathPrefix + "servers")
					.header(
							"Content-Type", "application/json").header(
							"X-Auth-Token", token).accept(
							MediaType.APPLICATION_XML).post(
							String.class, json);
		} catch (final UniformInterfaceException e) {
			final String responseEntity = e.getResponse().getEntity(String.class);
			throw new OpenstackException(e + " Response entity: " + responseEntity);
		}

		try {
			// if we are here, the machine started!
			final DocumentBuilder documentBuilder = createDocumentBuilder();
			final Document doc = documentBuilder.parse(new InputSource(new StringReader(serverBootResponse)));

			final String status = xpath.evaluate(
					"/server/@status", doc);
			if (!status.startsWith("BUILD")) {
				throw new IllegalStateException("Expected server status of BUILD(*), got: " + status);
			}

			final String serverId = xpath.evaluate(
					"/server/@id", doc);
			final String rootPassword = xpath.evaluate(
					"/server/@adminPass", doc);
			MachineDetails md = new MachineDetails();
			md.setMachineId(serverId);
			md.setRemoteUsername(serverTemplate.getUsername());
			md.setRemotePassword(rootPassword);
			return md;
		} catch (XPathExpressionException e) {
			throw new OpenstackException("Failed to parse XML Response from server. Response was: "
					+ serverBootResponse + ", Error was: " + e.getMessage(), e);
		} catch (SAXException e) {
			throw new OpenstackException("Failed to parse XML Response from server. Response was: "
					+ serverBootResponse + ", Error was: " + e.getMessage(), e);
		} catch (IOException e) {
			throw new OpenstackException("Failed to send request to server. Response was: " + serverBootResponse
					+ ", Error was: " + e.getMessage(), e);
		}
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617890103/fstmerge_var2_7770005470384228444

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/openstack/RSCloudDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617890287/fstmerge_var1_4965083041574792736
private File createEnvironmentFile(final InstallationDetails details) throws IOException {

		String remoteDirectory = details.getRemoteDir();
		if (remoteDirectory.endsWith("/")) {
			remoteDirectory = remoteDirectory.substring(0, remoteDirectory.length() - 1);
		}
		if (details.isManagement()) {
			// add the relative path to the cloud file location
			remoteDirectory = remoteDirectory + "/" + details.getRelativeLocalDir();
		}

		String authGroups = null;
		if (details.getAuthGroups() != null) {
			// authgroups should be a strongly typed object convertible into a
			// String
			authGroups = details.getAuthGroups();
		}

		final EnvironmentFileBuilder builder = new EnvironmentFileBuilder(details.getScriptLanguage())
				.exportVar(LUS_IP_ADDRESS_ENV, details.getLocator())
				.exportVar(GSA_MODE_ENV, details.isManagement() ? "lus" : "agent")
				.exportVar(CloudifyConstants.SPRING_ACTIVE_PROFILE_ENV_VAR, details.getSecurityProfile())
				.exportVar(NO_WEB_SERVICES_ENV,
						details.isNoWebServices() ? "true" : "false")
				.exportVar(
						MACHINE_IP_ADDRESS_ENV,
						details.isBindToPrivateIp() ? details.getPrivateIp()
								: details.getPublicIp())
				.exportVar(MACHINE_ZONES_ENV, details.getZones())
				.exportVarWithQuotes(CloudifyConstants.CLOUDIFY_LINK_ENV,
						details.getCloudifyUrl())
				.exportVarWithQuotes(CloudifyConstants.CLOUDIFY_OVERRIDES_LINK_ENV,
						details.getOverridesUrl())
				.exportVar(WORKING_HOME_DIRECTORY_ENV, remoteDirectory)
				.exportVar(CloudifyConstants.GIGASPACES_AUTH_GROUPS, authGroups)
				.exportVar(CloudifyConstants.GIGASPACES_AGENT_ENV_PRIVATE_IP, details.getPrivateIp())
				.exportVar(CloudifyConstants.GIGASPACES_AGENT_ENV_PUBLIC_IP, details.getPublicIp())
				.exportVar(CloudifyConstants.GIGASPACES_CLOUD_TEMPLATE_NAME, details.getTemplateName())
				.exportVar(CloudifyConstants.GIGASPACES_CLOUD_MACHINE_ID, details.getMachineId())
				.exportVar(CloudifyConstants.CLOUDIFY_CLOUD_MACHINE_ID, details.getMachineId())
				// maintain backwards compatibility for pre 2.3.0
				.exportVar(CloudifyConstants.CLOUDIFY_AGENT_ENV_PRIVATE_IP, details.getPrivateIp())
				.exportVar(CloudifyConstants.CLOUDIFY_AGENT_ENV_PUBLIC_IP, details.getPublicIp());
		
		builder.exportVar(STORAGE_VOLUME_ATTACHED, Boolean.toString(details.isStorageVolumeAttached()));
		if (details.isStorageVolumeAttached()) {
			builder.exportVar(STORAGE_FORMAT_TYPE, details.getStorageFormatType());
			builder.exportVar(STORAGE_DEVICE_NAME, details.getStorageDeviceName());
			builder.exportVar(STORAGE_MOUNT_PATH, details.getStorageMountPath());
		}

		if (details.getReservationId() != null) {
			builder.exportVar(GSA_RESERVATION_ID_ENV, details.getReservationId().toString());
		}

		if (details.isManagement()) {
			String remotePath = details.getRemoteDir();
			if (!remotePath.endsWith("/")) {
				remotePath += "/";
			}
			builder.exportVar(CLOUD_FILE, remotePath + details.getCloudFile().getName());

			logger.log(Level.FINE, "Setting ESM/GSM/LUS java options.");
			builder.exportVar("ESM_JAVA_OPTIONS", details.getEsmCommandlineArgs());
			builder.exportVar("LUS_JAVA_OPTIONS", details.getLusCommandlineArgs());
			builder.exportVar("GSM_JAVA_OPTIONS", details.getGsmCommandlineArgs());

			logger.log(Level.FINE, "Setting gsc lrmi port-range and custom rest/webui ports.");
			builder.exportVar(CloudifyConstants.GSC_LRMI_PORT_RANGE_ENVIRONMENT_VAR, details.getGscLrmiPortRange());
			builder.exportVar(CloudifyConstants.REST_PORT_ENV_VAR, details.getRestPort().toString());
			builder.exportVar(CloudifyConstants.REST_MAX_MEMORY_ENVIRONMENT_VAR, details.getRestMaxMemory());
			builder.exportVar(CloudifyConstants.WEBUI_PORT_ENV_VAR, details.getWebuiPort().toString());
			builder.exportVar(CloudifyConstants.WEBUI_MAX_MEMORY_ENVIRONMENT_VAR, details.getWebuiMaxMemory());
		}
		logger.log(Level.FINE, "Setting GSA java options.");
		builder.exportVar("GSA_JAVA_OPTIONS", details.getGsaCommandlineArgs());

		if (details.getUsername() != null) {
			builder.exportVar("USERNAME", details.getUsername());
		}
		if (details.getPassword() != null) {
			builder.exportVar("PASSWORD", details.getPassword());
		}

		builder.exportVar(CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR, details.getRemoteDir()
				+ "/" + CloudifyConstants.SECURITY_FILE_NAME);
		if (StringUtils.isNotBlank(details.getKeystorePassword())) {
			builder.exportVar(CloudifyConstants.KEYSTORE_FILE_ENV_VAR, details.getRemoteDir()
					+ "/" + CloudifyConstants.KEYSTORE_FILE_NAME);
			builder.exportVar(CloudifyConstants.KEYSTORE_PASSWORD_ENV_VAR, details.getKeystorePassword());
		}

		final Set<Entry<String, String>> entries = details.getExtraRemoteEnvironmentVariables().entrySet();
		for (final Entry<String, String> entry : entries) {
			builder.exportVar(entry.getKey(), entry.getValue());
		}

		final String fileContents = builder.toString();

		final File tempFolder = Utils.createTempFolder();
		final File tempFile = new File(tempFolder, builder.getEnvironmentFileName());
		tempFile.deleteOnExit();
		FileUtils.writeStringToFile(tempFile, fileContents);

		if (logger.isLoggable(Level.FINE)) {
			logger.fine("Created environment file with the following contents: " + fileContents);
		}
		return tempFile;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617890287/fstmerge_base_5767244485197169580
private File createEnvironmentFile(final InstallationDetails details) throws IOException {

		String remoteDirectory = details.getRemoteDir();
		if (remoteDirectory.endsWith("/")) {
			remoteDirectory = remoteDirectory.substring(0, remoteDirectory.length() - 1);
		}
		if (details.isManagement()) {
			// add the relative path to the cloud file location
			remoteDirectory = remoteDirectory + "/" + details.getRelativeLocalDir();
		}

		String authGroups = null;
		if (details.getAuthGroups() != null) {
			// authgroups should be a strongly typed object convertible into a
			// String
			authGroups = details.getAuthGroups();
		}

		final EnvironmentFileBuilder builder = new EnvironmentFileBuilder(details.getScriptLanguage())
				.exportVar(LUS_IP_ADDRESS_ENV, details.getLocator())
				.exportVar(GSA_MODE_ENV, details.isManagement() ? "lus" : "agent")
				.exportVar(CloudifyConstants.SPRING_ACTIVE_PROFILE_ENV_VAR, details.getSecurityProfile())
				.exportVar(NO_WEB_SERVICES_ENV,
						details.isNoWebServices() ? "true" : "false")
				.exportVar(
						MACHINE_IP_ADDRESS_ENV,
						details.isBindToPrivateIp() ? details.getPrivateIp()
								: details.getPublicIp())
				.exportVar(MACHINE_ZONES_ENV, details.getZones())
				.exportVarWithQuotes(CloudifyConstants.CLOUDIFY_LINK_ENV,
						details.getCloudifyUrl())
				.exportVarWithQuotes(CloudifyConstants.CLOUDIFY_OVERRIDES_LINK_ENV,
						details.getOverridesUrl())
				.exportVar(WORKING_HOME_DIRECTORY_ENV, remoteDirectory)
				.exportVar(CloudifyConstants.GIGASPACES_AUTH_GROUPS, authGroups)
				.exportVar(CloudifyConstants.GIGASPACES_AGENT_ENV_PRIVATE_IP, details.getPrivateIp())
				.exportVar(CloudifyConstants.GIGASPACES_AGENT_ENV_PUBLIC_IP, details.getPublicIp())
				.exportVar(CloudifyConstants.GIGASPACES_CLOUD_TEMPLATE_NAME, details.getTemplateName())
				.exportVar(CloudifyConstants.GIGASPACES_CLOUD_MACHINE_ID, details.getMachineId())
				.exportVar(CloudifyConstants.CLOUDIFY_CLOUD_MACHINE_ID, details.getMachineId())

				// maintain backwards compatibility for pre 2.3.0
				.exportVar(CloudifyConstants.CLOUDIFY_AGENT_ENV_PRIVATE_IP, details.getPrivateIp())
				.exportVar(CloudifyConstants.CLOUDIFY_AGENT_ENV_PUBLIC_IP, details.getPublicIp());

		if (details.getReservationId() != null) {
			builder.exportVar(GSA_RESERVATION_ID_ENV, details.getReservationId().toString());
		}

		if (details.isManagement()) {
			String remotePath = details.getRemoteDir();
			if (!remotePath.endsWith("/")) {
				remotePath += "/";
			}
			builder.exportVar(CLOUD_FILE, remotePath + details.getCloudFile().getName());

			logger.log(Level.FINE, "Setting ESM/GSM/LUS/GSA/GSC java options");

			builder.exportVar("ESM_JAVA_OPTIONS", details.getEsmCommandlineArgs());
			builder.exportVar("LUS_JAVA_OPTIONS", details.getLusCommandlineArgs());
			builder.exportVar("GSM_JAVA_OPTIONS", details.getGsmCommandlineArgs());
			builder.exportVar("GSA_JAVA_OPTIONS", details.getGsaCommandlineArgs());
			builder.exportVar("GSC_JAVA_OPTIONS", details.getGscCommandlineArgs());

			if (details.getRestPort() != null) {
				builder.exportVar(CloudifyConstants.REST_PORT_ENV_VAR, details.getRestPort().toString());
			}
			if (details.getRestMaxMemory() != null) {
				builder.exportVar(CloudifyConstants.REST_MAX_MEMORY_ENVIRONMENT_VAR, details.getRestMaxMemory());
			}
			if (details.getWebuiPort() != null) {
				builder.exportVar(CloudifyConstants.WEBUI_PORT_ENV_VAR, details.getWebuiPort().toString());
			}
			if (details.getWebuiMaxMemory() != null) {
				builder.exportVar(CloudifyConstants.WEBUI_MAX_MEMORY_ENVIRONMENT_VAR, details.getWebuiMaxMemory());
			}
		}

		if (details.getUsername() != null) {
			builder.exportVar("USERNAME", details.getUsername());
		}
		if (details.getPassword() != null) {
			builder.exportVar("PASSWORD", details.getPassword());
		}

		builder.exportVar(CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR, details.getRemoteDir()
				+ "/" + CloudifyConstants.SECURITY_FILE_NAME);
		if (StringUtils.isNotBlank(details.getKeystorePassword())) {
			builder.exportVar(CloudifyConstants.KEYSTORE_FILE_ENV_VAR, details.getRemoteDir()
					+ "/" + CloudifyConstants.KEYSTORE_FILE_NAME);
			builder.exportVar(CloudifyConstants.KEYSTORE_PASSWORD_ENV_VAR, details.getKeystorePassword());
		}

		final Set<Entry<String, String>> entries = details.getExtraRemoteEnvironmentVariables().entrySet();
		for (final Entry<String, String> entry : entries) {
			builder.exportVar(entry.getKey(), entry.getValue());
		}

		final String fileContents = builder.toString();

		final File tempFolder = Utils.createTempFolder();
		final File tempFile = new File(tempFolder, builder.getEnvironmentFileName());
		tempFile.deleteOnExit();
		FileUtils.writeStringToFile(tempFile, fileContents);

		return tempFile;
=======
private File createEnvironmentFile(final InstallationDetails details) throws IOException {

		String remoteDirectory = details.getRemoteDir();
		if (remoteDirectory.endsWith("/")) {
			remoteDirectory = remoteDirectory.substring(0, remoteDirectory.length() - 1);
		}
		if (details.isManagement()) {
			// add the relative path to the cloud file location
			remoteDirectory = remoteDirectory + "/" + details.getRelativeLocalDir();
		}

		String authGroups = null;
		if (details.getAuthGroups() != null) {
			// authgroups should be a strongly typed object convertible into a
			// String
			authGroups = details.getAuthGroups();
		}

		final String springProfiles = createSpringProfilesString(details);
		final EnvironmentFileBuilder builder = new EnvironmentFileBuilder(details.getScriptLanguage())
				.exportVar(LUS_IP_ADDRESS_ENV, details.getLocator())
				.exportVar(GSA_MODE_ENV, details.isManagement() ? "lus" : "agent")
				.exportVar(CloudifyConstants.SPRING_ACTIVE_PROFILE_ENV_VAR, springProfiles)
				.exportVar(NO_WEB_SERVICES_ENV,
						details.isNoWebServices() ? "true" : "false")
				.exportVar(
						MACHINE_IP_ADDRESS_ENV,
						details.isBindToPrivateIp() ? details.getPrivateIp()
								: details.getPublicIp())
				.exportVar(MACHINE_ZONES_ENV, details.getZones())
				.exportVarWithQuotes(CloudifyConstants.CLOUDIFY_LINK_ENV,
						details.getCloudifyUrl())
				.exportVarWithQuotes(CloudifyConstants.CLOUDIFY_OVERRIDES_LINK_ENV,
						details.getOverridesUrl())
				.exportVar(WORKING_HOME_DIRECTORY_ENV, remoteDirectory)
				.exportVar(CloudifyConstants.GIGASPACES_AUTH_GROUPS, authGroups)
				.exportVar(CloudifyConstants.GIGASPACES_AGENT_ENV_PRIVATE_IP, details.getPrivateIp())
				.exportVar(CloudifyConstants.GIGASPACES_AGENT_ENV_PUBLIC_IP, details.getPublicIp())
				.exportVar(CloudifyConstants.GIGASPACES_CLOUD_TEMPLATE_NAME, details.getTemplateName())
				.exportVar(CloudifyConstants.GIGASPACES_CLOUD_MACHINE_ID, details.getMachineId())
				.exportVar(CloudifyConstants.CLOUDIFY_CLOUD_MACHINE_ID, details.getMachineId())

				// maintain backwards compatibility for pre 2.3.0
				.exportVar(CloudifyConstants.CLOUDIFY_AGENT_ENV_PRIVATE_IP, details.getPrivateIp())
				.exportVar(CloudifyConstants.CLOUDIFY_AGENT_ENV_PUBLIC_IP, details.getPublicIp());

		if (details.getReservationId() != null) {
			builder.exportVar(GSA_RESERVATION_ID_ENV, details.getReservationId().toString());
		}

		if (details.isManagement()) {
			String remotePath = details.getRemoteDir();
			if (!remotePath.endsWith("/")) {
				remotePath += "/";
			}
			builder.exportVar(CLOUD_FILE, remotePath + details.getCloudFile().getName());

			logger.log(Level.FINE, "Setting ESM/GSM/LUS java options.");
			builder.exportVar("ESM_JAVA_OPTIONS", details.getEsmCommandlineArgs());
			builder.exportVar("LUS_JAVA_OPTIONS", details.getLusCommandlineArgs());
			builder.exportVar("GSM_JAVA_OPTIONS", details.getGsmCommandlineArgs());

			logger.log(Level.FINE, "Setting gsc lrmi port-range and custom rest/webui ports.");
			builder.exportVar(CloudifyConstants.GSC_LRMI_PORT_RANGE_ENVIRONMENT_VAR, details.getGscLrmiPortRange());
			builder.exportVar(CloudifyConstants.REST_PORT_ENV_VAR, details.getRestPort().toString());
			builder.exportVar(CloudifyConstants.REST_MAX_MEMORY_ENVIRONMENT_VAR, details.getRestMaxMemory());
			builder.exportVar(CloudifyConstants.WEBUI_PORT_ENV_VAR, details.getWebuiPort().toString());
			builder.exportVar(CloudifyConstants.WEBUI_MAX_MEMORY_ENVIRONMENT_VAR, details.getWebuiMaxMemory());
		}
		logger.log(Level.FINE, "Setting GSA java options.");
		builder.exportVar("GSA_JAVA_OPTIONS", details.getGsaCommandlineArgs());

		if (details.getUsername() != null) {
			builder.exportVar("USERNAME", details.getUsername());
		}
		if (details.getPassword() != null) {
			builder.exportVar("PASSWORD", details.getPassword());
		}

		builder.exportVar(CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR, details.getRemoteDir()
				+ "/" + CloudifyConstants.SECURITY_FILE_NAME);
		if (StringUtils.isNotBlank(details.getKeystorePassword())) {
			builder.exportVar(CloudifyConstants.KEYSTORE_FILE_ENV_VAR, details.getRemoteDir()
					+ "/" + CloudifyConstants.KEYSTORE_FILE_NAME);
			builder.exportVar(CloudifyConstants.KEYSTORE_PASSWORD_ENV_VAR, details.getKeystorePassword());
		}

		final Set<Entry<String, String>> entries = details.getExtraRemoteEnvironmentVariables().entrySet();
		for (final Entry<String, String> entry : entries) {
			builder.exportVar(entry.getKey(), entry.getValue());
		}

		final String fileContents = builder.toString();

		final File tempFolder = Utils.createTempFolder();
		final File tempFile = new File(tempFolder, builder.getEnvironmentFileName());
		tempFile.deleteOnExit();
		FileUtils.writeStringToFile(tempFile, fileContents);

		if (logger.isLoggable(Level.FINE)) {
			logger.fine("Created environment file with the following contents: " + fileContents);
		}
		return tempFile;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617890287/fstmerge_var2_648252445413974267
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/installer/AgentlessInstaller.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617890411/fstmerge_var1_4602283382885361142
@Override
	public String toString() {
		return "InstallationDetails [privateIP=" + privateIp + ", publicIP=" + publicIp + ", locator=" + locator
				+ ", connectToPrivateIP=" + connectedToPrivateIp + ", cloudifyUrl=" + cloudifyUrl
				+ ", bindToPrivateIP=" + bindToPrivateIp + ", username=" + username + ", password=***" + ", keyFile="
				+ keyFile + ", localDir=" + localDir + ", remoteDir=" + remoteDir + ", isLus=" + isManagement
				+ ", zones="
				+ zones + ", extraRemoteEnvironmentVariables = " + extraRemoteEnvironmentVariables
				+ ", authGroups=***]" + ", storageVolumeAttached=" + storageVolumeAttached
				+ ", storageFormatType=" + storageFormatType + ", storageDeviceName=" + storageDeviceName
				+ ", storageMountPath=" + storageMountPath;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617890411/fstmerge_base_7203011016612771121
@Override
	public String toString() {
		return "InstallationDetails [privateIP=" + privateIp + ", publicIP=" + publicIp + ", locator=" + locator
				+ ", connectToPrivateIP=" + connectedToPrivateIp + ", cloudifyUrl=" + cloudifyUrl
				+ ", bindToPrivateIP=" + bindToPrivateIp + ", username=" + username + ", password=***" + ", keyFile="
				+ keyFile + ", localDir=" + localDir + ", remoteDir=" + remoteDir + ", isLus=" + isManagement
				+ ", zones="
				+ zones + ", extraRemoteEnvironmentVariables = " + extraRemoteEnvironmentVariables
				+ ", authGroups=***]";
=======
@Override
	public String toString() {
		return "InstallationDetails [privateIP=" + privateIp + ", publicIP=" + publicIp + ", locator=" + locator
				+ ", connectToPrivateIP=" + connectedToPrivateIp + ", cloudifyUrl=" + cloudifyUrl
				+ ", bindToPrivateIP=" + bindToPrivateIp + ", username=" + username + ", password=***" + ", keyFile="
				+ keyFile + ", localDir=" + localDir + ", remoteDir=" + remoteDir + ", isLus=" + isManagement
				+ ", zones="
				+ zones + ", extraRemoteEnvironmentVariables = " + extraRemoteEnvironmentVariables
				+ ", authGroups=***]";
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617890411/fstmerge_var2_2308211782704329367
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/installer/InstallationDetails.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617890454/fstmerge_var1_3278602237940316575
public void setManagementOnlyFiles(final List<String> managementOnlyFiles) {

		// copy list into array - make sure to use '/' as separator char for string comparisons later on.
		this.managementOnlyFiles = new String[managementOnlyFiles.size()];
		int i = 0;
		for (String string : managementOnlyFiles) {
			this.managementOnlyFiles[i] = string.replace("\\", "/");
		}

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617890454/fstmerge_base_8463666525747847157
public void setManagementOnlyFiles(final List<String> managementOnlyFiles) {

		// copy list into array - make sure to use '/' as separator char for string comparisons later on.
		this.managementOnlyFiles = new String[managementOnlyFiles.size()];
		int i = 0;
		for (String string : managementOnlyFiles) {
			this.managementOnlyFiles[i] = string.replace("\\", "/");
		}

=======
public void setManagementOnlyFiles(final List<String> managementOnlyFiles) {

		// copy list into array - make sure to use '/' as separator char for string comparisons later on.
		this.managementOnlyFiles = new String[managementOnlyFiles.size()];
		final int i = 0;
		for (final String string : managementOnlyFiles) {
			this.managementOnlyFiles[i] = string.replace("\\", "/");
		}

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617890454/fstmerge_var2_7994721949220181615
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/installer/InstallationDetails.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617890696/fstmerge_var1_5507764838590895416
public void setInstallerConfiguration(CloudTemplateInstallerConfiguration installerConfiguration) {
		this.installerConfiguration = installerConfiguration;
	}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617890696/fstmerge_base_281479722211061509
=======
public void setInstallerConfiguration(final CloudTemplateInstallerConfiguration installerConfiguration) {
		this.installerConfiguration = installerConfiguration;
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617890696/fstmerge_var2_6708768279518106406

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/main/java/org/cloudifysource/esc/installer/InstallationDetails.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617891347/fstmerge_var1_5513835052090788750
@Test
	public void testByonWithGstring() throws IOException, DSLException, CloudProvisioningException {
		final File cloudFile = new File("src/test/resources/byon-gstring/testbyon-cloud.groovy");
		final Cloud cloud = ServiceReader.readCloud(cloudFile);

		validateCloud(cloud);

		ByonProvisioningDriver driver = new ByonProvisioningDriver();
		driver.setProvisioningDriverClassContext(new DefaultProvisioningDriverClassContext());
		driver.setConfig(cloud, cloud.getCloudCompute().getTemplates().keySet().iterator().next(), true, "test");

		Cloud modifiedCloud = driver.getCloud();

		// make sure there were no modifications to the cloud object
		validateCloud(modifiedCloud);

		ByonDeployer deployer = driver.getDeployer();

		Set<CustomNode> nodes = deployer.getAllNodesByTemplateName(cloud.getCloudCompute().
				getTemplates().keySet().iterator().next());
		Assert.assertNotNull(nodes);
		Assert.assertEquals(1, nodes.size());
		CustomNode node = nodes.iterator().next();
		Assert.assertEquals("pc-lab100", node.getPrivateIP());



||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617891347/fstmerge_base_7486507973028108738
@Test
	public void testByonWithGstring() throws IOException, DSLException, CloudProvisioningException {
		final File cloudFile = new File("src/test/resources/byon-gstring/testbyon-cloud.groovy");
		final Cloud cloud = ServiceReader.readCloud(cloudFile);

		validateCloud(cloud);

		ByonProvisioningDriver driver = new ByonProvisioningDriver();
		driver.setProvisioningDriverClassContext(new DefaultProvisioningDriverClassContext());
		driver.setConfig(cloud, cloud.getTemplates().keySet().iterator().next(), true, "test");

		Cloud modifiedCloud = driver.getCloud();

		// make sure there were no modifications to the cloud object
		validateCloud(modifiedCloud);

		ByonDeployer deployer = driver.getDeployer();

		Set<CustomNode> nodes = deployer.getAllNodesByTemplateName(cloud.getTemplates().keySet().iterator().next());
		Assert.assertNotNull(nodes);
		Assert.assertEquals(1, nodes.size());
		CustomNode node = nodes.iterator().next();
		Assert.assertEquals("pc-lab100", node.getPrivateIP());



=======
@Test
	public void testByonWithGstring() throws IOException, DSLException, CloudProvisioningException {
		final File cloudFile = new File("src/test/resources/byon-gstring/testbyon-cloud.groovy");
		final Cloud cloud = ServiceReader.readCloud(cloudFile);

		validateCloud(cloud);

		ByonProvisioningDriver driver = new ByonProvisioningDriver();
		driver.setProvisioningDriverClassContext(new DefaultProvisioningDriverClassContext());
		driver.setConfig(cloud, cloud.getTemplates().keySet().iterator().next(), true, "test");

		Cloud modifiedCloud = driver.getCloud();

		// make sure there were no modifications to the cloud object
		validateCloud(modifiedCloud);

		ByonDeployer deployer = driver.getDeployer();

		Set<CustomNode> nodes = deployer.getAllNodesByTemplateName(cloud.getTemplates().keySet().iterator().next());
		Assert.assertNotNull(nodes);
		Assert.assertEquals(1, nodes.size());
		CustomNode node = nodes.iterator().next();
		Assert.assertEquals("pc-lab100", node.getPrivateIP());



>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617891347/fstmerge_var2_2847435917320130517
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/test/java/org/cloudifysource/esc/byon/ParseByonCloudNodesTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617891352/fstmerge_var1_5499936555492203618
private void validateCloud(final Cloud cloud) {
		Assert.assertNotNull(cloud);
		Assert.assertTrue(cloud.getCloudCompute().getTemplates().size() == 1);
		ComputeTemplate template = cloud.getCloudCompute().getTemplates().values().iterator().next();
		Assert.assertNotNull(template.getCustom());

		List<Object> list = (List<Object>) template.getCustom().get("nodesList");

		Assert.assertTrue(list.size() == 1);

		Map<Object, Object> map = (Map<Object, Object>) list.iterator().next();
		Assert.assertTrue(map.containsKey("host-list"));
		final Object hostList = map.get("host-list");

		Assert.assertTrue(hostList instanceof GString);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617891352/fstmerge_base_3746079782715112145
private void validateCloud(final Cloud cloud) {
		Assert.assertNotNull(cloud);
		Assert.assertTrue(cloud.getTemplates().size() == 1);
		CloudTemplate template = cloud.getTemplates().values().iterator().next();
		Assert.assertNotNull(template.getCustom());

		List<Object> list = (List<Object>) template.getCustom().get("nodesList");

		Assert.assertTrue(list.size() == 1);

		Map<Object, Object> map = (Map<Object, Object>) list.iterator().next();
		Assert.assertTrue(map.containsKey("host-list"));
		final Object hostList = map.get("host-list");

		Assert.assertTrue(hostList instanceof GString);
=======
private void validateCloud(final Cloud cloud) {
		Assert.assertNotNull(cloud);
		Assert.assertTrue(cloud.getTemplates().size() == 1);
		CloudTemplate template = cloud.getTemplates().values().iterator().next();
		Assert.assertNotNull(template.getCustom());

		List<Object> list = (List<Object>) template.getCustom().get("nodesList");

		Assert.assertTrue(list.size() == 1);

		Map<Object, Object> map = (Map<Object, Object>) list.iterator().next();
		Assert.assertTrue(map.containsKey("host-list"));
		final Object hostList = map.get("host-list");

		Assert.assertTrue(hostList instanceof GString);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617891352/fstmerge_var2_8554841127011796538
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/test/java/org/cloudifysource/esc/byon/ParseByonCloudNodesTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617891356/fstmerge_var1_2707278341279770268
@Test
	public void test() {
		try {
			// load the cloud file
			final File cloudFile = new File(TEST_RESOURCES + "/testbyon-cloud.groovy");
			System.out.println("Trying to read cloud file " + cloudFile.getAbsolutePath());
			final Cloud cloud = ServiceReader.readCloud(cloudFile);

			System.out.println("Creating BYON deployer");
			final ByonDeployer deployer = new ByonDeployer();
			List<Map<String, String>> nodesList = null;
			final Map<String, ComputeTemplate> templatesMap = cloud.getCloudCompute().getTemplates();
			for (final String templateName : templatesMap.keySet()) {
				final Map<String, Object> customSettings = cloud.getCloudCompute().getTemplates().get(templateName).getCustom();
				Assert.assertNotNull("Custom settings not found for template " + templateName, customSettings);
				if (customSettings != null) {
					nodesList = (List<Map<String, String>>) customSettings.get(CLOUD_NODES_LIST);
				}
				Assert.assertNotNull("NodesList not found for template " + templateName, nodesList);
				if (nodesList == null) {
					System.out.println("Failed to create cloud deployer, invalid configuration, nodesList is null");
					throw new CloudProvisioningException("Failed to create BYON cloud deployer, invalid configuration");
				}
				deployer.addNodesList(templateName, templatesMap.get(templateName), nodesList);
			}

			Set<CustomNode> allNodes = deployer.getAllNodesByTemplateName("SMALL_LINUX");
			Set<CustomNode> expectedNodes = new HashSet<CustomNode>();
			// id, ip, username, credential
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test01", "0.0.0.1", "tgrid1", "tgrid1",
					"byon-test01"));
			// id, ip
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test02", "0.0.0.2", null, null, "byon-test02"));
			// idPrefix, ipList
			// expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test11", "0.0.0.3", null, null, "byon-test11"));
			// expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test12", "0.0.0.4", null, null, "byon-test12"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test11", "pc-lab39", null, null, "byon-test11"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test12", "pc-lab40", null, null, "byon-test12"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test13", "0.0.0.5", null, null, "byon-test13"));
			// id (template), ipList
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test21", "0.0.0.6", null, null, "byon-test21"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test22", "0.0.0.7", null, null, "byon-test22"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test23", "0.0.0.8", null, null, "byon-test23"));
			// id, ipRange
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test31", "0.0.0.9", null, null, "byon-test31"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test32", "0.0.0.10", null, null, "byon-test32"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test33", "0.0.0.11", null, null, "byon-test33"));
			// id, CIDR
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test41", "0.0.0.12", null, null, "byon-test41"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test42", "0.0.0.13", null, null, "byon-test42"));
			System.out.println(Arrays.toString(allNodes.toArray()));

			Assert.assertTrue("Wrong output", allNodes.size() == expectedNodes.size()
					&& expectedNodes.containsAll(allNodes) && allNodes.containsAll(expectedNodes));
		} catch (final Exception e) {
			System.out.println("Failed to create cloud deployer, exception thrown: " + e.getMessage());
			e.printStackTrace();
			throw new IllegalStateException("Failed to create cloud deployer", e);
		}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617891356/fstmerge_base_8886503670569272328
@Test
	public void test() {
		try {
			// load the cloud file
			final File cloudFile = new File(TEST_RESOURCES + "/testbyon-cloud.groovy");
			System.out.println("Trying to read cloud file " + cloudFile.getAbsolutePath());
			final Cloud cloud = ServiceReader.readCloud(cloudFile);

			System.out.println("Creating BYON deployer");
			final ByonDeployer deployer = new ByonDeployer();
			List<Map<String, String>> nodesList = null;
			final Map<String, CloudTemplate> templatesMap = cloud.getTemplates();
			for (final String templateName : templatesMap.keySet()) {
				final Map<String, Object> customSettings = cloud.getTemplates().get(templateName).getCustom();
				Assert.assertNotNull("Custom settings not found for template " + templateName, customSettings);
				if (customSettings != null) {
					nodesList = (List<Map<String, String>>) customSettings.get(CLOUD_NODES_LIST);
				}
				Assert.assertNotNull("NodesList not found for template " + templateName, nodesList);
				if (nodesList == null) {
					System.out.println("Failed to create cloud deployer, invalid configuration, nodesList is null");
					throw new CloudProvisioningException("Failed to create BYON cloud deployer, invalid configuration");
				}
				deployer.addNodesList(templateName, templatesMap.get(templateName), nodesList);
			}

			Set<CustomNode> allNodes = deployer.getAllNodesByTemplateName("SMALL_LINUX");
			Set<CustomNode> expectedNodes = new HashSet<CustomNode>();
			// id, ip, username, credential
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test01", "0.0.0.1", "tgrid1", "tgrid1",
					"byon-test01"));
			// id, ip
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test02", "0.0.0.2", null, null, "byon-test02"));
			// idPrefix, ipList
			// expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test11", "0.0.0.3", null, null, "byon-test11"));
			// expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test12", "0.0.0.4", null, null, "byon-test12"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test11", "pc-lab39", null, null, "byon-test11"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test12", "pc-lab40", null, null, "byon-test12"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test13", "0.0.0.5", null, null, "byon-test13"));
			// id (template), ipList
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test21", "0.0.0.6", null, null, "byon-test21"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test22", "0.0.0.7", null, null, "byon-test22"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test23", "0.0.0.8", null, null, "byon-test23"));
			// id, ipRange
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test31", "0.0.0.9", null, null, "byon-test31"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test32", "0.0.0.10", null, null, "byon-test32"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test33", "0.0.0.11", null, null, "byon-test33"));
			// id, CIDR
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test41", "0.0.0.12", null, null, "byon-test41"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test42", "0.0.0.13", null, null, "byon-test42"));
			System.out.println(Arrays.toString(allNodes.toArray()));

			Assert.assertTrue("Wrong output", allNodes.size() == expectedNodes.size()
					&& expectedNodes.containsAll(allNodes) && allNodes.containsAll(expectedNodes));
		} catch (final Exception e) {
			System.out.println("Failed to create cloud deployer, exception thrown: " + e.getMessage());
			e.printStackTrace();
			throw new IllegalStateException("Failed to create cloud deployer", e);
		}
=======
@Test
	public void test() {
		try {
			// load the cloud file
			final File cloudFile = new File(TEST_RESOURCES + "/testbyon-cloud.groovy");
			System.out.println("Trying to read cloud file " + cloudFile.getAbsolutePath());
			final Cloud cloud = ServiceReader.readCloud(cloudFile);

			System.out.println("Creating BYON deployer");
			final ByonDeployer deployer = new ByonDeployer();
			List<Map<String, String>> nodesList = null;
			final Map<String, CloudTemplate> templatesMap = cloud.getTemplates();
			for (final String templateName : templatesMap.keySet()) {
				final Map<String, Object> customSettings = cloud.getTemplates().get(templateName).getCustom();
				Assert.assertNotNull("Custom settings not found for template " + templateName, customSettings);
				if (customSettings != null) {
					nodesList = (List<Map<String, String>>) customSettings.get(CLOUD_NODES_LIST);
				}
				Assert.assertNotNull("NodesList not found for template " + templateName, nodesList);
				if (nodesList == null) {
					System.out.println("Failed to create cloud deployer, invalid configuration, nodesList is null");
					throw new CloudProvisioningException("Failed to create BYON cloud deployer, invalid configuration");
				}
				deployer.addNodesList(templateName, templatesMap.get(templateName), nodesList);
			}

			Set<CustomNode> allNodes = deployer.getAllNodesByTemplateName("SMALL_LINUX");
			Set<CustomNode> expectedNodes = new HashSet<CustomNode>();
			// id, ip, username, credential
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test01", "0.0.0.1", "tgrid1", "tgrid1",
					"byon-test01"));
			// id, ip
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test02", "0.0.0.2", null, null, "byon-test02"));
			// idPrefix, ipList
			// expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test11", "0.0.0.3", null, null, "byon-test11"));
			// expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test12", "0.0.0.4", null, null, "byon-test12"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test11", "pc-lab39", null, null, "byon-test11"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test12", "pc-lab40", null, null, "byon-test12"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test13", "0.0.0.5", null, null, "byon-test13"));
			// id (template), ipList
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test21", "0.0.0.6", null, null, "byon-test21"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test22", "0.0.0.7", null, null, "byon-test22"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test23", "0.0.0.8", null, null, "byon-test23"));
			// id, ipRange
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test31", "0.0.0.9", null, null, "byon-test31"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test32", "0.0.0.10", null, null, "byon-test32"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test33", "0.0.0.11", null, null, "byon-test33"));
			// id, CIDR
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test41", "0.0.0.12", null, null, "byon-test41"));
			expectedNodes.add(new CustomNodeImpl(PROVIDER, "byon-test42", "0.0.0.13", null, null, "byon-test42"));
			System.out.println(Arrays.toString(allNodes.toArray()));

			Assert.assertTrue("Wrong output", allNodes.size() == expectedNodes.size()
					&& expectedNodes.containsAll(allNodes) && allNodes.containsAll(expectedNodes));
		} catch (final Exception e) {
			System.out.println("Failed to create cloud deployer, exception thrown: " + e.getMessage());
			e.printStackTrace();
			throw new IllegalStateException("Failed to create cloud deployer", e);
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617891356/fstmerge_var2_7322624717311676782
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc/src/test/java/org/cloudifysource/esc/byon/ParseByonCloudNodesTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617891552/fstmerge_var1_7481602703365454414
public void bootstrapCloudAndWait(final String securityProfile, final String username,
			final String password, final String keystorePassword, final long timeout, final TimeUnit timeoutUnit)
			throws InstallerException, CLIException, InterruptedException {

		final long end = System.currentTimeMillis()
				+ timeoutUnit.toMillis(timeout);

		createProvisioningDriver();

		// Start the cloud machines!!!
		MachineDetails[] servers;
		try {
			servers = provisioning.startManagementMachines(timeout, timeoutUnit);
		} catch (final CloudProvisioningException e) {
			final CLIStatusException cliStatusException =
					new CLIStatusException(e, CloudifyErrorMessages.CLOUD_API_ERROR.getName(), e.getMessage());
			throw cliStatusException;
		} catch (final TimeoutException e) {
			throw new CLIException("Cloudify bootstrap on provider "
					+ this.cloud.getProvider().getProvider() + " timed-out. "
					+ "Please try to run again using the –timeout option.", e);
		}

		// from this point on - close machines if an exception is thrown (to
		// avoid leaks).
		try {

			// log details in FINE
			if (logger.isLoggable(Level.FINE)) {
				for (final MachineDetails server : servers) {
					logServerDetails(server);
				}
			}

			validateServers(servers);

			// Start the management agents and other processes
			if (servers[0].isAgentRunning()) {
				// must be using existing machines.
				throw new IllegalStateException(
						"Cloud bootstrapper found existing management machines with the same name. "
								+ "Please shut them down before continuing");
			}

			startManagememntProcesses(servers, securityProfile, keystorePassword, end);

			if (!isNoWebServices()) {
				final Integer restPort = getRestPort(cloud.getConfiguration().getComponents().getRest().getPort(),
						ShellUtils.isSecureConnection(securityProfile));
				final Integer webuiPort = getWebuiPort(cloud.getConfiguration().getComponents().getWebui().getPort(),
						ShellUtils.isSecureConnection(securityProfile));
				waitForManagementWebServices(ShellUtils.isSecureConnection(securityProfile), username, password,
						restPort, webuiPort, end, servers);
			}

		} catch (final IOException e) {
			stopManagementMachines();
			throw new CLIException("Cloudify bootstrap on provider "
					+ this.cloud.getProvider().getProvider()
					+ " failed. Reason: " + e.getMessage(), e);
		} catch (final URISyntaxException e) {
			stopManagementMachines();
			throw new CLIException("Bootstrap-cloud failed. Reason: "
					+ e.getMessage(), e);
		} catch (final TimeoutException e) {
			stopManagementMachines();
			throw new CLIException("Cloudify bootstrap on provider "
					+ this.cloud.getProvider().getProvider() + " timed-out. "
					+ "Please try to run again using the –timeout option.", e);
		} catch (final CLIException e) {
			stopManagementMachines();
			throw e;
		} catch (final InstallerException e) {
			stopManagementMachines();
			throw e;
		} catch (final InterruptedException e) {
			stopManagementMachines();
			throw e;
		}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617891552/fstmerge_base_4472139572116593515
public void bootstrapCloudAndWait(final String securityProfile, final String username,
			final String password, final String keystorePassword, final long timeout, final TimeUnit timeoutUnit)
					throws InstallerException, CLIException, InterruptedException {

		final long end = System.currentTimeMillis()
				+ timeoutUnit.toMillis(timeout);

		createProvisioningDriver();

		// Start the cloud machines!!!
		MachineDetails[] servers;
		try {
			servers = provisioning.startManagementMachines(timeout, timeoutUnit);
		} catch (final CloudProvisioningException e) {
			CLIStatusException cliStatusException = new CLIStatusException(e, 
					CloudifyErrorMessages.CLOUD_API_ERROR.getName(), e.getMessage());
			throw cliStatusException;
		} catch (final TimeoutException e) {
			throw new CLIException("Cloudify bootstrap on provider "
					+ this.cloud.getProvider().getProvider() + " timed-out. "
					+ "Please try to run again using the –timeout option.", e);
		}

		if (servers.length == 0) {
			throw new IllegalArgumentException(
					"Received zero management servers from provisioning implementation");
		}

		// from this point on - close machines if an exception is thrown (to
		// avoid leaks).
		try {

			// log details in FINE
			if (logger.isLoggable(Level.FINE)) {
				for (final MachineDetails server : servers) {
					logServerDetails(server);
				}
			}

			// Start the management agents and other processes
			if (servers[0].isAgentRunning()) {
				// must be using existing machines.
				// TODO - check if management machines are running properly. If
				// so - use them, like connect.
				throw new IllegalStateException(
						"Cloud bootstrapper found existing management machines with the same name. "
								+ "Please shut them down before continuing");
			}

			startManagememntProcesses(servers, securityProfile, keystorePassword, end);

			if (!isNoWebServices()) {
				Integer restPort = getRestPort(cloud.getConfiguration().getComponents().getRest().getPort(),
						ShellUtils.isSecureConnection(securityProfile));
				Integer webuiPort = getWebuiPort(cloud.getConfiguration().getComponents().getWebui().getPort(),
						ShellUtils.isSecureConnection(securityProfile));
				waitForManagementWebServices(ShellUtils.isSecureConnection(securityProfile), username, password,
						restPort, webuiPort, end, servers);
			}

		} catch (final IOException e) {
			stopManagementMachines();
			throw new CLIException("Cloudify bootstrap on provider "
					+ this.cloud.getProvider().getProvider()
					+ " failed. Reason: " + e.getMessage(), e);
		} catch (final URISyntaxException e) {
			stopManagementMachines();
			throw new CLIException("Bootstrap-cloud failed. Reason: "
					+ e.getMessage(), e);
		} catch (final TimeoutException e) {
			stopManagementMachines();
			throw new CLIException("Cloudify bootstrap on provider "
					+ this.cloud.getProvider().getProvider() + " timed-out. "
					+ "Please try to run again using the –timeout option.", e);
		} catch (final CLIException e) {
			stopManagementMachines();
			throw e;
		} catch (final InstallerException e) {
			stopManagementMachines();
			throw e;
		} catch (final InterruptedException e) {
			stopManagementMachines();
			throw e;
		}
=======
public void bootstrapCloudAndWait(final String securityProfile, final String username,
			final String password, final String keystorePassword, final long timeout, final TimeUnit timeoutUnit)
			throws InstallerException, CLIException, InterruptedException {

		final long end = System.currentTimeMillis()
				+ timeoutUnit.toMillis(timeout);

		createProvisioningDriver();

		// Start the cloud machines!!!
		final MachineDetails[] servers = getOrCreateManagementServers(timeout, timeoutUnit);

		// from this point on - close machines if an exception is thrown (to
		// avoid leaks).
		try {

			// log details in FINE
			if (logger.isLoggable(Level.FINE)) {
				for (final MachineDetails server : servers) {
					logServerDetails(server);
				}
			}

			validateServers(servers);

			// Start the management agents and other processes
			if (servers[0].isAgentRunning()) {
				// must be using existing machines.
				throw new IllegalStateException(
						"Cloud bootstrapper found existing management machines with the same name. "
								+ "Please shut them down before continuing");
			}

			startManagememntProcesses(servers, securityProfile, keystorePassword, end);

			if (!isNoWebServices()) {
				final Integer restPort = getRestPort(cloud.getConfiguration().getComponents().getRest().getPort(),
						ShellUtils.isSecureConnection(securityProfile));
				final Integer webuiPort = getWebuiPort(cloud.getConfiguration().getComponents().getWebui().getPort(),
						ShellUtils.isSecureConnection(securityProfile));
				waitForManagementWebServices(ShellUtils.isSecureConnection(securityProfile), username, password,
						restPort, webuiPort, end, servers);
			}

		} catch (final IOException e) {
			stopManagementMachines();
			throw new CLIException("Cloudify bootstrap on provider "
					+ this.cloud.getProvider().getProvider()
					+ " failed. Reason: " + e.getMessage(), e);
		} catch (final URISyntaxException e) {
			stopManagementMachines();
			throw new CLIException("Bootstrap-cloud failed. Reason: "
					+ e.getMessage(), e);
		} catch (final TimeoutException e) {
			stopManagementMachines();
			throw new CLIException("Cloudify bootstrap on provider "
					+ this.cloud.getProvider().getProvider() + " timed-out. "
					+ "Please try to run again using the –timeout option.", e);
		} catch (final CLIException e) {
			stopManagementMachines();
			throw e;
		} catch (final InstallerException e) {
			stopManagementMachines();
			throw e;
		} catch (final InterruptedException e) {
			stopManagementMachines();
			throw e;
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617891552/fstmerge_var2_7539033382532811945
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc-commands/src/main/java/org/cloudifysource/esc/shell/installer/CloudGridAgentBootstrapper.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617891598/fstmerge_var1_7270357181190183664
private void stopManagementMachines() {
		try {
			provisioning.stopManagementMachines();
		} catch (final CloudProvisioningException e) {
			// log a warning, don't throw an exception on this failure
			logger.warning("Failed to clean management machines after provisioning failure, reported error: "
					+ e.getMessage());
		} catch (final TimeoutException e) {
			// log a warning, don't throw an exception on this failure
			logger.warning("Failed to clean management machines after provisioning failure, the operation timed out ("
					+ e.getMessage() + ")");
		}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617891598/fstmerge_base_4700447679756759367
private void stopManagementMachines() {
		try {
			provisioning.stopManagementMachines();
		} catch (final CloudProvisioningException e) {
			// log a warning, don't throw an exception on this failure
			logger.warning("Failed to clean management machines after provisioning failure, reported error: "
					+ e.getMessage());
		} catch (final TimeoutException e) {
			// log a warning, don't throw an exception on this failure
			logger.warning("Failed to clean management machines after provisioning failure, the operation timed out ("
					+ e.getMessage() + ")");
		}
=======
private void stopManagementMachines() {
		if (this.useExistingManagers || this.existingManagersFile != null) {
			// if we did not start the machines, we will not close them.
			return;
		}
		try {
			provisioning.stopManagementMachines();
		} catch (final CloudProvisioningException e) {
			// log a warning, don't throw an exception on this failure
			logger.warning("Failed to clean management machines after provisioning failure, reported error: "
					+ e.getMessage());
		} catch (final TimeoutException e) {
			// log a warning, don't throw an exception on this failure
			logger.warning("Failed to clean management machines after provisioning failure, the operation timed out ("
					+ e.getMessage() + ")");
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617891598/fstmerge_var2_6130337050740197297
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc-commands/src/main/java/org/cloudifysource/esc/shell/installer/CloudGridAgentBootstrapper.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617891623/fstmerge_var1_7530644781117262794
private MachineDetails[] startManagememntProcesses(final MachineDetails[] machines, final String securityProfile,
			final String keystorePassword, final long endTime) throws InterruptedException, TimeoutException,
			InstallerException, IOException {

		final AgentlessInstaller installer = new AgentlessInstaller();
		installer.addListener(new CliAgentlessInstallerListener(this.verbose));

		// Update the logging level of jsch used by the AgentlessInstaller
		Logger.getLogger(AgentlessInstaller.SSH_LOGGER_NAME).setLevel(
				Level.parse(cloud.getProvider().getSshLoggingLevel()));

		final ComputeTemplate template = cloud.getCloudCompute().getTemplates().get(
				cloud.getConfiguration().getManagementMachineTemplate());

		// fixConfigRelativePaths(cloud, template);

		final int numOfManagementMachines = machines.length;

		final InstallationDetails[] installations = createInstallationDetails(numOfManagementMachines, machines,
				template, securityProfile, keystorePassword);
		// only one machine should try and deploy the WebUI and Rest Admin unless
		// noWebServices is true
		int i = isNoWebServices() ? 0 : 1;
		for (; i < installations.length; i++) {
			installations[i].setNoWebServices(true);
		}

		final String lookup = createLocatorsString(installations);
		for (final InstallationDetails detail : installations) {
			detail.setLocator(lookup);
		}

		// executes the agentless installer on all of the machines,
		// asynchronously
		installOnMachines(endTime, installer, numOfManagementMachines,
				installations);

		return machines;

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617891623/fstmerge_base_1363017263353267166
private MachineDetails[] startManagememntProcesses(final MachineDetails[] machines, final String securityProfile,
			final String keystorePassword, final long endTime) throws InterruptedException, TimeoutException,
			InstallerException, IOException {

		final AgentlessInstaller installer = new AgentlessInstaller();
		installer.addListener(new CliAgentlessInstallerListener(this.verbose));

		// Update the logging level of jsch used by the AgentlessInstaller
		Logger.getLogger(AgentlessInstaller.SSH_LOGGER_NAME).setLevel(
				Level.parse(cloud.getProvider().getSshLoggingLevel()));

		final CloudTemplate template = cloud.getTemplates().get(
				cloud.getConfiguration().getManagementMachineTemplate());

		// fixConfigRelativePaths(cloud, template);

		final int numOfManagementMachines = machines.length;

		final InstallationDetails[] installations = createInstallationDetails(numOfManagementMachines, machines,
				template, securityProfile, keystorePassword);
		// only one machine should try and deploy the WebUI and Rest Admin unless
		// noWebServices is true
		int i = isNoWebServices() ? 0 : 1;
		for (; i < installations.length; i++) {
			installations[i].setNoWebServices(true);
		}

		final String lookup = createLocatorsString(installations);
		for (final InstallationDetails detail : installations) {
			detail.setLocator(lookup);
		}

		// executes the agentless installer on all of the machines,
		// asynchronously
		installOnMachines(endTime, installer, numOfManagementMachines,
				installations);

		return machines;

=======
private MachineDetails[] startManagememntProcesses(final MachineDetails[] machines, final String securityProfile,
			final String keystorePassword, final long endTime) throws InterruptedException, TimeoutException,
			InstallerException, IOException {

		final AgentlessInstaller installer = new AgentlessInstaller();
		installer.addListener(new CliAgentlessInstallerListener(this.verbose));

		// Update the logging level of jsch used by the AgentlessInstaller
		Logger.getLogger(AgentlessInstaller.SSH_LOGGER_NAME).setLevel(
				Level.parse(cloud.getProvider().getSshLoggingLevel()));

		final CloudTemplate template = cloud.getTemplates().get(
				cloud.getConfiguration().getManagementMachineTemplate());

		// fixConfigRelativePaths(cloud, template);

		final int numOfManagementMachines = machines.length;

		final InstallationDetails[] installations = createInstallationDetails(numOfManagementMachines, machines,
				template, securityProfile, keystorePassword);
		// only one machine should try and deploy the WebUI and Rest Admin unless
		// noWebServices is true
		int i = isNoWebServices() ? 0 : 1;
		for (; i < installations.length; i++) {
			installations[i].setNoWebServices(true);
		}

		final String lookup = createLocatorsString(installations);
		for (final InstallationDetails detail : installations) {
			detail.setLocator(lookup);
		}

		// executes the agentless installer on all of the machines,
		// asynchronously
		installOnMachines(endTime, installer, numOfManagementMachines,
				installations);

		return machines;

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617891623/fstmerge_var2_1190458061497116543
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc-commands/src/main/java/org/cloudifysource/esc/shell/installer/CloudGridAgentBootstrapper.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617891639/fstmerge_var1_3244142016418622502
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617891639/fstmerge_base_988288628618160812
private InstallationDetails[] createInstallationDetails(final int numOfManagementMachines,
			final MachineDetails[] machineDetails, final CloudTemplate template, final String securityProfile,
			final String keystorePassword) throws FileNotFoundException {
		final InstallationDetails[] details = new InstallationDetails[numOfManagementMachines];

		final GSAReservationId reservationId = null;
		final String managementAuthGroups = null;

		for (int i = 0; i < details.length; i++) {
			final ExactZonesConfig zones = new ExactZonesConfigurer().addZone(
					MANAGEMENT_GSA_ZONE).create();
			details[i] = Utils.createInstallationDetails(machineDetails[i], cloud, template, zones, null, null, true,
					this.cloudFile, reservationId, cloud.getConfiguration().getManagementMachineTemplate(),
					securityProfile, keystorePassword, managementAuthGroups);
		}

		return details;
	}
=======
private InstallationDetails[] createInstallationDetails(final int numOfManagementMachines,
			final MachineDetails[] machineDetails, final CloudTemplate template, final String securityProfile,
			final String keystorePassword) throws FileNotFoundException {
		final InstallationDetails[] details = new InstallationDetails[numOfManagementMachines];

		final GSAReservationId reservationId = null;
		final String managementAuthGroups = null;

		for (int i = 0; i < details.length; i++) {
			final ExactZonesConfig zones = new ExactZonesConfigurer().addZone(
					MANAGEMENT_GSA_ZONE).create();
			details[i] = Utils.createInstallationDetails(machineDetails[i], cloud, template, zones, null, null, true,
					this.cloudFile, reservationId, cloud.getConfiguration().getManagementMachineTemplate(),
					securityProfile, keystorePassword, managementAuthGroups);
		}

		return details;
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617891639/fstmerge_var2_3394109373541702125

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/esc-commands/src/main/java/org/cloudifysource/esc/shell/installer/CloudGridAgentBootstrapper.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ private final String BUILD_NUM = "3990-146"; ##FSTMerge## private final String BUILD_NUM = "3986-81"; ##FSTMerge## private final String BUILD_NUM = "3987-46";
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/cloudify/package_build/gigaspaces/src/java/com/j_spaces/kernel/CloudifyVersion.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617892076/fstmerge_var1_8498352630189297049
Map<String, ComputeTemplate> listTemplates() 
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617892076/fstmerge_base_4999731089306976364
Map<String, CloudTemplate> listTemplates() 
=======
Map<String, CloudTemplate> listTemplates()
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617892076/fstmerge_var2_384333603514661291
			throws CLIException;

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/AdminFacade.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617892080/fstmerge_var1_7417287228024406192
ComputeTemplate getTemplate(final String templateName) 
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617892080/fstmerge_base_2427866620462411997
CloudTemplate getTemplate(final String templateName) 
=======
CloudTemplate getTemplate(final String templateName)
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617892080/fstmerge_var2_1287160648013915859
			throws CLIException;

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/AdminFacade.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ private static final String SPRING_SECURITY_CONFIG_FILE = 
			System.getenv(CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR); ##FSTMerge## private static final String SPRING_SECURITY_CONFIG_FILE = 
			System.getenv(CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR); ##FSTMerge## private static final String SPRING_SECURITY_CONFIG_FILE =
			System.getenv(CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR);
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/commands/StartManagement.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ @Option(required = false, description = "The password for a secure connection to the rest server", name = "-password")
    private String password; ##FSTMerge## @Option(required = false, description = "The password for a secure connection to the rest server", name = "-password")
    private String password; ##FSTMerge## @Option(required = false, description = "The password for a secure connection to the rest server",
    		name = "-password")
    private String password;
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/commands/StartManagement.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617892781/fstmerge_var1_2542449129657355775
@Override
	protected Object doExecute()
			throws Exception {
		new CloudifyLicenseVerifier().verifyLicense();

		if (getTimeoutInMinutes() < 0) {
			throw new CLIException("-timeout cannot be negative");
		}
		
		if (SPRING_SECURITY_CONFIG_FILE == null) {
			throw new IllegalStateException("Environment variable " 
					+ CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR + " cannot be null");
		}
		if (securityProfile == null) {
			throw new IllegalStateException("Environment variable " + CloudifyConstants.SPRING_ACTIVE_PROFILE_ENV_VAR
					+ " cannot be null");
		}
		if (CloudifyConstants.SPRING_PROFILE_SECURE.equals(securityProfile)) {
			if (KEYSTORE_FILE == null) {
				throw new IllegalStateException("Environment variable " + CloudifyConstants.KEYSTORE_FILE_ENV_VAR 
						+ " cannot be null");				
			}
			if (KEYSTORE_PASSWORD == null) {
				throw new IllegalStateException("Environment variable " + CloudifyConstants.KEYSTORE_PASSWORD_ENV_VAR 
						+ " cannot be null");
			}
		}

		setSecurityMode();

		final LocalhostGridAgentBootstrapper installer = new LocalhostGridAgentBootstrapper();
		installer.setVerbose(verbose);
		installer.setLookupGroups(lookupGroups);
		installer.setLookupLocators(lookupLocators);
		installer.setNicAddress(nicAddress);
		installer.setProgressInSeconds(DEFAULT_PROGRESS_INTERVAL_SECONDS);
		installer.setAdminFacade((AdminFacade) session.get(Constants.ADMIN_FACADE));
		installer.setNoWebServices(noWebServices);
		installer.setNoManagementSpace(noManagementSpace);
		installer.setNotHighlyAvailableManagementSpace(isNotHAManagementSpace());
		installer.setAutoShutdown(autoShutdown);
		installer.setWaitForWebui(true);
		installer.setCloudFilePath(cloudFileName);

		installer.startManagementOnLocalhostAndWait(securityProfile, SPRING_SECURITY_CONFIG_FILE, username, password,
				KEYSTORE_FILE, KEYSTORE_PASSWORD, getTimeoutInMinutes(), TimeUnit.MINUTES);
		return "Management started successfully. Use the shutdown-management command to shutdown"
				+ " management processes running on local machine.";
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617892781/fstmerge_base_650260633638261048
@Override
	protected Object doExecute()
			throws Exception {
		new CloudifyLicenseVerifier().verifyLicense();

		if (getTimeoutInMinutes() < 0) {
			throw new CLIException("-timeout cannot be negative");
		}
		
		if (SPRING_SECURITY_CONFIG_FILE == null) {
			throw new IllegalStateException("Environment variable " 
					+ CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR + " cannot be null");
		}
		if (securityProfile == null) {
			throw new IllegalStateException("Environment variable " + CloudifyConstants.SPRING_ACTIVE_PROFILE_ENV_VAR
					+ " cannot be null");
		}
		if (CloudifyConstants.SPRING_PROFILE_SECURE.equals(securityProfile)) {
			if (KEYSTORE_FILE == null) {
				throw new IllegalStateException("Environment variable " + CloudifyConstants.KEYSTORE_FILE_ENV_VAR 
						+ " cannot be null");				
			}
			if (KEYSTORE_PASSWORD == null) {
				throw new IllegalStateException("Environment variable " + CloudifyConstants.KEYSTORE_PASSWORD_ENV_VAR 
						+ " cannot be null");
			}
		}

		setSecurityMode();

		final LocalhostGridAgentBootstrapper installer = new LocalhostGridAgentBootstrapper();
		installer.setVerbose(verbose);
		installer.setLookupGroups(lookupGroups);
		installer.setLookupLocators(lookupLocators);
		installer.setNicAddress(nicAddress);
		installer.setProgressInSeconds(DEFAULT_PROGRESS_INTERVAL_SECONDS);
		installer.setAdminFacade((AdminFacade) session.get(Constants.ADMIN_FACADE));
		installer.setNoWebServices(noWebServices);
		installer.setNoManagementSpace(noManagementSpace);
		installer.setNotHighlyAvailableManagementSpace(isNotHAManagementSpace());
		installer.setAutoShutdown(autoShutdown);
		installer.setWaitForWebui(true);
		installer.setCloudFilePath(cloudFileName);

		installer.startManagementOnLocalhostAndWait(securityProfile, SPRING_SECURITY_CONFIG_FILE, username, password,
				KEYSTORE_FILE, KEYSTORE_PASSWORD, getTimeoutInMinutes(), TimeUnit.MINUTES);
		return "Management started successfully. Use the shutdown-management command to shutdown"
				+ " management processes running on local machine.";
=======
@Override
	protected Object doExecute()
			throws Exception {
		new CloudifyLicenseVerifier().verifyLicense();

		if (getTimeoutInMinutes() < 0) {
			throw new CLIException("-timeout cannot be negative");
		}

		if (SPRING_SECURITY_CONFIG_FILE == null) {
			throw new IllegalStateException("Environment variable "
					+ CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR + " cannot be null");
		}
		if (securityProfile == null) {
			throw new IllegalStateException("Environment variable " + CloudifyConstants.SPRING_ACTIVE_PROFILE_ENV_VAR
					+ " cannot be null");
		}
		if (CloudifyConstants.SPRING_PROFILE_SECURE.equals(securityProfile)) {
			if (KEYSTORE_FILE == null) {
				throw new IllegalStateException("Environment variable " + CloudifyConstants.KEYSTORE_FILE_ENV_VAR
						+ " cannot be null");
			}
			if (KEYSTORE_PASSWORD == null) {
				throw new IllegalStateException("Environment variable " + CloudifyConstants.KEYSTORE_PASSWORD_ENV_VAR
						+ " cannot be null");
			}
		}

		setSecurityMode();

		final LocalhostGridAgentBootstrapper installer = new LocalhostGridAgentBootstrapper();
		installer.setVerbose(verbose);
		installer.setLookupGroups(lookupGroups);
		installer.setLookupLocators(lookupLocators);
		installer.setNicAddress(nicAddress);
		installer.setProgressInSeconds(DEFAULT_PROGRESS_INTERVAL_SECONDS);
		installer.setAdminFacade((AdminFacade) session.get(Constants.ADMIN_FACADE));
		installer.setNoWebServices(noWebServices);
		installer.setNoManagementSpace(noManagementSpace);
		installer.setNotHighlyAvailableManagementSpace(isNotHAManagementSpace());
		installer.setAutoShutdown(autoShutdown);
		installer.setWaitForWebui(true);
		installer.setCloudFilePath(cloudFileName);

		installer.startManagementOnLocalhostAndWait(securityProfile, SPRING_SECURITY_CONFIG_FILE, username, password,
				KEYSTORE_FILE, KEYSTORE_PASSWORD, getTimeoutInMinutes(), TimeUnit.MINUTES);
		return "Management started successfully. Use the shutdown-management command to shutdown"
				+ " management processes running on local machine.";
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617892781/fstmerge_var2_5642516604570009114
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/commands/StartManagement.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617892787/fstmerge_var1_977249071525875879
private boolean isNotHAManagementSpace() throws IOException, DSLException {
		if (cloudFileName != null && !cloudFileName.trim().isEmpty()) {
			File cloudFile = new File(cloudFileName);
			
			final Cloud cloud = ServiceReader.readCloud(cloudFile);
			if (cloud != null) {
				if (cloud.getProvider() != null) {
					final int numberOfManagementMachines = cloud.getProvider().getNumberOfManagementMachines();
					return numberOfManagementMachines < 2;
				}
			}

		}
		return true;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617892787/fstmerge_base_8833922602694845955
private boolean isNotHAManagementSpace() throws IOException, DSLException {
		if (cloudFileName != null && !cloudFileName.trim().isEmpty()) {
			File cloudFile = new File(cloudFileName);
			
			final Cloud cloud = ServiceReader.readCloud(cloudFile);
			if (cloud != null) {
				if (cloud.getProvider() != null) {
					final int numberOfManagementMachines = cloud.getProvider().getNumberOfManagementMachines();
					return numberOfManagementMachines < 2;
				}
			}

		}
		return true;
=======
private boolean isNotHAManagementSpace() throws IOException, DSLException {
		if (cloudFileName != null && !cloudFileName.trim().isEmpty()) {
			File cloudFile = new File(cloudFileName);

			final Cloud cloud = ServiceReader.readCloud(cloudFile);
			if (cloud != null) {
				if (cloud.getProvider() != null) {
					final int numberOfManagementMachines = cloud.getProvider().getNumberOfManagementMachines();
					return numberOfManagementMachines < 2;
				}
			}

		}
		return true;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617892787/fstmerge_var2_3904115007202677229
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/commands/StartManagement.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617892810/fstmerge_var1_8449886622114858566
private void setSecurityMode() throws IOException {
		
		if (StringUtils.isNotBlank(username) && StringUtils.isBlank(password)) {
			throw new IllegalArgumentException("Password is missing or empty");
		}
		
		if (StringUtils.isBlank(username) && StringUtils.isNotBlank(password)) {
			throw new IllegalArgumentException("Username is missing or empty");
		}
		
		//no need to copy security config file / keystore file since we're on the mgmt server.
		if (StringUtils.isBlank(securityProfile)) {
			// TODO [noak] : log this, warning?
			securityProfile = CloudifyConstants.SPRING_PROFILE_NON_SECURE;
		}

		// The security files are expected to be in <cloudify home>\config\security
		if (securityProfile.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_SECURE_NO_SSL)
				|| securityProfile.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_SECURE)) {
			//verify we have the security config file at place
			File securityConfigFile = new File(SPRING_SECURITY_CONFIG_FILE);
			if (!securityConfigFile.isFile()) {
				throw new IllegalArgumentException("Security configuration file not found on management server at the "
						+ "expected location: " + securityConfigFile.getCanonicalPath());
			}
		}
		
		if (securityProfile.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_SECURE)) {
			//verify we have the keystore file at place
			File keystoreFile = new File(KEYSTORE_FILE);
			if (!keystoreFile.isFile()) {
				throw new IllegalArgumentException("Keystore file not found on management server at the expected "
						+ "location: " + keystoreFile.getCanonicalPath());
			}
		}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617892810/fstmerge_base_6641238473217474696
private void setSecurityMode() throws IOException {
		
		if (StringUtils.isNotBlank(username) && StringUtils.isBlank(password)) {
			throw new IllegalArgumentException("Password is missing or empty");
		}
		
		if (StringUtils.isBlank(username) && StringUtils.isNotBlank(password)) {
			throw new IllegalArgumentException("Username is missing or empty");
		}
		
		//no need to copy security config file / keystore file since we're on the mgmt server.
		if (StringUtils.isBlank(securityProfile)) {
			// TODO [noak] : log this, warning?
			securityProfile = CloudifyConstants.SPRING_PROFILE_NON_SECURE;
		}

		// The security files are expected to be in <cloudify home>\config\security
		if (securityProfile.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_SECURE_NO_SSL)
				|| securityProfile.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_SECURE)) {
			//verify we have the security config file at place
			File securityConfigFile = new File(SPRING_SECURITY_CONFIG_FILE);
			if (!securityConfigFile.isFile()) {
				throw new IllegalArgumentException("Security configuration file not found on management server at the "
						+ "expected location: " + securityConfigFile.getCanonicalPath());
			}
		}
		
		if (securityProfile.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_SECURE)) {
			//verify we have the keystore file at place
			File keystoreFile = new File(KEYSTORE_FILE);
			if (!keystoreFile.isFile()) {
				throw new IllegalArgumentException("Keystore file not found on management server at the expected "
						+ "location: " + keystoreFile.getCanonicalPath());
			}
		}
=======
private void setSecurityMode() throws IOException {

		if (StringUtils.isNotBlank(username) && StringUtils.isBlank(password)) {
			throw new IllegalArgumentException("Password is missing or empty");
		}

		if (StringUtils.isBlank(username) && StringUtils.isNotBlank(password)) {
			throw new IllegalArgumentException("Username is missing or empty");
		}

		//no need to copy security config file / keystore file since we're on the mgmt server.
		if (StringUtils.isBlank(securityProfile)) {
			// TODO [noak] : log this, warning?
			securityProfile = CloudifyConstants.SPRING_PROFILE_NON_SECURE;
		}

		// The security files are expected to be in <cloudify home>\config\security
		if (securityProfile.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_SECURE_NO_SSL)
				|| securityProfile.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_SECURE)) {
			//verify we have the security config file at place
			File securityConfigFile = new File(SPRING_SECURITY_CONFIG_FILE);
			if (!securityConfigFile.isFile()) {
				throw new IllegalArgumentException("Security configuration file not found on management server at the "
						+ "expected location: " + securityConfigFile.getCanonicalPath());
			}
		}

		if (securityProfile.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_SECURE)) {
			//verify we have the keystore file at place
			File keystoreFile = new File(KEYSTORE_FILE);
			if (!keystoreFile.isFile()) {
				throw new IllegalArgumentException("Keystore file not found on management server at the expected "
						+ "location: " + keystoreFile.getCanonicalPath());
			}
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617892810/fstmerge_var2_8587401529532842763
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/commands/StartManagement.java
Conflict type: LineBasedMCFd
Conflict body: 
@SuppressWarnings("unchecked")
	@Override
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893040/fstmerge_var1_9191293944899457577
	public Map<String, ComputeTemplate> listTemplates() 
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893040/fstmerge_base_1187979899757761213
	public Map<String, CloudTemplate> listTemplates() 
=======
	public Map<String, CloudTemplate> listTemplates()
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893040/fstmerge_var2_5837032789259202179
			throws CLIStatusException {
		final String url = SERVICE_CONTROLLER_URL + "templates";
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893040/fstmerge_var1_9191293944899457577
		Map<String, ComputeTemplate> response = new HashMap<String, ComputeTemplate>();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893040/fstmerge_base_1187979899757761213
		Map<String, CloudTemplate> response = new HashMap<String, CloudTemplate>();
=======
		final Map<String, CloudTemplate> response = new HashMap<String, CloudTemplate>();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893040/fstmerge_var2_5837032789259202179
		try {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893040/fstmerge_var1_9191293944899457577
			Map<String, Object> responseMap = (Map<String, Object>) client.get(url);
			for (Entry<String, Object> entry : responseMap.entrySet()) {
				ObjectMapper mapper = new ObjectMapper();
				ComputeTemplate convertValue = mapper.convertValue(entry.getValue(), ComputeTemplate.class);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893040/fstmerge_base_1187979899757761213
			Map<String, Object> responseMap = (Map<String, Object>) client.get(url);
			for (Entry<String, Object> entry : responseMap.entrySet()) {
				ObjectMapper mapper = new ObjectMapper();
				CloudTemplate convertValue = mapper.convertValue(entry.getValue(), CloudTemplate.class);
=======
			final Map<String, Object> responseMap = (Map<String, Object>) client.get(url);
			for (final Entry<String, Object> entry : responseMap.entrySet()) {
				final ObjectMapper mapper = new ObjectMapper();
				final CloudTemplate convertValue = mapper.convertValue(entry.getValue(), CloudTemplate.class);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893040/fstmerge_var2_5837032789259202179
				response.put(entry.getKey(), convertValue);
			}
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893040/fstmerge_base_1187979899757761213
		} catch (ErrorStatusException e) {
=======
		} catch (final ErrorStatusException e) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893040/fstmerge_var2_5837032789259202179
			throw new CLIStatusException(e, e.getReasonCode(), e.getArgs());
		}
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893040/fstmerge_base_1187979899757761213
		return response;		
=======
		return response;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893040/fstmerge_var2_5837032789259202179
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/rest/RestAdminFacade.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893044/fstmerge_var1_8998203485422566175
	public ComputeTemplate getTemplate(final String templateName) 
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893044/fstmerge_base_3140924673424635944
	public CloudTemplate getTemplate(final String templateName) 
=======
	public CloudTemplate getTemplate(final String templateName)
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893044/fstmerge_var2_937890931285549883
			throws CLIStatusException {
		final String url = SERVICE_CONTROLLER_URL + "templates/" + templateName;
		ComputeTemplate response;
		try {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893044/fstmerge_base_3140924673424635944
			Object result = client.get(url);
=======
			final Object result = client.get(url);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893044/fstmerge_var2_937890931285549883

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893044/fstmerge_var1_8998203485422566175
			final ObjectMapper mapper = new ObjectMapper();
			response = mapper.convertValue(result, ComputeTemplate.class);

		} catch (final ErrorStatusException e) {
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893044/fstmerge_base_3140924673424635944
			ObjectMapper mapper = new ObjectMapper();
			response = mapper.convertValue(result, CloudTemplate.class);
			
		} catch (ErrorStatusException e) {
=======
			final ObjectMapper mapper = new ObjectMapper();
			response = mapper.convertValue(result, CloudTemplate.class);

		} catch (final ErrorStatusException e) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893044/fstmerge_var2_937890931285549883
			throw new CLIStatusException(e, e.getReasonCode(), e.getArgs());
		}
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893044/fstmerge_base_3140924673424635944
		return response;	
=======
		return response;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893044/fstmerge_var2_937890931285549883
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/rest/RestAdminFacade.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893131/fstmerge_var1_2691279358386047845
@Override
	public void install() throws ProcessingUnitAlreadyDeployedException, CLIException {

		if (agentZone == null) {
			throw new IllegalStateException("Management services must be installed on management zone");
		}

		final ElasticSpaceDeployment deployment = new ElasticSpaceDeployment(serviceName)
				.memoryCapacityPerContainer(memoryInMB, MemoryUnit.MEGABYTES).highlyAvailable(highlyAvailable)
				.numberOfPartitions(1)
				// All PUs on this role share the same machine. Machines
				// are identified by zone.
				.sharedMachineProvisioning(
						"public",
						new DiscoveredMachineProvisioningConfigurer().addGridServiceAgentZone(agentZone)
								.reservedMemoryCapacityPerMachine(RESERVED_MEMORY_IN_MB, MemoryUnit.MEGABYTES)
								.create())
				// Eager scale (1 container per machine per PU)
				.scale(new EagerScaleConfigurer().atMostOneContainerPerMachine().create())
				.addCommandLineArgument(this.lrmiCommandLineArgument);

		for (final Entry<Object, Object> prop : getContextProperties().entrySet()) {
			deployment.addContextProperty(prop.getKey().toString(), prop.getValue().toString());
		}

		for (final String requiredPUName : dependencies) {
			deployment.addDependencies(new ProcessingUnitDeploymentDependenciesConfigurer()
					.dependsOnMinimumNumberOfDeployedInstancesPerPartition(requiredPUName, 1).create());
		}
		// The gsc java options define the lrmi port range and memory size if not defined.

		getGridServiceManager().deploy(deployment);

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893131/fstmerge_base_6374907431653659386
@Override
	public void install() throws ProcessingUnitAlreadyDeployedException, CLIException {

		if (agentZone == null) {
			throw new IllegalStateException("Management services must be installed on management zone");
		}

		final ElasticSpaceDeployment deployment = new ElasticSpaceDeployment(serviceName)
				.memoryCapacityPerContainer(memoryInMB, MemoryUnit.MEGABYTES).highlyAvailable(highlyAvailable)
				.numberOfPartitions(1)
				// All PUs on this role share the same machine. Machines
				// are identified by zone.
				.sharedMachineProvisioning(
						"public",
						new DiscoveredMachineProvisioningConfigurer().addGridServiceAgentZone(agentZone)
								.reservedMemoryCapacityPerMachine(RESERVED_MEMORY_IN_MB, MemoryUnit.MEGABYTES)
								.create())
				// Eager scale (1 container per machine per PU)
				.scale(new EagerScaleConfigurer().atMostOneContainerPerMachine().create());

		for (final Entry<Object, Object> prop : getContextProperties().entrySet()) {
			deployment.addContextProperty(prop.getKey().toString(), prop.getValue().toString());
		}

		for (final String requiredPUName : dependencies) {
			deployment.addDependencies(new ProcessingUnitDeploymentDependenciesConfigurer()
					.dependsOnMinimumNumberOfDeployedInstancesPerPartition(requiredPUName, 1).create());
		}

		getGridServiceManager().deploy(deployment);

=======
@Override
	public void install() throws ProcessingUnitAlreadyDeployedException, CLIException {

		if (agentZone == null) {
			throw new IllegalStateException("Management services must be installed on management zone");
		}

		final File puFile = getManagementSpacePUFile();

		// final ElasticSpaceDeployment deployment = new ElasticSpaceDeployment(serviceName)
		final ElasticStatefulProcessingUnitDeployment deployment =
				new ElasticStatefulProcessingUnitDeployment(puFile).name(serviceName)
						.memoryCapacityPerContainer(memoryInMB, MemoryUnit.MEGABYTES).highlyAvailable(highlyAvailable)
						.numberOfPartitions(1)
						// All PUs on this role share the same machine. Machines
						// are identified by zone.
						.sharedMachineProvisioning(
								"public",
								new DiscoveredMachineProvisioningConfigurer().addGridServiceAgentZone(agentZone)
										.reservedMemoryCapacityPerMachine(RESERVED_MEMORY_IN_MB, MemoryUnit.MEGABYTES)
										.create())
						// Eager scale (1 container per machine per PU)
						.scale(new EagerScaleConfigurer().atMostOneContainerPerMachine().create())
						.addCommandLineArgument(this.lrmiCommandLineArgument);

		if (this.persistentStoragePath != null) {
			deployment.addCommandLineArgument("-Dspring.profiles.active=persistent");
		}

		for (final Entry<Object, Object> prop : getContextProperties().entrySet()) {
			deployment.addContextProperty(prop.getKey().toString(), prop.getValue().toString());
		}

		for (final String requiredPUName : dependencies) {
			deployment.addDependencies(new ProcessingUnitDeploymentDependenciesConfigurer()
					.dependsOnMinimumNumberOfDeployedInstancesPerPartition(requiredPUName, 1).create());
		}
		// The gsc java options define the lrmi port range and memory size if not defined.

		getGridServiceManager().deploy(deployment);

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893131/fstmerge_var2_3297072234251874948
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementSpaceServiceInstaller.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893135/fstmerge_var1_4572481507251758038
public void installOnLocalCloud() 
			throws ProcessingUnitAlreadyDeployedException, CLIException {

		if (agentZone == null) {
			throw new IllegalStateException("Management services must be installed on management zone");
		}

		SpaceDeployment deployment = new SpaceDeployment(serviceName).addZone(serviceName);

		for (final Entry<Object, Object> prop : getContextProperties().entrySet()) {
			deployment.setContextProperty(prop.getKey().toString(), prop.getValue().toString());
		}

		for (final String requiredPUName : dependencies) {
			deployment.addDependencies(new ProcessingUnitDeploymentDependenciesConfigurer()
					.dependsOnMinimumNumberOfDeployedInstancesPerPartition(requiredPUName, 1).create());
		}

		getGridServiceManager().deploy(deployment);

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893135/fstmerge_base_6317565408967767476
public void installOnLocalCloud() 
			throws ProcessingUnitAlreadyDeployedException, CLIException {

		if (agentZone == null) {
			throw new IllegalStateException("Management services must be installed on management zone");
		}

		SpaceDeployment deployment = new SpaceDeployment(serviceName).addZone(serviceName);

		for (final Entry<Object, Object> prop : getContextProperties().entrySet()) {
			deployment.setContextProperty(prop.getKey().toString(), prop.getValue().toString());
		}

		for (final String requiredPUName : dependencies) {
			deployment.addDependencies(new ProcessingUnitDeploymentDependenciesConfigurer()
					.dependsOnMinimumNumberOfDeployedInstancesPerPartition(requiredPUName, 1).create());
		}

		getGridServiceManager().deploy(deployment);

=======
public void installOnLocalCloud()
			throws ProcessingUnitAlreadyDeployedException, CLIException {

		if (agentZone == null) {
			throw new IllegalStateException("Management services must be installed on management zone");
		}

		final File puFile = getManagementSpacePUFile();

		final ProcessingUnitDeployment deployment =
				new ProcessingUnitDeployment(puFile).name(serviceName).addZone(serviceName);

		// SpaceDeployment deployment = new SpaceDeployment(serviceName).addZone(serviceName);

		for (final Entry<Object, Object> prop : getContextProperties().entrySet()) {
			deployment.setContextProperty(prop.getKey().toString(), prop.getValue().toString());
		}

		for (final String requiredPUName : dependencies) {
			deployment.addDependencies(new ProcessingUnitDeploymentDependenciesConfigurer()
					.dependsOnMinimumNumberOfDeployedInstancesPerPartition(requiredPUName, 1).create());
		}

		getGridServiceManager().deploy(deployment);

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893135/fstmerge_var2_2012805782598141744
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementSpaceServiceInstaller.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893140/fstmerge_var1_3493237279498668054
@Override
	public void waitForInstallation(final AdminFacade adminFacade, final GridServiceAgent agent, final long timeout,
			final TimeUnit timeunit) throws InterruptedException, TimeoutException, CLIException {
		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {
			/**
			 * {@inheritDoc}
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {

				final Space space = admin.getSpaces().getSpaceByName(serviceName);
				if (space != null) {
					final SpacePartition partition = space.getPartition(0);
					if (partition != null && partition.getPrimary() != null) {
						gigaspace = space.getGigaSpace();
						return true;
					}
				}
				
				logger.fine("Connecting to management space.");
				if (verbose){
					publishEvent("Connecting to management space.");
				}
				return false;
			}
		});
		
		logger.fine("Management space is available.");
		if (verbose){
			logger.fine("Management space is available.");
		}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893140/fstmerge_base_738867514022366769
@Override
	public void waitForInstallation(final AdminFacade adminFacade, final GridServiceAgent agent, final long timeout,
			final TimeUnit timeunit) throws InterruptedException, TimeoutException, CLIException {
		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {
			/**
			 * {@inheritDoc}
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {

				final Space space = admin.getSpaces().getSpaceByName(serviceName);
				if (space != null) {
					final SpacePartition partition = space.getPartition(0);
					if (partition != null && partition.getPrimary() != null) {
						gigaspace = space.getGigaSpace();
						return true;
					}
				}
				
				logger.fine("Connecting to management space.");
				if (verbose){
					publishEvent("Connecting to management space.");
				}
				return false;
			}
		});
		
		logger.fine("Management space is available.");
		if (verbose){
			logger.fine("Management space is available.");
		}
=======
@Override
	public void waitForInstallation(final AdminFacade adminFacade, final GridServiceAgent agent, final long timeout,
			final TimeUnit timeunit) throws InterruptedException, TimeoutException, CLIException {
		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {
			/**
			 * {@inheritDoc}
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {

				final Space space = admin.getSpaces().getSpaceByName(serviceName);
				if (space != null) {
					final SpacePartition partition = space.getPartition(0);
					if (partition != null && partition.getPrimary() != null) {
						gigaspace = space.getGigaSpace();
						return true;
					}
				}

				logger.fine("Connecting to management space.");
				if (verbose) {
					publishEvent("Connecting to management space.");
				}
				return false;
			}
		});

		logger.fine("Management space is available.");
		if (verbose) {
			logger.fine("Management space is available.");
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893140/fstmerge_var2_5130655531278681034
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementSpaceServiceInstaller.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893149/fstmerge_var1_6538882721122589555
public void addListener(LocalhostBootstrapperListener listener) {
		this.eventsListenersList.add(listener);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893149/fstmerge_base_3457134478997081401
public void addListener(LocalhostBootstrapperListener listener) {
		this.eventsListenersList.add(listener);
=======
public void addListener(final LocalhostBootstrapperListener listener) {
		this.eventsListenersList.add(listener);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893149/fstmerge_var2_926219698865452555
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementSpaceServiceInstaller.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893154/fstmerge_var1_3620848487145543661
public void addListeners(List<LocalhostBootstrapperListener> listeners) {
		for (LocalhostBootstrapperListener listener : listeners) {
			this.eventsListenersList.add(listener);
		}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893154/fstmerge_base_8539466921887494319
public void addListeners(List<LocalhostBootstrapperListener> listeners) {
		for (LocalhostBootstrapperListener listener : listeners) {
			this.eventsListenersList.add(listener);
		}
=======
public void addListeners(final List<LocalhostBootstrapperListener> listeners) {
		for (final LocalhostBootstrapperListener listener : listeners) {
			this.eventsListenersList.add(listener);
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893154/fstmerge_var2_7239120582896274312
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementSpaceServiceInstaller.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893164/fstmerge_var1_6583180050667944750
public void setIsLocalCloud(boolean isLocalCloud) {
		this.isLocalcloud = isLocalCloud;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893164/fstmerge_base_4055464053032270260
public void setIsLocalCloud(boolean isLocalCloud) {
		this.isLocalcloud = isLocalCloud;
		
=======
public void setIsLocalCloud(final boolean isLocalCloud) {
		this.isLocalcloud = isLocalCloud;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893164/fstmerge_var2_4187913357612590916
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementSpaceServiceInstaller.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893169/fstmerge_var1_1226781807029208459
public void setLrmiCommandLineArgument(final String lrmiCommandLineArgument) {
		this.lrmiCommandLineArgument  = lrmiCommandLineArgument;
	}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893169/fstmerge_base_4801296616456888591
=======
public void setLrmiCommandLineArgument(final String lrmiCommandLineArgument) {
		this.lrmiCommandLineArgument = lrmiCommandLineArgument;
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893169/fstmerge_var2_6788170465619600226

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementSpaceServiceInstaller.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893214/fstmerge_var1_4946843251921889095
public abstract void waitForInstallation(AdminFacade adminFacade, GridServiceAgent agent, long timeout, 
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893214/fstmerge_base_4229224117304163814
public abstract void waitForInstallation(AdminFacade adminFacade, GridServiceAgent agent, long timeout, 
=======
public abstract void waitForInstallation(AdminFacade adminFacade, GridServiceAgent agent, long timeout,
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893214/fstmerge_var2_6391186171082183187
			TimeUnit timeunit) throws InterruptedException, TimeoutException, CLIException;

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/AbstractManagementServiceInstaller.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893259/fstmerge_var1_159347232222883996
public void installLocalCloud() throws CLIException {

		if (agentZone == null) {
			throw new IllegalStateException("Management services must be installed on management zone");
		}
		
		final ProcessingUnitDeployment deployment = new ProcessingUnitDeployment(
				getGSFile(warFile))
				.addZone(serviceName) 
				.name(serviceName);

		for (final Entry<Object, Object> prop : getContextProperties().entrySet()) {
			deployment.setContextProperty(prop.getKey().toString(), prop.getValue().toString());
		}

		for (final String requiredPUName : dependencies) {
			deployment.addDependencies(new ProcessingUnitDeploymentDependenciesConfigurer()
					.dependsOnMinimumNumberOfDeployedInstancesPerPartition(requiredPUName, 1).create());
		}

		getGridServiceManager().deploy(deployment);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893259/fstmerge_base_8326925630000231508
public void installLocalCloud() throws CLIException {

		if (agentZone == null) {
			throw new IllegalStateException("Management services must be installed on management zone");
		}
		
		final ProcessingUnitDeployment deployment = new ProcessingUnitDeployment(
				getGSFile(warFile))
				.addZone(serviceName) 
				.name(serviceName);

		for (final Entry<Object, Object> prop : getContextProperties().entrySet()) {
			deployment.setContextProperty(prop.getKey().toString(), prop.getValue().toString());
		}

		for (final String requiredPUName : dependencies) {
			deployment.addDependencies(new ProcessingUnitDeploymentDependenciesConfigurer()
					.dependsOnMinimumNumberOfDeployedInstancesPerPartition(requiredPUName, 1).create());
		}

		getGridServiceManager().deploy(deployment);
=======
public void installLocalCloud() throws CLIException {

		if (agentZone == null) {
			throw new IllegalStateException("Management services must be installed on management zone");
		}

		final ProcessingUnitDeployment deployment = new ProcessingUnitDeployment(
				getGSFile(warFile))
				.addZone(serviceName)
				.name(serviceName);

		for (final Entry<Object, Object> prop : getContextProperties().entrySet()) {
			deployment.setContextProperty(prop.getKey().toString(), prop.getValue().toString());
		}

		for (final String requiredPUName : dependencies) {
			deployment.addDependencies(new ProcessingUnitDeploymentDependenciesConfigurer()
					.dependsOnMinimumNumberOfDeployedInstancesPerPartition(requiredPUName, 1).create());
		}

		getGridServiceManager().deploy(deployment);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893259/fstmerge_var2_9012128717754589559
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementWebServiceInstaller.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893273/fstmerge_var1_5157360683850978713
public URL waitForProcessingUnitInstance(final GridServiceAgent agent, final long timeout, final TimeUnit timeunit)
			throws InterruptedException, TimeoutException, CLIException {

		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {
			boolean messagePublished = false;
			/**
			 * {@inheritDoc}
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {
				logger.fine("Waiting for " + serviceName + " service.");
				if (!messagePublished){
					String message = ShellUtils.getMessageBundle().getString("starting_management_web_service");
					publishEvent(MessageFormat.format(message, serviceName.toUpperCase()));
					messagePublished = true;
				}
				final ProcessingUnit pu = getProcessingUnit();
				boolean isDone = false;
				if (pu != null) {
					for (final ProcessingUnitInstance instance : pu) {
						if (agent.equals(instance.getGridServiceContainer().getGridServiceAgent())) {
							isDone = true;
							break;
						}
					}
				}
				if (!isDone){
					publishEvent(null);
				}
				return isDone;
			}
		});

		// TODO [noak]: verify this always the correct port (SSL-wise) ?
		final URL url = getWebProcessingUnitURL(agent, getProcessingUnit(), isSecureConnection);
		final String serviceNameCapital = StringUtils.capitalize(serviceName);
		String returnMessage = ShellUtils.getMessageBundle().getString("web_service_available_at");
		logger.fine(returnMessage);
		publishEvent(MessageFormat.format(returnMessage, serviceNameCapital, url));
		return url;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893273/fstmerge_base_1756847413205007223
public URL waitForProcessingUnitInstance(final GridServiceAgent agent, final long timeout, final TimeUnit timeunit)
			throws InterruptedException, TimeoutException, CLIException {

		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {
			boolean messagePublished = false;
			/**
			 * {@inheritDoc}
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {
				logger.fine("Waiting for " + serviceName + " service.");
				if (!messagePublished){
					String message = ShellUtils.getMessageBundle().getString("starting_management_web_service");
					publishEvent(MessageFormat.format(message, serviceName.toUpperCase()));
					messagePublished = true;
				}
				final ProcessingUnit pu = getProcessingUnit();
				boolean isDone = false;
				if (pu != null) {
					for (final ProcessingUnitInstance instance : pu) {
						if (agent.equals(instance.getGridServiceContainer().getGridServiceAgent())) {
							isDone = true;
							break;
						}
					}
				}
				if (!isDone){
					publishEvent(null);
				}
				return isDone;
			}
		});

		// TODO [noak]: verify this always the correct port (SSL-wise) ?
		final URL url = getWebProcessingUnitURL(agent, getProcessingUnit(), isSecureConnection);
		final String serviceNameCapital = StringUtils.capitalize(serviceName);
		String returnMessage = ShellUtils.getMessageBundle().getString("web_service_available_at");
		logger.fine(returnMessage);
		publishEvent(MessageFormat.format(returnMessage, serviceNameCapital, url));
		return url;
=======
public URL waitForProcessingUnitInstance(final GridServiceAgent agent, final long timeout, final TimeUnit timeunit)
			throws InterruptedException, TimeoutException, CLIException {

		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {
			private boolean messagePublished = false;

			/**
			 * {@inheritDoc}
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {
				logger.fine("Waiting for " + serviceName + " service.");
				if (!messagePublished) {
					final String message = ShellUtils.getMessageBundle().getString("starting_management_web_service");
					publishEvent(MessageFormat.format(message, serviceName.toUpperCase()));
					messagePublished = true;
				}
				final ProcessingUnit pu = getProcessingUnit();
				boolean isDone = false;
				if (pu != null) {
					for (final ProcessingUnitInstance instance : pu) {
						if (agent.equals(instance.getGridServiceContainer().getGridServiceAgent())) {
							isDone = true;
							break;
						}
					}
				}
				if (!isDone) {
					publishEvent(null);
				}
				return isDone;
			}
		});

		// TODO [noak]: verify this always the correct port (SSL-wise) ?
		final URL url = getWebProcessingUnitURL(agent, getProcessingUnit(), isSecureConnection);
		final String serviceNameCapital = StringUtils.capitalize(serviceName);
		final String returnMessage = ShellUtils.getMessageBundle().getString("web_service_available_at");
		logger.fine(returnMessage);
		publishEvent(MessageFormat.format(returnMessage, serviceNameCapital, url));
		return url;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893273/fstmerge_var2_4366601133669455755
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementWebServiceInstaller.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893279/fstmerge_var1_3448613327315434871
private void waitForConnection(final AdminFacade adminFacade, final String username, final String password,
			final URL url, final long timeout, final TimeUnit timeunit)
					throws InterruptedException, TimeoutException,
			CLIException {
		adminFacade.disconnect();
		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {
			/**
			 * {@inheritDoc}
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {

				try {
					adminFacade.connect(username, password, url.toString(), isSecureConnection);
					return true;
				} catch (final CLIException e) {
					if (verbose) {
						logger.log(Level.INFO, "Error connecting to web service [" + serviceName + "].", e);
					}
				}
				logger.log(Level.INFO, "Connecting to web service [" + serviceName + "].");
				return false;
			}
		});
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893279/fstmerge_base_8933977857610761300
private void waitForConnection(final AdminFacade adminFacade, final String username, final String password,
			final URL url, final long timeout, final TimeUnit timeunit)
					throws InterruptedException, TimeoutException,
			CLIException {
		adminFacade.disconnect();
		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {
			/**
			 * {@inheritDoc}
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {

				try {
					adminFacade.connect(username, password, url.toString(), isSecureConnection);
					return true;
				} catch (final CLIException e) {
					if (verbose) {
						logger.log(Level.INFO, "Error connecting to web service [" + serviceName + "].", e);
					}
				}
				logger.log(Level.INFO, "Connecting to web service [" + serviceName + "].");
				return false;
			}
		});
=======
private void waitForConnection(final AdminFacade adminFacade, final String username, final String password,
			final URL url, final long timeout, final TimeUnit timeunit)
			throws InterruptedException, TimeoutException,
			CLIException {
		adminFacade.disconnect();
		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {
			/**
			 * {@inheritDoc}
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {

				try {
					adminFacade.connect(username, password, url.toString(), isSecureConnection);
					return true;
				} catch (final CLIException e) {
					if (verbose) {
						logger.log(Level.INFO, "Error connecting to web service [" + serviceName + "].", e);
					}
				}
				logger.log(Level.INFO, "Connecting to web service [" + serviceName + "].");
				return false;
			}
		});
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893279/fstmerge_var2_8618569531445850510
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementWebServiceInstaller.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893301/fstmerge_var1_7332482575505718767
public static URL getWebProcessingUnitURL(final GridServiceAgent agent, final ProcessingUnit pu, 
			final boolean isSecureConnection) {
		ProcessingUnitInstance pui = null;

		for (final ProcessingUnitInstance instance : pu.getInstances()) {
			if (instance.getGridServiceContainer() != null
					&& instance.getGridServiceContainer().getGridServiceAgent() != null
					&& instance.getGridServiceContainer().getGridServiceAgent().equals(agent)) {
				pui = instance;
			}
		}

		if (pui == null) {
			throw new IllegalStateException("Failed finding " + pu.getName() + " on "
					+ agent.getMachine().getHostAddress());
		}

		final Map<String, ServiceDetails> alldetails = pui.getServiceDetailsByServiceId();

		final ServiceDetails details = alldetails.get("jee-container");
		final String host = details.getAttributes().get("host").toString();
		final String port = details.getAttributes().get("port").toString();
		final String ctx = details.getAttributes().get("context-path").toString();
		final String url = ShellUtils.getRestProtocol(isSecureConnection) + "://" + host + ":" + port + ctx;
		try {
			return new URL(url);
		} catch (final MalformedURLException e) {
			// this is a bug since we formed the URL correctly
			throw new IllegalStateException(e);
		}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893301/fstmerge_base_6683932157672574323
public static URL getWebProcessingUnitURL(final GridServiceAgent agent, final ProcessingUnit pu, 
			final boolean isSecureConnection) {
		ProcessingUnitInstance pui = null;

		for (final ProcessingUnitInstance instance : pu.getInstances()) {
			if (instance.getGridServiceContainer() != null
					&& instance.getGridServiceContainer().getGridServiceAgent() != null
					&& instance.getGridServiceContainer().getGridServiceAgent().equals(agent)) {
				pui = instance;
			}
		}

		if (pui == null) {
			throw new IllegalStateException("Failed finding " + pu.getName() + " on "
					+ agent.getMachine().getHostAddress());
		}

		final Map<String, ServiceDetails> alldetails = pui.getServiceDetailsByServiceId();

		final ServiceDetails details = alldetails.get("jee-container");
		final String host = details.getAttributes().get("host").toString();
		final String port = details.getAttributes().get("port").toString();
		final String ctx = details.getAttributes().get("context-path").toString();
		final String url = ShellUtils.getRestProtocol(isSecureConnection) + "://" + host + ":" + port + ctx;
		try {
			return new URL(url);
		} catch (final MalformedURLException e) {
			// this is a bug since we formed the URL correctly
			throw new IllegalStateException(e);
		}
=======
public static URL getWebProcessingUnitURL(final GridServiceAgent agent, final ProcessingUnit pu,
			final boolean isSecureConnection) {
		ProcessingUnitInstance pui = null;

		for (final ProcessingUnitInstance instance : pu.getInstances()) {
			if (instance.getGridServiceContainer() != null
					&& instance.getGridServiceContainer().getGridServiceAgent() != null
					&& instance.getGridServiceContainer().getGridServiceAgent().equals(agent)) {
				pui = instance;
			}
		}

		if (pui == null) {
			throw new IllegalStateException("Failed finding " + pu.getName() + " on "
					+ agent.getMachine().getHostAddress());
		}

		final Map<String, ServiceDetails> alldetails = pui.getServiceDetailsByServiceId();

		final ServiceDetails details = alldetails.get("jee-container");
		final String host = details.getAttributes().get("host").toString();
		final String port = details.getAttributes().get("port").toString();
		final String ctx = details.getAttributes().get("context-path").toString();
		final String url = ShellUtils.getRestProtocol(isSecureConnection) + "://" + host + ":" + port + ctx;
		try {
			return new URL(url);
		} catch (final MalformedURLException e) {
			// this is a bug since we formed the URL correctly
			throw new IllegalStateException(e);
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893301/fstmerge_var2_9062543537565577252
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementWebServiceInstaller.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893311/fstmerge_var1_3804652829395778639
public void addListener(LocalhostBootstrapperListener listener) {
		this.eventsListenersList.add(listener);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893311/fstmerge_base_3055148604991026381
public void addListener(LocalhostBootstrapperListener listener) {
		this.eventsListenersList.add(listener);
=======
public void addListener(final LocalhostBootstrapperListener listener) {
		this.eventsListenersList.add(listener);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893311/fstmerge_var2_1244535576095796459
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementWebServiceInstaller.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893315/fstmerge_var1_5145614288431086993
public void addListeners(List<LocalhostBootstrapperListener> listeners) {
		for (LocalhostBootstrapperListener listener : listeners) {
			this.eventsListenersList.add(listener);
		}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893315/fstmerge_base_650258980610204101
public void addListeners(List<LocalhostBootstrapperListener> listeners) {
		for (LocalhostBootstrapperListener listener : listeners) {
			this.eventsListenersList.add(listener);
		}
=======
public void addListeners(final List<LocalhostBootstrapperListener> listeners) {
		for (final LocalhostBootstrapperListener listener : listeners) {
			this.eventsListenersList.add(listener);
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893315/fstmerge_var2_1775746003462339541
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementWebServiceInstaller.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893324/fstmerge_var1_247274008929323997
public void setIsLocalCloud(boolean isLocalCloud) {
		this.isLocalcloud = isLocalCloud;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893324/fstmerge_base_3647202425789678329
public void setIsLocalCloud(boolean isLocalCloud) {
		this.isLocalcloud = isLocalCloud;
=======
public void setIsLocalCloud(final boolean isLocalCloud) {
		this.isLocalcloud = isLocalCloud;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893324/fstmerge_var2_1151948385778235570
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementWebServiceInstaller.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893328/fstmerge_var1_7435399143134658773
public void setIsSecureConnection(boolean isSecureConnection) {
		this.isSecureConnection = isSecureConnection;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893328/fstmerge_base_2961775817286790746
public void setIsSecureConnection(boolean isSecureConnection) {
		this.isSecureConnection = isSecureConnection;
=======
public void setIsSecureConnection(final boolean isSecureConnection) {
		this.isSecureConnection = isSecureConnection;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893328/fstmerge_var2_9080979705560922016
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementWebServiceInstaller.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893333/fstmerge_var1_2119147676010554798
public void setLrmiCommandLineArgument(final String lrmiCommandLineArgument) {
		this.lrmiCommandLineArgument  = lrmiCommandLineArgument;
	}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893333/fstmerge_base_4073168834208745156
=======
public void setLrmiCommandLineArgument(final String lrmiCommandLineArgument) {
		this.lrmiCommandLineArgument = lrmiCommandLineArgument;
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893333/fstmerge_var2_7373833754724893429

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/ManagementWebServiceInstaller.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893417/fstmerge_var1_5941022847208408766
public void startLocalCloudOnLocalhostAndWait(final String securityProfile, final String securityFilePath, 
			final String username, final String password, final String keystoreFilePath, final String keystorePassword,
			final int timeout, final TimeUnit timeunit) throws CLIException, InterruptedException, TimeoutException {

		setGridServiceAgentZone(LOCALCLOUD_GSA_ZONES);

		setDefaultNicAddress();

		setDefaultLocalcloudLookup();

		if (isWindows()) {
			startManagementOnLocalhostAndWaitInternal(LOCALCLOUD_WIN_MANAGEMENT_ARGUMENTS, securityProfile, 
					securityFilePath, username, password, keystoreFilePath, keystorePassword, timeout, timeunit, true);
		} else {
			startManagementOnLocalhostAndWaitInternal(LOCALCLOUD_LINUX_MANAGEMENT_ARGUMENTS, securityProfile, 
					securityFilePath, username, password, keystoreFilePath, keystorePassword, timeout, timeunit, true);
		}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893417/fstmerge_base_8164363151239188730
public void startLocalCloudOnLocalhostAndWait(final String securityProfile, final String securityFilePath, 
			final String username, final String password, final String keystoreFilePath, final String keystorePassword,
			final int timeout, final TimeUnit timeunit) throws CLIException, InterruptedException, TimeoutException {

		setGridServiceAgentZone(LOCALCLOUD_GSA_ZONES);

		setDefaultNicAddress();

		setDefaultLocalcloudLookup();

		if (isWindows()) {
			startManagementOnLocalhostAndWaitInternal(LOCALCLOUD_WIN_MANAGEMENT_ARGUMENTS, securityProfile, 
					securityFilePath, username, password, keystoreFilePath, keystorePassword, timeout, timeunit, true);
		} else {
			startManagementOnLocalhostAndWaitInternal(LOCALCLOUD_LINUX_MANAGEMENT_ARGUMENTS, securityProfile, 
					securityFilePath, username, password, keystoreFilePath, keystorePassword, timeout, timeunit, true);
		}
=======
public void startLocalCloudOnLocalhostAndWait(final String securityProfile, final String securityFilePath,
			final String username, final String password, final String keystoreFilePath, final String keystorePassword,
			final int timeout, final TimeUnit timeunit) throws CLIException, InterruptedException, TimeoutException {

		setGridServiceAgentZone(LOCALCLOUD_GSA_ZONES);

		setDefaultNicAddress();

		setDefaultLocalcloudLookup();

		if (isWindows()) {
			startManagementOnLocalhostAndWaitInternal(LOCALCLOUD_WIN_MANAGEMENT_ARGUMENTS, securityProfile,
					securityFilePath, username, password, keystoreFilePath, keystorePassword, timeout, timeunit, true);
		} else {
			startManagementOnLocalhostAndWaitInternal(LOCALCLOUD_LINUX_MANAGEMENT_ARGUMENTS, securityProfile,
					securityFilePath, username, password, keystoreFilePath, keystorePassword, timeout, timeunit, true);
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893417/fstmerge_var2_5266867023092968140
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893437/fstmerge_var1_9011844345967174662
public void startManagementOnLocalhostAndWait(final String securityProfile, final String securityFilePath,
			final String username, final String password, final String keystoreFilePath, final String keystorePassword,
			final int timeout, final TimeUnit timeunit) throws CLIException, InterruptedException, TimeoutException {

		setGridServiceAgentZone(MANAGEMENT_ZONE);

		setDefaultNicAddress();

		startManagementOnLocalhostAndWaitInternal(CLOUD_MANAGEMENT_ARGUMENTS, securityProfile, securityFilePath,
				username, password, keystoreFilePath, keystorePassword, timeout, timeunit, false);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893437/fstmerge_base_3945948904476953161
public void startManagementOnLocalhostAndWait(final String securityProfile, final String securityFilePath,
			final String username, final String password, final String keystoreFilePath, final String keystorePassword,
			final int timeout, final TimeUnit timeunit) throws CLIException, InterruptedException, TimeoutException {

		setGridServiceAgentZone(MANAGEMENT_ZONE);

		setDefaultNicAddress();

		startManagementOnLocalhostAndWaitInternal(CLOUD_MANAGEMENT_ARGUMENTS, securityProfile, securityFilePath,
				username, password, keystoreFilePath, keystorePassword, timeout, timeunit, false);
=======
public void startManagementOnLocalhostAndWait(final String securityProfile, final String securityFilePath,
			final String username, final String password, final String keystoreFilePath, final String keystorePassword,
			final int timeout, final TimeUnit timeunit) throws CLIException, InterruptedException, TimeoutException {

		try {
			this.cloud = ServiceReader.readCloud(new File(this.cloudFilePath));
		} catch (final IOException e) {
			throw new CLIException("Failed to read cloud file: " + e.getMessage(), e);
		} catch (final DSLException e) {
			throw new CLIException("Failed to read cloud file: " + e.getMessage(), e);
		}

		setGridServiceAgentZone(MANAGEMENT_ZONE);

		setDefaultNicAddress();

		startManagementOnLocalhostAndWaitInternal(CLOUD_MANAGEMENT_ARGUMENTS, securityProfile, securityFilePath,
				username, password, keystoreFilePath, keystorePassword, timeout, timeunit, false);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893437/fstmerge_var2_4932590935363138337
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893461/fstmerge_var1_806149655087149821
private void uninstallApplications(final long timeout, final TimeUnit timeunit) throws InterruptedException,
			TimeoutException, CLIException {

		Collection<String> applicationsList = null;
		boolean applicationsExist = false;
		try {
			if (!adminFacade.isConnected()) {
				throw new CLIException("Failed to fetch applications list. "
						+ "Client is not connected to the rest server.");
			}

			applicationsList = adminFacade.getApplicationNamesList();
			// If there existed other applications besides the management.
			applicationsExist = applicationsList.size() > 1;
		} catch (final CLIException e) {
			if (!force) {
				throw new CLIStatusException(e, "failed_to_access_rest_before_teardown");
			}
			final String errorMessage = "Failed to fetch the currently deployed applications list."
					+ " Continuing teardown-localcloud.";
			if (verbose) {
				logger.log(Level.FINE, errorMessage, e);
				publishEvent(errorMessage + System.getProperty("line.separator") + e.toString());
			} else {
				logger.log(Level.FINE, errorMessage);
				publishEvent(errorMessage);
			}
			// Suppress exception. continue with teardown.
			return;
		}

		if (applicationsExist && !force) {
			throw new CLIStatusException("apps_deployed_before_teardown_localcloud", applicationsList.toString());
		}
		final String uninstallMessage = ShellUtils.getMessageBundle().getString(
				"uninstalling_applications_before_teardown");
		publishEvent(uninstallMessage);
		for (final String appName : applicationsList) {
			try {
				if (!appName.equals(MANAGEMENT_APPLICATION)) {
					logger.fine("Uninstalling application " + appName);
					final Map<String, String> uninstallApplicationResponse = adminFacade.uninstallApplication(appName,
							(int) timeout);
					if (uninstallApplicationResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {
						final String pollingID = uninstallApplicationResponse
								.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);
						this.adminFacade.waitForLifecycleEvents(pollingID, (int) timeout,
                                CloudifyConstants.TIMEOUT_ERROR_MESSAGE);
					} else {
						publishEvent("Failed to retrieve lifecycle logs from rest. " + "Check logs for more details.");
					}
				}
			} catch (final CLIException e) {
				final String errorMessage = "Application " + appName + " faild to uninstall."
						+ " Continuing teardown-localcloud.";
				if (!force) {
					throw new CLIStatusException(e, "failed_to_uninstall_app_before_teardown", appName);
				}
				if (verbose) {
					logger.log(Level.FINE, errorMessage, e);
					publishEvent(errorMessage);
				} else {
					logger.log(Level.FINE, errorMessage);
				}
			}
		}
		if (applicationsExist) {
			waitForUninstallApplications(timeout, timeunit);
			publishEvent(ShellUtils.getMessageBundle().getString("all_apps_removed_before_teardown"));
			logger.fine(ShellUtils.getMessageBundle().getString("all_apps_removed_before_teardown"));
		}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893461/fstmerge_base_3590556795512956943
private void uninstallApplications(final long timeout, final TimeUnit timeunit) throws InterruptedException,
			TimeoutException, CLIException {

		Collection<String> applicationsList = null;
		boolean applicationsExist = false;
		try {
			if (!adminFacade.isConnected()) {
				throw new CLIException("Failed to fetch applications list. "
						+ "Client is not connected to the rest server.");
			}

			applicationsList = adminFacade.getApplicationNamesList();
			// If there existed other applications besides the management.
			applicationsExist = applicationsList.size() > 1;
		} catch (final CLIException e) {
			if (!force) {
				throw new CLIStatusException(e, "failed_to_access_rest_before_teardown");
			}
			final String errorMessage = "Failed to fetch the currently deployed applications list."
					+ " Continuing teardown-localcloud.";
			if (verbose) {
				logger.log(Level.FINE, errorMessage, e);
				publishEvent(errorMessage + System.getProperty("line.separator") + e.toString());
			} else {
				logger.log(Level.FINE, errorMessage);
				publishEvent(errorMessage);
			}
			// Suppress exception. continue with teardown.
			return;
		}

		if (applicationsExist && !force) {
			throw new CLIStatusException("apps_deployed_before_teardown_localcloud", applicationsList.toString());
		}
		final String uninstallMessage = ShellUtils.getMessageBundle().getString(
				"uninstalling_applications_before_teardown");
		publishEvent(uninstallMessage);
		for (final String appName : applicationsList) {
			try {
				if (!appName.equals(MANAGEMENT_APPLICATION)) {
					logger.fine("Uninstalling application " + appName);
					final Map<String, String> uninstallApplicationResponse = adminFacade.uninstallApplication(appName,
							(int) timeout);
					if (uninstallApplicationResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {
						final String pollingID = uninstallApplicationResponse
								.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);
						this.adminFacade.waitForLifecycleEvents(pollingID, (int) timeout,
                                CloudifyConstants.TIMEOUT_ERROR_MESSAGE);
					} else {
						publishEvent("Failed to retrieve lifecycle logs from rest. " + "Check logs for more details.");
					}
				}
			} catch (final CLIException e) {
				final String errorMessage = "Application " + appName + " faild to uninstall."
						+ " Continuing teardown-localcloud.";
				if (!force) {
					throw new CLIStatusException(e, "failed_to_uninstall_app_before_teardown", appName);
				}
				if (verbose) {
					logger.log(Level.FINE, errorMessage, e);
					publishEvent(errorMessage);
				} else {
					logger.log(Level.FINE, errorMessage);
				}
			}
		}
		if (applicationsExist) {
			waitForUninstallApplications(timeout, timeunit);
			publishEvent(ShellUtils.getMessageBundle().getString("all_apps_removed_before_teardown"));
			logger.fine(ShellUtils.getMessageBundle().getString("all_apps_removed_before_teardown"));
		}
=======
private void uninstallApplications(final long timeout, final TimeUnit timeunit) throws InterruptedException,
			TimeoutException, CLIException {

		Collection<String> applicationsList = null;
		boolean applicationsExist = false;
		try {
			if (!adminFacade.isConnected()) {
				throw new CLIException("Failed to fetch applications list. "
						+ "Client is not connected to the rest server.");
			}

			applicationsList = adminFacade.getApplicationNamesList();
			// If there existed other applications besides the management.
			applicationsExist = applicationsList.size() > 1;
		} catch (final CLIException e) {
			if (!force) {
				throw new CLIStatusException(e, "failed_to_access_rest_before_teardown");
			}
			final String errorMessage = "Failed to fetch the currently deployed applications list."
					+ " Continuing teardown-localcloud.";
			if (verbose) {
				logger.log(Level.FINE, errorMessage, e);
				publishEvent(errorMessage + System.getProperty("line.separator") + e.toString());
			} else {
				logger.log(Level.FINE, errorMessage);
				publishEvent(errorMessage);
			}
			// Suppress exception. continue with teardown.
			return;
		}

		if (applicationsExist && !force) {
			throw new CLIStatusException("apps_deployed_before_teardown_localcloud", applicationsList.toString());
		}
		final String uninstallMessage = ShellUtils.getMessageBundle().getString(
				"uninstalling_applications_before_teardown");
		publishEvent(uninstallMessage);
		for (final String appName : applicationsList) {
			try {
				if (!appName.equals(MANAGEMENT_APPLICATION)) {
					logger.fine("Uninstalling application " + appName);
					final Map<String, String> uninstallApplicationResponse = adminFacade.uninstallApplication(appName,
							(int) timeout);
					if (uninstallApplicationResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {
						final String pollingID = uninstallApplicationResponse
								.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);
						this.adminFacade.waitForLifecycleEvents(pollingID, (int) timeout,
								CloudifyConstants.TIMEOUT_ERROR_MESSAGE);
					} else {
						publishEvent("Failed to retrieve lifecycle logs from rest. " + "Check logs for more details.");
					}
				}
			} catch (final CLIException e) {
				final String errorMessage = "Application " + appName + " faild to uninstall."
						+ " Continuing teardown-localcloud.";
				if (!force) {
					throw new CLIStatusException(e, "failed_to_uninstall_app_before_teardown", appName);
				}
				if (verbose) {
					logger.log(Level.FINE, errorMessage, e);
					publishEvent(errorMessage);
				} else {
					logger.log(Level.FINE, errorMessage);
				}
			}
		}
		if (applicationsExist) {
			waitForUninstallApplications(timeout, timeunit);
			publishEvent(ShellUtils.getMessageBundle().getString("all_apps_removed_before_teardown"));
			logger.fine(ShellUtils.getMessageBundle().getString("all_apps_removed_before_teardown"));
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893461/fstmerge_var2_5846751182059441934
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893482/fstmerge_var1_8429013270141682634
private void shutdownAgentAndWait(final GridServiceAgent agent, final long timeout, final TimeUnit timeunit)
			throws InterruptedException, TimeoutException, CLIException {

		// We need to shutdown the agent after we close the admin to avoid
		// closed exception since the admin
		// still monitors
		// the deployment behind the scenes, we call the direct proxy to the gsa
		// since the admin is closed and
		// we don't
		// want to use objects it generated
		final GSA gsa = ((InternalGridServiceAgent) agent).getGSA();
		try {
			gsa.shutdown();
		} catch (final RemoteException e) {
			if (!NetworkExceptionHelper.isConnectOrCloseException(e)) {
				logger.log(Level.FINER, "Failed to shutdown GSA", e);
				throw new AdminException("Failed to shutdown GSA", e);
			}
		}

		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {

			private boolean messagePublished = false;

			/**
			 * Pings the agent to verify it's not available, indicating it was
			 * shut down.
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {
				if (!messagePublished) {
					final String shuttingDownAgentMessage = ShellUtils.getMessageBundle().getString(
							"shutting_down_cloudify_agent_teardown_localcloud");
					publishEvent(shuttingDownAgentMessage);

					final String shuttingDownManagmentMessage = ShellUtils.getMessageBundle().getString(
                            "shutting_down_cloudify_management");
					publishEvent(shuttingDownManagmentMessage);

					messagePublished = true;
				}
				logger.fine("Waiting for agent to shutdown");
				try {
					gsa.ping();
				} catch (final RemoteException e) {
					// Probably NoSuchObjectException meaning the GSA is going
					// down
					return true;
				}
				publishEvent(null);
				return false;
			}

		});
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893482/fstmerge_base_6993010707573481963
private void shutdownAgentAndWait(final GridServiceAgent agent, final long timeout, final TimeUnit timeunit)
			throws InterruptedException, TimeoutException, CLIException {

		// We need to shutdown the agent after we close the admin to avoid
		// closed exception since the admin
		// still monitors
		// the deployment behind the scenes, we call the direct proxy to the gsa
		// since the admin is closed and
		// we don't
		// want to use objects it generated
		final GSA gsa = ((InternalGridServiceAgent) agent).getGSA();
		try {
			gsa.shutdown();
		} catch (final RemoteException e) {
			if (!NetworkExceptionHelper.isConnectOrCloseException(e)) {
				logger.log(Level.FINER, "Failed to shutdown GSA", e);
				throw new AdminException("Failed to shutdown GSA", e);
			}
		}

		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {

			private boolean messagePublished = false;

			/**
			 * Pings the agent to verify it's not available, indicating it was
			 * shut down.
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {
				if (!messagePublished) {
					final String shuttingDownAgentMessage = ShellUtils.getMessageBundle().getString(
							"shutting_down_cloudify_agent_teardown_localcloud");
					publishEvent(shuttingDownAgentMessage);

					final String shuttingDownManagmentMessage = ShellUtils.getMessageBundle().getString(
                            "shutting_down_cloudify_management");
					publishEvent(shuttingDownManagmentMessage);

					messagePublished = true;
				}
				logger.fine("Waiting for agent to shutdown");
				try {
					gsa.ping();
				} catch (final RemoteException e) {
					// Probably NoSuchObjectException meaning the GSA is going
					// down
					return true;
				}
				publishEvent(null);
				return false;
			}

		});
=======
private void shutdownAgentAndWait(final GridServiceAgent agent, final long timeout, final TimeUnit timeunit)
			throws InterruptedException, TimeoutException, CLIException {

		// We need to shutdown the agent after we close the admin to avoid
		// closed exception since the admin
		// still monitors
		// the deployment behind the scenes, we call the direct proxy to the gsa
		// since the admin is closed and
		// we don't
		// want to use objects it generated
		final GSA gsa = ((InternalGridServiceAgent) agent).getGSA();
		try {
			gsa.shutdown();
		} catch (final RemoteException e) {
			if (!NetworkExceptionHelper.isConnectOrCloseException(e)) {
				logger.log(Level.FINER, "Failed to shutdown GSA", e);
				throw new AdminException("Failed to shutdown GSA", e);
			}
		}

		createConditionLatch(timeout, timeunit).waitFor(new ConditionLatch.Predicate() {

			private boolean messagePublished = false;

			/**
			 * Pings the agent to verify it's not available, indicating it was shut down.
			 */
			@Override
			public boolean isDone() throws CLIException, InterruptedException {
				if (!messagePublished) {
					final String shuttingDownAgentMessage = ShellUtils.getMessageBundle().getString(
							"shutting_down_cloudify_agent_teardown_localcloud");
					publishEvent(shuttingDownAgentMessage);

					final String shuttingDownManagmentMessage = ShellUtils.getMessageBundle().getString(
							"shutting_down_cloudify_management");
					publishEvent(shuttingDownManagmentMessage);

					messagePublished = true;
				}
				logger.fine("Waiting for agent to shutdown");
				try {
					gsa.ping();
				} catch (final RemoteException e) {
					// Probably NoSuchObjectException meaning the GSA is going
					// down
					return true;
				}
				publishEvent(null);
				return false;
			}

		});
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893482/fstmerge_var2_936688721419200168
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893488/fstmerge_var1_4378495209670151054
private void runGsAgentOnLocalHost(final String name, final String[] gsAgentArguments, 
			final String securityProfile, final String securityFilePath, final String keystoreFilePath, 
			final String keystorePassword) throws CLIException, InterruptedException {

		final List<String> args = new ArrayList<String>();
		args.addAll(Arrays.asList(gsAgentArguments));

		String[] command;
		if (isLocalCloud) {
			publishEvent(ShellUtils.getMessageBundle().getString("starting_bootstrap_localcloud"));
			if (isWindows()) {
				command = Arrays.copyOf(WINDOWS_LOCALCLOUD_COMMAND, WINDOWS_LOCALCLOUD_COMMAND.length);
				args.addAll(Arrays.asList(WINDOWS_ARGUMENTS_POSTFIX));
			} else {
				command = Arrays.copyOf(LINUX_LOCALCLOUD_COMMAND, LINUX_LOCALCLOUD_COMMAND.length);
				args.addAll(Arrays.asList(LINUX_ARGUMENTS_POSTFIX));
			}
		} else {
			if (isWindows()) {
				command = Arrays.copyOf(WINDOWS_CLOUD_COMMAND, WINDOWS_CLOUD_COMMAND.length);
				args.addAll(Arrays.asList(WINDOWS_ARGUMENTS_POSTFIX));
			} else {
				command = Arrays.copyOf(LINUX_CLOUD_COMMAND, LINUX_CLOUD_COMMAND.length);
				args.addAll(Arrays.asList(LINUX_ARGUMENTS_POSTFIX));
			}
		}
		if (verbose) {
			final String message = "Starting "
					+ name
					+ (verbose ? ":\n" + StringUtils.collectionToDelimitedString(Arrays.asList(command), " ") + " "
							+ StringUtils.collectionToDelimitedString(args, " ") : "");
			publishEvent(message);
			logger.fine(message);
		}

		publishEvent(ShellUtils.getMessageBundle().getString("starting_cloudify_management"));
		runCommand(command, args.toArray(new String[args.size()]), securityProfile, securityFilePath, keystoreFilePath,
				keystorePassword);

||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893488/fstmerge_base_7967039583666653153
private void runGsAgentOnLocalHost(final String name, final String[] gsAgentArguments, 
			final String securityProfile, final String securityFilePath, final String keystoreFilePath, 
			final String keystorePassword) throws CLIException, InterruptedException {

		final List<String> args = new ArrayList<String>();
		args.addAll(Arrays.asList(gsAgentArguments));

		String[] command;
		if (isLocalCloud) {
			publishEvent(ShellUtils.getMessageBundle().getString("starting_bootstrap_localcloud"));
			if (isWindows()) {
				command = Arrays.copyOf(WINDOWS_LOCALCLOUD_COMMAND, WINDOWS_LOCALCLOUD_COMMAND.length);
				args.addAll(Arrays.asList(WINDOWS_ARGUMENTS_POSTFIX));
			} else {
				command = Arrays.copyOf(LINUX_LOCALCLOUD_COMMAND, LINUX_LOCALCLOUD_COMMAND.length);
				args.addAll(Arrays.asList(LINUX_ARGUMENTS_POSTFIX));
			}
		} else {
			if (isWindows()) {
				command = Arrays.copyOf(WINDOWS_CLOUD_COMMAND, WINDOWS_CLOUD_COMMAND.length);
				args.addAll(Arrays.asList(WINDOWS_ARGUMENTS_POSTFIX));
			} else {
				command = Arrays.copyOf(LINUX_CLOUD_COMMAND, LINUX_CLOUD_COMMAND.length);
				args.addAll(Arrays.asList(LINUX_ARGUMENTS_POSTFIX));
			}
		}
		if (verbose) {
			final String message = "Starting "
					+ name
					+ (verbose ? ":\n" + StringUtils.collectionToDelimitedString(Arrays.asList(command), " ") + " "
							+ StringUtils.collectionToDelimitedString(args, " ") : "");
			publishEvent(message);
			logger.fine(message);
		}

		publishEvent(ShellUtils.getMessageBundle().getString("starting_cloudify_management"));
		runCommand(command, args.toArray(new String[args.size()]), securityProfile, securityFilePath, keystoreFilePath,
				keystorePassword);

=======
private void runGsAgentOnLocalHost(final String name, final String[] gsAgentArguments,
			final String securityProfile, final String securityFilePath, final String keystoreFilePath,
			final String keystorePassword) throws CLIException, InterruptedException {

		final List<String> args = new ArrayList<String>();
		args.addAll(Arrays.asList(gsAgentArguments));

		String[] command;
		if (isLocalCloud) {
			publishEvent(ShellUtils.getMessageBundle().getString("starting_bootstrap_localcloud"));
			if (isWindows()) {
				command = Arrays.copyOf(WINDOWS_LOCALCLOUD_COMMAND, WINDOWS_LOCALCLOUD_COMMAND.length);
				args.addAll(Arrays.asList(WINDOWS_ARGUMENTS_POSTFIX));
			} else {
				command = Arrays.copyOf(LINUX_LOCALCLOUD_COMMAND, LINUX_LOCALCLOUD_COMMAND.length);
				args.addAll(Arrays.asList(LINUX_ARGUMENTS_POSTFIX));
			}
		} else {
			if (isWindows()) {
				command = Arrays.copyOf(WINDOWS_CLOUD_COMMAND, WINDOWS_CLOUD_COMMAND.length);
				args.addAll(Arrays.asList(WINDOWS_ARGUMENTS_POSTFIX));
			} else {
				command = Arrays.copyOf(LINUX_CLOUD_COMMAND, LINUX_CLOUD_COMMAND.length);
				args.addAll(Arrays.asList(LINUX_ARGUMENTS_POSTFIX));
			}
		}
		if (verbose) {
			final String message = "Starting "
					+ name
					+ (verbose ? ":\n" + StringUtils.collectionToDelimitedString(Arrays.asList(command), " ") + " "
							+ StringUtils.collectionToDelimitedString(args, " ") : "");
			publishEvent(message);
			logger.fine(message);
		}

		publishEvent(ShellUtils.getMessageBundle().getString("starting_cloudify_management"));
		runCommand(command, args.toArray(new String[args.size()]), securityProfile, securityFilePath, keystoreFilePath,
				keystorePassword);

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893488/fstmerge_var2_2672411410911917708
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893498/fstmerge_var1_4993685499792874048
private void startManagementOnLocalhostAndWaitInternal(final String[] gsAgentArgs, final String securityProfile, 
			final String securityFilePath, final String username, final String password, final String keystoreFilePath,
			final String keystorePassword, final int timeout, final TimeUnit timeunit, final boolean isLocalCloud)
			throws CLIException, InterruptedException, TimeoutException {

		setIsLocalCloud(isLocalCloud);

		final long end = System.currentTimeMillis() + timeunit.toMillis(timeout);

		if (gsaZones == null || gsaZones.isEmpty()) {
			throw new CLIException("Agent must be started with a zone");
		}

		final ConnectionLogsFilter connectionLogs = new ConnectionLogsFilter();
		connectionLogs.supressConnectionErrors();
		final Admin admin = createAdmin();
		try {
			setLookupDefaults(admin);
			GridServiceAgent agent;
			try {
				try {
					if (!isLocalCloud || fastExistingAgentCheck()) {
						waitForExistingAgent(admin, progressInSeconds, TimeUnit.SECONDS);
						throw new CLIException("Agent already running on local machine.");
					}
				} catch (final TimeoutException e) {
					// no existing agent running on local machine
				}

				runGsAgentOnLocalHost("agent and management processes", gsAgentArgs, securityProfile, securityFilePath,
						keystoreFilePath, keystorePassword);
				agent = waitForNewAgent(admin, ShellUtils.millisUntil(TIMEOUT_ERROR_MESSAGE, end),
						TimeUnit.MILLISECONDS);
			} finally {
				connectionLogs.restoreConnectionErrors();
			}

			// waiting for LUS, GSM and ESM services to start
			waitForManagementProcesses(agent, ShellUtils.millisUntil(TIMEOUT_ERROR_MESSAGE, end),
					TimeUnit.MILLISECONDS);

			final List<AbstractManagementServiceInstaller> waitForManagementServices =
					new LinkedList<AbstractManagementServiceInstaller>();

			if (isLocalCloud) {
				startLocalCloudManagementServicesContainer(agent);
			}

			connectionLogs.supressConnectionErrors();
			try {
				ManagementSpaceServiceInstaller managementSpaceInstaller = null;
				if (!noManagementSpace) {
					final boolean highlyAvailable = !isLocalCloud && !notHighlyAvailableManagementSpace;
					String gscLrmiCommandLineArg = getGscLrmiCommandLineArg();
					managementSpaceInstaller = new ManagementSpaceServiceInstaller();
					managementSpaceInstaller.setAdmin(agent.getAdmin());
					managementSpaceInstaller.setVerbose(verbose);
					managementSpaceInstaller.setProgress(progressInSeconds, TimeUnit.SECONDS);
					managementSpaceInstaller.setMemory(CloudifyConstants.MANAGEMENT_SPACE_MEMORY_IN_MB, MemoryUnit.MEGABYTES);
					managementSpaceInstaller.setServiceName(MANAGEMENT_SPACE_NAME);
					managementSpaceInstaller.setManagementZone(MANAGEMENT_ZONE);
					managementSpaceInstaller.setHighlyAvailable(highlyAvailable);
					managementSpaceInstaller.addListeners(this.eventsListenersList);
					managementSpaceInstaller.setIsLocalCloud(isLocalCloud);
					managementSpaceInstaller.setLrmiCommandLineArgument(gscLrmiCommandLineArg);
					try {
						managementSpaceInstaller.installSpace();
						waitForManagementServices.add(managementSpaceInstaller);
					} catch (final ProcessingUnitAlreadyDeployedException e) {
						if (verbose) {
							logger.fine("Service " + MANAGEMENT_SPACE_NAME + " already installed");
							publishEvent("Service " + MANAGEMENT_SPACE_NAME + " already installed");
						}
					}
				}

				if (!noWebServices) {
					installWebServices(username, password, isLocalCloud, 
							ShellUtils.isSecureConnection(securityProfile), agent, waitForManagementServices);
				}

				for (final AbstractManagementServiceInstaller managementServiceInstaller : waitForManagementServices) {
					managementServiceInstaller.waitForInstallation(adminFacade, agent, 
							ShellUtils.millisUntil(TIMEOUT_ERROR_MESSAGE, end), TimeUnit.MILLISECONDS);
					if (managementServiceInstaller instanceof ManagementSpaceServiceInstaller) {
						logger.fine("Writing cloud configuration to space.");
						if (verbose) {
							publishEvent("Writing cloud configuration to space.");
						}
						final GigaSpace gigaspace = managementSpaceInstaller.getGigaSpace();

						final CloudConfigurationHolder holder = new CloudConfigurationHolder(null, getCloudFilePath());
						logger.fine("Writing cloud Configuration to space: " + holder);
						gigaspace.write(holder);
						// Shut down the space proxy so that if the cloud is
						// turned down later, there will not
						// be any discovery errors.
						// Note: in a spring environment, the bean shutdown
						// would clean this up.
						// TODO - Move the space writing part into the
						// management space
						// installer and do the clean up there.
						((ISpaceProxy) gigaspace.getSpace()).close();
					}
				}

			} finally {
				connectionLogs.restoreConnectionErrors();
			}
		} finally {
			admin.close();
		}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893498/fstmerge_base_8629476855284126411
private void startManagementOnLocalhostAndWaitInternal(final String[] gsAgentArgs, final String securityProfile, 
			final String securityFilePath, final String username, final String password, final String keystoreFilePath,
			final String keystorePassword, final int timeout, final TimeUnit timeunit, final boolean isLocalCloud)
			throws CLIException, InterruptedException, TimeoutException {

		setIsLocalCloud(isLocalCloud);

		final long end = System.currentTimeMillis() + timeunit.toMillis(timeout);

		if (gsaZones == null || gsaZones.isEmpty()) {
			throw new CLIException("Agent must be started with a zone");
		}

		final ConnectionLogsFilter connectionLogs = new ConnectionLogsFilter();
		connectionLogs.supressConnectionErrors();
		final Admin admin = createAdmin();
		try {
			setLookupDefaults(admin);
			GridServiceAgent agent;
			try {
				try {
					if (!isLocalCloud || fastExistingAgentCheck()) {
						waitForExistingAgent(admin, progressInSeconds, TimeUnit.SECONDS);
						throw new CLIException("Agent already running on local machine.");
					}
				} catch (final TimeoutException e) {
					// no existing agent running on local machine
				}

				runGsAgentOnLocalHost("agent and management processes", gsAgentArgs, securityProfile, securityFilePath,
						keystoreFilePath, keystorePassword);
				agent = waitForNewAgent(admin, ShellUtils.millisUntil(TIMEOUT_ERROR_MESSAGE, end),
						TimeUnit.MILLISECONDS);
			} finally {
				connectionLogs.restoreConnectionErrors();
			}

			// waiting for LUS, GSM and ESM services to start
			waitForManagementProcesses(agent, ShellUtils.millisUntil(TIMEOUT_ERROR_MESSAGE, end),
					TimeUnit.MILLISECONDS);

			final List<AbstractManagementServiceInstaller> waitForManagementServices =
					new LinkedList<AbstractManagementServiceInstaller>();

			if (isLocalCloud) {
				startLocalCloudManagementServicesContainer(agent);
			}

			connectionLogs.supressConnectionErrors();
			try {
				ManagementSpaceServiceInstaller managementSpaceInstaller = null;
				if (!noManagementSpace) {
					final boolean highlyAvailable = !isLocalCloud && !notHighlyAvailableManagementSpace;
					managementSpaceInstaller = new ManagementSpaceServiceInstaller();
					managementSpaceInstaller.setAdmin(agent.getAdmin());
					managementSpaceInstaller.setVerbose(verbose);
					managementSpaceInstaller.setProgress(progressInSeconds, TimeUnit.SECONDS);
					managementSpaceInstaller.setMemory(MANAGEMENT_SPACE_MEMORY_IN_MB, MemoryUnit.MEGABYTES);
					managementSpaceInstaller.setServiceName(MANAGEMENT_SPACE_NAME);
					managementSpaceInstaller.setManagementZone(MANAGEMENT_ZONE);
					managementSpaceInstaller.setHighlyAvailable(highlyAvailable);
					managementSpaceInstaller.addListeners(this.eventsListenersList);
					managementSpaceInstaller.setIsLocalCloud(isLocalCloud);
					try {
						managementSpaceInstaller.installSpace();
						waitForManagementServices.add(managementSpaceInstaller);
					} catch (final ProcessingUnitAlreadyDeployedException e) {
						if (verbose) {
							logger.fine("Service " + MANAGEMENT_SPACE_NAME + " already installed");
							publishEvent("Service " + MANAGEMENT_SPACE_NAME + " already installed");
						}
					}
				}

				if (!noWebServices) {
					installWebServices(username, password, isLocalCloud, 
							ShellUtils.isSecureConnection(securityProfile), agent, waitForManagementServices);
				}

				for (final AbstractManagementServiceInstaller managementServiceInstaller : waitForManagementServices) {
					managementServiceInstaller.waitForInstallation(adminFacade, agent, 
							ShellUtils.millisUntil(TIMEOUT_ERROR_MESSAGE, end), TimeUnit.MILLISECONDS);
					if (managementServiceInstaller instanceof ManagementSpaceServiceInstaller) {
						logger.fine("Writing cloud configuration to space.");
						if (verbose) {
							publishEvent("Writing cloud configuration to space.");
						}
						final GigaSpace gigaspace = managementSpaceInstaller.getGigaSpace();

						final CloudConfigurationHolder holder = new CloudConfigurationHolder(null, getCloudFilePath());
						logger.fine("Writing cloud Configuration to space: " + holder);
						gigaspace.write(holder);
						// Shut down the space proxy so that if the cloud is
						// turned down later, there will not
						// be any discovery errors.
						// Note: in a spring environment, the bean shutdown
						// would clean this up.
						// TODO - Move the space writing part into the
						// management space
						// installer and do the clean up there.
						((ISpaceProxy) gigaspace.getSpace()).close();
					}
				}

			} finally {
				connectionLogs.restoreConnectionErrors();
			}
		} finally {
			admin.close();
		}
=======
private void startManagementOnLocalhostAndWaitInternal(final String[] gsAgentArgs, final String securityProfile,
			final String securityFilePath, final String username, final String password, final String keystoreFilePath,
			final String keystorePassword, final int timeout, final TimeUnit timeunit, final boolean isLocalCloud)
			throws CLIException, InterruptedException, TimeoutException {

		setIsLocalCloud(isLocalCloud);

		final long end = System.currentTimeMillis() + timeunit.toMillis(timeout);

		if (gsaZones == null || gsaZones.isEmpty()) {
			throw new CLIException("Agent must be started with a zone");
		}

		final ConnectionLogsFilter connectionLogs = new ConnectionLogsFilter();
		connectionLogs.supressConnectionErrors();
		final Admin admin = createAdmin();
		try {
			setLookupDefaults(admin);
			GridServiceAgent agent;
			try {
				try {
					if (!isLocalCloud || fastExistingAgentCheck()) {
						waitForExistingAgent(admin, progressInSeconds, TimeUnit.SECONDS);
						throw new CLIException("Agent already running on local machine.");
					}
				} catch (final TimeoutException e) {
					// no existing agent running on local machine
				}

				runGsAgentOnLocalHost("agent and management processes", gsAgentArgs, securityProfile, securityFilePath,
						keystoreFilePath, keystorePassword);
				agent = waitForNewAgent(admin, ShellUtils.millisUntil(TIMEOUT_ERROR_MESSAGE, end),
						TimeUnit.MILLISECONDS);
			} finally {
				connectionLogs.restoreConnectionErrors();
			}

			// waiting for LUS, GSM and ESM services to start
			waitForManagementProcesses(agent, ShellUtils.millisUntil(TIMEOUT_ERROR_MESSAGE, end),
					TimeUnit.MILLISECONDS);

			final List<AbstractManagementServiceInstaller> waitForManagementServices =
					new LinkedList<AbstractManagementServiceInstaller>();

			if (isLocalCloud) {
				startLocalCloudManagementServicesContainer(agent);
			}

			connectionLogs.supressConnectionErrors();
			try {
				ManagementSpaceServiceInstaller managementSpaceInstaller = null;
				if (!noManagementSpace) {
					final boolean highlyAvailable = !isLocalCloud && !notHighlyAvailableManagementSpace;
					final String gscLrmiCommandLineArg = getGscLrmiCommandLineArg();
					managementSpaceInstaller = new ManagementSpaceServiceInstaller();
					managementSpaceInstaller.setAdmin(agent.getAdmin());
					managementSpaceInstaller.setVerbose(verbose);
					managementSpaceInstaller.setProgress(progressInSeconds, TimeUnit.SECONDS);
					managementSpaceInstaller.setMemory(CloudifyConstants.MANAGEMENT_SPACE_MEMORY_IN_MB,
							MemoryUnit.MEGABYTES);
					managementSpaceInstaller.setServiceName(MANAGEMENT_SPACE_NAME);
					managementSpaceInstaller.setManagementZone(MANAGEMENT_ZONE);
					managementSpaceInstaller.setHighlyAvailable(highlyAvailable);
					managementSpaceInstaller.addListeners(this.eventsListenersList);
					managementSpaceInstaller.setIsLocalCloud(isLocalCloud);
					managementSpaceInstaller.setLrmiCommandLineArgument(gscLrmiCommandLineArg);

					if (!this.isLocalCloud) {
						final String persistentStoragePath = this.cloud.getConfiguration().getPersistentStoragePath();
						if (persistentStoragePath != null) {
							final String spaceStoragePath = persistentStoragePath + "/management-space/db.h2";
							managementSpaceInstaller.setPersistentStoragePath(spaceStoragePath);
						}
					}
					try {
						managementSpaceInstaller.installSpace();
						waitForManagementServices.add(managementSpaceInstaller);
					} catch (final ProcessingUnitAlreadyDeployedException e) {
						if (verbose) {
							logger.fine("Service " + MANAGEMENT_SPACE_NAME + " already installed");
							publishEvent("Service " + MANAGEMENT_SPACE_NAME + " already installed");
						}
					}
				}

				if (!noWebServices) {
					installWebServices(username, password, isLocalCloud,
							ShellUtils.isSecureConnection(securityProfile), agent, waitForManagementServices);
				}

				for (final AbstractManagementServiceInstaller managementServiceInstaller : waitForManagementServices) {
					managementServiceInstaller.waitForInstallation(adminFacade, agent,
							ShellUtils.millisUntil(TIMEOUT_ERROR_MESSAGE, end), TimeUnit.MILLISECONDS);
					if (managementServiceInstaller instanceof ManagementSpaceServiceInstaller) {
						logger.fine("Writing cloud configuration to space.");
						if (verbose) {
							publishEvent("Writing cloud configuration to space.");
						}
						final GigaSpace gigaspace = managementSpaceInstaller.getGigaSpace();

						final CloudConfigurationHolder holder = new CloudConfigurationHolder(null, getCloudFilePath());
						logger.fine("Writing cloud Configuration to space: " + holder);
						gigaspace.write(holder);
						// Shut down the space proxy so that if the cloud is
						// turned down later, there will not
						// be any discovery errors.
						// Note: in a spring environment, the bean shutdown
						// would clean this up.
						// TODO - Move the space writing part into the
						// management space
						// installer and do the clean up there.
						((ISpaceProxy) gigaspace.getSpace()).close();
					}
				}

			} finally {
				connectionLogs.restoreConnectionErrors();
			}
		} finally {
			admin.close();
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893498/fstmerge_var2_2999040072903632083
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893507/fstmerge_var1_8560939763755045851
private String getGscLrmiCommandLineArg() {
		String lrmiPortRangeCommandLineArgument = "-D" + CloudifyConstants.LRMI_BIND_PORT_CONTEXT_PROPERTY + "=";
		String portRange = System.getenv().get(CloudifyConstants.GSC_LRMI_PORT_RANGE_ENVIRONMENT_VAR);
		if (!org.apache.commons.lang.StringUtils.isEmpty(portRange)) {
			lrmiPortRangeCommandLineArgument += portRange; 
		} else {
			lrmiPortRangeCommandLineArgument += CloudifyConstants.DEFAULT_GSC_LRMI_PORT_RANGE; 
		}
		return lrmiPortRangeCommandLineArgument;
	}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893507/fstmerge_base_4688593617806455790
=======
private String getGscLrmiCommandLineArg() {
		String lrmiPortRangeCommandLineArgument = "-D" + CloudifyConstants.LRMI_BIND_PORT_CONTEXT_PROPERTY + "=";
		final String portRange = System.getenv().get(CloudifyConstants.GSC_LRMI_PORT_RANGE_ENVIRONMENT_VAR);
		if (!org.apache.commons.lang.StringUtils.isEmpty(portRange)) {
			lrmiPortRangeCommandLineArgument += portRange;
		} else {
			lrmiPortRangeCommandLineArgument += CloudifyConstants.DEFAULT_GSC_LRMI_PORT_RANGE;
		}
		return lrmiPortRangeCommandLineArgument;
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893507/fstmerge_var2_4385175697967447686

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893512/fstmerge_var1_8617863803578425412
private void installWebServices(final String username, final String password, final boolean isLocalCloud,
			final boolean isSecureConnection, final GridServiceAgent agent, 
			final List<AbstractManagementServiceInstaller> waitForManagementServices)
			throws CLIException {
		String gscLrmiCommandLineArg = getGscLrmiCommandLineArg();
		long webuiMemory = getWebServiceMemory(CloudifyConstants.WEBUI_MAX_MEMORY_ENVIRONMENT_VAR);
		int webuiPort = getWebservicePort(CloudifyConstants.WEBUI_PORT_ENV_VAR, isSecureConnection);
		
		final ManagementWebServiceInstaller webuiInstaller = new ManagementWebServiceInstaller();
		webuiInstaller.setAdmin(agent.getAdmin());
		webuiInstaller.setVerbose(verbose);
		webuiInstaller.setProgress(progressInSeconds, TimeUnit.SECONDS);
		webuiInstaller.setMemory(webuiMemory, MemoryUnit.MEGABYTES);
		webuiInstaller.setPort(webuiPort);
		webuiInstaller.setWarFile(new File(WEBUI_FILE));
		webuiInstaller.setServiceName(WEBUI_NAME);
		webuiInstaller.setManagementZone(MANAGEMENT_ZONE);
		webuiInstaller.addListeners(this.eventsListenersList);
		webuiInstaller.setIsLocalCloud(isLocalCloud);
		webuiInstaller.setIsSecureConnection(isSecureConnection);
		webuiInstaller.setLrmiCommandLineArgument(gscLrmiCommandLineArg);
		
		try {
			webuiInstaller.installWebService();
		} catch (final ProcessingUnitAlreadyDeployedException e) {
			if (verbose) {
				logger.fine("Service " + WEBUI_NAME + " already installed");
				publishEvent("Service " + WEBUI_NAME + " already installed");
			}
		}
		if (waitForWebUi) {
			waitForManagementServices.add(webuiInstaller);
		} else {
			webuiInstaller.logServiceLocation();
		}
		int restPort = getWebservicePort(CloudifyConstants.REST_PORT_ENV_VAR, isSecureConnection);
		long webServiceMemory = getWebServiceMemory(CloudifyConstants.REST_MAX_MEMORY_ENVIRONMENT_VAR);
		
		final ManagementWebServiceInstaller restInstaller = new ManagementWebServiceInstaller();
		restInstaller.setAdmin(agent.getAdmin());
		restInstaller.setProgress(progressInSeconds, TimeUnit.SECONDS);
		restInstaller.setVerbose(verbose);
		restInstaller.setMemory(webServiceMemory, MemoryUnit.MEGABYTES);
		restInstaller.setPort(restPort);
		restInstaller.setUsername(username);
		restInstaller.setPassword(password);
		restInstaller.setWarFile(new File(REST_FILE));
		restInstaller.setServiceName(REST_NAME);
		restInstaller.setManagementZone(MANAGEMENT_ZONE);
		restInstaller.dependencies.add(CloudifyConstants.MANAGEMENT_SPACE_NAME);
		restInstaller.setWaitForConnection();
		restInstaller.addListeners(this.eventsListenersList);
		restInstaller.setIsLocalCloud(isLocalCloud);
		restInstaller.setIsSecureConnection(isSecureConnection);
		restInstaller.setLrmiCommandLineArgument(gscLrmiCommandLineArg);
		
		try {
			restInstaller.installWebService();
		} catch (final ProcessingUnitAlreadyDeployedException e) {
			if (verbose) {
				logger.fine("Service " + REST_NAME + " already installed");
				publishEvent("Service " + REST_NAME + " already installed");
			}
		}
		waitForManagementServices.add(restInstaller);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893512/fstmerge_base_2076164635407495871
private void installWebServices(final String username, final String password, final boolean isLocalCloud,
			final boolean isSecureConnection, final GridServiceAgent agent, 
			final List<AbstractManagementServiceInstaller> waitForManagementServices)
			throws CLIException {
		final ManagementWebServiceInstaller webuiInstaller = new ManagementWebServiceInstaller();
		webuiInstaller.setAdmin(agent.getAdmin());
		webuiInstaller.setVerbose(verbose);
		webuiInstaller.setProgress(progressInSeconds, TimeUnit.SECONDS);
		webuiInstaller.setMemory(getWebServiceMemory(CloudifyConstants.WEBUI_MAX_MEMORY_ENVIRONMENT_VAR), MemoryUnit.MEGABYTES);
		webuiInstaller.setPort(getWebservicePort(CloudifyConstants.WEBUI_PORT_ENV_VAR, isSecureConnection));
		webuiInstaller.setWarFile(new File(WEBUI_FILE));
		webuiInstaller.setServiceName(WEBUI_NAME);
		webuiInstaller.setManagementZone(MANAGEMENT_ZONE);
		webuiInstaller.addListeners(this.eventsListenersList);
		webuiInstaller.setIsLocalCloud(isLocalCloud);
		webuiInstaller.setIsSecureConnection(isSecureConnection);
		
		try {
			webuiInstaller.installWebService();
		} catch (final ProcessingUnitAlreadyDeployedException e) {
			if (verbose) {
				logger.fine("Service " + WEBUI_NAME + " already installed");
				publishEvent("Service " + WEBUI_NAME + " already installed");
			}
		}
		if (waitForWebUi) {
			waitForManagementServices.add(webuiInstaller);
		} else {
			webuiInstaller.logServiceLocation();
		}
		final ManagementWebServiceInstaller restInstaller = new ManagementWebServiceInstaller();
		restInstaller.setAdmin(agent.getAdmin());
		restInstaller.setProgress(progressInSeconds, TimeUnit.SECONDS);
		restInstaller.setVerbose(verbose);
		restInstaller.setMemory(getWebServiceMemory(CloudifyConstants.REST_MAX_MEMORY_ENVIRONMENT_VAR), MemoryUnit.MEGABYTES);
		restInstaller.setPort(getWebservicePort(CloudifyConstants.REST_PORT_ENV_VAR, isSecureConnection));
		restInstaller.setUsername(username);
		restInstaller.setPassword(password);
		restInstaller.setWarFile(new File(REST_FILE));
		restInstaller.setServiceName(REST_NAME);
		restInstaller.setManagementZone(MANAGEMENT_ZONE);
		restInstaller.dependencies.add(CloudifyConstants.MANAGEMENT_SPACE_NAME);
		restInstaller.setWaitForConnection();
		restInstaller.addListeners(this.eventsListenersList);
		restInstaller.setIsLocalCloud(isLocalCloud);
		restInstaller.setIsSecureConnection(isSecureConnection);
		
		try {
			restInstaller.installWebService();
		} catch (final ProcessingUnitAlreadyDeployedException e) {
			if (verbose) {
				logger.fine("Service " + REST_NAME + " already installed");
				publishEvent("Service " + REST_NAME + " already installed");
			}
		}
		waitForManagementServices.add(restInstaller);
=======
private void installWebServices(final String username, final String password, final boolean isLocalCloud,
			final boolean isSecureConnection, final GridServiceAgent agent,
			final List<AbstractManagementServiceInstaller> waitForManagementServices)
			throws CLIException {
		final String gscLrmiCommandLineArg = getGscLrmiCommandLineArg();
		final long webuiMemory = getWebServiceMemory(CloudifyConstants.WEBUI_MAX_MEMORY_ENVIRONMENT_VAR);
		final int webuiPort = getWebservicePort(CloudifyConstants.WEBUI_PORT_ENV_VAR, isSecureConnection);

		final ManagementWebServiceInstaller webuiInstaller = new ManagementWebServiceInstaller();
		webuiInstaller.setAdmin(agent.getAdmin());
		webuiInstaller.setVerbose(verbose);
		webuiInstaller.setProgress(progressInSeconds, TimeUnit.SECONDS);
		webuiInstaller.setMemory(webuiMemory, MemoryUnit.MEGABYTES);
		webuiInstaller.setPort(webuiPort);
		webuiInstaller.setWarFile(new File(WEBUI_FILE));
		webuiInstaller.setServiceName(WEBUI_NAME);
		webuiInstaller.setManagementZone(MANAGEMENT_ZONE);
		webuiInstaller.addListeners(this.eventsListenersList);
		webuiInstaller.setIsLocalCloud(isLocalCloud);
		webuiInstaller.setIsSecureConnection(isSecureConnection);
		webuiInstaller.setLrmiCommandLineArgument(gscLrmiCommandLineArg);

		try {
			webuiInstaller.installWebService();
		} catch (final ProcessingUnitAlreadyDeployedException e) {
			if (verbose) {
				logger.fine("Service " + WEBUI_NAME + " already installed");
				publishEvent("Service " + WEBUI_NAME + " already installed");
			}
		}
		if (waitForWebUi) {
			waitForManagementServices.add(webuiInstaller);
		} else {
			webuiInstaller.logServiceLocation();
		}
		final int restPort = getWebservicePort(CloudifyConstants.REST_PORT_ENV_VAR, isSecureConnection);
		final long webServiceMemory = getWebServiceMemory(CloudifyConstants.REST_MAX_MEMORY_ENVIRONMENT_VAR);

		final ManagementWebServiceInstaller restInstaller = new ManagementWebServiceInstaller();
		restInstaller.setAdmin(agent.getAdmin());
		restInstaller.setProgress(progressInSeconds, TimeUnit.SECONDS);
		restInstaller.setVerbose(verbose);
		restInstaller.setMemory(webServiceMemory, MemoryUnit.MEGABYTES);
		restInstaller.setPort(restPort);
		restInstaller.setUsername(username);
		restInstaller.setPassword(password);
		restInstaller.setWarFile(new File(REST_FILE));
		restInstaller.setServiceName(REST_NAME);
		restInstaller.setManagementZone(MANAGEMENT_ZONE);
		restInstaller.dependencies.add(CloudifyConstants.MANAGEMENT_SPACE_NAME);
		restInstaller.setWaitForConnection();
		restInstaller.addListeners(this.eventsListenersList);
		restInstaller.setIsLocalCloud(isLocalCloud);
		restInstaller.setIsSecureConnection(isSecureConnection);
		restInstaller.setLrmiCommandLineArgument(gscLrmiCommandLineArg);

		try {
			restInstaller.installWebService();
		} catch (final ProcessingUnitAlreadyDeployedException e) {
			if (verbose) {
				logger.fine("Service " + REST_NAME + " already installed");
				publishEvent("Service " + REST_NAME + " already installed");
			}
		}
		waitForManagementServices.add(restInstaller);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893512/fstmerge_var2_5402437364771860474
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893516/fstmerge_var1_4445123145612421234
private long getWebServiceMemory(final String memoryEnvironmentVar) {
		long memory;
		String memoryString = System.getenv().get(memoryEnvironmentVar);
		if (org.apache.commons.lang.StringUtils.isNotBlank(memoryString)) {
			memory = getMemoryFromMemoryString(memoryString);
		} else {
			if (memoryEnvironmentVar.equals(CloudifyConstants.REST_MAX_MEMORY_ENVIRONMENT_VAR)) {
				memory = getMemoryFromMemoryString(CloudifyConstants.DEFAULT_REST_MAX_MEMORY);
			} else {
				memory = getMemoryFromMemoryString(CloudifyConstants.DEFAULT_REST_MIN_MEMORY);
			}
		}
		return memory;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893516/fstmerge_base_7743386012255232465
private long getWebServiceMemory(String memoryEnvironmentVar) {
		String memoryString = System.getenv().get(memoryEnvironmentVar);
		if (org.apache.commons.lang.StringUtils.isNotBlank(memoryString)) {
			return Integer.parseInt(memoryString.substring(0, memoryString.length() - 1));
		} else {
			if (memoryEnvironmentVar.equals(CloudifyConstants.REST_MAX_MEMORY_ENVIRONMENT_VAR)) {
				return REST_MEMORY_IN_MB;
			}
		}
		return WEBUI_MEMORY_IN_MB;
		
=======
private long getWebServiceMemory(final String memoryEnvironmentVar) {
		long memory;
		final String memoryString = System.getenv().get(memoryEnvironmentVar);
		if (org.apache.commons.lang.StringUtils.isNotBlank(memoryString)) {
			memory = getMemoryFromMemoryString(memoryString);
		} else {
			if (memoryEnvironmentVar.equals(CloudifyConstants.REST_MAX_MEMORY_ENVIRONMENT_VAR)) {
				memory = getMemoryFromMemoryString(CloudifyConstants.DEFAULT_REST_MAX_MEMORY);
			} else {
				memory = getMemoryFromMemoryString(CloudifyConstants.DEFAULT_REST_MIN_MEMORY);
			}
		}
		return memory;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893516/fstmerge_var2_4120131476020069250
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893520/fstmerge_var1_2987375691871764045
private long getMemoryFromMemoryString(String memoryString) {
		return Long.parseLong(memoryString.substring(0, memoryString.length() - 1));
	}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893520/fstmerge_base_6691103771522523989
=======
private long getMemoryFromMemoryString(final String memoryString) {
		return Long.parseLong(memoryString.substring(0, memoryString.length() - 1));
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893520/fstmerge_var2_8234958419221960248

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893523/fstmerge_var1_4664637423994905933
private int getWebservicePort(String portEnvVriable, boolean isSecureConnection) {
		String port = System.getenv().get(portEnvVriable);
		if (org.apache.commons.lang.StringUtils.isNotBlank(port)) {
			return Integer.parseInt(port);
		} 
		if (portEnvVriable.equals(CloudifyConstants.WEBUI_PORT_ENV_VAR)) {
			if (isSecureConnection){
				return CloudifyConstants.SECURE_WEBUI_PORT;
			} else {
				return CloudifyConstants.DEFAULT_WEBUI_PORT;
			}
		} else {
			if (isSecureConnection){
				return CloudifyConstants.SECURE_REST_PORT;
			} else {
				return CloudifyConstants.DEFAULT_REST_PORT;
			}
		}
		
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893523/fstmerge_base_8155207356011573355
private int getWebservicePort(String portEnvVriable, boolean isSecureConnection) {
		String port = System.getenv().get(portEnvVriable);
		if (org.apache.commons.lang.StringUtils.isNotBlank(port)) {
			return Integer.parseInt(port);
		} 
		if (portEnvVriable.equals(CloudifyConstants.WEBUI_PORT_ENV_VAR)) {
			if (isSecureConnection){
				return CloudifyConstants.SECURE_WEBUI_PORT;
			} else {
				return CloudifyConstants.DEFAULT_WEBUI_PORT;
			}
		} else {
			if (isSecureConnection){
				return CloudifyConstants.SECURE_REST_PORT;
			} else {
				return CloudifyConstants.DEFAULT_REST_PORT;
			}
		}
		
=======
private int getWebservicePort(final String portEnvVriable, final boolean isSecureConnection) {
		final String port = System.getenv().get(portEnvVriable);
		if (org.apache.commons.lang.StringUtils.isNotBlank(port)) {
			return Integer.parseInt(port);
		}
		if (portEnvVriable.equals(CloudifyConstants.WEBUI_PORT_ENV_VAR)) {
			if (isSecureConnection) {
				return CloudifyConstants.SECURE_WEBUI_PORT;
			} else {
				return CloudifyConstants.DEFAULT_WEBUI_PORT;
			}
		} else {
			if (isSecureConnection) {
				return CloudifyConstants.SECURE_REST_PORT;
			} else {
				return CloudifyConstants.DEFAULT_REST_PORT;
			}
		}

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893523/fstmerge_var2_3053598595747598301
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893544/fstmerge_var1_6249037038004896503
public void startAgentOnLocalhostAndWait(final String securityProfile, final String keystorePassword,
			final long timeout, final TimeUnit timeunit) throws CLIException, InterruptedException, TimeoutException {

		setIsLocalCloud(false);

		setDefaultNicAddress();

		final ConnectionLogsFilter connectionLogs = new ConnectionLogsFilter();
		connectionLogs.supressConnectionErrors();
		final Admin admin = createAdmin();
		try {
			setLookupDefaults(admin);

			try {
				waitForExistingAgent(admin, WAIT_EXISTING_AGENT_TIMEOUT_SECONDS, TimeUnit.SECONDS);
				throw new CLIException("Agent already running on local machine. Use shutdown-agent first.");
			} catch (final TimeoutException e) {
				// no existing agent running on local machine
			}
			runGsAgentOnLocalHost("agent", AGENT_ARGUMENTS, securityProfile, "" /*securityFilePath*/,
					"" /*keystoreFilePath*/, keystorePassword);

			// wait for agent to start
			waitForNewAgent(admin, timeout, timeunit);
		} finally {
			admin.close();
			connectionLogs.restoreConnectionErrors();
		}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893544/fstmerge_base_2121123159282195575
public void startAgentOnLocalhostAndWait(final String securityProfile, final String keystorePassword,
			final long timeout, final TimeUnit timeunit) throws CLIException, InterruptedException, TimeoutException {

		setIsLocalCloud(false);

		setDefaultNicAddress();

		final ConnectionLogsFilter connectionLogs = new ConnectionLogsFilter();
		connectionLogs.supressConnectionErrors();
		final Admin admin = createAdmin();
		try {
			setLookupDefaults(admin);

			try {
				waitForExistingAgent(admin, WAIT_EXISTING_AGENT_TIMEOUT_SECONDS, TimeUnit.SECONDS);
				throw new CLIException("Agent already running on local machine. Use shutdown-agent first.");
			} catch (final TimeoutException e) {
				// no existing agent running on local machine
			}
			runGsAgentOnLocalHost("agent", AGENT_ARGUMENTS, securityProfile, "" /*securityFilePath*/,
					"" /*keystoreFilePath*/, keystorePassword);

			// wait for agent to start
			waitForNewAgent(admin, timeout, timeunit);
		} finally {
			admin.close();
			connectionLogs.restoreConnectionErrors();
		}
=======
public void startAgentOnLocalhostAndWait(final String securityProfile, final String keystorePassword,
			final long timeout, final TimeUnit timeunit) throws CLIException, InterruptedException, TimeoutException {

		setIsLocalCloud(false);

		setDefaultNicAddress();

		final ConnectionLogsFilter connectionLogs = new ConnectionLogsFilter();
		connectionLogs.supressConnectionErrors();
		final Admin admin = createAdmin();
		try {
			setLookupDefaults(admin);

			try {
				waitForExistingAgent(admin, WAIT_EXISTING_AGENT_TIMEOUT_SECONDS, TimeUnit.SECONDS);
				throw new CLIException("Agent already running on local machine. Use shutdown-agent first.");
			} catch (final TimeoutException e) {
				// no existing agent running on local machine
			}
			runGsAgentOnLocalHost("agent", AGENT_ARGUMENTS, securityProfile, "" /* securityFilePath */,
					"" /* keystoreFilePath */, keystorePassword);

			// wait for agent to start
			waitForNewAgent(admin, timeout, timeunit);
		} finally {
			admin.close();
			connectionLogs.restoreConnectionErrors();
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893544/fstmerge_var2_6510785053144815794
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893573/fstmerge_var1_5526332767803948384
private void runCommand(final String[] command, final String[] args, final String securityProfile,
			final String securityFilePath, final String keystoreFilePath, final String keystorePassword) 
					throws CLIException, InterruptedException {

		final File directory = new File(Environment.getHomeDirectory(), "/bin").getAbsoluteFile();

		// gs-agent.sh/bat need full path
		command[command.length - 1] = new File(directory, command[command.length - 1]).getAbsolutePath();

		final List<String> commandLine = new ArrayList<String>();
		commandLine.addAll(Arrays.asList(command));
		commandLine.addAll(Arrays.asList(args));

		final String commandString = StringUtils.collectionToDelimitedString(commandLine, " ");
		final File filename = createScript(commandString);
		final ProcessBuilder pb = new ProcessBuilder().command(filename.getAbsolutePath()).directory(directory);

		String localCloudOptions = "-Xmx" + CloudifyConstants.DEFAULT_LOCALCLOUD_GSA_GSM_ESM_LUS_MEMORY_IN_MB + "m" + " -D" + CloudifyConstants.LUS_PORT_CONTEXT_PROPERTY + "="
				+ lusPort + " -D" + GSM_EXCLUDE_GSC_ON_FAILED_INSTANCE + "=" + GSM_EXCLUDE_GSC_ON_FAILED_INSTACE_BOOL
				+ " " + GSM_PENDING_REQUESTS_DELAY + " -D" + ZONES_PROPERTY + "=" + gsaZones;

		String gsaJavaOptions = "-Xmx" + CloudifyConstants.DEFAULT_AGENT_MAX_MEMORY;
		if (gsaZones != null) {
			gsaJavaOptions += " -D" + ZONES_PROPERTY + "=" + gsaZones;
		}
		if (autoShutdown) {
			gsaJavaOptions += " " + AUTO_SHUTDOWN_COMMANDLINE_ARGUMENT;
		}
		String lusJavaOptions = "-Xmx" + CloudifyConstants.DEFAULT_LUS_MAX_MEMORY + " -D" + CloudifyConstants.LUS_PORT_CONTEXT_PROPERTY + "=" + lusPort
				+ " -D" + ZONES_PROPERTY + "=" + MANAGEMENT_ZONE;
		String gsmJavaOptions = "-Xmx" + CloudifyConstants.DEFAULT_GSM_MAX_MEMORY + " -D" + CloudifyConstants.LUS_PORT_CONTEXT_PROPERTY + "=" + lusPort
				+ " -D" + GSM_EXCLUDE_GSC_ON_FAILED_INSTANCE + "=" + GSM_EXCLUDE_GSC_ON_FAILED_INSTACE_BOOL + " -D"
				+ ZONES_PROPERTY + "=" + MANAGEMENT_ZONE + " " + GSM_PENDING_REQUESTS_DELAY;
		String esmJavaOptions = "-Xmx" + CloudifyConstants.DEFAULT_ESM_MAX_MEMORY + " -D" + ZONES_PROPERTY + "=" + MANAGEMENT_ZONE;
		String gscJavaOptions = "";

		final Map<String, String> environment = pb.environment();
		if (lookupGroups != null) {
			environment.put("LOOKUPGROUPS", lookupGroups);
		}

		if (lookupLocators != null) {
			final String disableMulticast = "-Dcom.gs.multicast.enabled=false";
			environment.put("LOOKUPLOCATORS", lookupLocators);
			gsaJavaOptions += " " + disableMulticast;
			lusJavaOptions += " " + disableMulticast;
			gsmJavaOptions += " " + disableMulticast;
			esmJavaOptions += " " + disableMulticast;
			gscJavaOptions += " " + disableMulticast;
			localCloudOptions += " " + disableMulticast;
		}
		// in case environment vars were defined,
		// They will override the existing component java options.  
		gsaJavaOptions += " " + environment.get("GSA_JAVA_OPTIONS") == null ? "" : environment.get("GSA_JAVA_OPTIONS");
		lusJavaOptions += " " + environment.get("LUS_JAVA_OPTIONS") == null ? "" : environment.get("LUS_JAVA_OPTIONS");
		gsmJavaOptions += " " + environment.get("GSM_JAVA_OPTIONS") == null ? "" : environment.get("GSM_JAVA_OPTIONS");
		esmJavaOptions += " " + environment.get("ESM_JAVA_OPTIONS") == null ? "" : environment.get("ESM_JAVA_OPTIONS");
		gscJavaOptions += " " + environment.get("GSC_JAVA_OPTIONS") == null ? "" : environment.get("GSC_JAVA_OPTIONS");
		
		if (nicAddress != null) {
			environment.put("NIC_ADDR", nicAddress);
		}
		environment.put("RMI_OPTIONS", "");
		logger.fine("Setting env var " + CloudifyConstants.SPRING_ACTIVE_PROFILE_ENV_VAR + " to: " + securityProfile);
		environment.put(CloudifyConstants.SPRING_ACTIVE_PROFILE_ENV_VAR, securityProfile);
		if (ShellUtils.isSecureConnection(securityProfile)) {
			logger.fine("Setting env var " + CloudifyConstants.KEYSTORE_FILE_ENV_VAR + " to: " + keystoreFilePath);
			environment.put(CloudifyConstants.KEYSTORE_FILE_ENV_VAR, keystoreFilePath);
			logger.fine("Setting env var " + CloudifyConstants.KEYSTORE_PASSWORD_ENV_VAR + " to: " + keystorePassword);
			environment.put(CloudifyConstants.KEYSTORE_PASSWORD_ENV_VAR, keystorePassword);	
		}
		logger.fine("Setting env var " + CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR + " to: " + securityFilePath);
		environment.put(CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR, securityFilePath);

		if (isLocalCloud) {
			logger.fine("Setting env vars COMPONENT_JAVA_OPTIONS: " + localCloudOptions);
			environment.put("COMPONENT_JAVA_OPTIONS", localCloudOptions);
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_HARDWARE_ID, "localcloud");
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_IMAGE_ID, "localcloud");
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_TEMPLATE_NAME, "localcloud");
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_MACHINE_ID, "localcloud");
			if (nicAddress != null) {
				environment.put(CloudifyConstants.GIGASPACES_AGENT_ENV_PRIVATE_IP, nicAddress);
				environment.put(CloudifyConstants.GIGASPACES_AGENT_ENV_PUBLIC_IP, nicAddress);
			}
		} else {
			logger.fine("Setting env vars " + "GSA_JAVA_OPTIONS: gsaJavaOptions" + gsaJavaOptions 
					+ "; LUS_JAVA_OPTIONS: " + lusJavaOptions + "; GSM_JAVA_OPTIONS: " + gsmJavaOptions 
					+ "; ESM_JAVA_OPTIONS: " + esmJavaOptions + "; GSC_JAVA_OPTIONS: " + gscJavaOptions);
			environment.put("GSA_JAVA_OPTIONS", gsaJavaOptions);
			environment.put("LUS_JAVA_OPTIONS", lusJavaOptions);
			environment.put("GSM_JAVA_OPTIONS", gsmJavaOptions);
			environment.put("ESM_JAVA_OPTIONS", esmJavaOptions);
			environment.put("GSC_JAVA_OPTIONS", gscJavaOptions);
		}
		// start process
		// there is no need to redirect output, since the process suppresses
		// output
		try {
			logger.fine("Executing command: " + commandString);
			final Process proc = pb.start();
			Thread.sleep(MIN_PROC_ERROR_TIME);
			try {
				// The assumption is that if the script contains errors,
				// the processBuilder will finish by the end of the above sleep
				// period.
				if (proc.exitValue() != 0) {
					String errorMessage = "Error while starting agent. "
							+ "Please make sure that another agent is not already running. ";
					if (verbose) {
						errorMessage = errorMessage.concat("Command executed: " + commandString);
					}
					throw new CLIException(errorMessage);
				}
				// ProcessBuilder is still running. We assume the agent script
				// is running fine.
			} catch (final IllegalThreadStateException e) {
				logger.fine("agent is starting...");
			}
		} catch (final IOException e) {
			throw new CLIException("Error while starting agent", e);
		}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893573/fstmerge_base_6474597134732437376
private void runCommand(final String[] command, final String[] args, final String securityProfile,
			final String securityFilePath, final String keystoreFilePath, final String keystorePassword) 
					throws CLIException, InterruptedException {

		final File directory = new File(Environment.getHomeDirectory(), "/bin").getAbsoluteFile();

		// gs-agent.sh/bat need full path
		command[command.length - 1] = new File(directory, command[command.length - 1]).getAbsolutePath();

		final List<String> commandLine = new ArrayList<String>();
		commandLine.addAll(Arrays.asList(command));
		commandLine.addAll(Arrays.asList(args));

		final String commandString = StringUtils.collectionToDelimitedString(commandLine, " ");
		final File filename = createScript(commandString);
		final ProcessBuilder pb = new ProcessBuilder().command(filename.getAbsolutePath()).directory(directory);

		String localCloudOptions = "-Xmx" + LOCALCLOUD_MEMORY_IN_MB + "m" + " -D" + CloudifyConstants.LUS_PORT_CONTEXT_PROPERTY + "="
				+ lusPort + " -D" + GSM_EXCLUDE_GSC_ON_FAILED_INSTANCE + "=" + GSM_EXCLUDE_GSC_ON_FAILED_INSTACE_BOOL
				+ " " + GSM_PENDING_REQUESTS_DELAY + " -D" + ZONES_PROPERTY + "=" + gsaZones;

		String gsaJavaOptions = "-Xmx" + GSA_MEMORY_IN_MB + "m";
		if (gsaZones != null) {
			gsaJavaOptions += " -D" + ZONES_PROPERTY + "=" + gsaZones;
		}
		if (autoShutdown) {
			gsaJavaOptions += " " + AUTO_SHUTDOWN_COMMANDLINE_ARGUMENT;
		}
		String lusJavaOptions = "-Xmx" + LUS_MEMORY_IN_MB + "m" + " -D" + CloudifyConstants.LUS_PORT_CONTEXT_PROPERTY + "=" + lusPort
				+ " -D" + ZONES_PROPERTY + "=" + MANAGEMENT_ZONE;
		String gsmJavaOptions = "-Xmx" + GSM_MEMORY_IN_MB + "m" + " -D" + CloudifyConstants.LUS_PORT_CONTEXT_PROPERTY + "=" + lusPort
				+ " -D" + GSM_EXCLUDE_GSC_ON_FAILED_INSTANCE + "=" + GSM_EXCLUDE_GSC_ON_FAILED_INSTACE_BOOL + " -D"
				+ ZONES_PROPERTY + "=" + MANAGEMENT_ZONE + " " + GSM_PENDING_REQUESTS_DELAY;
		String esmJavaOptions = "-Xmx" + ESM_MEMORY_IN_MB + "m" + " -D" + ZONES_PROPERTY + "=" + MANAGEMENT_ZONE;
		String gscJavaOptions = "";

		final Map<String, String> environment = pb.environment();
		if (lookupGroups != null) {
			environment.put("LOOKUPGROUPS", lookupGroups);
		}

		if (lookupLocators != null) {
			final String disableMulticast = "-Dcom.gs.multicast.enabled=false";
			environment.put("LOOKUPLOCATORS", lookupLocators);
			gsaJavaOptions += " " + disableMulticast;
			lusJavaOptions += " " + disableMulticast;
			gsmJavaOptions += " " + disableMulticast;
			esmJavaOptions += " " + disableMulticast;
			gscJavaOptions += " " + disableMulticast;
			localCloudOptions += " " + disableMulticast;
		}
		// in case environment vars were defined,
		// They will override the existing component java options.  
		gsaJavaOptions += " " + environment.get("GSA_JAVA_OPTIONS") == null ? "" : environment.get("GSA_JAVA_OPTIONS");
		lusJavaOptions += " " + environment.get("LUS_JAVA_OPTIONS") == null ? "" : environment.get("LUS_JAVA_OPTIONS");
		gsmJavaOptions += " " + environment.get("GSM_JAVA_OPTIONS") == null ? "" : environment.get("GSM_JAVA_OPTIONS");
		esmJavaOptions += " " + environment.get("ESM_JAVA_OPTIONS") == null ? "" : environment.get("ESM_JAVA_OPTIONS");
		gscJavaOptions += " " + environment.get("GSC_JAVA_OPTIONS") == null ? "" : environment.get("GSC_JAVA_OPTIONS");
		
		if (nicAddress != null) {
			environment.put("NIC_ADDR", nicAddress);
		}
		environment.put("RMI_OPTIONS", "");
		logger.fine("Setting env var " + CloudifyConstants.SPRING_ACTIVE_PROFILE_ENV_VAR + " to: " + securityProfile);
		environment.put(CloudifyConstants.SPRING_ACTIVE_PROFILE_ENV_VAR, securityProfile);
		if (ShellUtils.isSecureConnection(securityProfile)) {
			logger.fine("Setting env var " + CloudifyConstants.KEYSTORE_FILE_ENV_VAR + " to: " + keystoreFilePath);
			environment.put(CloudifyConstants.KEYSTORE_FILE_ENV_VAR, keystoreFilePath);
			logger.fine("Setting env var " + CloudifyConstants.KEYSTORE_PASSWORD_ENV_VAR + " to: " + keystorePassword);
			environment.put(CloudifyConstants.KEYSTORE_PASSWORD_ENV_VAR, keystorePassword);	
		}
		logger.fine("Setting env var " + CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR + " to: " + securityFilePath);
		environment.put(CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR, securityFilePath);

		if (isLocalCloud) {
			environment.put("COMPONENT_JAVA_OPTIONS", localCloudOptions);
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_HARDWARE_ID, "localcloud");
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_IMAGE_ID, "localcloud");
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_TEMPLATE_NAME, "localcloud");
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_MACHINE_ID, "localcloud");
			if (nicAddress != null) {
				environment.put(CloudifyConstants.GIGASPACES_AGENT_ENV_PRIVATE_IP, nicAddress);
				environment.put(CloudifyConstants.GIGASPACES_AGENT_ENV_PUBLIC_IP, nicAddress);
			}

		} else {
			environment.put("GSA_JAVA_OPTIONS", gsaJavaOptions);
			environment.put("LUS_JAVA_OPTIONS", lusJavaOptions);
			environment.put("GSM_JAVA_OPTIONS", gsmJavaOptions);
			environment.put("ESM_JAVA_OPTIONS", esmJavaOptions);
			environment.put("GSC_JAVA_OPTIONS", gscJavaOptions);
		}
		// start process
		// there is no need to redirect output, since the process suppresses
		// output
		try {
			logger.fine("Executing command: " + commandString);
			final Process proc = pb.start();
			Thread.sleep(MIN_PROC_ERROR_TIME);
			try {
				// The assumption is that if the script contains errors,
				// the processBuilder will finish by the end of the above sleep
				// period.
				if (proc.exitValue() != 0) {
					String errorMessage = "Error while starting agent. "
							+ "Please make sure that another agent is not already running. ";
					if (verbose) {
						errorMessage = errorMessage.concat("Command executed: " + commandString);
					}
					throw new CLIException(errorMessage);
				}
				// ProcessBuilder is still running. We assume the agent script
				// is running fine.
			} catch (final IllegalThreadStateException e) {
				logger.fine("agent is starting...");
			}
		} catch (final IOException e) {
			throw new CLIException("Error while starting agent", e);
		}
=======
private void runCommand(final String[] command, final String[] args, final String securityProfile,
			final String securityFilePath, final String keystoreFilePath, final String keystorePassword)
			throws CLIException, InterruptedException {

		final File directory = new File(Environment.getHomeDirectory(), "/bin").getAbsoluteFile();

		// gs-agent.sh/bat need full path
		command[command.length - 1] = new File(directory, command[command.length - 1]).getAbsolutePath();

		final List<String> commandLine = new ArrayList<String>();
		commandLine.addAll(Arrays.asList(command));
		commandLine.addAll(Arrays.asList(args));

		final String commandString = StringUtils.collectionToDelimitedString(commandLine, " ");
		final File filename = createScript(commandString);
		final ProcessBuilder pb = new ProcessBuilder().command(filename.getAbsolutePath()).directory(directory);

		String localCloudOptions =
				"-Xmx" + CloudifyConstants.DEFAULT_LOCALCLOUD_GSA_GSM_ESM_LUS_MEMORY_IN_MB + "m" + " -D"
						+ CloudifyConstants.LUS_PORT_CONTEXT_PROPERTY + "="
						+ lusPort + " -D" + GSM_EXCLUDE_GSC_ON_FAILED_INSTANCE + "="
						+ GSM_EXCLUDE_GSC_ON_FAILED_INSTACE_BOOL
						+ " " + GSM_PENDING_REQUESTS_DELAY + " -D" + ZONES_PROPERTY + "=" + gsaZones;

		String gsaJavaOptions = "-Xmx" + CloudifyConstants.DEFAULT_AGENT_MAX_MEMORY;
		if (gsaZones != null) {
			gsaJavaOptions += " -D" + ZONES_PROPERTY + "=" + gsaZones;
		}
		if (autoShutdown) {
			gsaJavaOptions += " " + AUTO_SHUTDOWN_COMMANDLINE_ARGUMENT;
		}
		String lusJavaOptions =
				"-Xmx" + CloudifyConstants.DEFAULT_LUS_MAX_MEMORY + " -D" + CloudifyConstants.LUS_PORT_CONTEXT_PROPERTY
						+ "=" + lusPort
						+ " -D" + ZONES_PROPERTY + "=" + MANAGEMENT_ZONE;
		String gsmJavaOptions =
				"-Xmx" + CloudifyConstants.DEFAULT_GSM_MAX_MEMORY + " -D" + CloudifyConstants.LUS_PORT_CONTEXT_PROPERTY
						+ "=" + lusPort
						+ " -D" + GSM_EXCLUDE_GSC_ON_FAILED_INSTANCE + "=" + GSM_EXCLUDE_GSC_ON_FAILED_INSTACE_BOOL
						+ " -D"
						+ ZONES_PROPERTY + "=" + MANAGEMENT_ZONE + " " + GSM_PENDING_REQUESTS_DELAY;
		if (!this.isLocalCloud) {
			final String persistentStoragePath = this.cloud.getConfiguration().getPersistentStoragePath();
			if (persistentStoragePath != null) {
				final String gsmStoragePath = persistentStoragePath + "/gsm";
				gsmJavaOptions = gsmJavaOptions + " com.gs.persistency.logDirectory=" + gsmStoragePath;
			}
		}

		String esmJavaOptions =
				"-Xmx" + CloudifyConstants.DEFAULT_ESM_MAX_MEMORY + " -D" + ZONES_PROPERTY + "=" + MANAGEMENT_ZONE;
		String gscJavaOptions = "";

		final Map<String, String> environment = pb.environment();
		if (lookupGroups != null) {
			environment.put("LOOKUPGROUPS", lookupGroups);
		}

		if (lookupLocators != null) {
			final String disableMulticast = "-Dcom.gs.multicast.enabled=false";
			environment.put("LOOKUPLOCATORS", lookupLocators);
			gsaJavaOptions += " " + disableMulticast;
			lusJavaOptions += " " + disableMulticast;
			gsmJavaOptions += " " + disableMulticast;
			esmJavaOptions += " " + disableMulticast;
			gscJavaOptions += " " + disableMulticast;
			localCloudOptions += " " + disableMulticast;
		}
		// in case environment vars were defined,
		// They will override the existing component java options.
		gsaJavaOptions += " " + environment.get("GSA_JAVA_OPTIONS") == null ? "" : environment.get("GSA_JAVA_OPTIONS");
		lusJavaOptions += " " + environment.get("LUS_JAVA_OPTIONS") == null ? "" : environment.get("LUS_JAVA_OPTIONS");
		gsmJavaOptions += " " + environment.get("GSM_JAVA_OPTIONS") == null ? "" : environment.get("GSM_JAVA_OPTIONS");
		esmJavaOptions += " " + environment.get("ESM_JAVA_OPTIONS") == null ? "" : environment.get("ESM_JAVA_OPTIONS");
		gscJavaOptions += " " + environment.get("GSC_JAVA_OPTIONS") == null ? "" : environment.get("GSC_JAVA_OPTIONS");

		if (nicAddress != null) {
			environment.put("NIC_ADDR", nicAddress);
		}
		environment.put("RMI_OPTIONS", "");

		final String springProfiles = createSpringProfilesList(securityProfile);
		logger.fine("Setting env var " + CloudifyConstants.SPRING_ACTIVE_PROFILE_ENV_VAR + " to: " + springProfiles);
		environment.put(CloudifyConstants.SPRING_ACTIVE_PROFILE_ENV_VAR, springProfiles);
		if (ShellUtils.isSecureConnection(securityProfile)) {
			logger.fine("Setting env var " + CloudifyConstants.KEYSTORE_FILE_ENV_VAR + " to: " + keystoreFilePath);
			environment.put(CloudifyConstants.KEYSTORE_FILE_ENV_VAR, keystoreFilePath);
			logger.fine("Setting env var " + CloudifyConstants.KEYSTORE_PASSWORD_ENV_VAR + " to: " + keystorePassword);
			environment.put(CloudifyConstants.KEYSTORE_PASSWORD_ENV_VAR, keystorePassword);
		}
		logger.fine("Setting env var " + CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR + " to: "
				+ securityFilePath);
		environment.put(CloudifyConstants.SPRING_SECURITY_CONFIG_FILE_ENV_VAR, securityFilePath);

		if (isLocalCloud) {
			logger.fine("Setting env vars COMPONENT_JAVA_OPTIONS: " + localCloudOptions);
			environment.put("COMPONENT_JAVA_OPTIONS", localCloudOptions);
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_HARDWARE_ID, "localcloud");
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_IMAGE_ID, "localcloud");
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_TEMPLATE_NAME, "localcloud");
			environment.put(CloudifyConstants.GIGASPACES_CLOUD_MACHINE_ID, "localcloud");
			if (nicAddress != null) {
				environment.put(CloudifyConstants.GIGASPACES_AGENT_ENV_PRIVATE_IP, nicAddress);
				environment.put(CloudifyConstants.GIGASPACES_AGENT_ENV_PUBLIC_IP, nicAddress);
			}
		} else {
			logger.fine("Setting env vars " + "GSA_JAVA_OPTIONS: gsaJavaOptions" + gsaJavaOptions
					+ "; LUS_JAVA_OPTIONS: " + lusJavaOptions + "; GSM_JAVA_OPTIONS: " + gsmJavaOptions
					+ "; ESM_JAVA_OPTIONS: " + esmJavaOptions + "; GSC_JAVA_OPTIONS: " + gscJavaOptions);
			environment.put("GSA_JAVA_OPTIONS", gsaJavaOptions);
			environment.put("LUS_JAVA_OPTIONS", lusJavaOptions);
			environment.put("GSM_JAVA_OPTIONS", gsmJavaOptions);
			environment.put("ESM_JAVA_OPTIONS", esmJavaOptions);
			environment.put("GSC_JAVA_OPTIONS", gscJavaOptions);
		}
		// start process
		// there is no need to redirect output, since the process suppresses
		// output
		try {
			logger.fine("Executing command: " + commandString);
			final Process proc = pb.start();
			Thread.sleep(MIN_PROC_ERROR_TIME);
			try {
				// The assumption is that if the script contains errors,
				// the processBuilder will finish by the end of the above sleep
				// period.
				if (proc.exitValue() != 0) {
					String errorMessage = "Error while starting agent. "
							+ "Please make sure that another agent is not already running. ";
					if (verbose) {
						errorMessage = errorMessage.concat("Command executed: " + commandString);
					}
					throw new CLIException(errorMessage);
				}
				// ProcessBuilder is still running. We assume the agent script
				// is running fine.
			} catch (final IllegalThreadStateException e) {
				logger.fine("agent is starting...");
			}
		} catch (final IOException e) {
			throw new CLIException("Error while starting agent", e);
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893573/fstmerge_var2_8545222103805767754
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893612/fstmerge_var1_5517446629204387231
public void setCloudFilePath(final String cloudFilePath) {
		this.cloudFilePath = cloudFilePath;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893612/fstmerge_base_4529638442112819815
public void setCloudFilePath(final String cloudFilePath) {
		this.cloudFilePath = cloudFilePath;
=======
public void setCloudFilePath(final String cloudFilePath) {
		this.cloudFilePath = cloudFilePath;

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418617893612/fstmerge_var2_3996617181323167745
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f7be7_73143/rev_f7be7-73143/CLI/src/main/java/org/cloudifysource/shell/installer/LocalhostGridAgentBootstrapper.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_4c945_df2d7/rev_4c945-df2d7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_a03be_b8244/rev_a03be-b8244.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_144a2_815c3/rev_144a2-815c3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_be6ff_8db92/rev_be6ff-8db92.revisions
Conflict type: LineBasedMCFd
Conflict body: 
private void handleExceptionAfterMachineCreated(final String machineIp, final MachineDetails machineDetails,
			final long end) {
		VolumeDetails attachedVolume = null;
		boolean storageTemplateUsed = isStorageTemplateUsed();
		try {
			// if an agent is found (not supposed to, we got here after it wasn't found earlier) - shut it down
			boolean machineIpExists = machineIp != null && !machineIp.trim().isEmpty();
			if (machineIpExists) {
				try {
					final GridServiceAgent agent = getGSAByIpOrHost(machineIp);
					if (agent != null) {
						logger.info("handleExceptionAfterMachineCreated is shutting down agent: " + agent
								+ " on host: " + machineIp);

						agent.shutdown();
						logger.fine("Agent on host: " + machineIp + " successfully shut down");

					}
				} catch (final Exception e) {
					// even if shutting down the agent failed, this node will be shut down later
					logger.log(Level.WARNING, "Failed to shutdown agent on host: " + machineIp
							+ ". Continuing with shutdown of " + "machine.", e);
				}
				if (storageTemplateUsed) {
					logger.log(Level.INFO, "Getting attached volume details from machine with ip " + machineIp);
					long timeout = end - System.currentTimeMillis();
					attachedVolume = getAttachedVolumeDetails(machineIp, timeout, TimeUnit.MILLISECONDS);
				}
			}

			logger.info("Stopping machine " + machineDetails.getPrivateAddress()
					+ ", DEFAULT_SHUTDOWN_TIMEOUT_AFTER_PROVISION_FAILURE");
			this.cloudifyProvisioning.stopMachine(machineDetails.getPrivateAddress(),
					DEFAULT_SHUTDOWN_TIMEOUT_AFTER_PROVISION_FAILURE, TimeUnit.MINUTES);
			
			if (storageTemplateUsed) {
				if (machineIpExists && attachedVolume != null) {
					long timeout = end - System.currentTimeMillis();
					handleVolumeOnStopMachine(attachedVolume, timeout, TimeUnit.MILLISECONDS);
				} else {
					logger.log(Level.WARNING, "Failed detecting volume. Could not obtain volume details.");
				}
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618363439/fstmerge_var1_2800460919642290695
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618363439/fstmerge_base_647129020077941814
			} catch (StorageProvisioningException e) {
				logger.log(Level.SEVERE, "Failed detaching volume from machine with ip: " 
								+ machineIp + ". There may still be leaking volumes.", e);
=======
			} catch (StorageProvisioningException e) {
				logger.log(Level.SEVERE, "Failed detaching volume from machine with ip: "
								+ machineIp + ". There may still be leaking volumes.", e);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618363439/fstmerge_var2_5726927484320320602
			}
		} catch (final Exception e) {
			logger.log(
					Level.WARNING,
					"Machine Provisioning failed. "
							+ "An error was encountered while trying to shutdown the new machine ( "
							+ machineDetails.toString() + "). Error was: " + e.getMessage(), e);
		}
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_be6ff_8db92/rev_be6ff-8db92/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/ElasticMachineProvisioningCloudifyAdapter.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
	public boolean stopMachine(final GridServiceAgent agent, final long duration, final TimeUnit unit)
			throws ElasticMachineProvisioningException,
			ElasticGridServiceAgentProvisioningException,
			InterruptedException, TimeoutException {

		final long endTime = System.currentTimeMillis() + unit.toMillis(duration);
		final String machineIp = agent.getMachine().getHostAddress();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618363473/fstmerge_var1_7935094013565383307
		
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618363473/fstmerge_base_7117235629878715183
		try {
			if (isStorageTemplateUsed()) {
				handleVolumeOnStopMachine(machineIp, duration, unit);
			}
		} catch (StorageProvisioningException e) {
			logger.log(Level.SEVERE, "Failed detaching volume from machine with ip: " 
							+ machineIp + ". There may still be leaking volumes.", e);
		}
		
=======
		try {
			if (isStorageTemplateUsed()) {
				handleVolumeOnStopMachine(machineIp, duration, unit);
			}
		} catch (StorageProvisioningException e) {
			logger.log(Level.SEVERE, "Failed detaching volume from machine with ip: "
							+ machineIp + ". There may still be leaking volumes.", e);
		}

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618363473/fstmerge_var2_5667990503089414049
		Exception failedToShutdownAgentException = null;
		final GridServiceAgentStopRequestedEvent agentStopEvent = new GridServiceAgentStopRequestedEvent();
		agentStopEvent.setHostAddress(machineIp);
		agentStopEvent.setAgentUid(agent.getUid());
		agentEventListener.elasticGridServiceAgentProvisioningProgressChanged(agentStopEvent);

		logger.fine("Shutting down agent: " + agent + " on host: " + machineIp);
		try {
			agent.shutdown();
			logger.fine("Agent on host: " + machineIp + " successfully shut down");

			final GridServiceAgentStoppedEvent agentStoppedEvent = new GridServiceAgentStoppedEvent();
			agentStoppedEvent.setHostAddress(machineIp);
			agentStoppedEvent.setAgentUid(agent.getUid());
			agentEventListener.elasticGridServiceAgentProvisioningProgressChanged(agentStoppedEvent);
		} catch (final Exception e) {
			failedToShutdownAgentException = e;
			logger.log(Level.FINE, "Failed to shutdown agent on host: " + machineIp
					+ ". Continuing with shutdown of machine.", e);
		}

		try {

			final MachineStopRequestedEvent machineStopEvent = new MachineStopRequestedEvent();
			machineStopEvent.setHostAddress(machineIp);
			machineEventListener.elasticMachineProvisioningProgressChanged(machineStopEvent);
			
			boolean storageTemplateUsed = isStorageTemplateUsed();
			VolumeDetails attachedVolume = null;
			if (storageTemplateUsed) {
				logger.log(Level.INFO, "Getting attached volume details from machine with ip " + machineIp);
				attachedVolume = getAttachedVolumeDetails(machineIp, duration, unit);
			}

			logger.fine("Cloudify Adapter is shutting down machine with ip: " + machineIp);
			final boolean shutdownSuccessful = this.cloudifyProvisioning.stopMachine(machineIp, duration, unit);
			logger.fine("Shutdown result of machine: " + machineIp + " was: " + shutdownSuccessful);

			if (shutdownSuccessful) {
				final MachineStoppedEvent machineStoppedEvent = new MachineStoppedEvent();
				machineStoppedEvent.setHostAddress(machineIp);
				machineEventListener.elasticMachineProvisioningProgressChanged(machineStoppedEvent);

				// machine was shutdown, but an error happened while shutting down agent.
				// lets wait for the agent to not be discovered until we reach the timeout.

				while (agent.isDiscovered()) {
					Thread.sleep(DEFAULT_AGENT_DISCOVERY_INTERVAL);
					if (System.currentTimeMillis() > endTime && agent.isDiscovered()) {
						if (failedToShutdownAgentException != null) {
							throw new ElasticGridServiceAgentProvisioningException(
									"Machine is stopped but agent [" + agent.getUid() + "] is still discovered."
											+ "Failed to shutdown agent:" + failedToShutdownAgentException.getMessage(),
									failedToShutdownAgentException);
						}
						throw new ElasticGridServiceAgentProvisioningException(
								"Machine is stopped but agent[" + agent.getUid()
										+ "] is still discovered.");

					}
				}
			}
			
			// This step is not being done before shutting down the machine since it appears to 
			// make the the stop machine process significantly longer. The correct way of detaching and 
			// deleting a volume should be to first unmount the device, and then detach and delete. 
			//we don't support it for now.
			if (storageTemplateUsed) {
				if (attachedVolume != null) {
					handleVolumeOnStopMachine(attachedVolume, duration, unit);
				} else {
					logger.log(Level.WARNING, "Could not find an attached volume on machine with ip " + machineIp);
				}
			}
			
			return shutdownSuccessful;

		} catch (final CloudProvisioningException e) {
			throw new ElasticMachineProvisioningException("Attempt to shutdown machine with IP: " + machineIp
					+ " for agent with UID: " + agent.getUid() + " has failed with error: " + e.getMessage(), e);
		}
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_be6ff_8db92/rev_be6ff-8db92/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/ElasticMachineProvisioningCloudifyAdapter.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618363476/fstmerge_var1_2736075017024901386
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618363476/fstmerge_base_3405873025137713682
void handleVolumeOnStopMachine(final String machineIp, final long duration, 
			final TimeUnit unit) throws TimeoutException,
			StorageProvisioningException {
		logger.info("detaching all volumes attachet to machine with ip: " + machineIp);
		Set<VolumeDetails> attachedVolumes = this.storageProvisioning.listVolumes(machineIp, duration, unit);
		StorageTemplate storageTemplate = this.cloud.getCloudStorage().getTemplates().get(this.storageTemplateName);
		for (VolumeDetails volumeDetails : attachedVolumes) {
			String id = volumeDetails.getId();
			logger.info("getting volume name using volume id " + id);
			String volumeName = this.storageProvisioning.getVolumeName(id);
			String namePrefix = storageTemplate.getNamePrefix();
			if (!StringUtils.isEmpty(volumeName) && volumeName.startsWith(namePrefix)) {
				logger.info("detaching volume with id " + id + " from machine with ip: " + machineIp);
				this.storageProvisioning.detachVolume(id, machineIp, duration, unit);
				boolean deleteOnExit = storageTemplate.isDeleteOnExit();
				if (deleteOnExit) {
					logger.info("deleting volume with id " + id);
					//TODO the first param should be the storage location
					this.storageProvisioning.deleteVolume("", id, duration, unit);
				}
			}
		}
	}
=======
void handleVolumeOnStopMachine(final String machineIp, final long duration,
			final TimeUnit unit) throws TimeoutException,
			StorageProvisioningException {
		logger.info("detaching all volumes attachet to machine with ip: " + machineIp);
		Set<VolumeDetails> attachedVolumes = this.storageProvisioning.listVolumes(machineIp, duration, unit);
		StorageTemplate storageTemplate = this.cloud.getCloudStorage().getTemplates().get(this.storageTemplateName);
		for (VolumeDetails volumeDetails : attachedVolumes) {
			String id = volumeDetails.getId();
			logger.info("getting volume name using volume id " + id);
			String volumeName = this.storageProvisioning.getVolumeName(id);
			String namePrefix = storageTemplate.getNamePrefix();
			if (!StringUtils.isEmpty(volumeName) && volumeName.startsWith(namePrefix)) {
				logger.info("detaching volume with id " + id + " from machine with ip: " + machineIp);
				this.storageProvisioning.detachVolume(id, machineIp, duration, unit);
				boolean deleteOnExit = storageTemplate.isDeleteOnExit();
				if (deleteOnExit) {
					logger.info("deleting volume with id " + id);
					//TODO the first param should be the storage location
					this.storageProvisioning.deleteVolume("", id, duration, unit);
				}
			}
		}
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618363476/fstmerge_var2_4432081647607906789

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_be6ff_8db92/rev_be6ff-8db92/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/ElasticMachineProvisioningCloudifyAdapter.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_c19c9_58f3c/rev_c19c9-58f3c.revisions
Conflict type: LineBasedMCFd
Conflict body: 
private void doDeploy(
			final String applicationName,
			final String serviceName,
			final String authGroups,
			final String templateName,
			final String[] agentZones,
			final File serviceFile,
			final Properties contextProperties,
			final Service service,
			final byte[] serviceCloudConfigurationContents,
			final boolean selfHealing,
			final File cloudOverrides) throws TimeoutException, DSLException, IOException, RestErrorException {

		boolean locationAware = false;
		boolean dedicated = true;
		if (service != null) {
			locationAware = service.isLocationAware();
			dedicated = IsolationUtils.isDedicated(service);
		}

		final int externalProcessMemoryInMB = 512;
		final int containerMemoryInMB = 128;
		final int reservedMemoryCapacityPerMachineInMB = 256;

		contextProperties.setProperty(CloudifyConstants.CONTEXT_PROPERTY_ASYNC_INSTALL,
				"true");
		if (!selfHealing) {
			contextProperties.setProperty(
					CloudifyConstants.CONTEXT_PROPERTY_DISABLE_SELF_HEALING,
					"false");
		}

		final ElasticStatelessProcessingUnitDeployment deployment =
				new ElasticStatelessProcessingUnitDeployment(serviceFile)
		.memoryCapacityPerContainer(externalProcessMemoryInMB, MemoryUnit.MEGABYTES)
		.addCommandLineArgument("-Xmx" + containerMemoryInMB + "m")
		.addCommandLineArgument("-Xms" + containerMemoryInMB + "m")
		.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME, applicationName)
		.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_AUTH_GROUPS, authGroups)
		.name(serviceName);
		if (cloud == null) { // Azure or local-cloud
			if (!isLocalCloud()) {
				// Azure: Eager scale (1 container per machine per PU)
				setSharedMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				deployment.scale(ElasticScaleConfigFactory
						.createEagerScaleConfig());
			} else {
				// local cloud
				setPublicMachineProvisioning(deployment, agentZones,
						reservedMemoryCapacityPerMachineInMB);
				if (service == null || service.getScalingRules() == null) {
					final int totalMemoryInMB = calculateTotalMemoryInMB(
							serviceName, service, externalProcessMemoryInMB);
					final ManualCapacityScaleConfig scaleConfig = new ManualCapacityScaleConfigurer()
					.memoryCapacity(totalMemoryInMB, MemoryUnit.MEGABYTES).create();
					deployment.scale(scaleConfig);
				} else {
					final AutomaticCapacityScaleConfig scaleConfig = ElasticScaleConfigFactory
							.createAutomaticCapacityScaleConfig(serviceName,
									service, externalProcessMemoryInMB, false, false);
					deployment.scale(scaleConfig);
				}
			}
		} else {

			deployment.addCommandLineArgument("-Xmx" + cloud.getConfiguration().getComponents().getUsm().getMaxMemory())
			.addCommandLineArgument("-Xms" + cloud.getConfiguration().getComponents().getUsm().getMinMemory())
			.addCommandLineArgument("-D" + CloudifyConstants.LRMI_BIND_PORT_CONTEXT_PROPERTY + "="
									+ cloud.getConfiguration().getComponents().getUsm().getPortRange());

			final ComputeTemplate template = getComputeTemplate(cloud, templateName);

			long cloudExternalProcessMemoryInMB = 0;

			if (dedicated) {
				cloudExternalProcessMemoryInMB = calculateExternalProcessMemory(cloud, template);
			} else {
				cloudExternalProcessMemoryInMB = IsolationUtils.getInstanceMemoryMB(service);
			}

			logger.info("Creating cloud machine provisioning config. Template remote directory is: "
					+ template.getRemoteDirectory());
						
			final CloudifyMachineProvisioningConfig config = new CloudifyMachineProvisioningConfig(
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618475322/fstmerge_var1_2373437464132681221
					cloud, template, templateName, this.managementTemplate.getRemoteDirectory(), 
					service.getStorage() != null ? service.getStorage().getTemplate() : null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618475322/fstmerge_base_5801695571818287640
					cloud, template, templateName, this.managementTemplate.getRemoteDirectory(),
					service.getStorage().getTemplate());
=======
					cloud, template, templateName, this.managementTemplate.getRemoteDirectory(), 
					service.getStorage().getTemplate());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618475322/fstmerge_var2_1175639264306348131
			config.setAuthGroups(authGroups);
			if (cloudOverrides != null) {
				if (logger.isLoggable(Level.FINE)) {
					logger.fine("Recieved request for installation of "
							+ serviceName + " with cloud overrides parameters [ "
							+ FileUtils.readFileToString(cloudOverrides) + "]");
				}
				config.setCloudOverridesPerService(cloudOverrides);
			} else {
				if (logger.isLoggable(Level.FINE)) {
					logger.fine("No cloud overrides parameters were requested for the installation of "
							+ serviceName);
				}
			}
			if (serviceCloudConfigurationContents != null) {
				config.setServiceCloudConfiguration(serviceCloudConfigurationContents);
			}

			final String locators = extractLocators(admin);
			config.setLocator(locators);

			if (IsolationUtils.isUseManagement(service)) {
				config.setDedicatedManagementMachines(false);
			} else {
				config.setDedicatedManagementMachines(true);
			}
			if (dedicated) {
				// service deployment will have a dedicated agent per instance
				setDedicatedMachineProvisioning(deployment, config);
			} else {

				// check what mode of isolation we should use
				if (IsolationUtils.isGlobal(service)) {
					logger.info("global mode is on. will use public machine provisioning for "
							+ serviceName + " deployment.");
					logger.info("isolationSLA = " + service.getIsolationSLA());
					// service instances can be deployed across all agents
					setPublicMachineProvisioning(deployment, config);
					
				} else if (IsolationUtils.isAppShared(service)) {
					logger.info("app shared mode is on. will use shared machine provisioning for "
							+ serviceName + " deployment. isolation id = " + applicationName);
					// service instances can be deployed across all agents with the correct isolation id
					setSharedMachineProvisioning(deployment, config, applicationName);
				} else if (IsolationUtils.isTenantShared(service)) {
					if (authGroups == null) {
						throw new IllegalStateException("authGroups cannot be null when using tenant shared isolation");
					}
					logger.info("tenant shared mode is on. will use shared machine provisioning for "
							+ serviceName + " deployment. isolation id = " + authGroups);
					// service instances can be deployed across all agents with the correct isolation id
					setSharedMachineProvisioning(deployment, config, authGroups);
				}
			}

			deployment.memoryCapacityPerContainer((int) cloudExternalProcessMemoryInMB, MemoryUnit.MEGABYTES);
			if (service == null || service.getScalingRules() == null) {
				final int totalMemoryInMB = calculateTotalMemoryInMB(
						serviceName, service,
						(int) cloudExternalProcessMemoryInMB);
				final double totalCpuCores = calculateTotalCpuCores(service);
				final ManualCapacityScaleConfig scaleConfig = ElasticScaleConfigFactory
						.createManualCapacityScaleConfig(totalMemoryInMB,
								totalCpuCores, locationAware, dedicated);
				deployment.scale(scaleConfig);
			} else {
				final AutomaticCapacityScaleConfig scaleConfig = ElasticScaleConfigFactory
						.createAutomaticCapacityScaleConfig(serviceName,
								service, (int) cloudExternalProcessMemoryInMB,
								locationAware, dedicated);
				deployment.scale(scaleConfig);
			}
		}

		// add context properties
		setContextProperties(deployment, contextProperties);
		verifyEsmExistsInCluster();
		deployAndWait(serviceName, deployment);
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_c19c9_58f3c/rev_c19c9-58f3c/restful/src/main/java/org/cloudifysource/rest/controllers/ServiceController.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618480305/fstmerge_var1_3484731791230558545
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618480305/fstmerge_base_1380625357530185098
@Override
	public void setConfig(final Cloud cloud, final String computeTemplateName, final String storageTemplateName) {

		logger.fine("Initializing storage provisioning on Openstack. Using template: " + storageTemplateName);
		
		publishEvent(EVENT_ATTEMPT_CONNECTION_TO_CLOUD_API, cloud.getProvider().getProvider());
		initDeployer(cloud, computeTemplateName, storageTemplateName);
		publishEvent(EVENT_ACCOMPLISHED_CONNECTION_TO_CLOUD_API, cloud.getProvider().getProvider());
		novaContext = this.computeContext.unwrap();
		storageTemplate = cloud.getCloudStorage().getTemplates().get(storageTemplateName);
	}
=======
@Override
	public void setConfig(final Cloud cloud, final String computeTemplateName, final String storageTemplateName) {

		logger.fine("Initializing storage provisioning on Openstack. Using template: " + storageTemplateName);
		
		publishEvent(EVENT_ATTEMPT_CONNECTION_TO_CLOUD_API, cloud.getProvider().getProvider());
		initDeployer(cloud, computeTemplateName, storageTemplateName);
		publishEvent(EVENT_ACCOMPLISHED_CONNECTION_TO_CLOUD_API, cloud.getProvider().getProvider());
		novaContext = this.computeContext.unwrap();
		computeTemplate = cloud.getCloudCompute().getTemplates().get(computeTemplateName);
		storageTemplate = cloud.getCloudStorage().getTemplates().get(storageTemplateName);
		region = getRegionFromHardwareId(computeTemplate.getHardwareId());
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618480305/fstmerge_var2_4969275732518616959

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_c19c9_58f3c/rev_c19c9-58f3c/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/storage/openstack/OpenstackStorageDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618480309/fstmerge_var1_8805196704330397685
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618480309/fstmerge_base_2010397629678090192
@Override
	public VolumeDetails createVolume(final String location, final long duration, final TimeUnit timeUnit) throws 
		TimeoutException, StorageProvisioningException {
		
		final long endTime = System.currentTimeMillis() + timeUnit.toMillis(duration);
		final VolumeDetails volumeDetails;
		final Volume volume;

		Optional<? extends VolumeApi> volumeApi = getVolumeApi(location);

		if (!volumeApi.isPresent()) {
			throw new StorageProvisioningException("Failed to create volume, Openstack API is not initialized.");
		}
		
		if (computeContext == null) {
			throw new StorageProvisioningException("Failed to create volume, compute context is not initialized.");
		}
		
		String volumeName = storageTemplate.getNamePrefix() + System.currentTimeMillis();
		CreateVolumeOptions options = CreateVolumeOptions.Builder
				.name(volumeName)
				.description(VOLUME_DESCRIPTION)
				.availabilityZone(getStorageZone());

		volume = volumeApi.get().create(storageTemplate.getSize(), options);
		
		try {
			volumeDetails = waitForVolume(volumeApi, volume.getId(), endTime);
		} catch (final Exception e) {
			logger.log(Level.WARNING, "volume: " + volume.getId() + " failed to start up correctly. Shutting it down."
					+ " Error was: " + e.getMessage(), e);
			try {
				deleteVolume(location, volume.getId(), duration, timeUnit);
			} catch (final Exception e2) {
				logger.log(Level.WARNING, "Error while deleting volume: " + volume.getId() 
						+ ". Error was: " + e.getMessage() + ".It may be leaking.", e);
			}
			throw new StorageProvisioningException(e);
		}
		
		return volumeDetails;
	}
=======
@Override
	public VolumeDetails createVolume(final String location, final long duration, final TimeUnit timeUnit) throws 
		TimeoutException, StorageProvisioningException {
		
		final long endTime = System.currentTimeMillis() + timeUnit.toMillis(duration);
		final VolumeDetails volumeDetails = new VolumeDetails();
		Volume volume;
		
		//ignoring the passed location, it's a wrong format, taking the compute location instead
		Optional<? extends VolumeApi> volumeApi = getVolumeApi();

		if (!volumeApi.isPresent()) {
			throw new StorageProvisioningException("Failed to create volume, Openstack API is not initialized.");
		}
		
		if (computeContext == null) {
			throw new StorageProvisioningException("Failed to create volume, compute context is not initialized.");
		}
		
		String volumeName = storageTemplate.getNamePrefix() + System.currentTimeMillis();
		CreateVolumeOptions options = CreateVolumeOptions.Builder
				.name(volumeName)
				.description(VOLUME_DESCRIPTION)
				.availabilityZone(getStorageZone());

		volume = volumeApi.get().create(storageTemplate.getSize(), options);
		
		try {
			waitForVolumeToReachStatus(Volume.Status.AVAILABLE, volumeApi, volume.getId(), endTime);
			volume = volumeApi.get().get(volume.getId());
			volumeDetails.setId(volume.getId());
			volumeDetails.setName(volume.getName());
			volumeDetails.setSize(volume.getSize());
			volumeDetails.setLocation(volume.getZone());
			logger.fine("Volume provisioned: " + volumeDetails.toString());
		} catch (final Exception e) {
			logger.log(Level.WARNING, "volume: " + volume.getId() + " failed to start up correctly. Shutting it down."
					+ " Error was: " + e.getMessage(), e);
			try {
				deleteVolume(region, volume.getId(), duration, timeUnit);
			} catch (final Exception e2) {
				logger.log(Level.WARNING, "Error while deleting volume: " + volume.getId() 
						+ ". Error was: " + e.getMessage() + ". It may be leaking.", e);
			}
			throw new StorageProvisioningException(e);
		}
		
		return volumeDetails;
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618480309/fstmerge_var2_8320464704008695832

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_c19c9_58f3c/rev_c19c9-58f3c/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/storage/openstack/OpenstackStorageDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618480313/fstmerge_var1_5381453975495541866
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618480313/fstmerge_base_6518862359362097917
@Override
	public void attachVolume(final String volumeId, final String machineIp, final long duration, 
			final TimeUnit timeUnit) throws TimeoutException, StorageProvisioningException {
		
		NodeMetadata node = deployer.getServerWithIP(machineIp);
		if (node == null) {
			throw new StorageProvisioningException("Failed to attach volume " + volumeId + " to server. Server "
					+ "with ip: " + machineIp + " not found");
		}
		
		Optional<? extends VolumeAttachmentApi> volumeAttachmentApi = 
				getAttachmentApi(node.getLocation().getParent().getId());
		
		if (volumeAttachmentApi.isPresent()) {
			volumeAttachmentApi.get().attachVolumeToServerAsDevice(volumeId, node.getProviderId(), 
					storageTemplate.getDeviceName());
		} else {
			throw new StorageProvisioningException("Failed to attach volume " + volumeId 
					+ ", Openstack API is not initialized.");
		}
	}
=======
@Override
	public void attachVolume(final String volumeId, final String machineIp, final long duration, 
			final TimeUnit timeUnit) throws TimeoutException, StorageProvisioningException {
		
		final long endTime = System.currentTimeMillis() + timeUnit.toMillis(duration);
		NodeMetadata node = deployer.getServerWithIP(machineIp);
		if (node == null) {
			throw new StorageProvisioningException("Failed to attach volume " + volumeId + " to server. Server "
					+ "with ip: " + machineIp + " not found");
		}
		
		Optional<? extends VolumeAttachmentApi> volumeAttachmentApi = getAttachmentApi();
		Optional<? extends VolumeApi> volumeApi = getVolumeApi();
		
		if (!volumeApi.isPresent() || !volumeAttachmentApi.isPresent()) {
			throw new StorageProvisioningException("Failed to attach volume " + volumeId 
					+ ", Openstack API is not initialized.");
		}
		logger.fine("Attaching volume on Openstack");
		
		volumeAttachmentApi.get().attachVolumeToServerAsDevice(volumeId, node.getProviderId(), 
			storageTemplate.getDeviceName());
		
		try {
			waitForVolumeToReachStatus(Volume.Status.IN_USE, volumeApi, volumeId, endTime);
			logger.fine("Volume " + volumeId + " attached successfully to machine : " + machineIp);
		} catch (final Exception e) {
			logger.log(Level.WARNING, "volume: " + volumeId + " failed to attach to machine " + machineIp
					+ ". Error was: " + e.getMessage(), e);
			try {
				detachVolume(region, volumeId, duration, timeUnit);
			} catch (final Exception e2) {
				logger.log(Level.WARNING, "Error while detaching volume: " + volumeId 
						+ " after a failed attachment. Error was: " + e.getMessage() + ". It may be leaking.", e);
			}
			throw new StorageProvisioningException(e);
		}
		
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618480313/fstmerge_var2_1602367858357151186

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_c19c9_58f3c/rev_c19c9-58f3c/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/storage/openstack/OpenstackStorageDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618480338/fstmerge_var1_5566994800298426924
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618480338/fstmerge_base_5812315530368598868
private JCloudsDeployer initDeployer(final Cloud cloud, final String computeTemplateName, final String 
			storageTemplateName) {
		
		if (deployer != null) {
			return deployer;
		}
		
		try {
			logger.fine("Creating JClouds context deployer for Openstack with user: " + cloud.getUser().getUser());
			final StorageTemplate storageTemplate = cloud.getCloudStorage().getTemplates().get(storageTemplateName);
			final ComputeTemplate computeTemplate = cloud.getCloudCompute().getTemplates().get(computeTemplateName);
			final Properties props = new Properties();
			props.putAll(computeTemplate.getOverrides());
			//props.put(OPENSTACK_JCLOUDS_ENDPOINT, getComputeEndpoint(computeTemplate));
			//props.put(CREDENTIALS_TYPE_PROPERTY, CREDENTIALS_TYPE);
			props.putAll(storageTemplate.getCustom());

			deployer = new JCloudsDeployer(cloud.getProvider().getProvider(), cloud.getUser().getUser(),
					cloud.getUser().getApiKey(), props);
		} catch (final Exception e) {
			publishEvent("connection_to_cloud_api_failed", cloud.getProvider().getProvider());
			throw new IllegalStateException("Failed to create cloud Deployer", e);
		}
		
		return deployer;
	}
=======
private JCloudsDeployer initDeployer(final Cloud cloud, final String computeTemplateName, final String 
			storageTemplateName) {
		
		if (deployer != null) {
			return deployer;
		}
		
		try {
			logger.fine("Creating JClouds context deployer for Openstack with user: " + cloud.getUser().getUser());
			final Properties props = new Properties();
			props.putAll(computeTemplate.getOverrides());
			props.putAll(storageTemplate.getCustom());

			deployer = new JCloudsDeployer(cloud.getProvider().getProvider(), cloud.getUser().getUser(),
					cloud.getUser().getApiKey(), props);
		} catch (final Exception e) {
			publishEvent("connection_to_cloud_api_failed", cloud.getProvider().getProvider());
			throw new IllegalStateException("Failed to create cloud Deployer", e);
		}
		
		return deployer;
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618480338/fstmerge_var2_2897157417065139535

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_c19c9_58f3c/rev_c19c9-58f3c/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/storage/openstack/OpenstackStorageDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618480350/fstmerge_var1_7496800602490777532
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618480350/fstmerge_base_4867369994294902700
private String getStorageZone() throws IllegalArgumentException {
		String zone;
		Map<String, Object> customSettings = storageTemplate.getCustom();
		
		if (customSettings != null) {
			Object zoneObj = customSettings.get(OPENSTACK_CUSTOM_VOLUME_ZONE);
			if (zoneObj instanceof String) {
				zone = (String) zoneObj;
				if (StringUtils.isBlank(zone)) {
					throw new IllegalArgumentException("Storate template custom property is missing or empty: " 
							+ OPENSTACK_CUSTOM_VOLUME_ZONE);
				}
			} else {
				throw new IllegalArgumentException("Storate template custom property \"" + OPENSTACK_CUSTOM_VOLUME_ZONE
						+ "\" must be of type String"); 
			}
		} else {
			throw new IllegalArgumentException("Storate template is missing a \"custom\" section with the required "
					+ "property \"" + OPENSTACK_CUSTOM_VOLUME_ZONE  + "\"");
		}
		
		return zone;
	}
=======
private String getStorageZone() throws IllegalArgumentException {
		String zone;
		Map<String, Object> customSettings = storageTemplate.getCustom();
		
		if (customSettings != null) {
			Object zoneObj = customSettings.get(OPENSTACK_CUSTOM_VOLUME_ZONE);
			if (zoneObj instanceof String) {
				zone = (String) zoneObj;
				if (StringUtils.isBlank(zone)) {
					throw new IllegalArgumentException("Storate template custom property is missing or empty: " 
							+ OPENSTACK_CUSTOM_VOLUME_ZONE);
				}
			} else {
				throw new IllegalArgumentException("Storate template custom property \"" + OPENSTACK_CUSTOM_VOLUME_ZONE 
						+ "\" is missing or not a String"); 
			}
		} else {
			throw new IllegalArgumentException("Storate template is missing a \"custom\" section with the required "
					+ "property \"" + OPENSTACK_CUSTOM_VOLUME_ZONE  + "\"");
		}
		
		return zone;
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418618480350/fstmerge_var2_5942183865800177946

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_c19c9_58f3c/rev_c19c9-58f3c/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/storage/openstack/OpenstackStorageDriver.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_3433b_2d65c/rev_3433b-2d65c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_07600_e2f81/rev_07600-e2f81.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_ebaa2_d4452/rev_ebaa2-d4452.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_174f5_27292/rev_174f5-27292.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_0e55b_76df9/rev_0e55b-76df9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_2b67c_94ec0/rev_2b67c-94ec0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_cca5a_fdfa8/rev_cca5a-fdfa8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_ab17e_29120/rev_ab17e-29120.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_a86e9_3345d/rev_a86e9-3345d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_6ab44_68da5/rev_6ab44-68da5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_7eeb5_ff94a/rev_7eeb5-ff94a.revisions
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418619812999/fstmerge_var1_7819420708167621901
CloudifyMachineProvisioningConfig createCloudifyMachineProvisioningConfig() {
		
		final Cloud cloud = deploymentConfig.getCloud();
		final String serviceTemplateName = deploymentConfig.getTemplateName();
		final String managementMachineTemplateName = cloud.getConfiguration().getManagementMachineTemplate();
		final Map<String, ComputeTemplate> templates = cloud.getCloudCompute().getTemplates();
		
		final ComputeTemplate serviceTemplate = templates.get(serviceTemplateName);
		final ComputeTemplate managementTemplate = templates.get(managementMachineTemplateName);
		
		String storageTemplate = null;
		if (deploymentConfig.getService().getStorage() != null) {
			storageTemplate = deploymentConfig.getService().getStorage().getTemplate();
			logger.fine("Storage template " + storageTemplate + " is used with deployment");
		}
		logger.fine("Creating cloud machine provisioning config. Template remote directory is: "
				+ serviceTemplate.getRemoteDirectory());
		//TODO: is there any reason for passing the remote dir? this could be extracted from the cloud file.
		final CloudifyMachineProvisioningConfig config = new CloudifyMachineProvisioningConfig(
				cloud, serviceTemplate, serviceTemplateName, managementTemplate.getRemoteDirectory(),
				storageTemplate);
		config.setAuthGroups(deploymentConfig.getAuthGroups());
		
		String cloudOverrides = deploymentConfig.getCloudOverrides();
		if (cloudOverrides != null) {
			logger.fine("Recieved request for installation of "
					+ deploymentConfig.getAbsolutePUName() + " with cloud overrides parameters [ "
					+ cloudOverrides + "]");
			config.setCloudOverridesPerService(cloudOverrides);
		} else {
			logger.fine("No cloud overrides parameters were requested for the installation of "
					+ deploymentConfig.getAbsolutePUName());
		}
		//TODO: When is this used?
		addCloudConfigurationCostants(config);

		config.setLocator(deploymentConfig.getLocators());
		
		return config;
	}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418619812999/fstmerge_base_7754226125681971354
=======
CloudifyMachineProvisioningConfig createCloudifyMachineProvisioningConfig() {
		
		final Cloud cloud = deploymentConfig.getCloud();
		final String serviceTemplateName = deploymentConfig.getTemplateName();
		final String managementMachineTemplateName = cloud.getConfiguration().getManagementMachineTemplate();
		final Map<String, ComputeTemplate> templates = cloud.getCloudCompute().getTemplates();
		
		final ComputeTemplate serviceTemplate = templates.get(serviceTemplateName);
		final ComputeTemplate managementTemplate = templates.get(managementMachineTemplateName);
		
		String storageTemplate = null;
		if (deploymentConfig.getService().getStorage() != null) {
			storageTemplate = deploymentConfig.getService().getStorage().getTemplate();
			logger.fine("Storage template " + storageTemplate + " is used with deployment");
		}
		logger.fine("Creating cloud machine provisioning config. Template remote directory is: "
				+ serviceTemplate.getRemoteDirectory());
		//TODO: is there any reason for passing the remote dir? this could be extracted from the cloud file.
		final CloudifyMachineProvisioningConfig config = new CloudifyMachineProvisioningConfig(
				cloud, serviceTemplate, serviceTemplateName, managementTemplate.getRemoteDirectory(),
				storageTemplate);
		config.setAuthGroups(deploymentConfig.getInstallRequest().getAuthGroups());
		
		String cloudOverrides = deploymentConfig.getCloudOverrides();
		if (cloudOverrides != null) {
			logger.fine("Recieved request for installation of "
					+ deploymentConfig.getAbsolutePUName() + " with cloud overrides parameters [ "
					+ cloudOverrides + "]");
			config.setCloudOverridesPerService(cloudOverrides);
		} else {
			logger.fine("No cloud overrides parameters were requested for the installation of "
					+ deploymentConfig.getAbsolutePUName());
		}
		//TODO: When is this used?
		addCloudConfigurationCostants(config);

		config.setLocator(deploymentConfig.getLocators());
		
		return config;
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418619812999/fstmerge_var2_6203793046704285382

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_7eeb5_ff94a/rev_7eeb5-ff94a/restful/src/main/java/org/cloudifysource/rest/deploy/ElasticProcessingUnitDeploymentFactoryImpl.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418619813015/fstmerge_var1_2542732647460584589
private void setIsolationConfig(
			final ElasticDeploymentTopology deployment,
			final boolean dedicated, final CloudifyMachineProvisioningConfig config) {
		final Service service = deploymentConfig.getService();
		if (IsolationUtils.isUseManagement(service)) {
			config.setDedicatedManagementMachines(false);
		} else {
			config.setDedicatedManagementMachines(true);
		}
		if (dedicated) {
			// service deployment will have a dedicated agent per instance
			deployment.dedicatedMachineProvisioning(config);
		} else {
			// check what mode of isolation we should use
			if (IsolationUtils.isGlobal(service)) {
				logger.info("global mode is on. will use public machine provisioning for "
						+ deploymentConfig.getAbsolutePUName() + " deployment.");
				logger.info("isolationSLA = " + service.getIsolationSLA());
				// service instances can be deployed across all agents
				deployment.publicMachineProvisioning(config);

			} else if (IsolationUtils.isAppShared(service)) {
				final String applicationName = deploymentConfig.getApplicationName();
				logger.info("app shared mode is on. will use shared machine provisioning for "
						+ deploymentConfig.getAbsolutePUName() + " deployment. isolation id = " + applicationName);
				// service instances can be deployed across all agents with the correct isolation id
				deployment.sharedMachineProvisioning(applicationName, config);
			} else if (IsolationUtils.isTenantShared(service)) {
				String authGroups = deploymentConfig.getAuthGroups();
				if (authGroups == null) {
					throw new IllegalStateException("authGroups cannot be null when using tenant shared isolation");
				}
				logger.info("tenant shared mode is on. will use shared machine provisioning for "
						+ deploymentConfig.getAbsolutePUName() + " deployment. isolation id = " + authGroups);
				// service instances can be deployed across all agents with the correct isolation id
				deployment.sharedMachineProvisioning(authGroups, config);
			}
			if (IsolationUtils.isGlobal(service) && IsolationUtils.isUseManagement(service)) {
				final String managementMachineTemplateName = deploymentConfig.getCloud().
						getConfiguration().getManagementMachineTemplate();
				final ComputeDetails compute = service.getCompute();
				if (compute != null) {
					if (compute.getTemplate() != null && !compute.getTemplate().isEmpty()) {
						if (!compute.getTemplate().equals(managementMachineTemplateName)) {
							// this is just a clarification log.
							// the service wont be installed on a management machine(even if there is enough memory)
							// because the management machine template does not match the desired template
							logger.warning("Installation of service " + service.getName() + " on a management machine "
									+ "will not be attempted since the specified template(" + compute.getTemplate()
									+ ")"
									+ " is different than the management machine template("
									+ managementMachineTemplateName + ")");
						}
					}
				} else {
					// normal default is to the first template. but when specified useManagement
					// do a silent default to the management machine template.
					deploymentConfig.setTemplateName(managementMachineTemplateName);
				}
			}
		}
	}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418619813015/fstmerge_base_906667560293837707
=======
private void setIsolationConfig(
			final ElasticDeploymentTopology deployment,
			final boolean dedicated, final CloudifyMachineProvisioningConfig config) {
		final Service service = deploymentConfig.getService();
		if (IsolationUtils.isUseManagement(service)) {
			config.setDedicatedManagementMachines(false);
		} else {
			config.setDedicatedManagementMachines(true);
		}
		if (dedicated) {
			// service deployment will have a dedicated agent per instance
			deployment.dedicatedMachineProvisioning(config);
		} else {
			// check what mode of isolation we should use
			if (IsolationUtils.isGlobal(service)) {
				logger.info("global mode is on. will use public machine provisioning for "
						+ deploymentConfig.getAbsolutePUName() + " deployment.");
				logger.info("isolationSLA = " + service.getIsolationSLA());
				// service instances can be deployed across all agents
				deployment.publicMachineProvisioning(config);

			} else if (IsolationUtils.isAppShared(service)) {
				final String applicationName = deploymentConfig.getApplicationName();
				logger.info("app shared mode is on. will use shared machine provisioning for "
						+ deploymentConfig.getAbsolutePUName() + " deployment. isolation id = " + applicationName);
				// service instances can be deployed across all agents with the correct isolation id
				deployment.sharedMachineProvisioning(applicationName, config);
			} else if (IsolationUtils.isTenantShared(service)) {
				String authGroups = deploymentConfig.getInstallRequest().getAuthGroups();
				if (authGroups == null) {
					throw new IllegalStateException("authGroups cannot be null when using tenant shared isolation");
				}
				logger.info("tenant shared mode is on. will use shared machine provisioning for "
						+ deploymentConfig.getAbsolutePUName() + " deployment. isolation id = " + authGroups);
				// service instances can be deployed across all agents with the correct isolation id
				deployment.sharedMachineProvisioning(authGroups, config);
			}
			if (IsolationUtils.isGlobal(service) && IsolationUtils.isUseManagement(service)) {
				final String managementMachineTemplateName = deploymentConfig.getCloud().
						getConfiguration().getManagementMachineTemplate();
				final ComputeDetails compute = service.getCompute();
				if (compute != null) {
					if (compute.getTemplate() != null && !compute.getTemplate().isEmpty()) {
						if (!compute.getTemplate().equals(managementMachineTemplateName)) {
							// this is just a clarification log.
							// the service wont be installed on a management machine(even if there is enough memory)
							// because the management machine template does not match the desired template
							logger.warning("Installation of service " + service.getName() + " on a management machine "
									+ "will not be attempted since the specified template(" + compute.getTemplate()
									+ ")"
									+ " is different than the management machine template("
									+ managementMachineTemplateName + ")");
						}
					}
				} else {
					// normal default is to the first template. but when specified useManagement
					// do a silent default to the management machine template.
					deploymentConfig.setTemplateName(managementMachineTemplateName);
				}
			}
		}
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418619813015/fstmerge_var2_7796145515662795357

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_7eeb5_ff94a/rev_7eeb5-ff94a/restful/src/main/java/org/cloudifysource/rest/deploy/ElasticProcessingUnitDeploymentFactoryImpl.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418619813038/fstmerge_var1_6233364903467111455
private void addSharedDeploymentParameters(
			final ElasticDeploymentTopology deployment) {
		deployment.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME,
														deploymentConfig.getApplicationName())
				  .addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_AUTH_GROUPS,
						  									deploymentConfig.getAuthGroups())
				  .name(deploymentConfig.getAbsolutePUName());
		// add context properties
		final Properties contextProperties = createServiceContextProperties();
		setContextProperties(deployment, contextProperties);
		deployment.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_DEPLOYMENT_ID, 
				deploymentConfig.getDeploymentId());
		
        if (!isLocalcloud()) {
        	logger.fine("setting lrmi bind ports and container memory context properties");
            deployment.addCommandLineArgument("-D" + CloudifyConstants.LRMI_BIND_PORT_CONTEXT_PROPERTY + "="
                    + deploymentConfig.getCloud().getConfiguration().getComponents().getUsm().getPortRange())
                      .addCommandLineArgument("-Xmx" + deploymentConfig.getCloud().getConfiguration().getComponents()
                    		  .getUsm().getMaxMemory())
                      .addCommandLineArgument("-Xms" + deploymentConfig.getCloud().getConfiguration().getComponents()
                    		  .getUsm().getMinMemory());
            
    		final CloudifyMachineProvisioningConfig config = createCloudifyMachineProvisioningConfig();
    		//TODO: uncomment this when isolation is defined for pu types. 
    		//isolation should work out of the box for every pu type.
//    		setIsolationConfig(deployment, dedicated, config);
    		deployment.dedicatedMachineProvisioning(config);
			
        } else { //localcloud
        	setLocalcloudMachineProvisioningConfig(deployment);
        }
	}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418619813038/fstmerge_base_1057705108696562636
=======
private void addSharedDeploymentParameters(
			final ElasticDeploymentTopology deployment) {
		deployment.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME,
														deploymentConfig.getApplicationName())
				  .addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_AUTH_GROUPS,
						  									deploymentConfig.getInstallRequest().getAuthGroups())
				  .name(deploymentConfig.getAbsolutePUName());
		// add context properties
		final Properties contextProperties = createServiceContextProperties();
		setContextProperties(deployment, contextProperties);
		deployment.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_DEPLOYMENT_ID, 
				deploymentConfig.getDeploymentId());
		
        if (!isLocalcloud()) {
        	logger.fine("setting lrmi bind ports and container memory context properties");
            deployment.addCommandLineArgument("-D" + CloudifyConstants.LRMI_BIND_PORT_CONTEXT_PROPERTY + "="
                    + deploymentConfig.getCloud().getConfiguration().getComponents().getUsm().getPortRange())
                      .addCommandLineArgument("-Xmx" + deploymentConfig.getCloud().getConfiguration().getComponents()
                    		  .getUsm().getMaxMemory())
                      .addCommandLineArgument("-Xms" + deploymentConfig.getCloud().getConfiguration().getComponents()
                    		  .getUsm().getMinMemory());
            
    		final CloudifyMachineProvisioningConfig config = createCloudifyMachineProvisioningConfig();
    		//TODO: uncomment this when isolation is defined for pu types. 
    		//isolation should work out of the box for every pu type.
//    		setIsolationConfig(deployment, dedicated, config);
    		deployment.dedicatedMachineProvisioning(config);
			
        } else { //localcloud
        	setLocalcloudMachineProvisioningConfig(deployment);
        }
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418619813038/fstmerge_var2_447035368690032416

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_7eeb5_ff94a/rev_7eeb5-ff94a/restful/src/main/java/org/cloudifysource/rest/deploy/ElasticProcessingUnitDeploymentFactoryImpl.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_23ad1_b258e/rev_23ad1-b258e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_0e150_1fde9/rev_0e150-1fde9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_69dbf_ed3f9/rev_69dbf-ed3f9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_78ec5_43a46/rev_78ec5-43a46.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_1061b_9fa6e/rev_1061b-9fa6e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_a26a6_dc29c/rev_a26a6-dc29c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_e5a6c_4b76b/rev_e5a6c-4b76b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_a311a_1070a/rev_a311a-1070a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_6c24e_a7ef5/rev_6c24e-a7ef5.revisions
Conflict type: LineBasedMCFd
Conflict body: 
private Object filterModel(final ModelAndView modelAndView, final Object handler) 
    	throws RestErrorException {
    	
    	Object methodReturnObject = null;
    	Map<String, Object> model = modelAndView.getModel();
    	
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418621083029/fstmerge_var1_5171857369634498025
    	if (model != null && !model.isEmpty()) {
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418621083029/fstmerge_base_5302341594139359436
    	if (MapUtils.isNotEmpty(model)) {
=======
    	if (!model.isEmpty()) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418621083029/fstmerge_var2_2323772857431941764
    		// the model is not empty. The return value is the first value that is not a BindingResult
    		for (Map.Entry<String, Object> entry : model.entrySet()) {
                Object value = entry.getValue();
                if (!(value instanceof BindingResult)) {
                	methodReturnObject = value;
                	break;
                }
            }
    		if (methodReturnObject == null) {
    			logger.warning("return object not found in model: " + model.toString());
    			throw new RestErrorException("return object not found in model: " + model.toString());
    		}
    	} else {
    		// the model is empty, this means the return type is String or void
    		if (handler instanceof HandlerMethod) {
        		Class<?> returnType = ((HandlerMethod) handler).getMethod().getReturnType();
        		if (returnType == Void.TYPE) {
        			methodReturnObject = null;
        		} else if (returnType == String.class) {
        			String viewName = modelAndView.getViewName();
        			methodReturnObject = viewName;
        		} else {
        			logger.warning("return type not supported: " + returnType);
        			throw new RestErrorException("return type not supported: " + returnType);
        		}
        	} else {
        		logger.warning("handler object is not a HandlerMethod: " + handler);
    			throw new RestErrorException("handler object is not a HandlerMethod: " + handler);
        	}
    	}
    	
        return methodReturnObject;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_6c24e_a7ef5/rev_6c24e-a7ef5/restful/src/main/java/org/cloudifysource/rest/interceptors/ApiVersionValidationAndRestResponseBuilderInterceptor.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ private final String BUILD_NUM = "5200"; ##FSTMerge## private final String BUILD_NUM = "5199-130"; ##FSTMerge## private final String BUILD_NUM = "5985";
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_6c24e_a7ef5/rev_6c24e-a7ef5/cloudify/package_build/gigaspaces/src/java/com/j_spaces/kernel/CloudifyVersion.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ private final String BUILD_TIMESTAMP = "5200"; ##FSTMerge## private final String BUILD_TIMESTAMP = "5199-130"; ##FSTMerge## private final String BUILD_TIMESTAMP = "5985";
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_6c24e_a7ef5/rev_6c24e-a7ef5/cloudify/package_build/gigaspaces/src/java/com/j_spaces/kernel/CloudifyVersion.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_94f4c_a7ef5/rev_94f4c-a7ef5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_8c452_62b30/rev_8c452-62b30.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_4841f_245c1/rev_4841f-245c1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_5fa1e_55723/rev_5fa1e-55723.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_021ea_da9ed/rev_021ea-da9ed.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_69360_10850/rev_69360-10850.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_876d1_ccfa5/rev_876d1-ccfa5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_0dfe6_0c7e8/rev_0dfe6-0c7e8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_46200_d62a1/rev_46200-d62a1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_de006_01c86/rev_de006-01c86.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_48845_0ec1c/rev_48845-0ec1c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_3b5a3_3110b/rev_3b5a3-3110b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_46e78_88ba3/rev_46e78-88ba3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_a39fa_6c0ba/rev_a39fa-6c0ba.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_91be7_991cf/rev_91be7-991cf.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_6c36d_066a8/rev_6c36d-066a8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_2e84f_258d3/rev_2e84f-258d3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_1d2bd_1feae/rev_1d2bd-1feae.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_a92e9_2aadb/rev_a92e9-2aadb.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f4ecb_21329/rev_f4ecb-21329.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_52d1e_ec019/rev_52d1e-ec019.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_8fd4e_cec3f/rev_8fd4e-cec3f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_c7719_2ad91/rev_c7719-2ad91.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_ba55d_98bc5/rev_ba55d-98bc5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_d4fab_6bf5f/rev_d4fab-6bf5f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_e0ce4_56020/rev_e0ce4-56020.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_0015f_9b1bc/rev_0015f-9b1bc.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_a2bb6_bb210/rev_a2bb6-bb210.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_5dc52_a48d7/rev_5dc52-a48d7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_573d8_3241e/rev_573d8-3241e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_73f0c_7ca21/rev_73f0c-7ca21.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_bf3d6_a6b2a/rev_bf3d6-a6b2a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_70330_1a33d/rev_70330-1a33d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_30ae6_66d93/rev_30ae6-66d93.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_3b277_3d442/rev_3b277-3d442.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_43f7b_b3749/rev_43f7b-b3749.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_a0a53_2cae9/rev_a0a53-2cae9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_099ce_1ecea/rev_099ce-1ecea.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_3744a_e5902/rev_3744a-e5902.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_c9a76_86777/rev_c9a76-86777.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_8a76f_9559c/rev_8a76f-9559c.revisions
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418628199597/fstmerge_var1_5072894465533079385
private void initExceptionThrottler() {
		logger.fine("initilizing start-machine exception throttler.");
		exceptionThrottler = RateLimiter.create(1 / START_MACHINE_FAILURE_THROTTLING_TIMEOUT_SEC);
	}
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418628199597/fstmerge_base_1594058519065782016
=======
private void initExceptionThrottler() {
		logger.fine("initilizing start-machine exception throttler.");
		exceptionThrottler = RateLimiter.create(1.0 / START_MACHINE_FAILURE_THROTTLING_TIMEOUT_SEC);
	}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418628199597/fstmerge_var2_881238300708808884

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_8a76f_9559c/rev_8a76f-9559c/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/ElasticMachineProvisioningCloudifyAdapter.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418628200595/fstmerge_var1_7794496737642008703
@Override
    public void setConfig(final ComputeDriverConfiguration configuration) throws CloudProvisioningException {

        ComputeTemplate computeTemplate =
                configuration.getCloud().getCloudCompute().getTemplates().get(configuration.getCloudTemplate());
        boolean bareMetal = Utils.getBoolean(computeTemplate.getCustom()
                .get("org.cloudifysource.softlayer.bmi"), false);
        if (bareMetal) {
            configuration.getCloud().getProvider().setProvider("softlayer-bmi");
        } else {
            configuration.getCloud().getProvider().setProvider("softlayer");
        }
        super.setConfig(configuration);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418628200595/fstmerge_base_4604003621059568555
=======
@Override
    public void setConfig(final ComputeDriverConfiguration configuration) throws CloudProvisioningException {

        ComputeTemplate computeTemplate =
                configuration.getCloud().getCloudCompute().getTemplates().get(configuration.getCloudTemplate());
        bareMetal = Utils.getBoolean(computeTemplate.getCustom()
                .get("org.cloudifysource.softlayer.bmi"), false);
        if (bareMetal) {
            configuration.getCloud().getProvider().setProvider("softlayer-bmi");
        }
        super.setConfig(configuration);
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418628200595/fstmerge_var2_3273815741724947266

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_8a76f_9559c/rev_8a76f-9559c/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/jclouds/softlayer/SoftlayerProvisioningDriver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418628200599/fstmerge_var1_4661302919775057165
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418628200599/fstmerge_base_2479908939793323082
@Override
    public Set<Module> setupModules() {
        Set<Module> modules = super.setupModules();

        modules.add(new AbstractModule() {
            @Override
            protected void configure() {
                bind(VirtualGuestToNodeMetadata.class).to(VirtualGuestToReducedNodeMetaData.class);
            }
        });
        return modules;
    }
=======
@Override
    public Set<Module> setupModules() {
        Set<Module> modules = super.setupModules();
        if (!bareMetal) {
            modules.add(new AbstractModule() {
                @Override
                protected void configure() {
                    bind(VirtualGuestToNodeMetadata.class).to(VirtualGuestToReducedNodeMetaData.class);
                }
            });
        }
        return modules;
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418628200599/fstmerge_var2_8310238060562464283

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_8a76f_9559c/rev_8a76f-9559c/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/jclouds/softlayer/SoftlayerProvisioningDriver.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_0f682_a6399/rev_0f682-a6399.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_d0c47_d2c5c/rev_d0c47-d2c5c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f0398_6b1c4/rev_f0398-6b1c4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_2789c_4f0ef/rev_2789c-4f0ef.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_4e6d4_890e1/rev_4e6d4-890e1.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public OpenStackNetworkClient(final String endpoint, final String username, final String password,
			final String tenant, final String region, final String serviceName, final String networkApiVersion)
			throws OpenstackJsonSerializationException {
		super(endpoint, username, password, tenant, region);
		this.serviceName = serviceName;

		this.networkApiVersion = StringUtils.isEmpty(networkApiVersion) ? "v2.0" : networkApiVersion;
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418629151972/fstmerge_var1_4454487908035522727
		this.initToken();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418629151972/fstmerge_base_8925747268413300005
		logger.info("Openstack " + this.serviceName + " api version: " + this.networkApiVersion);
		this.initToken();
=======
		logger.info("Openstack " + this.serviceName + " api version: " + this.networkApiVersion);
		// this.initToken();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418629151972/fstmerge_var2_4674363256900057556
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_4e6d4_890e1/rev_4e6d4-890e1/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/openstack/OpenStackNetworkClient.java
Conflict type: LineBasedMCFd
Conflict body: 
public OpenStackComputeClient(final String endpoint, final String username, final String password,
			final String tenant, final String region, final String serviceName)
			throws OpenstackJsonSerializationException {
		super(endpoint, username, password, tenant, region);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418629152352/fstmerge_var1_4775935985776592141
		this.serviceName = serviceName;
		this.initToken();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418629152352/fstmerge_base_8880802558977688563
		this.serviceName = StringUtils.isEmpty(serviceName) ? "nova" : serviceName;
		this.initToken();
=======
		this.serviceName = StringUtils.isEmpty(serviceName) ? "nova" : serviceName;
		// this.initToken();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418629152352/fstmerge_var2_5270391912228979588
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_4e6d4_890e1/rev_4e6d4-890e1/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/openstack/OpenStackComputeClient.java
Conflict type: LineBasedMCFd
Conflict body: 
protected WebResource getWebResource() throws OpenstackException {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418629152546/fstmerge_var1_3030073553247995446
		if (serviceWebResource == null) {
			this.renewTokenIfNeeded();

			String endpoint = this.getEndpointByName(this.getServiceName());
			if (endpoint == null) {
				logger.finer("EndPoint by name returned null, trying to get service endpoint by its type '"
						+ this.getDefaultServiceType() + "'");
				endpoint = this.getServiceNameByType(this.getDefaultServiceType());
			}

			if (endpoint == null) {
				throw new OpenstackException("Cannot find endpoint for service '"
						+ this.getServiceName() + "' in the service catalog.");
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418629152546/fstmerge_base_2036013376595534456
		if (serviceWebResource == null) {
			this.renewTokenIfNeeded();
			final String endpoint = this.getEndpoint(this.getServiceName());
			if (endpoint == null) {
				throw new OpenstackException("Cannot find endpoint for service '"
						+ this.getServiceName() + "' in the service catalog.");
=======
		synchronized (this.webResourceMutex) {
			if (this.serviceWebResource == null) {
				this.renewTokenIfNeeded();
				final String endpoint = this.getEndpoint(this.getServiceName());
				if (endpoint == null) {
					throw new OpenstackException("Cannot find endpoint for service '"
							+ this.getServiceName() + "' in the service catalog.");
				}
				this.serviceClient = Client.create();
				if (WIRE_LOGGER.isLoggable(Level.FINE)) {
					this.serviceClient.addFilter(new LoggingFilter(WIRE_LOGGER));
				}
				this.serviceWebResource = this.serviceClient.resource(endpoint);
				logger.info("Openstack " + this.getServiceName() + " endpoint: " + endpoint);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418629152546/fstmerge_var2_6707427652772467805
			}
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418629152546/fstmerge_var1_3030073553247995446

			this.serviceClient = Client.create();
			this.serviceWebResource = serviceClient.resource(endpoint);
			logger.info("Openstack endpoint: " + endpoint);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418629152546/fstmerge_base_2036013376595534456
			this.serviceClient = Client.create();
			this.serviceWebResource = serviceClient.resource(endpoint);
			logger.info("Openstack " + this.getServiceName() + " endpoint: " + endpoint);
=======
			return serviceWebResource;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418629152546/fstmerge_var2_6707427652772467805
		}
	}

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_4e6d4_890e1/rev_4e6d4-890e1/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/openstack/OpenStackBaseClient.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_bf7bb_86e69/rev_bf7bb-86e69.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_e22b5_fae03/rev_e22b5-fae03.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_9ffae_c0796/rev_9ffae-c0796.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_3c3df_367c1/rev_3c3df-367c1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_c5219_e3b6c/rev_c5219-e3b6c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_f51c0_db1f0/rev_f51c0-db1f0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_bf924_76aa7/rev_bf924-76aa7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_6818b_a2c3d/rev_6818b-a2c3d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_b2552_70c44/rev_b2552-70c44.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_6f87b_6fdd5/rev_6f87b-6fdd5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_2205a_e92e9/rev_2205a-e92e9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_a34aa_623ff/rev_a34aa-623ff.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_c3213_91b61/rev_c3213-91b61.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_91419_11405/rev_91419-11405.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@Override
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418631957905/fstmerge_var1_6452504127940214541
    public Object getExternalApi(final String apiName) throws InterruptedException,
            ElasticMachineProvisioningException {
        Object externalApi = null;
        // TODO: (adaml) extract the names of the apis to constants.
        if (apiName.equals(CloudifyConstants.STORAGE_REMOTE_API_KEY)) {
            externalApi = new RemoteStorageProvisioningDriverAdapter(storageProvisioning, cloud.getCloudStorage().
                    getTemplates().get(storageTemplateName));
        } else if (apiName.equals(CloudifyConstants.NETWORK_REMOTE_API_KEY)) {
            externalApi = new RemoteNetworkProvisioningDriverAdapter(this.networkProvisioning);
        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418631957905/fstmerge_base_3586993238237056932
	public Object getExternalApi(final String apiName) throws InterruptedException,
			ElasticMachineProvisioningException {
		Object externalApi = null;
		// TODO: (adaml) extract the names of the apis to constants.
		if (apiName.equals(CloudifyConstants.STORAGE_REMOTE_API_KEY)) {
			externalApi = new RemoteStorageProvisioningDriverAdapter(storageProvisioning, cloud.getCloudStorage().
					getTemplates().get(storageTemplateName));
		} else if (apiName.equals(CloudifyConstants.NETWORK_REMOTE_API_KEY)) {
			externalApi = new RemoteNetworkProvisioningDriverAdapter(this.networkProvisioning);
		}
=======
	public Object getExternalApi(final String apiName) throws InterruptedException,
			ElasticMachineProvisioningException {
		Object externalApi = null;
		if (apiName.equals(CloudifyConstants.STORAGE_REMOTE_API_KEY)) {
			externalApi = new RemoteStorageProvisioningDriverAdapter(storageProvisioning, cloud.getCloudStorage().
					getTemplates().get(storageTemplateName));
		} else if (apiName.equals(CloudifyConstants.NETWORK_REMOTE_API_KEY)) {
			externalApi = new RemoteNetworkProvisioningDriverAdapter(this.networkProvisioning);
		}
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1418631957905/fstmerge_var2_6462033203781265465

        return externalApi;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_91419_11405/rev_91419-11405/esc/src/main/java/org/cloudifysource/esc/driver/provisioning/ElasticMachineProvisioningCloudifyAdapter.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_3e873_27bf6/rev_3e873-27bf6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_626e4_e4344/rev_626e4-e4344.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/cloudify/revisions/rev_2eefd_f784e/rev_2eefd-f784e.revisions