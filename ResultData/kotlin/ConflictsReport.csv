==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0a0df_ace7d/rev_0a0df-ace7d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_f79b5_f4c2a/rev_f79b5-f4c2a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_2b816_9ef80/rev_2b816-9ef80.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_63fd4_ad61e/rev_63fd4-ad61e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_725ac_87531/rev_725ac-87531.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public void testPropertiesInClasses() throws Exception {
        assertType("new Properties().p", "Int");
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419020773569/fstmerge_var1_279376755251034171
        assertType("new Props<Int>().p", "Int");
        assertType("new Props<out Int>().p", "Int");
        assertErrorType("new Props<in Int>().p");
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419020773569/fstmerge_base_4892031896561865436
=======
        assertType("new Props<Int>().p", "Int");
        assertType("new Props<out Int>().p", "Int");
        assertErrorType("new Props<in Int>().p");

        assertType("new Props<Properties>().p.p", "Int");
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419020773569/fstmerge_var2_1600775398051445043
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_725ac_87531/rev_725ac-87531/idea/tests/org/jetbrains/jet/types/JetTypeCheckerTest.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c5d8a_e1994/rev_c5d8a-e1994.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_a532b_dfe64/rev_a532b-dfe64.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_efdfb_66089/rev_efdfb-66089.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_02624_b346c/rev_02624-b346c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_bec9f_3ecf9/rev_bec9f-3ecf9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0f71e_aec27/rev_0f71e-aec27.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3425c_1e567/rev_3425c-1e567.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d8cdc_74338/rev_d8cdc-74338.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c084b_7e43c/rev_c084b-7e43c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_2711d_c2f8e/rev_2711d-c2f8e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_1261d_4e244/rev_1261d-4e244.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e57ed_c54d2/rev_e57ed-c54d2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d9bbe_77d42/rev_d9bbe-77d42.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_7d964_45ca9/rev_7d964-45ca9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_1966d_e897c/rev_1966d-e897c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_78481_29dba/rev_78481-29dba.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_78481_fa52f/rev_78481-fa52f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_82dab_b6735/rev_82dab-b6735.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_797f9_63aec/rev_797f9-63aec.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0dfc7_a6b31/rev_0dfc7-a6b31.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_1c6da_d7a2c/rev_1c6da-d7a2c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_8cf05_a1e05/rev_8cf05-a1e05.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6a03e_53423/rev_6a03e-53423.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_9a9c7_2fd4f/rev_9a9c7-2fd4f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c1dc1_15f55/rev_c1dc1-15f55.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_dcdb3_9625a/rev_dcdb3-9625a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_f2349_29fa1/rev_f2349-29fa1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c327a_33425/rev_c327a-33425.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419022254489/fstmerge_var1_4124749229137085368
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419022254489/fstmerge_base_4644946252850314720
public void generate(JetNamespace namespace, BindingContext bindingContext) {
        AnalyzingUtils.applyHandler(ErrorHandler.THROW_EXCEPTION, bindingContext);

        final JetStandardLibrary standardLibrary = JetStandardLibrary.getJetStandardLibrary(project);
        final FunctionCodegen functionCodegen = new FunctionCodegen(namespace, v, standardLibrary, bindingContext, codegens);
        final PropertyCodegen propertyCodegen = new PropertyCodegen(v, standardLibrary, bindingContext, functionCodegen);
        final ClassCodegen classCodegen = codegens.forClass(bindingContext);

        if (hasNonConstantPropertyInitializers(namespace)) {
            generateStaticInitializers(namespace, bindingContext);
        }

        for (JetDeclaration declaration : namespace.getDeclarations()) {
            if (declaration instanceof JetProperty) {
                propertyCodegen.gen((JetProperty) declaration, OwnerKind.NAMESPACE);
            }
            else if (declaration instanceof JetFunction) {
                try {
                    functionCodegen.gen((JetFunction) declaration, OwnerKind.NAMESPACE);
                } catch (Exception e) {
                    throw new RuntimeException("Failed to generate function " + declaration.getName(), e);
                }
            }
            else if (declaration instanceof JetClassOrObject) {
                classCodegen.generate((JetClassOrObject) declaration);
            }
            else if (declaration instanceof JetNamespace) {
                JetNamespace childNamespace = (JetNamespace) declaration;
                codegens.forNamespace(childNamespace).generate(childNamespace, bindingContext);
            }
        }
    }
=======
public void generate(JetNamespace namespace, BindingContext bindingContext) {
        AnalyzingUtils.applyHandler(ErrorHandler.THROW_EXCEPTION, bindingContext);

        final JetStandardLibrary standardLibrary = JetStandardLibrary.getJetStandardLibrary(project);
        final FunctionCodegen functionCodegen = new FunctionCodegen(namespace, v, standardLibrary, bindingContext, codegens);
        final PropertyCodegen propertyCodegen = new PropertyCodegen(v, standardLibrary, bindingContext, functionCodegen);
        final ClassCodegen classCodegen = codegens.forClass(bindingContext);

        if (hasNonConstantPropertyInitializers(namespace)) {
            generateStaticInitializers(namespace, bindingContext);
        }

        for (JetDeclaration declaration : namespace.getDeclarations()) {
            if (declaration instanceof JetProperty) {
                propertyCodegen.gen((JetProperty) declaration, OwnerKind.NAMESPACE);
            }
            else if (declaration instanceof JetNamedFunction) {
                try {
                    functionCodegen.gen((JetNamedFunction) declaration, OwnerKind.NAMESPACE);
                } catch (Exception e) {
                    throw new RuntimeException("Failed to generate function " + declaration.getName(), e);
                }
            }
            else if (declaration instanceof JetClassOrObject) {
                classCodegen.generate((JetClassOrObject) declaration);
            }
            else if (declaration instanceof JetNamespace) {
                JetNamespace childNamespace = (JetNamespace) declaration;
                codegens.forNamespace(childNamespace).generate(childNamespace, bindingContext);
            }
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419022254489/fstmerge_var2_5418576575940088454

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c327a_33425/rev_c327a-33425/idea/src/org/jetbrains/jet/codegen/NamespaceCodegen.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419022254836/fstmerge_var1_8239650255921514724
public void gen(JetFunction f, OwnerKind kind) {
        final JetTypeReference receiverTypeRef = f.getReceiverTypeRef();
        final JetType receiverType = receiverTypeRef == null ? null : state.getBindingContext().resolveTypeReference(receiverTypeRef);
        Method method = state.getTypeMapper().mapSignature(f);
        List<ValueParameterDescriptor> paramDescrs = state.getBindingContext().getFunctionDescriptor(f).getUnsubstitutedValueParameters();
        generateMethod(f, kind, method, receiverType, paramDescrs);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419022254836/fstmerge_base_5520563950000831391
public void gen(JetFunction f, OwnerKind kind) {
        final JetTypeReference receiverTypeRef = f.getReceiverTypeRef();
        final JetType receiverType = receiverTypeRef == null ? null : bindingContext.resolveTypeReference(receiverTypeRef);
        Method method = typeMapper.mapSignature(f);
        List<ValueParameterDescriptor> paramDescrs = bindingContext.getFunctionDescriptor(f).getUnsubstitutedValueParameters();
        generateMethod(f, kind, method, receiverType, paramDescrs);
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419022254836/fstmerge_var2_8968768803893082140

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c327a_33425/rev_c327a-33425/idea/src/org/jetbrains/jet/codegen/FunctionCodegen.java
Conflict type: LineBasedMCFd
Conflict body: 
protected void generatePrimaryConstructor() {
        ConstructorDescriptor constructorDescriptor = state.getBindingContext().getConstructorDescriptor((JetElement) myClass);
        if (constructorDescriptor == null && !(myClass instanceof JetObjectDeclaration)) return;

        Method method;
        if (myClass instanceof JetObjectDeclaration) {
            method = new Method("<init>", Type.VOID_TYPE, new Type[0]);
        }
        else {
            method = state.getTypeMapper().mapConstructorSignature(constructorDescriptor, kind);
        }
        int flags = Opcodes.ACC_PUBLIC; // TODO
        final MethodVisitor mv = v.visitMethod(flags, "<init>", method.getDescriptor(), null, null);
        mv.visitCode();

        Type[] argTypes = method.getArgumentTypes();
        List<ValueParameterDescriptor> paramDescrs = constructorDescriptor != null
                ? constructorDescriptor.getUnsubstitutedValueParameters()
                : Collections.<ValueParameterDescriptor>emptyList();

        ConstructorFrameMap frameMap = new ConstructorFrameMap(state.getTypeMapper(), constructorDescriptor, kind);

        final InstructionAdapter iv = new InstructionAdapter(mv);
        ExpressionCodegen codegen = new ExpressionCodegen(mv, frameMap, Type.VOID_TYPE,
                descriptor, kind, StackValue.local(0, state.getTypeMapper().jvmType(descriptor, kind)), state);

        String classname = state.getTypeMapper().jvmName(descriptor, kind);
        final Type classType = Type.getType("L" + classname + ";");

        List<JetDelegationSpecifier> specifiers = myClass.getDelegationSpecifiers();

        if (specifiers.isEmpty() || !(specifiers.get(0) instanceof JetDelegatorToSuperCall)) {
            // TODO correct calculation of super class
            String superClass = "java/lang/Object";
            if (!specifiers.isEmpty()) {
                final JetType superType = state.getBindingContext().resolveTypeReference(specifiers.get(0).getTypeReference());
                ClassDescriptor superClassDescriptor = (ClassDescriptor) superType.getConstructor().getDeclarationDescriptor();
                if (superClassDescriptor.hasConstructors()) {
                    superClass = getSuperClass();
                }
            }
            iv.load(0, Type.getType("L" + superClass + ";"));
            iv.invokespecial(superClass, "<init>", /* TODO super constructor descriptor */"()V");
        }

        final DeclarationDescriptor outerDescriptor = descriptor.getContainingDeclaration();
        if (outerDescriptor instanceof ClassDescriptor) {
            final ClassDescriptor outerClassDescriptor = (ClassDescriptor) outerDescriptor;
            final Type type = JetTypeMapper.jetImplementationType(outerClassDescriptor);
            codegen.addOuterThis(outerClassDescriptor, StackValue.local(frameMap.getOuterThisIndex(), type));
            String interfaceDesc = type.getDescriptor();
            final String fieldName = "this$0";
            v.visitField(Opcodes.ACC_PRIVATE | Opcodes.ACC_FINAL, fieldName, interfaceDesc, null, null);
            iv.load(0, classType);
            iv.load(frameMap.getOuterThisIndex(), type);
            iv.putfield(classname, fieldName, interfaceDesc);
        }

        if (kind == OwnerKind.DELEGATING_IMPLEMENTATION) {
            String interfaceDesc = JetTypeMapper.jetInterfaceType(descriptor).getDescriptor();
            v.visitField(Opcodes.ACC_PRIVATE | Opcodes.ACC_FINAL, "$this", interfaceDesc, /*TODO*/null, null);
            iv.load(0, classType);
            iv.load(frameMap.getDelegateThisIndex(), argTypes[0]);
            iv.putfield(classname, "$this", interfaceDesc);
        }

        HashSet<FunctionDescriptor> overridden = new HashSet<FunctionDescriptor>();
        for (JetDeclaration declaration : myClass.getDeclarations()) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419022254887/fstmerge_var1_710733091857370616
            if (declaration instanceof JetFunction) {
                overridden.addAll(state.getBindingContext().getFunctionDescriptor((JetFunction) declaration).getOverriddenFunctions());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419022254887/fstmerge_base_3921498070117746409
            if (declaration instanceof JetFunction) {
                overridden.addAll(bindingContext.getFunctionDescriptor((JetFunction) declaration).getOverriddenFunctions());
=======
            if (declaration instanceof JetNamedFunction) {
                overridden.addAll(bindingContext.getFunctionDescriptor((JetNamedFunction) declaration).getOverriddenFunctions());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419022254887/fstmerge_var2_906279666580739568
            }
        }

        int n = 0;
        for (JetDelegationSpecifier specifier : specifiers) {
            boolean delegateOnStack = specifier instanceof JetDelegatorToSuperCall && n > 0 ||
                                      specifier instanceof JetDelegatorByExpressionSpecifier;

            if (delegateOnStack) {
                iv.load(0, classType);
            }

            if (specifier instanceof JetDelegatorToSuperCall) {
                ConstructorDescriptor constructorDescriptor1 = state.getBindingContext().resolveSuperConstructor((JetDelegatorToSuperCall) specifier);
                generateDelegatorToConstructorCall(iv, codegen, (JetDelegatorToSuperCall) specifier, constructorDescriptor1, n == 0, frameMap);
            }
            else if (specifier instanceof JetDelegatorByExpressionSpecifier) {
                codegen.genToJVMStack(((JetDelegatorByExpressionSpecifier) specifier).getDelegateExpression());
            }

            if (delegateOnStack) {
                JetType superType = state.getBindingContext().resolveTypeReference(specifier.getTypeReference());
                ClassDescriptor superClassDescriptor = (ClassDescriptor) superType.getConstructor().getDeclarationDescriptor();
                String delegateField = "$delegate_" + n;
                Type fieldType = JetTypeMapper.jetInterfaceType(superClassDescriptor);
                String fieldDesc = fieldType.getDescriptor();
                v.visitField(Opcodes.ACC_PRIVATE, delegateField, fieldDesc, /*TODO*/null, null);
                iv.putfield(classname, delegateField, fieldDesc);

                JetClass superClass = (JetClass) state.getBindingContext().getDeclarationPsiElement(superClassDescriptor);
                generateDelegates(myClass, superClass,
                        new OwnerKind.DelegateKind(StackValue.field(fieldType, classname, delegateField, false),
                                JetTypeMapper.jvmNameForInterface(superClassDescriptor)), overridden);
            }

            n++;
        }

        if (frameMap.getFirstTypeParameter() > 0 && kind == OwnerKind.IMPLEMENTATION) {
            generateTypeInfoInitializer(frameMap.getFirstTypeParameter(), frameMap.getTypeParameterCount(), iv);
        }

        generateInitializers(codegen, iv);

        int curParam = 0;
        List<JetParameter> constructorParameters = getPrimaryConstructorParameters();
        for (JetParameter parameter : constructorParameters) {
            if (parameter.getValOrVarNode() != null) {
                VariableDescriptor descriptor = paramDescrs.get(curParam);
                Type type = state.getTypeMapper().mapType(descriptor.getOutType());
                iv.load(0, classType);
                iv.load(frameMap.getIndex(descriptor), type);
                iv.putfield(classname, descriptor.getName(), type.getDescriptor());
            }
            curParam++;
        }

        mv.visitInsn(Opcodes.RETURN);
        mv.visitMaxs(0, 0);
        mv.visitEnd();
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c327a_33425/rev_c327a-33425/idea/src/org/jetbrains/jet/codegen/ImplementationBodyCodegen.java
Conflict type: LineBasedMCFd
Conflict body: 
protected void generateDelegates(JetClassOrObject inClass, JetClass toClass, OwnerKind kind, Set<FunctionDescriptor> overriden) {
        final FunctionCodegen functionCodegen = new FunctionCodegen(toClass, v, state);
        final PropertyCodegen propertyCodegen = new PropertyCodegen(v, functionCodegen, state);

        for (JetDeclaration declaration : toClass.getDeclarations()) {
            if (declaration instanceof JetProperty) {
                propertyCodegen.gen((JetProperty) declaration, kind);
            }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419022254917/fstmerge_var1_1031359275449487115
            else if (declaration instanceof JetFunction) {
                if (!overriden.contains(state.getBindingContext().getFunctionDescriptor((JetFunction) declaration))) {
                    functionCodegen.gen((JetFunction) declaration, kind);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419022254917/fstmerge_base_3329217870893881955
            else if (declaration instanceof JetFunction) {
                if (!overriden.contains(bindingContext.getFunctionDescriptor((JetFunction) declaration))) {
                    functionCodegen.gen((JetFunction) declaration, kind);
=======
            else if (declaration instanceof JetNamedFunction) {
                if (!overriden.contains(bindingContext.getFunctionDescriptor((JetNamedFunction) declaration))) {
                    functionCodegen.gen((JetNamedFunction) declaration, kind);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419022254917/fstmerge_var2_3183587741469317266
                }
            }
        }

        for (JetParameter p : toClass.getPrimaryConstructorParameters()) {
            if (p.getValOrVarNode() != null) {
                PropertyDescriptor propertyDescriptor = state.getBindingContext().getPropertyDescriptor(p);
                if (propertyDescriptor != null) {
                    propertyCodegen.generateDefaultGetter(propertyDescriptor, Opcodes.ACC_PUBLIC, kind);
                    if (propertyDescriptor.isVar()) {
                        propertyCodegen.generateDefaultSetter(propertyDescriptor, Opcodes.ACC_PUBLIC, kind);
                    }
                }
            }
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c327a_33425/rev_c327a-33425/idea/src/org/jetbrains/jet/codegen/ImplementationBodyCodegen.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ef1cb_a35e6/rev_ef1cb-a35e6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_24819_78873/rev_24819-78873.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_a2721_e0d59/rev_a2721-e0d59.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ad2b1_6a328/rev_ad2b1-6a328.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_15f5c_9cf7a/rev_15f5c-9cf7a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_99bf6_c0ef1/rev_99bf6-c0ef1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_7af18_671b8/rev_7af18-671b8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b3b8a_847c7/rev_b3b8a-847c7.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@Nullable
        private JetType checkEnrichedType(@Nullable JetType expressionType, @NotNull JetExpression expression, @NotNull TypeInferenceContext context) {
            if (expressionType == null || context.expectedType == null || context.expectedType == NO_EXPECTED_TYPE ||
                semanticServices.getTypeChecker().isSubtypeOf(expressionType, context.expectedType)) {
                return expressionType;
            }
            JetType enrichedType = null;

            VariableDescriptor variableDescriptor = getVariableDescriptorFromSimpleName(expression, context);
            if (variableDescriptor != null) {

                List<JetType> possibleTypes = Lists.newArrayList(context.dataFlowInfo.getPossibleTypes(variableDescriptor));
                Collections.reverse(possibleTypes);
                for (JetType possibleType : possibleTypes) {
                    if (semanticServices.getTypeChecker().isSubtypeOf(possibleType, context.expectedType)) {
                        enrichedType = possibleType;
                        break;
                    }
                }
                if (enrichedType == null) {
                    enrichedType = context.dataFlowInfo.getOutType(variableDescriptor);
                }
            }
            if (enrichedType == null) {
                enrichedType = expressionType;
            }

            if (variableDescriptor == null || !semanticServices.getTypeChecker().isSubtypeOf(enrichedType, context.expectedType)) {
                context.trace.getErrorHandler().typeMismatch(expression, context.expectedType, expressionType);
            } else {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419022965833/fstmerge_var1_7223484501194916589
                context.trace.record(BindingContext.AUTOCAST, expression, context.expectedType);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419022965833/fstmerge_base_18814796481445878
                context.trace.recordAutoCast(expression, context.expectedType);
=======
                context.trace.recordAutoCast(expression, context.expectedType, variableDescriptor);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419022965833/fstmerge_var2_5267937062202583232
            }
            return enrichedType;
        }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b3b8a_847c7/rev_b3b8a-847c7/idea/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
        public JetType visitQualifiedExpression(JetQualifiedExpression expression, TypeInferenceContext contextWithExpectedType) {
            TypeInferenceContext context = contextWithExpectedType.replaceExpectedType(NO_EXPECTED_TYPE);
            // TODO : functions as values
            JetExpression selectorExpression = expression.getSelectorExpression();
            JetExpression receiverExpression = expression.getReceiverExpression();
            JetType receiverType = context.services.typeInferrerVisitorWithNamespaces.getType(receiverExpression, new TypeInferenceContext(context.trace, context.scope, false, context.dataFlowInfo, NO_EXPECTED_TYPE, NO_EXPECTED_TYPE));
            if (receiverType == null) return null;

            // Clean resolution: no autocasts
            TemporaryBindingTrace cleanResolutionTrace = new TemporaryBindingTrace(context.trace.getBindingContext());
            TypeInferenceContext cleanResolutionContext = context.replaceBindingTrace(cleanResolutionTrace);
//            ErrorHandler errorHandler = context.trace.getErrorHandler();
//            errorHandler.openRegion();
            JetType selectorReturnType = getSelectorReturnType(receiverType, selectorExpression, cleanResolutionContext);

            //TODO move further
            if (expression.getOperationSign() == JetTokens.SAFE_ACCESS) {
                if (selectorReturnType != null && !selectorReturnType.isNullable() && !JetStandardClasses.isUnit(selectorReturnType)) {
                    selectorReturnType = TypeUtils.makeNullable(selectorReturnType);
                }
            }
            if (selectorReturnType != null) {
                cleanResolutionTrace.addAllMyDataTo(context.trace);
            }
            else {
                VariableDescriptor variableDescriptor = cleanResolutionContext.services.getVariableDescriptorFromSimpleName(receiverExpression, context);
                boolean somethingFound = false;
                if (variableDescriptor != null) {
                    List<JetType> possibleTypes = Lists.newArrayList(context.dataFlowInfo.getPossibleTypes(variableDescriptor));
                    Collections.reverse(possibleTypes);

                    TemporaryBindingTrace autocastResolutionTrace = new TemporaryBindingTrace(context.trace.getBindingContext());
                    TypeInferenceContext autocastResolutionContext = context.replaceBindingTrace(autocastResolutionTrace);
                    for (JetType possibleType : possibleTypes) {
                        selectorReturnType = getSelectorReturnType(possibleType, selectorExpression, autocastResolutionContext);
                        if (selectorReturnType != null) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419022966049/fstmerge_var1_7755251088293609764
                            autocastResolutionTrace.record(BindingContext.AUTOCAST, receiverExpression, possibleType);
                            autocastResolutionTrace.addAllMyDataTo(context.trace);
                            somethingFound = true;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419022966049/fstmerge_base_5657858920311519683
                            regionToCommit = errorHandler.closeAndReturnCurrentRegion();
                            context.trace.recordAutoCast(receiverExpression, possibleType);
=======
                            regionToCommit = errorHandler.closeAndReturnCurrentRegion();
                            context.trace.recordAutoCast(receiverExpression, possibleType, variableDescriptor);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419022966049/fstmerge_var2_3043495987632443085
                            break;
                        }
                        else {
                            autocastResolutionTrace = new TemporaryBindingTrace(context.trace.getBindingContext());
                            autocastResolutionContext = context.replaceBindingTrace(autocastResolutionTrace);
                        }
                    }
                }
                if (!somethingFound) {
                    cleanResolutionTrace.addAllMyDataTo(context.trace);
                }
            }

            JetType result;
            if (expression.getOperationSign() == JetTokens.QUEST) {
                if (selectorReturnType != null && !isBoolean(selectorReturnType) && selectorExpression != null) {
                    // TODO : more comprehensible error message
                    context.trace.getErrorHandler().typeMismatch(selectorExpression, semanticServices.getStandardLibrary().getBooleanType(), selectorReturnType);
                }
                result = TypeUtils.makeNullable(receiverType);
            }
            else {
                result = selectorReturnType;
            }
            if (selectorExpression != null && result != null) {
                context.trace.record(BindingContext.EXPRESSION_TYPE, selectorExpression, result);
            }
            if (selectorReturnType != null) {
                // TODO : extensions to 'Any?'
                if (selectorExpression != null) {
                    receiverType = context.services.enrichOutType(receiverExpression, receiverType, context);

                    context.services.checkNullSafety(receiverType, expression.getOperationTokenNode(), getCalleeFunctionDescriptor(selectorExpression, context));
                }
            }
            return context.services.checkType(result, expression, contextWithExpectedType);
        }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b3b8a_847c7/rev_b3b8a-847c7/idea/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ public static final BindingTrace DUMMY_TRACE = new BindingTrace() {

        @NotNull
        @Override
        public ErrorHandler getErrorHandler() {
            return new ErrorHandler() {
                @Override
                public void unresolvedReference(@NotNull JetReferenceExpression referenceExpression) {
                    throw new IllegalStateException("Unresolved: " + referenceExpression.getText());
                }
            };
        }


        @Override
        public BindingContext getBindingContext() {
            return new BindingContext() {

                @Override
                public Collection<JetDiagnostic> getDiagnostics() {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public <K, V> V get(ReadOnlySlice<K, V> slice, K key) {
                    return DUMMY_TRACE.get(slice, key);
                }
            };
        }

        @Override
        public <K, V> void record(WritableSlice<K, V> slice, K key, V value) {
        }

        @Override
        public <K> void record(WritableSlice<K, Boolean> slice, K key) {
        }

        @Override
        public <K, V> V get(ReadOnlySlice<K, V> slice, K key) {
            if (slice == BindingContext.PROCESSED) return (V) Boolean.FALSE;
            return null;
        }
    }; ##FSTMerge## public static final BindingTrace DUMMY_TRACE = new BindingTrace() {

        @Override
        public void recordExpressionType(@NotNull JetExpression expression, @NotNull JetType type) {
        }

        @Override
        public void recordReferenceResolution(@NotNull JetReferenceExpression expression, @NotNull DeclarationDescriptor descriptor) {
        }

        @Override
        public void recordLabelResolution(@NotNull JetReferenceExpression expression, @NotNull PsiElement element) {
        }

        @Override
        public void recordDeclarationResolution(@NotNull PsiElement declaration, @NotNull DeclarationDescriptor descriptor) {
        }

        @Override
        public void recordValueParameterAsPropertyResolution(@NotNull JetParameter declaration, @NotNull PropertyDescriptor descriptor) {

        }

        @Override
        public void recordTypeResolution(@NotNull JetTypeReference typeReference, @NotNull JetType type) {
        }

        @Override
        public void recordAnnotationResolution(@NotNull JetAnnotationEntry annotationEntry, @NotNull AnnotationDescriptor annotationDescriptor) {

        }

        @Override
        public void recordCompileTimeValue(@NotNull JetExpression expression, @NotNull CompileTimeConstant<?> value) {

        }

        @Override
        public void recordBlock(JetFunctionLiteralExpression expression) {
        }

        @Override
        public void recordStatement(@NotNull JetElement statement) {
        }

        @Override
        public void recordVariableReassignment(@NotNull JetExpression expression) {

        }

        @Override
        public void recordResolutionScope(@NotNull JetExpression expression, @NotNull JetScope scope) {
        }

        @Override
        public void removeStatementRecord(@NotNull JetElement statement) {
        }

        @Override
        public void requireBackingField(@NotNull PropertyDescriptor propertyDescriptor) {
        }

        @Override
        public void recordAutoCast(@NotNull JetExpression expression, @NotNull JetType type) {

        }

        @NotNull
        @Override
        public ErrorHandlerWithRegions getErrorHandler() {
            return new ErrorHandlerWithRegions(new ErrorHandler() {
                @Override
                public void unresolvedReference(@NotNull JetReferenceExpression referenceExpression) {
                    throw new IllegalStateException("Unresolved: " + referenceExpression.getText());
                }
            });
        }

        @Override
        public boolean isProcessed(@NotNull JetExpression expression) {
            return false;
        }

        @Override
        public void markAsProcessed(@NotNull JetExpression expression) {

        }

        @Override
        public BindingContext getBindingContext() {
            return new BindingContext() {

                @Override
                public DeclarationDescriptor getDeclarationDescriptor(PsiElement declaration) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public NamespaceDescriptor getNamespaceDescriptor(JetNamespace declaration) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public ClassDescriptor getClassDescriptor(JetClassOrObject declaration) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public TypeParameterDescriptor getTypeParameterDescriptor(JetTypeParameter declaration) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public FunctionDescriptor getFunctionDescriptor(JetNamedFunction declaration) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public ConstructorDescriptor getConstructorDescriptor(JetElement declaration) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public AnnotationDescriptor getAnnotationDescriptor(JetAnnotationEntry annotationEntry) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public CompileTimeConstant<?> getCompileTimeValue(JetExpression expression) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public VariableDescriptor getVariableDescriptor(JetProperty declaration) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public VariableDescriptor getVariableDescriptor(JetParameter declaration) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public PropertyDescriptor getPropertyDescriptor(JetParameter primaryConstructorParameter) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public PropertyDescriptor getPropertyDescriptor(JetObjectDeclarationName objectDeclarationName) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public JetType getExpressionType(JetExpression expression) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public DeclarationDescriptor resolveReferenceExpression(JetReferenceExpression referenceExpression) {
                    return null;
                }

                @Override
                public JetType resolveTypeReference(JetTypeReference typeReference) {
                    return null;
                }

                @Override
                public PsiElement resolveToDeclarationPsiElement(JetReferenceExpression referenceExpression) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public PsiElement getDeclarationPsiElement(DeclarationDescriptor descriptor) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public boolean isBlock(JetFunctionLiteralExpression expression) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public boolean isStatement(JetExpression expression) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public boolean hasBackingField(PropertyDescriptor propertyDescriptor) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public boolean isVariableReassignment(JetExpression expression) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public ConstructorDescriptor resolveSuperConstructor(JetDelegatorToSuperCall superCall) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public JetType getAutoCastType(@NotNull JetExpression expression) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public JetScope getResolutionScope(@NotNull JetExpression expression) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public Collection<JetDiagnostic> getDiagnostics() {
                    throw new UnsupportedOperationException(); // TODO
                }

            };
        }
    }; ##FSTMerge## public static final BindingTrace DUMMY_TRACE = new BindingTrace() {

        @Override
        public void recordExpressionType(@NotNull JetExpression expression, @NotNull JetType type) {
        }

        @Override
        public void recordReferenceResolution(@NotNull JetReferenceExpression expression, @NotNull DeclarationDescriptor descriptor) {
        }

        @Override
        public void recordLabelResolution(@NotNull JetReferenceExpression expression, @NotNull PsiElement element) {
        }

        @Override
        public void recordDeclarationResolution(@NotNull PsiElement declaration, @NotNull DeclarationDescriptor descriptor) {
        }

        @Override
        public void recordValueParameterAsPropertyResolution(@NotNull JetParameter declaration, @NotNull PropertyDescriptor descriptor) {

        }

        @Override
        public void recordTypeResolution(@NotNull JetTypeReference typeReference, @NotNull JetType type) {
        }

        @Override
        public void recordAnnotationResolution(@NotNull JetAnnotationEntry annotationEntry, @NotNull AnnotationDescriptor annotationDescriptor) {

        }

        @Override
        public void recordCompileTimeValue(@NotNull JetExpression expression, @NotNull CompileTimeConstant<?> value) {

        }

        @Override
        public void recordBlock(JetFunctionLiteralExpression expression) {
        }

        @Override
        public void recordStatement(@NotNull JetElement statement) {
        }

        @Override
        public void recordVariableReassignment(@NotNull JetExpression expression) {

        }

        @Override
        public void recordResolutionScope(@NotNull JetExpression expression, @NotNull JetScope scope) {
        }

        @Override
        public void removeStatementRecord(@NotNull JetElement statement) {
        }

        @Override
        public void requireBackingField(@NotNull PropertyDescriptor propertyDescriptor) {
        }

        @Override
        public void recordAutoCast(@NotNull JetExpression expression, @NotNull JetType type, @NotNull VariableDescriptor variableDescriptor) {

        }

        @NotNull
        @Override
        public ErrorHandlerWithRegions getErrorHandler() {
            return new ErrorHandlerWithRegions(new ErrorHandler() {
                @Override
                public void unresolvedReference(@NotNull JetReferenceExpression referenceExpression) {
                    throw new IllegalStateException("Unresolved: " + referenceExpression.getText());
                }
            });
        }

        @Override
        public boolean isProcessed(@NotNull JetExpression expression) {
            return false;
        }

        @Override
        public void markAsProcessed(@NotNull JetExpression expression) {

        }

        @Override
        public BindingContext getBindingContext() {
            return new BindingContext() {

                @Override
                public DeclarationDescriptor getDeclarationDescriptor(PsiElement declaration) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public NamespaceDescriptor getNamespaceDescriptor(JetNamespace declaration) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public ClassDescriptor getClassDescriptor(JetClassOrObject declaration) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public TypeParameterDescriptor getTypeParameterDescriptor(JetTypeParameter declaration) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public FunctionDescriptor getFunctionDescriptor(JetNamedFunction declaration) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public ConstructorDescriptor getConstructorDescriptor(JetElement declaration) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public AnnotationDescriptor getAnnotationDescriptor(JetAnnotationEntry annotationEntry) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public CompileTimeConstant<?> getCompileTimeValue(JetExpression expression) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public VariableDescriptor getVariableDescriptor(JetProperty declaration) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public VariableDescriptor getVariableDescriptor(JetParameter declaration) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public PropertyDescriptor getPropertyDescriptor(JetParameter primaryConstructorParameter) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public PropertyDescriptor getPropertyDescriptor(JetObjectDeclarationName objectDeclarationName) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public JetType getExpressionType(JetExpression expression) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public DeclarationDescriptor resolveReferenceExpression(JetReferenceExpression referenceExpression) {
                    return null;
                }

                @Override
                public JetType resolveTypeReference(JetTypeReference typeReference) {
                    return null;
                }

                @Override
                public PsiElement resolveToDeclarationPsiElement(JetReferenceExpression referenceExpression) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public PsiElement getDeclarationPsiElement(DeclarationDescriptor descriptor) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public boolean isBlock(JetFunctionLiteralExpression expression) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public boolean isStatement(JetExpression expression) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public boolean hasBackingField(PropertyDescriptor propertyDescriptor) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public boolean isVariableReassignment(JetExpression expression) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public ConstructorDescriptor resolveSuperConstructor(JetDelegatorToSuperCall superCall) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public JetType getAutoCastType(@NotNull JetExpression expression) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public JetScope getResolutionScope(@NotNull JetExpression expression) {
                    throw new UnsupportedOperationException(); // TODO
                }

                @Override
                public Collection<JetDiagnostic> getDiagnostics() {
                    throw new UnsupportedOperationException(); // TODO
                }

            };
        }
    };
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b3b8a_847c7/rev_b3b8a-847c7/idea/tests/org/jetbrains/jet/JetTestUtils.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d597d_e0bcc/rev_d597d-e0bcc.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_dddff_a4695/rev_dddff-a4695.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_496d3_6fd6a/rev_496d3-6fd6a.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@Override
        public JetType visitBinaryWithTypeRHSExpression(JetBinaryExpressionWithTypeRHS expression, TypeInferenceContext context) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023280011/fstmerge_var1_4443472224266405573
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023280011/fstmerge_base_4011843555424310083
            IElementType operationType = expression.getOperationSign().getReferencedNameElementType();
            JetType actualType = getType(context.scope, expression.getLeft(), false, context.replaceExpectedType(NO_EXPECTED_TYPE));
=======
            IElementType operationType = expression.getOperationSign().getReferencedNameElementType();
            JetType actualType = getType(expression.getLeft(), context.replaceExpectedType(NO_EXPECTED_TYPE).replaceScope(context.scope));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023280011/fstmerge_var2_2866544623966450393
            JetTypeReference right = expression.getRight();
            JetType result = null;
            if (right != null) {
                JetType targetType = context.typeResolver.resolveType(context.scope, right);

                if (isTypeFlexible(expression.getLeft())) {
                    TemporaryBindingTrace temporaryTraceWithExpectedType = new TemporaryBindingTrace(context.trace.getBindingContext());
                    boolean success = checkBinaryWithTypeRHS(expression, context, targetType, targetType, temporaryTraceWithExpectedType);
                    if (success) {
                        temporaryTraceWithExpectedType.addAllMyDataTo(context.trace);
                    }
                    else {
                        TemporaryBindingTrace temporaryTraceWithoutExpectedType = new TemporaryBindingTrace(context.trace.getBindingContext());
                        checkBinaryWithTypeRHS(expression, context, targetType, NO_EXPECTED_TYPE, temporaryTraceWithoutExpectedType);
                        temporaryTraceWithoutExpectedType.addAllMyDataTo(context.trace);
                    }
                }
                else {
                    TemporaryBindingTrace temporaryTraceWithoutExpectedType = new TemporaryBindingTrace(context.trace.getBindingContext());
                    checkBinaryWithTypeRHS(expression, context, targetType, NO_EXPECTED_TYPE, temporaryTraceWithoutExpectedType);
                    temporaryTraceWithoutExpectedType.addAllMyDataTo(context.trace);
                }

                IElementType operationType = expression.getOperationSign().getReferencedNameElementType();
                result = operationType == JetTokens.AS_SAFE ? TypeUtils.makeNullable(targetType) : targetType;
            }
            else {
                getType(context.scope, expression.getLeft(), false, context.replaceExpectedType(NO_EXPECTED_TYPE));
            }
            return context.services.checkType(result, expression, context);
        }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_496d3_6fd6a/rev_496d3-6fd6a/idea/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
        public JetType visitBlockExpression(JetBlockExpression expression, TypeInferenceContext context) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023280029/fstmerge_var1_5761749032125231180
            return getBlockReturnedType(context.scope, expression, context);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023280029/fstmerge_base_8722382799023317415
            return context.services.checkType(getBlockReturnedType(context.scope, expression, context), expression, context);
=======
            return context.services.checkType(context.services.getBlockReturnedType(context.scope, expression, CoercionStrategy.NO_COERCION, context), expression, context);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023280029/fstmerge_var2_2902057763607347161
        }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_496d3_6fd6a/rev_496d3-6fd6a/idea/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023280086/fstmerge_var1_1742858519270390048
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023280086/fstmerge_base_8379292982677808871
@Nullable
        private JetType checkIterableConvention(@NotNull JetType type, @NotNull ASTNode reportErrorsOn, TypeInferenceContext context) {
            OverloadResolutionResult iteratorResolutionResult = context.services.resolveNoParametersFunction(type, context.scope, "iterator");
            if (iteratorResolutionResult.isSuccess()) {
                JetType iteratorType = iteratorResolutionResult.getFunctionDescriptor().getReturnType();
                boolean hasNextFunctionSupported = checkHasNextFunctionSupport(reportErrorsOn, iteratorType, context);
                boolean hasNextPropertySupported = checkHasNextPropertySupport(reportErrorsOn, iteratorType, context);
                if (hasNextFunctionSupported && hasNextPropertySupported && !ErrorUtils.isErrorType(iteratorType)) {
                    // TODO : overload resolution rules impose priorities here???
                    context.trace.getErrorHandler().genericError(reportErrorsOn, "An ambiguity between 'iterator().hasNext()' function and 'iterator().hasNext()' property");
                }
                else if (!hasNextFunctionSupported && !hasNextPropertySupported) {
                    context.trace.getErrorHandler().genericError(reportErrorsOn, "Loop range must have an 'iterator().hasNext()' function or an 'iterator().hasNext' property");
                }

                OverloadResolutionResult nextResolutionResult = context.services.resolveNoParametersFunction(iteratorType, context.scope, "next");
                if (nextResolutionResult.isAmbiguity()) {
                    context.trace.getErrorHandler().genericError(reportErrorsOn, "Method 'iterator().next()' is ambiguous for this expression");
                } else if (nextResolutionResult.isNothing()) {
                    context.trace.getErrorHandler().genericError(reportErrorsOn, "Loop range must have an 'iterator().next()' method");
                } else {
                    return nextResolutionResult.getFunctionDescriptor().getReturnType();
                }
            }
            else {
                String errorMessage = "For-loop range must have an iterator() method";
                if (iteratorResolutionResult.isAmbiguity()) {
                    errorMessage = "Method 'iterator()' is ambiguous for this expression";
                }
                context.trace.getErrorHandler().genericError(reportErrorsOn, errorMessage);
            }
            return null;
        }
=======
@Nullable
        private JetType checkIterableConvention(@NotNull JetType type, @NotNull ASTNode reportErrorsOn, TypeInferenceContext context) {
            OverloadResolutionResult<FunctionDescriptor> iteratorResolutionResult = context.services.callResolver.resolveExactSignature(context.scope, type, "iterator", Collections.<JetType>emptyList());
            if (iteratorResolutionResult.isSuccess()) {
                JetType iteratorType = iteratorResolutionResult.getDescriptor().getReturnType();
                boolean hasNextFunctionSupported = checkHasNextFunctionSupport(reportErrorsOn, iteratorType, context);
                boolean hasNextPropertySupported = checkHasNextPropertySupport(reportErrorsOn, iteratorType, context);
                if (hasNextFunctionSupported && hasNextPropertySupported && !ErrorUtils.isErrorType(iteratorType)) {
                    // TODO : overload resolution rules impose priorities here???
                    context.trace.getErrorHandler().genericError(reportErrorsOn, "An ambiguity between 'iterator().hasNext()' function and 'iterator().hasNext()' property");
                }
                else if (!hasNextFunctionSupported && !hasNextPropertySupported) {
                    context.trace.getErrorHandler().genericError(reportErrorsOn, "Loop range must have an 'iterator().hasNext()' function or an 'iterator().hasNext' property");
                }

                OverloadResolutionResult<FunctionDescriptor> nextResolutionResult = context.services.callResolver.resolveExactSignature(context.scope, iteratorType, "next", Collections.<JetType>emptyList());
                if (nextResolutionResult.isAmbiguity()) {
                    context.trace.getErrorHandler().genericError(reportErrorsOn, "Method 'iterator().next()' is ambiguous for this expression");
                } else if (nextResolutionResult.isNothing()) {
                    context.trace.getErrorHandler().genericError(reportErrorsOn, "Loop range must have an 'iterator().next()' method");
                } else {
                    return nextResolutionResult.getDescriptor().getReturnType();
                }
            }
            else {
                String errorMessage = "For-loop range must have an iterator() method";
                if (iteratorResolutionResult.isAmbiguity()) {
                    errorMessage = "Method 'iterator()' is ambiguous for this expression";
                }
                context.trace.getErrorHandler().genericError(reportErrorsOn, errorMessage);
            }
            return null;
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023280086/fstmerge_var2_8145702189091111979

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_496d3_6fd6a/rev_496d3-6fd6a/idea/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023280091/fstmerge_var1_900216516202388811
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023280091/fstmerge_base_3626103962702930422
private boolean checkHasNextFunctionSupport(@NotNull ASTNode reportErrorsOn, @NotNull JetType iteratorType, TypeInferenceContext context) {
            OverloadResolutionResult hasNextResolutionResult = context.services.resolveNoParametersFunction(iteratorType, context.scope, "hasNext");
            if (hasNextResolutionResult.isAmbiguity()) {
                context.trace.getErrorHandler().genericError(reportErrorsOn, "Method 'iterator().hasNext()' is ambiguous for this expression");
            } else if (hasNextResolutionResult.isNothing()) {
                return false;
            } else {
                JetType hasNextReturnType = hasNextResolutionResult.getFunctionDescriptor().getReturnType();
                if (!isBoolean(hasNextReturnType)) {
                    context.trace.getErrorHandler().genericError(reportErrorsOn, "The 'iterator().hasNext()' method of the loop range must return Boolean, but returns " + hasNextReturnType);
                }
            }
            return true;
        }
=======
private boolean checkHasNextFunctionSupport(@NotNull ASTNode reportErrorsOn, @NotNull JetType iteratorType, TypeInferenceContext context) {
            OverloadResolutionResult<FunctionDescriptor> hasNextResolutionResult = context.services.callResolver.resolveExactSignature(context.scope, iteratorType, "hasNext", Collections.<JetType>emptyList());
            if (hasNextResolutionResult.isAmbiguity()) {
                context.trace.getErrorHandler().genericError(reportErrorsOn, "Method 'iterator().hasNext()' is ambiguous for this expression");
            } else if (hasNextResolutionResult.isNothing()) {
                return false;
            } else {
                JetType hasNextReturnType = hasNextResolutionResult.getDescriptor().getReturnType();
                if (!isBoolean(hasNextReturnType)) {
                    context.trace.getErrorHandler().genericError(reportErrorsOn, "The 'iterator().hasNext()' method of the loop range must return Boolean, but returns " + hasNextReturnType);
                }
            }
            return true;
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023280091/fstmerge_var2_4323610176919832646

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_496d3_6fd6a/rev_496d3-6fd6a/idea/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_705f4_69549/rev_705f4-69549.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_234ea_8c356/rev_234ea-8c356.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@Override
        public JetType visitFunctionLiteralExpression(JetFunctionLiteralExpression expression, TypeInferenceContext context) {
            JetFunctionLiteral functionLiteral = expression.getFunctionLiteral();

            JetTypeReference receiverTypeRef = functionLiteral.getReceiverTypeRef();
            final JetType receiverType;
            if (receiverTypeRef != null) {
                receiverType = context.typeResolver.resolveType(context.scope, receiverTypeRef);
            } else {
                receiverType = context.scope.getThisType();
            }

            FunctionDescriptorImpl functionDescriptor = new FunctionDescriptorImpl(
                    context.scope.getContainingDeclaration(), Collections.<AnnotationDescriptor>emptyList(), "<anonymous>");

            List<JetType> parameterTypes = new ArrayList<JetType>();
            List<ValueParameterDescriptor> valueParameterDescriptors = Lists.newArrayList();
            List<JetParameter> parameters = functionLiteral.getValueParameters();
            JetType expectedType = context.expectedType;
            
            List<ValueParameterDescriptor> valueParameters = null;
            boolean functionTypeExpected = expectedType != NO_EXPECTED_TYPE && JetStandardClasses.isFunctionType(expectedType);
            if (functionTypeExpected) {
                valueParameters = JetStandardClasses.getValueParameters(functionDescriptor, expectedType);
            }

            for (int i = 0, parametersSize = parameters.size(); i < parametersSize; i++) {
                JetParameter parameter = parameters.get(i);
                JetTypeReference typeReference = parameter.getTypeReference();

                JetType type;
                if (typeReference != null) {
                    type = context.typeResolver.resolveType(context.scope, typeReference);
                }
                else {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023490709/fstmerge_var1_4262218252697001809
                    context.trace.getErrorHandler().genericError(parameter.getNode(), "Type inference for parameters is not implemented yet ");
                    type = ErrorUtils.createErrorType("Not inferred");
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023490709/fstmerge_base_6885540455912620211
                    context.trace.getErrorHandler().genericError(parameter.getNode(), "Type inference for parameters is not implemented yet");
                    type = ErrorUtils.createErrorType("Not inferred");
=======
                    if (valueParameters != null) {
                        type = valueParameters.get(i).getOutType();
                    }
                    else {
                        context.trace.getErrorHandler().genericError(parameter.getNode(), "Cannot infer a type for this parameter. To specify it explicitly use the {(p : Type) => ...} notation");
                        type = ErrorUtils.createErrorType("Cannot be inferred");
                    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023490709/fstmerge_var2_5520158977408460993
                }
                ValueParameterDescriptor valueParameterDescriptor = context.classDescriptorResolver.resolveValueParameterDescriptor(functionDescriptor, parameter, i, type);
                parameterTypes.add(valueParameterDescriptor.getOutType());
                valueParameterDescriptors.add(valueParameterDescriptor);
            }

            JetType effectiveReceiverType;
            if (receiverTypeRef == null) {
                if (functionTypeExpected) {
                    effectiveReceiverType = JetStandardClasses.getReceiverType(expectedType);
                }
                else {
                    effectiveReceiverType = null;
                }
            }
            else {
                effectiveReceiverType = receiverType;
            }
            functionDescriptor.initialize(effectiveReceiverType, Collections.<TypeParameterDescriptor>emptyList(), valueParameterDescriptors, null);
            context.trace.record(BindingContext.FUNCTION, expression, functionDescriptor);

            JetType returnType = NO_EXPECTED_TYPE;
            JetScope functionInnerScope = FunctionDescriptorUtil.getFunctionInnerScope(context.scope, functionDescriptor, context.trace);
            JetTypeReference returnTypeRef = functionLiteral.getReturnTypeRef();
            if (returnTypeRef != null) {
                returnType = context.typeResolver.resolveType(context.scope, returnTypeRef);
                context.services.checkFunctionReturnType(functionInnerScope, expression, returnType, context.dataFlowInfo, CoercionStrategy.COERCION_TO_UNIT);
            }
            else {
                if (functionTypeExpected) {
                    returnType = JetStandardClasses.getReturnType(expectedType);
                }
                returnType = context.services.getBlockReturnedType(functionInnerScope, functionLiteral.getBodyExpression(), CoercionStrategy.COERCION_TO_UNIT, context.replaceExpectedType(returnType));
            }
            JetType safeReturnType = returnType == null ? ErrorUtils.createErrorType("<return type>") : returnType;
            functionDescriptor.setReturnType(safeReturnType);

            if (functionTypeExpected) {
                JetType expectedReturnType = JetStandardClasses.getReturnType(expectedType);
                if (JetStandardClasses.isUnit(expectedReturnType)) {
                    return context.services.checkType(JetStandardClasses.getFunctionType(Collections.<AnnotationDescriptor>emptyList(), effectiveReceiverType, parameterTypes, expectedReturnType), expression, context);
                }

            }
            return context.services.checkType(JetStandardClasses.getFunctionType(Collections.<AnnotationDescriptor>emptyList(), effectiveReceiverType, parameterTypes, safeReturnType), expression, context);
        }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_234ea_8c356/rev_234ea-8c356/idea/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
        public JetType visitQualifiedExpression(JetQualifiedExpression expression, TypeInferenceContext contextWithExpectedType) {
            TypeInferenceContext context = contextWithExpectedType.replaceExpectedType(NO_EXPECTED_TYPE);
            // TODO : functions as values
            JetExpression selectorExpression = expression.getSelectorExpression();
            JetExpression receiverExpression = expression.getReceiverExpression();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023490823/fstmerge_var1_6993054153350959408

            JetType receiverType = context.services.typeInferrerVisitorWithNamespaces.getType(receiverExpression, new TypeInferenceContext(context.trace, context.scope, false, context.dataFlowInfo, NO_EXPECTED_TYPE, NO_EXPECTED_TYPE));

            if (selectorExpression instanceof JetSimpleNameExpression) {
                propagateConstantValues(expression, context, (JetSimpleNameExpression) selectorExpression);
            }

            if (receiverType == null) return null;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023490823/fstmerge_base_6047948241675714985
            JetType receiverType = context.services.typeInferrerVisitorWithNamespaces.getType(receiverExpression, new TypeInferenceContext(context.trace, context.scope, false, context.dataFlowInfo, NO_EXPECTED_TYPE, NO_EXPECTED_TYPE));
            if (receiverType == null) return null;
=======
            JetType receiverType = context.services.typeInferrerVisitorWithNamespaces.getType(receiverExpression, context.replaceExpectedTypes(NO_EXPECTED_TYPE, NO_EXPECTED_TYPE));
            if (selectorExpression == null) return null;
            if (receiverType == null) receiverType = ErrorUtils.createErrorType("Type for " + expression.getText());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023490823/fstmerge_var2_5888970613214547451

            // Clean resolution: no autocasts
            TemporaryBindingTrace cleanResolutionTrace = TemporaryBindingTrace.create(context.trace);
            TypeInferenceContext cleanResolutionContext = context.replaceBindingTrace(cleanResolutionTrace);
            JetType selectorReturnType = getSelectorReturnType(receiverType, selectorExpression, cleanResolutionContext);

            //TODO move further
            if (expression.getOperationSign() == JetTokens.SAFE_ACCESS) {
                if (selectorReturnType != null && !selectorReturnType.isNullable() && !JetStandardClasses.isUnit(selectorReturnType)) {
                    selectorReturnType = TypeUtils.makeNullable(selectorReturnType);
                }
            }
            if (selectorReturnType != null) {
                cleanResolutionTrace.addAllMyDataTo(context.trace);
            }
            else {
                VariableDescriptor variableDescriptor = cleanResolutionContext.services.getVariableDescriptorFromSimpleName(receiverExpression, context);
                boolean somethingFound = false;
                if (variableDescriptor != null) {
                    List<JetType> possibleTypes = Lists.newArrayList(context.dataFlowInfo.getPossibleTypes(variableDescriptor));
                    Collections.reverse(possibleTypes);

                    TemporaryBindingTrace autocastResolutionTrace = TemporaryBindingTrace.create(context.trace);
                    TypeInferenceContext autocastResolutionContext = context.replaceBindingTrace(autocastResolutionTrace);
                    for (JetType possibleType : possibleTypes) {
                        selectorReturnType = getSelectorReturnType(possibleType, selectorExpression, autocastResolutionContext);
                        if (selectorReturnType != null) {
                            context.services.checkAutoCast(receiverExpression, possibleType, variableDescriptor, autocastResolutionTrace);
                            autocastResolutionTrace.commit();
                            somethingFound = true;
                            break;
                        }
                        else {
                            autocastResolutionTrace = TemporaryBindingTrace.create(context.trace);
                            autocastResolutionContext = context.replaceBindingTrace(autocastResolutionTrace);
                        }
                    }
                }
                if (!somethingFound) {
                    cleanResolutionTrace.commit();
                }
            }

            JetType result;
            if (expression.getOperationSign() == JetTokens.QUEST) {
                if (selectorReturnType != null && !isBoolean(selectorReturnType) && selectorExpression != null) {
                    // TODO : more comprehensible error message
                    context.trace.getErrorHandler().typeMismatch(selectorExpression, semanticServices.getStandardLibrary().getBooleanType(), selectorReturnType);
                }
                result = TypeUtils.makeNullable(receiverType);
            }
            else {
                result = selectorReturnType;
            }
            if (selectorExpression != null && result != null) {
                context.trace.record(BindingContext.EXPRESSION_TYPE, selectorExpression, result);
            }
            if (selectorReturnType != null) {
                // TODO : extensions to 'Any?'
                if (selectorExpression != null) {
                    receiverType = context.services.enrichOutType(receiverExpression, receiverType, context);

                    context.services.checkNullSafety(receiverType, expression.getOperationTokenNode(), getCalleeFunctionDescriptor(selectorExpression, context));
                }
            }
            return context.services.checkType(result, expression, contextWithExpectedType);
        }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_234ea_8c356/rev_234ea-8c356/idea/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
protected void generatePrimaryConstructor() {
        ConstructorDescriptor constructorDescriptor = state.getBindingContext().get(BindingContext.CONSTRUCTOR, myClass);
        if (constructorDescriptor == null && !(myClass instanceof JetObjectDeclaration) && !isEnum(myClass)) return;

        Method method;
        CallableMethod callableMethod;
        if (constructorDescriptor == null) {
            method = new Method("<init>", Type.VOID_TYPE, new Type[0]);
            callableMethod = new CallableMethod("", method, Opcodes.INVOKESPECIAL, Collections.<Type>emptyList());
        }
        else {
            callableMethod = state.getTypeMapper().mapToCallableMethod(constructorDescriptor, kind);
            method = callableMethod.getSignature();
        }
        int flags = Opcodes.ACC_PUBLIC; // TODO
        final MethodVisitor mv = v.visitMethod(flags, "<init>", method.getDescriptor(), null, null);
        mv.visitCode();

        Type[] argTypes = method.getArgumentTypes();
        List<ValueParameterDescriptor> paramDescrs = constructorDescriptor != null
                ? constructorDescriptor.getValueParameters()
                : Collections.<ValueParameterDescriptor>emptyList();

        ConstructorFrameMap frameMap = new ConstructorFrameMap(callableMethod, constructorDescriptor, kind);

        final InstructionAdapter iv = new InstructionAdapter(mv);
        ExpressionCodegen codegen = new ExpressionCodegen(mv, frameMap, Type.VOID_TYPE, context, state);

        String classname = state.getTypeMapper().jvmName(descriptor, kind);
        final Type classType = Type.getType("L" + classname + ";");

        List<JetDelegationSpecifier> specifiers = myClass.getDelegationSpecifiers();

        if (specifiers.isEmpty() || !(specifiers.get(0) instanceof JetDelegatorToSuperCall)) {
            // TODO correct calculation of super class
            String superClass = "java/lang/Object";
            if (!specifiers.isEmpty()) {
                final JetType superType = state.getBindingContext().get(BindingContext.TYPE, specifiers.get(0).getTypeReference());
                ClassDescriptor superClassDescriptor = (ClassDescriptor) superType.getConstructor().getDeclarationDescriptor();
                if (superClassDescriptor.hasConstructors()) {
                    superClass = getSuperClass();
                }
            }
            iv.load(0, Type.getType("L" + superClass + ";"));
            iv.invokespecial(superClass, "<init>", /* TODO super constructor descriptor */"()V");
        }

        final ClassDescriptor outerDescriptor = getOuterClassDescriptor();
        if (outerDescriptor != null && !outerDescriptor.isObject()) {
            final Type type = JetTypeMapper.jetImplementationType(outerDescriptor);
            String interfaceDesc = type.getDescriptor();
            final String fieldName = "this$0";
            v.visitField(Opcodes.ACC_PRIVATE | Opcodes.ACC_FINAL, fieldName, interfaceDesc, null, null);
            iv.load(0, classType);
            iv.load(frameMap.getOuterThisIndex(), type);
            iv.putfield(classname, fieldName, interfaceDesc);
        }

        if (kind == OwnerKind.DELEGATING_IMPLEMENTATION) {
            String interfaceDesc = JetTypeMapper.jetInterfaceType(descriptor).getDescriptor();
            v.visitField(Opcodes.ACC_PRIVATE | Opcodes.ACC_FINAL, "$this", interfaceDesc, /*TODO*/null, null);
            iv.load(0, classType);
            iv.load(frameMap.getDelegateThisIndex(), argTypes[0]);
            iv.putfield(classname, "$this", interfaceDesc);
        }

        HashSet<FunctionDescriptor> overridden = new HashSet<FunctionDescriptor>();
        for (JetDeclaration declaration : myClass.getDeclarations()) {
            if (declaration instanceof JetFunction) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023498272/fstmerge_var1_2428167120522005211
                overridden.addAll(state.getBindingContext().get(BindingContext.FUNCTION, declaration).getOverriddenFunctions());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023498272/fstmerge_base_7440503304562480526
                overridden.addAll(state.getBindingContext().get(BindingContext.FUNCTION, (JetNamedFunction) declaration).getOverriddenFunctions());
=======
                overridden.addAll(state.getBindingContext().get(BindingContext.FUNCTION, (JetNamedFunction) declaration).getOverriddenDescriptors());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023498272/fstmerge_var2_6318791445938686674
            }
        }

        int n = 0;
        for (JetDelegationSpecifier specifier : specifiers) {
            boolean delegateOnStack = specifier instanceof JetDelegatorToSuperCall && n > 0 ||
                                      specifier instanceof JetDelegatorByExpressionSpecifier;

            if (delegateOnStack) {
                iv.load(0, classType);
            }

            if (specifier instanceof JetDelegatorToSuperCall) {
                ConstructorDescriptor constructorDescriptor1 = (ConstructorDescriptor) state.getBindingContext().get(BindingContext.REFERENCE_TARGET, ((JetDelegatorToSuperCall) specifier).getCalleeExpression().getConstructorReferenceExpression());
                generateDelegatorToConstructorCall(iv, codegen, (JetDelegatorToSuperCall) specifier, constructorDescriptor1, n == 0, frameMap);
            }
            else if (specifier instanceof JetDelegatorByExpressionSpecifier) {
                codegen.genToJVMStack(((JetDelegatorByExpressionSpecifier) specifier).getDelegateExpression());
            }

            if (delegateOnStack) {
                JetType superType = state.getBindingContext().get(BindingContext.TYPE, specifier.getTypeReference());
                ClassDescriptor superClassDescriptor = (ClassDescriptor) superType.getConstructor().getDeclarationDescriptor();
                String delegateField = "$delegate_" + n;
                Type fieldType = JetTypeMapper.jetInterfaceType(superClassDescriptor);
                String fieldDesc = fieldType.getDescriptor();
                v.visitField(Opcodes.ACC_PRIVATE, delegateField, fieldDesc, /*TODO*/null, null);
                iv.putfield(classname, delegateField, fieldDesc);

                JetClass superClass = (JetClass) state.getBindingContext().get(BindingContext.DESCRIPTOR_TO_DECLARATION, superClassDescriptor);
                final ClassContext delegateContext = context.intoClass(superClassDescriptor,
                        new OwnerKind.DelegateKind(StackValue.field(fieldType, classname, delegateField, false),
                        JetTypeMapper.jvmNameForInterface(superClassDescriptor)));
                generateDelegates(superClass, delegateContext, overridden);
            }

            n++;
        }

        if (frameMap.getFirstTypeParameter() > 0 && kind == OwnerKind.IMPLEMENTATION) {
            generateTypeInfoInitializer(frameMap.getFirstTypeParameter(), frameMap.getTypeParameterCount(), iv);
        }

        generateInitializers(codegen, iv);

        int curParam = 0;
        List<JetParameter> constructorParameters = getPrimaryConstructorParameters();
        for (JetParameter parameter : constructorParameters) {
            if (parameter.getValOrVarNode() != null) {
                VariableDescriptor descriptor = paramDescrs.get(curParam);
                Type type = state.getTypeMapper().mapType(descriptor.getOutType());
                iv.load(0, classType);
                iv.load(frameMap.getIndex(descriptor), type);
                iv.putfield(classname, descriptor.getName(), type.getDescriptor());
            }
            curParam++;
        }

        mv.visitInsn(Opcodes.RETURN);
        mv.visitMaxs(0, 0);
        mv.visitEnd();
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_234ea_8c356/rev_234ea-8c356/idea/src/org/jetbrains/jet/codegen/ImplementationBodyCodegen.java
Conflict type: LineBasedMCFd
Conflict body: 
protected void generateInitializers(ExpressionCodegen codegen, InstructionAdapter iv) {
        for (JetDeclaration declaration : myClass.getDeclarations()) {
            if (declaration instanceof JetProperty) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023498299/fstmerge_var1_5170924986891018705
                final PropertyDescriptor propertyDescriptor = (PropertyDescriptor) state.getBindingContext().get(BindingContext.VARIABLE, declaration);
                if (state.getBindingContext().get(BindingContext.BACKING_FIELD_REQUIRED, propertyDescriptor)) {
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023498299/fstmerge_base_5551783089982449771
                final PropertyDescriptor propertyDescriptor = (PropertyDescriptor) state.getBindingContext().get(BindingContext.VARIABLE, (JetProperty) declaration);
                if ((boolean) state.getBindingContext().get(BindingContext.BACKING_FIELD_REQUIRED, propertyDescriptor)) {
=======
                final PropertyDescriptor propertyDescriptor = (PropertyDescriptor) state.getBindingContext().get(BindingContext.VARIABLE, (JetProperty) declaration);
                if (state.getBindingContext().get(BindingContext.BACKING_FIELD_REQUIRED, propertyDescriptor)) {
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023498299/fstmerge_var2_2554800775672921015
                    final JetExpression initializer = ((JetProperty) declaration).getInitializer();
                    if (initializer != null) {
                        CompileTimeConstant<?> compileTimeValue = state.getBindingContext().get(BindingContext.COMPILE_TIME_VALUE, initializer);
                        if(compileTimeValue != null) {
                            assert compileTimeValue != null;
                            Object value = compileTimeValue.getValue();
                            Type type = state.getTypeMapper().mapType(propertyDescriptor.getOutType());
                            if(JetTypeMapper.isPrimitive(type)) {
                                if( !propertyDescriptor.getOutType().isNullable() && value instanceof Number) {
                                    if(type == Type.INT_TYPE && ((Number)value).intValue() == 0)
                                        continue;
                                    if(type == Type.BYTE_TYPE && ((Number)value).byteValue() == 0)
                                        continue;
                                    if(type == Type.LONG_TYPE && ((Number)value).longValue() == 0L)
                                        continue;
                                    if(type == Type.SHORT_TYPE && ((Number)value).shortValue() == 0)
                                        continue;
                                    if(type == Type.DOUBLE_TYPE && ((Number)value).doubleValue() == 0d)
                                        continue;
                                    if(type == Type.FLOAT_TYPE && ((Number)value).byteValue() == 0f)
                                        continue;
                                }
                                if(type == Type.BOOLEAN_TYPE && value instanceof Boolean && !((Boolean)value))
                                    continue;
                                if(type == Type.CHAR_TYPE && value instanceof Character && ((Character)value) == 0)
                                    continue;
                            }
                            else {
                                if(value == null)
                                    continue;
                            }
                        }
                        iv.load(0, JetTypeMapper.TYPE_OBJECT);
                        Type type = codegen.expressionType(initializer);
                        if(propertyDescriptor.getOutType().isNullable())
                            type = state.getTypeMapper().boxType(type);
                        codegen.gen(initializer, type);
                        codegen.intermediateValueForProperty(propertyDescriptor, false, false).store(iv);
                    }

                }
            }
            else if (declaration instanceof JetClassInitializer) {
                codegen.gen(((JetClassInitializer) declaration).getBody(), Type.VOID_TYPE);
            }
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_234ea_8c356/rev_234ea-8c356/idea/src/org/jetbrains/jet/codegen/ImplementationBodyCodegen.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_2c25a_abfbe/rev_2c25a-abfbe.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public ItemPresentation getPresentation() {
        return new ItemPresentation() {
            @Override
            public String getPresentableText() {
                String name = myElement.getName();
                if (StringUtil.isEmpty(name)) {
                    if (myElement instanceof JetClassInitializer) {
                        return "<class initializer>";
                    }
                }
                return name;
            }

            @Override
            public String getLocationString() {
                return null;
            }

            @Override
            public Icon getIcon(boolean open) {
                return myElement.isValid()
                        ? PsiIconUtil.getProvidersIcon(myElement, open ? Iconable.ICON_FLAG_OPEN : Iconable.ICON_FLAG_CLOSED)
                        : null;
            }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023604613/fstmerge_var1_9215732126915560946

//            @Override
//            public TextAttributesKey getTextAttributesKey() {
//                return null;  //To change body of implemented methods use File | Settings | File Templates.
//            }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023604613/fstmerge_base_5089577517600314222

            @Override
            public TextAttributesKey getTextAttributesKey() {
                return null;  //To change body of implemented methods use File | Settings | File Templates.
            }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419023604613/fstmerge_var2_5983263444711720040
        };
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_2c25a_abfbe/rev_2c25a-abfbe/idea/src/org/jetbrains/jet/plugin/structureView/JetStructureViewElement.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_76423_fc4ee/rev_76423-fc4ee.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_fa631_53357/rev_fa631-53357.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6898f_cec83/rev_6898f-cec83.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_db719_dd0b3/rev_db719-dd0b3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_71bc4_f89a2/rev_71bc4-f89a2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_43dd5_32a00/rev_43dd5-32a00.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419024264818/fstmerge_var1_4544370235882183804
public static ClassModifiers resolveModifiers(@Nullable JetModifierList modifierList) {
        if (modifierList == null) return DEFAULT_MODIFIERS;
        boolean abstractModifier = modifierList.hasModifier(JetTokens.ABSTRACT_KEYWORD);
        boolean traitModifier = modifierList.hasModifier(JetTokens.TRAIT_KEYWORD);
        return new ClassModifiers(
                abstractModifier || traitModifier,
                modifierList.hasModifier(JetTokens.OPEN_KEYWORD) || abstractModifier || traitModifier,
                traitModifier
        );
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419024264818/fstmerge_base_6072818261449545064
public static ClassModifiers resolveModifiers(@Nullable JetModifierList modifierList) {
        if (modifierList == null) return DEFAULT_MODIFIERS;
        return new ClassModifiers(
                modifierList.hasModifier(JetTokens.ABSTRACT_KEYWORD),
                modifierList.hasModifier(JetTokens.OPEN_KEYWORD) || modifierList.hasModifier(JetTokens.ABSTRACT_KEYWORD),
                modifierList.hasModifier(JetTokens.TRAIT_KEYWORD)
        );
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419024264818/fstmerge_var2_8213546341992167991

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_43dd5_32a00/rev_43dd5-32a00/idea/src/org/jetbrains/jet/lang/descriptors/ClassModifiers.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_67d59_c7985/rev_67d59-c7985.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_bccf3_0a7c7/rev_bccf3-0a7c7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b7542_68c13/rev_b7542-68c13.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3dd9b_6fd7e/rev_3dd9b-6fd7e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_74cbb_910ba/rev_74cbb-910ba.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6ec8b_205e2/rev_6ec8b-205e2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0dfef_408c6/rev_0dfef-408c6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e8311_7f815/rev_e8311-7f815.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419025174302/fstmerge_var1_3191109633953689889
private void checkNullSafety(@Nullable JetType receiverType, @NotNull ASTNode operationTokenNode, @Nullable FunctionDescriptor callee) {
            if (receiverType != null && callee != null) {
                boolean namespaceType = receiverType instanceof NamespaceType;
                boolean nullableReceiver = !namespaceType && receiverType.isNullable();
                ReceiverDescriptor calleeReceiver = callee.getReceiver();
                boolean calleeForbidsNullableReceiver = !calleeReceiver.exists() || !calleeReceiver.getType().isNullable();

                IElementType operationSign = operationTokenNode.getElementType();
                if (nullableReceiver && calleeForbidsNullableReceiver && operationSign == JetTokens.DOT) {
//                    trace.getErrorHandler().genericError(operationTokenNode, "Only safe calls (?.) are allowed on a nullable receiver of type " + receiverType);
                    trace.report(UNSAFE_CALL.on(operationTokenNode, receiverType));
                }
                else if ((!nullableReceiver || !calleeForbidsNullableReceiver) && operationSign == JetTokens.SAFE_ACCESS) {
                    if (namespaceType) {
//                        trace.getErrorHandler().genericError(operationTokenNode, "Safe calls are not allowed on namespaces");
                        trace.report(SAFE_CALLS_ARE_NOT_ALLOWED_ON_NAMESPACES.on(operationTokenNode));
                    }
                    else {
//                        trace.getErrorHandler().genericWarning(operationTokenNode, "Unnecessary safe call on a non-null receiver of type  " + receiverType);

                        trace.report(UNNECESSARY_SAFE_CALL.on(operationTokenNode, receiverType));

                    }
                }
            }
        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419025174302/fstmerge_base_840750979235986036
private void checkNullSafety(@Nullable JetType receiverType, @NotNull ASTNode operationTokenNode, @Nullable FunctionDescriptor callee) {
            if (receiverType != null && callee != null) {
                boolean namespaceType = receiverType instanceof NamespaceType;
                JetType calleeReceiverType = callee.getReceiverType();
                boolean nullableReceiver = !namespaceType && receiverType.isNullable();
                boolean calleeForbidsNullableReceiver = calleeReceiverType == null || !calleeReceiverType.isNullable();

                IElementType operationSign = operationTokenNode.getElementType();
                if (nullableReceiver && calleeForbidsNullableReceiver && operationSign == JetTokens.DOT) {
//                    trace.getErrorHandler().genericError(operationTokenNode, "Only safe calls (?.) are allowed on a nullable receiver of type " + receiverType);
                    trace.report(UNSAFE_CALL.on(operationTokenNode, receiverType));
                }
                else if ((!nullableReceiver || !calleeForbidsNullableReceiver) && operationSign == JetTokens.SAFE_ACCESS) {
                    if (namespaceType) {
//                        trace.getErrorHandler().genericError(operationTokenNode, "Safe calls are not allowed on namespaces");
                        trace.report(SAFE_CALLS_ARE_NOT_ALLOWED_ON_NAMESPACES.on(operationTokenNode));
                    }
                    else {
//                        trace.getErrorHandler().genericWarning(operationTokenNode, "Unnecessary safe call on a non-null receiver of type  " + receiverType);

                        trace.report(UNNECESSARY_SAFE_CALL.on(operationTokenNode, receiverType));

                    }
                }
            }
        }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419025174302/fstmerge_var2_1239077247868123360

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e8311_7f815/rev_e8311-7f815/compiler/frontend/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d1fb0_4ac2a/rev_d1fb0-4ac2a.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@NotNull
    public FunctionDescriptorImpl resolveFunctionDescriptor(DeclarationDescriptor containingDescriptor, final JetScope scope, final JetNamedFunction function) {
        final FunctionDescriptorImpl functionDescriptor = new FunctionDescriptorImpl(
                containingDescriptor,
                annotationResolver.resolveAnnotations(scope, function.getModifierList()),
                JetPsiUtil.safeName(function.getName())
        );
        WritableScope innerScope = new WritableScopeImpl(scope, functionDescriptor, new TraceBasedRedeclarationHandler(trace)).setDebugName("Function descriptor header scope");
        innerScope.addLabeledDeclaration(functionDescriptor);

        List<TypeParameterDescriptor> typeParameterDescriptors = resolveTypeParameters(functionDescriptor, innerScope, function.getTypeParameters());
        resolveGenericBounds(function, innerScope, typeParameterDescriptors);

        JetType receiverType = null;
        JetTypeReference receiverTypeRef = function.getReceiverTypeRef();
        if (receiverTypeRef != null) {
            JetScope scopeForReceiver =
                    function.hasTypeParameterListBeforeFunctionName()
                            ? innerScope
                            : scope;
            receiverType = typeResolver.resolveType(scopeForReceiver, receiverTypeRef);
        }

        List<ValueParameterDescriptor> valueParameterDescriptors = resolveValueParameters(functionDescriptor, innerScope, function.getValueParameters());

        JetTypeReference returnTypeRef = function.getReturnTypeRef();
        JetType returnType;
        if (returnTypeRef != null) {
            returnType = typeResolver.resolveType(innerScope, returnTypeRef);
        }
        else if (function.hasBlockBody()) {
            returnType = JetStandardClasses.getUnitType();
        }
        else {
            final JetExpression bodyExpression = function.getBodyExpression();
            if (bodyExpression != null) {
                returnType = new DeferredType(new LazyValue<JetType>() {
                    @Override
                    protected JetType compute() {
                        JetFlowInformationProvider flowInformationProvider = computeFlowData(function, bodyExpression);
                        return semanticServices.getTypeInferrerServices(trace, flowInformationProvider).inferFunctionReturnType(scope, function, functionDescriptor);
                    }
                });
            }
            else {
//                trace.getErrorHandler().genericError(function.asElement().getNode(), "This function must either declare a return type or have a body element");
                trace.report(FUNCTION_WITH_NO_TYPE_NO_BODY.on(function.asElement()));
                returnType = ErrorUtils.createErrorType("No type, no body");
            }
        }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419025295315/fstmerge_var1_889772878069177761
        boolean hasBody = function.getBodyExpression() != null;
        Modality defaultModality = getDefaultModality(containingDescriptor, hasBody);
        Modality modality = resolveModalityFromModifiers(function.getModifierList(), defaultModality);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419025295315/fstmerge_base_3772580256364233716
        Modality defaultModality;
        if (containingDescriptor instanceof ClassDescriptor) {
            boolean isDefinitelyAbstract = ((ClassDescriptor) containingDescriptor).getKind() == ClassKind.TRAIT && function.getBodyExpression() == null;
            defaultModality = isDefinitelyAbstract ? Modality.ABSTRACT : Modality.FINAL;
        } else {
            defaultModality = Modality.FINAL;
        }
        Modality modality = resolveModalityFromModifiers(function.getModifierList(), defaultModality);
=======
        Modality defaultModality;
        if (containingDescriptor instanceof ClassDescriptor) {
            boolean isDefinitelyAbstract = ((ClassDescriptor) containingDescriptor).getKind() == ClassKind.TRAIT && function.getBodyExpression() == null;
            defaultModality = isDefinitelyAbstract ? Modality.ABSTRACT : Modality.FINAL;
        } else {
            defaultModality = Modality.FINAL;
        }
        Modality modality = resolveModalityFromModifiers(trace, function.getModifierList(), defaultModality);
        Visibility visibility = resolveVisibilityFromModifiers(trace, function.getModifierList());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419025295315/fstmerge_var2_1831780888370254886

        functionDescriptor.initialize(
                receiverType,
                typeParameterDescriptors,
                valueParameterDescriptors,
                returnType,
                modality,
                visibility);

        trace.record(BindingContext.FUNCTION, function, functionDescriptor);
        return functionDescriptor;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d1fb0_4ac2a/rev_d1fb0-4ac2a/compiler/frontend/src/org/jetbrains/jet/lang/resolve/ClassDescriptorResolver.java
Conflict type: LineBasedMCFd
Conflict body: 
@NotNull
    public PropertyDescriptor resolvePropertyDescriptor(@NotNull DeclarationDescriptor containingDeclaration, @NotNull JetScope scope, JetProperty property) {
        JetScope scopeWithTypeParameters;
        List<TypeParameterDescriptor> typeParameterDescriptors;
        List<JetTypeParameter> typeParameters = property.getTypeParameters();
        if (typeParameters.isEmpty()) {
            scopeWithTypeParameters = scope;
            typeParameterDescriptors = Collections.emptyList();
        }
        else {
            WritableScope writableScope = new WritableScopeImpl(scope, containingDeclaration, new TraceBasedRedeclarationHandler(trace)).setDebugName("Scope with type parameters of a property");
            typeParameterDescriptors = resolveTypeParameters(containingDeclaration, writableScope, typeParameters);
            resolveGenericBounds(property, writableScope, typeParameterDescriptors);
            scopeWithTypeParameters = writableScope;
        }

        JetType receiverType = null;
        JetTypeReference receiverTypeRef = property.getReceiverTypeRef();
        if (receiverTypeRef != null) {
            receiverType = typeResolver.resolveType(scopeWithTypeParameters, receiverTypeRef);
        }

        JetModifierList modifierList = property.getModifierList();
        boolean isVar = property.isVar();

        JetType type = getVariableType(scopeWithTypeParameters, property, true);

        boolean hasBody = property.getInitializer() != null;
        if (!hasBody) {
            JetPropertyAccessor getter = property.getGetter();
            if (getter != null && getter.getBodyExpression() != null) {
                hasBody = true;
            }
            JetPropertyAccessor setter = property.getSetter();
            if (!hasBody && setter != null && setter.getBodyExpression() != null) {
                hasBody = true;
            }
        }
        Modality defaultModality = getDefaultModality(containingDeclaration, hasBody);
        PropertyDescriptor propertyDescriptor = new PropertyDescriptor(
                containingDeclaration,
                annotationResolver.resolveAnnotations(scope, modifierList),
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419025295374/fstmerge_var1_5744737813559177119
                resolveModalityFromModifiers(modifierList, defaultModality),
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419025295374/fstmerge_base_5121206381676881384
                resolveModalityFromModifiers(modifierList), // TODO : default modifiers differ in different contexts
=======
                resolveModalityFromModifiers(trace, property.getModifierList()), // TODO : default modifiers differ in different contexts
                resolveVisibilityFromModifiers(trace, property.getModifierList()),
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419025295374/fstmerge_var2_2181460993818866855
                isVar,
                receiverType,
                JetPsiUtil.safeName(property.getName()),
                isVar ? type : null,
                type);

        propertyDescriptor.initialize(
                typeParameterDescriptors,
                resolvePropertyGetterDescriptor(scopeWithTypeParameters, property, propertyDescriptor),
                resolvePropertySetterDescriptor(scopeWithTypeParameters, property, propertyDescriptor));

        trace.record(BindingContext.VARIABLE, property, propertyDescriptor);
        return propertyDescriptor;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d1fb0_4ac2a/rev_d1fb0-4ac2a/compiler/frontend/src/org/jetbrains/jet/lang/resolve/ClassDescriptorResolver.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_9b55a_4c2e5/rev_9b55a-4c2e5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_93984_95af2/rev_93984-95af2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_eeb35_7281d/rev_eeb35-7281d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c8c74_fdac4/rev_c8c74-fdac4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_a06aa_23174/rev_a06aa-23174.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_8a927_70d48/rev_8a927-70d48.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_7b2c5_cbf70/rev_7b2c5-cbf70.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_1c299_22591/rev_1c299-22591.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419026315382/fstmerge_var1_5799220314346266752
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419026315382/fstmerge_base_4188419678893517319
private void collectNamespacesAndClassifiers(
            @NotNull final JetScope outerScope,
            @NotNull final NamespaceLike owner,
            @NotNull Collection<JetDeclaration> declarations) {
        for (JetDeclaration declaration : declarations) {
            declaration.accept(new JetVisitorVoid() {
                @Override
                public void visitNamespace(JetNamespace namespace) {
                    String name = JetPsiUtil.safeName(namespace.getName());

                    NamespaceDescriptorImpl namespaceDescriptor = owner.getNamespace(name);
                    if (namespaceDescriptor == null) {
                        namespaceDescriptor = new NamespaceDescriptorImpl(
                                owner.getOriginal(),
                                Collections.<AnnotationDescriptor>emptyList(), // TODO: annotations
                                name
                        );
                        namespaceDescriptor.initialize(new WritableScopeImpl(JetScope.EMPTY, namespaceDescriptor, new TraceBasedRedeclarationHandler(context.getTrace())).setDebugName("Namespace member scope"));
                        owner.addNamespace(namespaceDescriptor);
                        context.getTrace().record(BindingContext.NAMESPACE, namespace, namespaceDescriptor);
                    }
                    context.getNamespaceDescriptors().put(namespace, namespaceDescriptor);

                    WriteThroughScope namespaceScope = new WriteThroughScope(outerScope, namespaceDescriptor.getMemberScope(), new TraceBasedRedeclarationHandler(context.getTrace()));
                    context.getNamespaceScopes().put(namespace, namespaceScope);

                    processImports(namespace, namespaceScope, outerScope);

                    collectNamespacesAndClassifiers(namespaceScope, namespaceDescriptor, namespace.getDeclarations());
                }

                @Override
                public void visitClass(JetClass klass) {
                    MutableClassDescriptor mutableClassDescriptor = new MutableClassDescriptor(context.getTrace(), owner, outerScope, getClassKind(klass));

                    if (klass.hasModifier(JetTokens.ENUM_KEYWORD)) {
                        MutableClassDescriptor classObjectDescriptor = new MutableClassDescriptor(context.getTrace(), mutableClassDescriptor, outerScope, ClassKind.OBJECT);
                        classObjectDescriptor.setName("class-object-for-" + klass.getName());
                        classObjectDescriptor.setModality(Modality.FINAL);
                        classObjectDescriptor.setVisibility(ClassDescriptorResolver.resolveVisibilityFromModifiers(context.getTrace(), klass.getModifierList()));
                        classObjectDescriptor.createTypeConstructor();
                        createPrimaryConstructorForObject(null, classObjectDescriptor);
                        mutableClassDescriptor.setClassObjectDescriptor(classObjectDescriptor);
                    }
                    visitClassOrObject(
                            klass,
                            (Map) context.getClasses(),
                            owner,
                            outerScope,
                            mutableClassDescriptor);
                    owner.addClassifierDescriptor(mutableClassDescriptor);
                }

                @Override
                public void visitObjectDeclaration(JetObjectDeclaration declaration) {
                    createClassDescriptorForObject(declaration, owner);
                }

                @Override
                public void visitEnumEntry(JetEnumEntry enumEntry) {
                    MutableClassDescriptor classObjectDescriptor = ((MutableClassDescriptor) owner).getClassObjectDescriptor();
                    assert classObjectDescriptor != null : enumEntry.getParent().getText();
                    if (enumEntry.getPrimaryConstructorParameterList() == null) {
                        MutableClassDescriptor classDescriptor = createClassDescriptorForObject(enumEntry, classObjectDescriptor);
                        context.getObjects().remove(enumEntry);
                        context.getClasses().put(enumEntry, classDescriptor);
                    }
                    else {
                        MutableClassDescriptor mutableClassDescriptor = new MutableClassDescriptor(context.getTrace(), classObjectDescriptor, outerScope, ClassKind.CLASS); // TODO : Special kind for enum entry classes?
                        visitClassOrObject(
                                enumEntry,
                                (Map) context.getClasses(),
                                classObjectDescriptor,
                                outerScope,
                                mutableClassDescriptor);
                        classObjectDescriptor.addClassifierDescriptor(mutableClassDescriptor);
                    }
                }

                private MutableClassDescriptor createClassDescriptorForObject(@NotNull JetClassOrObject declaration, @NotNull NamespaceLike owner) {
                    MutableClassDescriptor mutableClassDescriptor = new MutableClassDescriptor(context.getTrace(), owner, outerScope, ClassKind.OBJECT) {
                        @Override
                        public ClassObjectStatus setClassObjectDescriptor(@NotNull MutableClassDescriptor classObjectDescriptor) {
                            return ClassObjectStatus.NOT_ALLOWED;
                        }
                    };
                    visitClassOrObject(declaration, (Map) context.getObjects(), owner, outerScope, mutableClassDescriptor);
                    createPrimaryConstructorForObject((JetDeclaration) declaration, mutableClassDescriptor);
                    context.getTrace().record(BindingContext.CLASS, declaration, mutableClassDescriptor);
                    return mutableClassDescriptor;
                }

                private void createPrimaryConstructorForObject(@Nullable JetDeclaration object, MutableClassDescriptor mutableClassDescriptor) {
                    ConstructorDescriptorImpl constructorDescriptor = new ConstructorDescriptorImpl(mutableClassDescriptor, Collections.<AnnotationDescriptor>emptyList(), true);
                    constructorDescriptor.initialize(Collections.<TypeParameterDescriptor>emptyList(), Collections.<ValueParameterDescriptor>emptyList(),
                                                     Modality.FINAL, Visibility.INTERNAL);//TODO check set mutableClassDescriptor.getVisibility()
                    // TODO : make the constructor private?
                    mutableClassDescriptor.setPrimaryConstructor(constructorDescriptor);
                    if (object != null) {
                        context.getTrace().record(CONSTRUCTOR, object, constructorDescriptor);
                    }
                }

                private void visitClassOrObject(@NotNull JetClassOrObject declaration, Map<JetClassOrObject, MutableClassDescriptor> map, NamespaceLike owner, JetScope outerScope, MutableClassDescriptor mutableClassDescriptor) {
                    mutableClassDescriptor.setName(JetPsiUtil.safeName(declaration.getName()));

                    map.put(declaration, mutableClassDescriptor);
//                    declaringScopes.put((JetDeclaration) declaration, outerScope);

                    JetScope classScope = mutableClassDescriptor.getScopeForMemberResolution();
                    collectNamespacesAndClassifiers(classScope, mutableClassDescriptor, declaration.getDeclarations());
                }

                @Override
                public void visitTypedef(JetTypedef typedef) {
//                    context.getTrace().getErrorHandler().genericError(typedef.getNode(), "Unsupported [TopDownAnalyzer]");
                    context.getTrace().report(UNSUPPORTED.on(typedef, "TypeHierarchyResolver"));
                }

                @Override
                public void visitClassObject(JetClassObject classObject) {
                    JetObjectDeclaration objectDeclaration = classObject.getObjectDeclaration();
                    if (objectDeclaration != null) {
                        NamespaceLike.ClassObjectStatus status = owner.setClassObjectDescriptor(createClassDescriptorForObject(objectDeclaration, owner));
                        switch (status) {
                            case DUPLICATE:
//                                context.getTrace().getErrorHandler().genericError(classObject.getNode(), "Only one class object is allowed per class");
                                context.getTrace().report(MANY_CLASS_OBJECTS.on(classObject));
                                break;
                            case NOT_ALLOWED:
//                                context.getTrace().getErrorHandler().genericError(classObject.getNode(), "A class object is not allowed here");
                                context.getTrace().report(CLASS_OBJECT_NOT_ALLOWED.on(classObject));
                                break;
                        }
                    }
                }
            });
        }
    }
=======
private void collectNamespacesAndClassifiers(
            @NotNull final JetScope outerScope,
            @NotNull final NamespaceLike owner,
            @NotNull Collection<JetDeclaration> declarations) {
        for (JetDeclaration declaration : declarations) {
            declaration.accept(new JetVisitorVoid() {
                @Override
                public void visitNamespace(JetNamespace namespace) {
                    String name = JetPsiUtil.safeName(namespace.getName());

                    NamespaceDescriptorImpl namespaceDescriptor = owner.getNamespace(name);
                    if (namespaceDescriptor == null) {
                        namespaceDescriptor = new NamespaceDescriptorImpl(
                                owner.getOriginal(),
                                Collections.<AnnotationDescriptor>emptyList(), // TODO: annotations
                                name
                        );
                        namespaceDescriptor.initialize(new WritableScopeImpl(JetScope.EMPTY, namespaceDescriptor, new TraceBasedRedeclarationHandler(context.getTrace())).setDebugName("Namespace member scope"));
                        owner.addNamespace(namespaceDescriptor);
                        context.getTrace().record(BindingContext.NAMESPACE, namespace, namespaceDescriptor);
                    }
                    context.getNamespaceDescriptors().put(namespace, namespaceDescriptor);

                    WriteThroughScope namespaceScope = new WriteThroughScope(outerScope, namespaceDescriptor.getMemberScope(), new TraceBasedRedeclarationHandler(context.getTrace()));
                    context.getNamespaceScopes().put(namespace, namespaceScope);

                    processImports(namespace, namespaceScope, outerScope);

                    collectNamespacesAndClassifiers(namespaceScope, namespaceDescriptor, namespace.getDeclarations());
                }

                @Override
                public void visitClass(JetClass klass) {
                    MutableClassDescriptor mutableClassDescriptor = new MutableClassDescriptor(context.getTrace(), owner, outerScope, getClassKind(klass));

                    if (klass.hasModifier(JetTokens.ENUM_KEYWORD)) {
                        MutableClassDescriptor classObjectDescriptor = new MutableClassDescriptor(context.getTrace(), mutableClassDescriptor, outerScope, ClassKind.OBJECT);
                        classObjectDescriptor.setName("class-object-for-" + klass.getName());
                        classObjectDescriptor.setModality(Modality.FINAL);
                        classObjectDescriptor.setVisibility(ClassDescriptorResolver.resolveVisibilityFromModifiers(klass.getModifierList()));
                        classObjectDescriptor.createTypeConstructor();
                        createPrimaryConstructorForObject(null, classObjectDescriptor);
                        mutableClassDescriptor.setClassObjectDescriptor(classObjectDescriptor);
                    }
                    visitClassOrObject(
                            klass,
                            (Map) context.getClasses(),
                            owner,
                            outerScope,
                            mutableClassDescriptor);
                    owner.addClassifierDescriptor(mutableClassDescriptor);
                }

                @Override
                public void visitObjectDeclaration(JetObjectDeclaration declaration) {
                    createClassDescriptorForObject(declaration, owner);
                }

                @Override
                public void visitEnumEntry(JetEnumEntry enumEntry) {
                    MutableClassDescriptor classObjectDescriptor = ((MutableClassDescriptor) owner).getClassObjectDescriptor();
                    assert classObjectDescriptor != null : enumEntry.getParent().getText();
                    if (enumEntry.getPrimaryConstructorParameterList() == null) {
                        MutableClassDescriptor classDescriptor = createClassDescriptorForObject(enumEntry, classObjectDescriptor);
                        context.getObjects().remove(enumEntry);
                        context.getClasses().put(enumEntry, classDescriptor);
                    }
                    else {
                        MutableClassDescriptor mutableClassDescriptor = new MutableClassDescriptor(context.getTrace(), classObjectDescriptor, outerScope, ClassKind.CLASS); // TODO : Special kind for enum entry classes?
                        visitClassOrObject(
                                enumEntry,
                                (Map) context.getClasses(),
                                classObjectDescriptor,
                                outerScope,
                                mutableClassDescriptor);
                        classObjectDescriptor.addClassifierDescriptor(mutableClassDescriptor);
                    }
                }

                private MutableClassDescriptor createClassDescriptorForObject(@NotNull JetClassOrObject declaration, @NotNull NamespaceLike owner) {
                    MutableClassDescriptor mutableClassDescriptor = new MutableClassDescriptor(context.getTrace(), owner, outerScope, ClassKind.OBJECT) {
                        @Override
                        public ClassObjectStatus setClassObjectDescriptor(@NotNull MutableClassDescriptor classObjectDescriptor) {
                            return ClassObjectStatus.NOT_ALLOWED;
                        }
                    };
                    visitClassOrObject(declaration, (Map) context.getObjects(), owner, outerScope, mutableClassDescriptor);
                    createPrimaryConstructorForObject((JetDeclaration) declaration, mutableClassDescriptor);
                    context.getTrace().record(BindingContext.CLASS, declaration, mutableClassDescriptor);
                    return mutableClassDescriptor;
                }

                private void createPrimaryConstructorForObject(@Nullable JetDeclaration object, MutableClassDescriptor mutableClassDescriptor) {
                    ConstructorDescriptorImpl constructorDescriptor = new ConstructorDescriptorImpl(mutableClassDescriptor, Collections.<AnnotationDescriptor>emptyList(), true);
                    constructorDescriptor.initialize(Collections.<TypeParameterDescriptor>emptyList(), Collections.<ValueParameterDescriptor>emptyList(),
                                                     Modality.FINAL, Visibility.INTERNAL);//TODO check set mutableClassDescriptor.getVisibility()
                    // TODO : make the constructor private?
                    mutableClassDescriptor.setPrimaryConstructor(constructorDescriptor);
                    if (object != null) {
                        context.getTrace().record(CONSTRUCTOR, object, constructorDescriptor);
                    }
                }

                private void visitClassOrObject(@NotNull JetClassOrObject declaration, Map<JetClassOrObject, MutableClassDescriptor> map, NamespaceLike owner, JetScope outerScope, MutableClassDescriptor mutableClassDescriptor) {
                    mutableClassDescriptor.setName(JetPsiUtil.safeName(declaration.getName()));

                    map.put(declaration, mutableClassDescriptor);
//                    declaringScopes.put((JetDeclaration) declaration, outerScope);

                    JetScope classScope = mutableClassDescriptor.getScopeForMemberResolution();
                    collectNamespacesAndClassifiers(classScope, mutableClassDescriptor, declaration.getDeclarations());
                }

                @Override
                public void visitTypedef(JetTypedef typedef) {
//                    context.getTrace().getErrorHandler().genericError(typedef.getNode(), "Unsupported [TopDownAnalyzer]");
                    context.getTrace().report(UNSUPPORTED.on(typedef, "TypeHierarchyResolver"));
                }

                @Override
                public void visitClassObject(JetClassObject classObject) {
                    JetObjectDeclaration objectDeclaration = classObject.getObjectDeclaration();
                    if (objectDeclaration != null) {
                        NamespaceLike.ClassObjectStatus status = owner.setClassObjectDescriptor(createClassDescriptorForObject(objectDeclaration, owner));
                        switch (status) {
                            case DUPLICATE:
//                                context.getTrace().getErrorHandler().genericError(classObject.getNode(), "Only one class object is allowed per class");
                                context.getTrace().report(MANY_CLASS_OBJECTS.on(classObject));
                                break;
                            case NOT_ALLOWED:
//                                context.getTrace().getErrorHandler().genericError(classObject.getNode(), "A class object is not allowed here");
                                context.getTrace().report(CLASS_OBJECT_NOT_ALLOWED.on(classObject));
                                break;
                        }
                    }
                }
            });
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419026315382/fstmerge_var2_8586767545220652970

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_1c299_22591/rev_1c299-22591/compiler/frontend/src/org/jetbrains/jet/lang/resolve/TypeHierarchyResolver.java
Conflict type: LineBasedMCFd
Conflict body: 
public void resolveBehaviorDeclarationBodies() {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419026315476/fstmerge_var1_8679457926480306818
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419026315476/fstmerge_base_6425512027797446693
//        bindOverrides();

=======

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419026315476/fstmerge_var2_1790078413306477728
        resolveDelegationSpecifierLists();
        resolveClassAnnotations();

        resolveAnonymousInitializers();
        resolvePropertyDeclarationBodies();

        resolveSecondaryConstructorBodies();
        resolveFunctionBodies();

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419026315476/fstmerge_var1_8679457926480306818
        checkIfPrimaryConstructorIsNecessary();
        
        computeDeferredTypes();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419026315476/fstmerge_base_6425512027797446693
        checkIfPrimaryConstructorIsNecessary();

//        checkOverrides();
=======

>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419026315476/fstmerge_var2_1790078413306477728
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_1c299_22591/rev_1c299-22591/compiler/frontend/src/org/jetbrains/jet/lang/resolve/BodyResolver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419026315644/fstmerge_var1_8327091211532766363
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419026315644/fstmerge_base_2315644372535409620
public static void process(
            @NotNull JetSemanticServices semanticServices,
            @NotNull BindingTrace trace,
            @NotNull JetScope outerScope, NamespaceLike owner, @NotNull List<JetDeclaration> declarations) {
        TopDownAnalysisContext context = new TopDownAnalysisContext(semanticServices, trace);
        new TypeHierarchyResolver(context).process(outerScope, owner, declarations);
        new DeclarationResolver(context).process();
        new DelegationResolver(context).process();
        new OverrideResolver(context).process();
        new BodyResolver(context).resolveBehaviorDeclarationBodies();
    }
=======
public static void process(
            @NotNull JetSemanticServices semanticServices,
            @NotNull BindingTrace trace,
            @NotNull JetScope outerScope, NamespaceLike owner, @NotNull List<JetDeclaration> declarations) {
        TopDownAnalysisContext context = new TopDownAnalysisContext(semanticServices, trace);
        new TypeHierarchyResolver(context).process(outerScope, owner, declarations);
        new DeclarationResolver(context).process();
        new DelegationResolver(context).process();
        new OverrideResolver(context).process();
        new BodyResolver(context).resolveBehaviorDeclarationBodies();
        new DeclarationsChecker(context).process();
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419026315644/fstmerge_var2_4870923598536209414

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_1c299_22591/rev_1c299-22591/compiler/frontend/src/org/jetbrains/jet/lang/resolve/TopDownAnalyzer.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3e388_e12b5/rev_3e388-e12b5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_9fbe6_16236/rev_9fbe6-16236.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_9fbe6_50418/rev_9fbe6-50418.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_29e76_f0bcf/rev_29e76-f0bcf.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_bdf41_a50ac/rev_bdf41-a50ac.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_9f534_a59d5/rev_9f534-a59d5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e3240_97756/rev_e3240-97756.revisions
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ ##FSTMerge## private static final Set<String> numberConversions = new HashSet(); ##FSTMerge## private static final Set<String> numberConversions = Sets.newHashSet();
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e3240_97756/rev_e3240-97756/compiler/frontend/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027221983/fstmerge_var1_8563327017181910242
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027221983/fstmerge_base_2148403719525330039
private void checkFunctionReturnType(JetScope functionInnerScope, JetDeclarationWithBody function, @NotNull final JetType expectedReturnType, @NotNull DataFlowInfo dataFlowInfo) {
            JetExpression bodyExpression = function.getBodyExpression();
            assert bodyExpression != null;
            
            final boolean blockBody = function.hasBlockBody();
            final TypeInferenceContext context =
                    blockBody
                    ? newContext(trace, functionInnerScope, dataFlowInfo, NO_EXPECTED_TYPE, expectedReturnType)
                    : newContext(trace, functionInnerScope, dataFlowInfo, expectedReturnType, FORBIDDEN);

            if (function instanceof JetFunctionLiteralExpression) {
                JetFunctionLiteralExpression functionLiteralExpression = (JetFunctionLiteralExpression) function;
                getBlockReturnedType(functionInnerScope, functionLiteralExpression.getBodyExpression(), CoercionStrategy.COERCION_TO_UNIT, context);
            }
            else {
                typeInferrerVisitor.getType(bodyExpression, context);
            }

            List<JetElement> unreachableElements = Lists.newArrayList();
            flowInformationProvider.collectUnreachableExpressions(function.asElement(), unreachableElements);

            // This is needed in order to highlight only '1 < 2' and not '1', '<' and '2' as well
            final Set<JetElement> rootUnreachableElements = JetPsiUtil.findRootExpressions(unreachableElements);

            // TODO : (return 1) || (return 2) -- only || and right of it is unreachable
            // TODO : try {return 1} finally {return 2}. Currently 'return 1' is reported as unreachable,
            //        though it'd better be reported more specifically

            for (JetElement element : rootUnreachableElements) {
//                trace.getErrorHandler().genericError(element.getNode(), "Unreachable code");
                trace.report(UNREACHABLE_CODE.on(element));
            }

            List<JetExpression> returnedExpressions = Lists.newArrayList();
            flowInformationProvider.collectReturnExpressions(function.asElement(), returnedExpressions);

            boolean nothingReturned = returnedExpressions.isEmpty();

            returnedExpressions.remove(function); // This will be the only "expression" if the body is empty

            if (expectedReturnType != NO_EXPECTED_TYPE && !JetStandardClasses.isUnit(expectedReturnType) && returnedExpressions.isEmpty() && !nothingReturned) {
//                trace.getErrorHandler().genericError(bodyExpression.getNode(), "This function must return a value of type " + expectedReturnType);
                trace.report(RETURN_TYPE_MISMATCH.on(bodyExpression, expectedReturnType));
            }

            for (JetExpression returnedExpression : returnedExpressions) {
                returnedExpression.accept(new JetVisitorVoid() {
                    @Override
                    public void visitReturnExpression(JetReturnExpression expression) {
                        if (!blockBody) {
//                            trace.getErrorHandler().genericError(expression.getNode(), "Returns are not allowed for functions with expression body. Use block body in '{...}'");
                            trace.report(RETURN_IN_FUNCTION_WITH_EXPRESSION_BODY.on(expression));
                        }
                    }

                    @Override
                    public void visitExpression(JetExpression expression) {
                        if (blockBody && !JetStandardClasses.isUnit(expectedReturnType) && !rootUnreachableElements.contains(expression)) {
                            //TODO move to pseudocode
                            JetType type = typeInferrerVisitor.getType(expression, context.replaceExpectedType(NO_EXPECTED_TYPE));
                            if (type == null || !JetStandardClasses.isNothing(type)) {
//                                trace.getErrorHandler().genericError(expression.getNode(), "A 'return' expression required in a function with a block body ('{...}')");
                                trace.report(NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY.on(expression));
                            }
                        }
                    }
                });
            }
        }
=======
private void checkFunctionReturnType(JetScope functionInnerScope, JetDeclarationWithBody function, @NotNull final JetType expectedReturnType, @NotNull DataFlowInfo dataFlowInfo) {
            JetExpression bodyExpression = function.getBodyExpression();
            if (bodyExpression == null) return;
            
            final boolean blockBody = function.hasBlockBody();
            final TypeInferenceContext context =
                    blockBody
                    ? newContext(trace, functionInnerScope, dataFlowInfo, NO_EXPECTED_TYPE, expectedReturnType)
                    : newContext(trace, functionInnerScope, dataFlowInfo, expectedReturnType, FORBIDDEN);

            if (function instanceof JetFunctionLiteralExpression) {
                JetFunctionLiteralExpression functionLiteralExpression = (JetFunctionLiteralExpression) function;
                getBlockReturnedType(functionInnerScope, functionLiteralExpression.getBodyExpression(), CoercionStrategy.COERCION_TO_UNIT, context);
            }
            else {
                typeInferrerVisitor.getType(bodyExpression, context);
            }

            List<JetElement> unreachableElements = Lists.newArrayList();
            flowInformationProvider.collectUnreachableExpressions(function.asElement(), unreachableElements);

            // This is needed in order to highlight only '1 < 2' and not '1', '<' and '2' as well
            final Set<JetElement> rootUnreachableElements = JetPsiUtil.findRootExpressions(unreachableElements);

            // TODO : (return 1) || (return 2) -- only || and right of it is unreachable
            // TODO : try {return 1} finally {return 2}. Currently 'return 1' is reported as unreachable,
            //        though it'd better be reported more specifically

            for (JetElement element : rootUnreachableElements) {
//                trace.getErrorHandler().genericError(element.getNode(), "Unreachable code");
                trace.report(UNREACHABLE_CODE.on(element));
            }

            List<JetExpression> returnedExpressions = Lists.newArrayList();
            flowInformationProvider.collectReturnExpressions(function.asElement(), returnedExpressions);

            boolean nothingReturned = returnedExpressions.isEmpty();

            returnedExpressions.remove(function); // This will be the only "expression" if the body is empty

            if (expectedReturnType != NO_EXPECTED_TYPE && !JetStandardClasses.isUnit(expectedReturnType) && returnedExpressions.isEmpty() && !nothingReturned) {
//                trace.getErrorHandler().genericError(bodyExpression.getNode(), "This function must return a value of type " + expectedReturnType);
                trace.report(RETURN_TYPE_MISMATCH.on(bodyExpression, expectedReturnType));
            }

            for (JetExpression returnedExpression : returnedExpressions) {
                returnedExpression.accept(new JetVisitorVoid() {
                    @Override
                    public void visitReturnExpression(JetReturnExpression expression) {
                        if (!blockBody) {
//                            trace.getErrorHandler().genericError(expression.getNode(), "Returns are not allowed for functions with expression body. Use block body in '{...}'");
                            trace.report(RETURN_IN_FUNCTION_WITH_EXPRESSION_BODY.on(expression));
                        }
                    }

                    @Override
                    public void visitExpression(JetExpression expression) {
                        if (blockBody && !JetStandardClasses.isUnit(expectedReturnType) && !rootUnreachableElements.contains(expression)) {
                            //TODO move to pseudocode
                            JetType type = typeInferrerVisitor.getType(expression, context.replaceExpectedType(NO_EXPECTED_TYPE));
                            if (type == null || !JetStandardClasses.isNothing(type)) {
//                                trace.getErrorHandler().genericError(expression.getNode(), "A 'return' expression required in a function with a block body ('{...}')");
                                trace.report(NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY.on(expression));
                            }
                        }
                    }
                });
            }
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027221983/fstmerge_var2_3529486085956156260

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e3240_97756/rev_e3240-97756/compiler/frontend/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222010/fstmerge_var1_2409676549187829975
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222010/fstmerge_base_3127396132455159318
@Nullable
        private JetType checkType(@Nullable JetType expressionType, @NotNull JetExpression expression, @NotNull TypeInferenceContext context) {
            if (expressionType != null && context.expectedType != null && context.expectedType != NO_EXPECTED_TYPE) {
                if (!semanticServices.getTypeChecker().isSubtypeOf(expressionType, context.expectedType)) {
                    context.trace.report(TYPE_MISMATCH.on(expression, context.expectedType, expressionType));
                }
            }
            return expressionType;
        }
=======
@Nullable
        private JetType checkType(@Nullable JetType expressionType, @NotNull JetExpression expression, @NotNull TypeInferenceContext context) {
            if (expressionType == null || context.expectedType == null || context.expectedType == NO_EXPECTED_TYPE ||
                semanticServices.getTypeChecker().isSubtypeOf(expressionType, context.expectedType)) {
                return expressionType;
            }
//            VariableDescriptor variableDescriptor = AutoCastUtils.getVariableDescriptorFromSimpleName(context.trace.getBindingContext(), expression);
//            boolean appropriateTypeFound = false;
//            if (variableDescriptor != null) {
//                List<JetType> possibleTypes = Lists.newArrayList(context.dataFlowInfo.getPossibleTypesForVariable(variableDescriptor));
//                Collections.reverse(possibleTypes);
//                for (JetType possibleType : possibleTypes) {
//                    if (semanticServices.getTypeChecker().isSubtypeOf(possibleType, context.expectedType)) {
//                        appropriateTypeFound = true;
//                        break;
//                    }
//                }
//                if (!appropriateTypeFound) {
//                    JetType notnullType = context.dataFlowInfo.getOutType(variableDescriptor);
//                    if (notnullType != null && semanticServices.getTypeChecker().isSubtypeOf(notnullType, context.expectedType)) {
//                        appropriateTypeFound = true;
//                    }
//                }
//            }
            if (AutoCastUtils.castExpression(expression, context.expectedType, context.dataFlowInfo, context.trace) == null) {
//                context.trace.getErrorHandler().typeMismatch(expression, context.expectedType, expressionType);
                context.trace.report(TYPE_MISMATCH.on(expression, context.expectedType, expressionType));
                return expressionType;
            }
//            checkAutoCast(expression, context.expectedType, variableDescriptor, context.trace);
            return context.expectedType;
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222010/fstmerge_var2_8041900014976543851

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e3240_97756/rev_e3240-97756/compiler/frontend/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222014/fstmerge_var1_8606706046548293324
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222014/fstmerge_base_7275426002577196479
@NotNull
        private List<JetType> checkArgumentTypes(@NotNull List<JetType> argumentTypes, @NotNull List<JetExpression> arguments, @NotNull List<TypeProjection> expectedArgumentTypes, @NotNull TypeInferenceContext context) {
            if (arguments.size() == 0 || argumentTypes.size() != arguments.size() || expectedArgumentTypes.size() != arguments.size()) {
                return argumentTypes;
            }
            List<JetType> result = Lists.newArrayListWithCapacity(arguments.size());
            for (int i = 0, argumentTypesSize = argumentTypes.size(); i < argumentTypesSize; i++) {
                result.add(checkEnrichedType(argumentTypes.get(i), arguments.get(i), context.replaceExpectedType(expectedArgumentTypes.get(i).getType())));
            }
            return result;
        }
=======
@NotNull
        private List<JetType> checkArgumentTypes(@NotNull List<JetType> argumentTypes, @NotNull List<JetExpression> arguments, @NotNull List<TypeProjection> expectedArgumentTypes, @NotNull TypeInferenceContext context) {
            if (arguments.size() == 0 || argumentTypes.size() != arguments.size() || expectedArgumentTypes.size() != arguments.size()) {
                return argumentTypes;
            }
            List<JetType> result = Lists.newArrayListWithCapacity(arguments.size());
            for (int i = 0, argumentTypesSize = argumentTypes.size(); i < argumentTypesSize; i++) {
                result.add(checkType(argumentTypes.get(i), arguments.get(i), context.replaceExpectedType(expectedArgumentTypes.get(i).getType())));
            }
            return result;
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222014/fstmerge_var2_2982845105492431118

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e3240_97756/rev_e3240-97756/compiler/frontend/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222064/fstmerge_var1_1596633466091573154
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222064/fstmerge_base_2531558895397795652
@Nullable
        public FunctionDescriptor resolveCallWithGivenName(@NotNull Call call, @NotNull JetReferenceExpression functionReference, @NotNull String name, @NotNull ReceiverDescriptor receiver) {
            return getCallResolver().resolveCallWithGivenName(trace, scope, call, functionReference, name, receiver, expectedType);
        }
=======
@Nullable
        public FunctionDescriptor resolveCallWithGivenName(@NotNull Call call, @NotNull JetReferenceExpression functionReference, @NotNull String name, @NotNull ReceiverDescriptor receiver) {
            return getCallResolver().resolveCallWithGivenName(trace, scope, call, functionReference, name, expectedType);
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222064/fstmerge_var2_8995516148761227031

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e3240_97756/rev_e3240-97756/compiler/frontend/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222104/fstmerge_var1_5774120505766300834
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222104/fstmerge_base_4048557298136043219
@Override
        public JetType visitSimpleNameExpression(JetSimpleNameExpression expression, TypeInferenceContext context) {
            // TODO : other members
            // TODO : type substitutions???
            String referencedName = expression.getReferencedName();
            if (expression.getReferencedNameElementType() == JetTokens.FIELD_IDENTIFIER
                    && referencedName != null) {
                PropertyDescriptor property = context.scope.getPropertyByFieldReference(referencedName);
                if (property == null) {
                    context.trace.report(UNRESOLVED_REFERENCE.on(expression));
                }
                else {
                    context.trace.record(REFERENCE_TARGET, expression, property);
                    return context.services.checkEnrichedType(property.getOutType(), expression, context);
                }
            }
            else {
                return getSelectorReturnType(ReceiverDescriptor.NO_RECEIVER, expression, context); // TODO : Extensions to this
//                assert JetTokens.IDENTIFIER == expression.getReferencedNameElementType();
//                if (referencedName != null) {
//                    VariableDescriptor variable = context.scope.getVariable(referencedName);
//                    if (variable != null) {
//                        context.trace.record(REFERENCE_TARGET, expression, variable);
//                        JetType result = variable.getOutType();
//                        if (result == null) {
//                            context.trace.getErrorHandler().genericError(expression.getNode(), "This variable is not readable in this context");
//                        }
//                        return context.services.checkEnrichedType(result, expression, context);
//                    }
//                    else {
//                        return lookupNamespaceOrClassObject(expression, referencedName, context);
//                        ClassifierDescriptor classifier = context.scope.getClassifier(referencedName);
//                        if (classifier != null) {
//                            JetType classObjectType = classifier.getClassObjectType();
//                            JetType result = null;
//                            if (classObjectType != null && (isNamespacePosition() || classifier.isClassObjectAValue())) {
//                                result = classObjectType;
//                            }
//                            else {
//                                context.trace.getErrorHandler().genericError(expression.getNode(), "Classifier " + classifier.getName() +  " does not have a class object");
//                            }
//                            context.trace.record(REFERENCE_TARGET, expression, classifier);
//                            return context.services.checkEnrichedType(result, expression, context);
//                        }
//                        else {
//                            JetType[] result = new JetType[1];
//                            if (furtherNameLookup(expression, referencedName, result, context)) {
//                                return context.services.checkEnrichedType(result[0], expression, context);
//                            }
//
//                        }
//                    }
//                    context.trace.report(UNRESOLVED_REFERENCE.on(expression));
//                }
            }
            return null;
        }
=======
@Override
        public JetType visitSimpleNameExpression(JetSimpleNameExpression expression, TypeInferenceContext context) {
            // TODO : other members
            // TODO : type substitutions???
            String referencedName = expression.getReferencedName();
            if (expression.getReferencedNameElementType() == JetTokens.FIELD_IDENTIFIER
                    && referencedName != null) {
                PropertyDescriptor property = context.scope.getPropertyByFieldReference(referencedName);
                if (property == null) {
                    context.trace.report(UNRESOLVED_REFERENCE.on(expression));
                }
                else {
                    context.trace.record(REFERENCE_TARGET, expression, property);
                    return context.services.checkType(property.getOutType(), expression, context);
                }
            }
            else {
                return getSelectorReturnType(NO_RECEIVER, null, expression, context); // TODO : Extensions to this
//                assert JetTokens.IDENTIFIER == expression.getReferencedNameElementType();
//                if (referencedName != null) {
//                    VariableDescriptor variable = context.scope.getVariable(referencedName);
//                    if (variable != null) {
//                        context.trace.record(REFERENCE_TARGET, expression, variable);
//                        JetType result = variable.getOutType();
//                        if (result == null) {
//                            context.trace.getErrorHandler().genericError(expression.getNode(), "This variable is not readable in this context");
//                        }
//                        return context.services.checkType(result, expression, context);
//                    }
//                    else {
//                        return lookupNamespaceOrClassObject(expression, referencedName, context);
//                        ClassifierDescriptor classifier = context.scope.getClassifier(referencedName);
//                        if (classifier != null) {
//                            JetType classObjectType = classifier.getClassObjectType();
//                            JetType result = null;
//                            if (classObjectType != null && (isNamespacePosition() || classifier.isClassObjectAValue())) {
//                                result = classObjectType;
//                            }
//                            else {
//                                context.trace.getErrorHandler().genericError(expression.getNode(), "Classifier " + classifier.getName() +  " does not have a class object");
//                            }
//                            context.trace.record(REFERENCE_TARGET, expression, classifier);
//                            return context.services.checkType(result, expression, context);
//                        }
//                        else {
//                            JetType[] result = new JetType[1];
//                            if (furtherNameLookup(expression, referencedName, result, context)) {
//                                return context.services.checkType(result[0], expression, context);
//                            }
//
//                        }
//                    }
//                    context.trace.report(UNRESOLVED_REFERENCE.on(expression));
//                }
            }
            return null;
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222104/fstmerge_var2_3819827474263584821

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e3240_97756/rev_e3240-97756/compiler/frontend/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222108/fstmerge_var1_2508153131390631390
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222108/fstmerge_base_3391349413736636425
private JetType lookupNamespaceOrClassObject(JetSimpleNameExpression expression, String referencedName, TypeInferenceContext context) {
            ClassifierDescriptor classifier = context.scope.getClassifier(referencedName);
            if (classifier != null) {
                JetType classObjectType = classifier.getClassObjectType();
                JetType result = null;
                if (classObjectType != null && (isNamespacePosition() || classifier.isClassObjectAValue())) {
                    result = classObjectType;
                }
                else {
//                    context.trace.getErrorHandler().genericError(expression.getNode(), "Classifier " + classifier.getName() +  " does not have a class object");
                    context.trace.report(NO_CLASS_OBJECT.on(expression, classifier));
                }
                context.trace.record(REFERENCE_TARGET, expression, classifier);
                if (result == null) {
                    return ErrorUtils.createErrorType("No class object in " + expression.getReferencedName());
                }
                return context.services.checkEnrichedType(result, expression, context);
            }
            else {
                JetType[] result = new JetType[1];
                if (furtherNameLookup(expression, referencedName, result, context)) {
                    return context.services.checkEnrichedType(result[0], expression, context);
                }

            }
            return null;
        }
=======
private JetType lookupNamespaceOrClassObject(JetSimpleNameExpression expression, String referencedName, TypeInferenceContext context) {
            ClassifierDescriptor classifier = context.scope.getClassifier(referencedName);
            if (classifier != null) {
                JetType classObjectType = classifier.getClassObjectType();
                JetType result = null;
                if (classObjectType != null) {
                    if (isNamespacePosition() || classifier.isClassObjectAValue()) {
                        result = classObjectType;
                    }
                    else {
    //                    context.trace.getErrorHandler().genericError(expression.getNode(), "Classifier " + classifier.getName() +  " does not have a class object");
                        context.trace.report(NO_CLASS_OBJECT.on(expression, classifier));
                    }
                    context.trace.record(REFERENCE_TARGET, expression, classifier);
                    if (result == null) {
                        return ErrorUtils.createErrorType("No class object in " + expression.getReferencedName());
                    }
                    return context.services.checkType(result, expression, context);
                }
            }
            JetType[] result = new JetType[1];
            TemporaryBindingTrace temporaryTrace = TemporaryBindingTrace.create(context.trace);
            if (furtherNameLookup(expression, referencedName, result, context.replaceBindingTrace(temporaryTrace))) {
                temporaryTrace.commit();
                return context.services.checkType(result[0], expression, context);
            }
            // To report NO_CLASS_OBJECT when no namespace found
            if (classifier != null) {
                context.trace.report(NO_CLASS_OBJECT.on(expression, classifier));
                context.trace.record(REFERENCE_TARGET, expression, classifier);
                return ErrorUtils.createErrorType("No class object in " + expression.getReferencedName());
            }
            temporaryTrace.commit();
            return result[0];
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222108/fstmerge_var2_428788773631947741

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e3240_97756/rev_e3240-97756/compiler/frontend/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222116/fstmerge_var1_1421250999943871781
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222116/fstmerge_base_616046005881882430
protected boolean furtherNameLookup(@NotNull JetSimpleNameExpression expression, @NotNull String referencedName, @NotNull JetType[] result, TypeInferenceContext context) {
            NamespaceType namespaceType = lookupNamespaceType(expression, referencedName, context);
            if (namespaceType != null) {
//                context.trace.getErrorHandler().genericError(expression.getNode(), "Expression expected, but a namespace name found");
                context.trace.report(EXPRESSION_EXPECTED_NAMESPACE_FOUND.on(expression));
                return true;
            }
            return false;
        }
=======
protected boolean furtherNameLookup(@NotNull JetSimpleNameExpression expression, @NotNull String referencedName, @NotNull JetType[] result, TypeInferenceContext context) {
            NamespaceType namespaceType = lookupNamespaceType(expression, referencedName, context);
            if (namespaceType != null) {
//                context.trace.getErrorHandler().genericError(expression.getNode(), "Expression expected, but a namespace name found");
                context.trace.report(EXPRESSION_EXPECTED_NAMESPACE_FOUND.on(expression));
                result[0] = ErrorUtils.createErrorType("Type for " + referencedName);
            }
            return false;
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222116/fstmerge_var2_6931782919042912445

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e3240_97756/rev_e3240-97756/compiler/frontend/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222126/fstmerge_var1_217435447237022566
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222126/fstmerge_base_398474575508726291
@Override
        public JetType visitFunctionLiteralExpression(JetFunctionLiteralExpression expression, TypeInferenceContext context) {
            JetFunctionLiteral functionLiteral = expression.getFunctionLiteral();

            JetTypeReference receiverTypeRef = functionLiteral.getReceiverTypeRef();
            final JetType receiverType;
            if (receiverTypeRef != null) {
                receiverType = context.typeResolver.resolveType(context.scope, receiverTypeRef);
            } else {
                ReceiverDescriptor implicitReceiver = context.scope.getImplicitReceiver();
                receiverType = implicitReceiver.exists() ? implicitReceiver.getType() : null;
            }

            FunctionDescriptorImpl functionDescriptor = new FunctionDescriptorImpl(
                    context.scope.getContainingDeclaration(), Collections.<AnnotationDescriptor>emptyList(), "<anonymous>");

            List<JetType> parameterTypes = new ArrayList<JetType>();
            List<ValueParameterDescriptor> valueParameterDescriptors = Lists.newArrayList();
            List<JetParameter> declaredValueParameters = functionLiteral.getValueParameters();
            JetType expectedType = context.expectedType;

            boolean functionTypeExpected = expectedType != NO_EXPECTED_TYPE && JetStandardClasses.isFunctionType(expectedType);
            List<ValueParameterDescriptor> expectedValueParameters =  (functionTypeExpected)
                                                              ? JetStandardClasses.getValueParameters(functionDescriptor, expectedType)
                                                              : null;

            if (functionTypeExpected && declaredValueParameters.isEmpty() && expectedValueParameters.size() == 1) {
                ValueParameterDescriptor valueParameterDescriptor = expectedValueParameters.get(0);
                ValueParameterDescriptor it = new ValueParameterDescriptorImpl(
                        functionDescriptor, 0, Collections.<AnnotationDescriptor>emptyList(), "it", valueParameterDescriptor.getInType(), valueParameterDescriptor.getOutType(), valueParameterDescriptor.hasDefaultValue(), valueParameterDescriptor.isVararg()
                );
                valueParameterDescriptors.add(it);
                parameterTypes.add(it.getOutType());
                context.trace.record(AUTO_CREATED_IT, it);
            }
            else {
                for (int i = 0; i < declaredValueParameters.size(); i++) {
                    JetParameter declaredParameter = declaredValueParameters.get(i);
                    JetTypeReference typeReference = declaredParameter.getTypeReference();

                    JetType type;
                    if (typeReference != null) {
                        type = context.typeResolver.resolveType(context.scope, typeReference);
                    }
                    else {
                        if (expectedValueParameters != null && i < expectedValueParameters.size()) {
                            type = expectedValueParameters.get(i).getOutType();
                        }
                        else {
    //                        context.trace.getErrorHandler().genericError(declaredParameter.getNode(), "Cannot infer a type for this declaredParameter. To specify it explicitly use the {(p : Type) => ...} notation");
                            context.trace.report(CANNOT_INFER_PARAMETER_TYPE.on(declaredParameter));
                            type = ErrorUtils.createErrorType("Cannot be inferred");
                        }
                    }
                    ValueParameterDescriptor valueParameterDescriptor = context.classDescriptorResolver.resolveValueParameterDescriptor(functionDescriptor, declaredParameter, i, type);
                    parameterTypes.add(valueParameterDescriptor.getOutType());
                    valueParameterDescriptors.add(valueParameterDescriptor);
                }
            }

            JetType effectiveReceiverType;
            if (receiverTypeRef == null) {
                if (functionTypeExpected) {
                    effectiveReceiverType = JetStandardClasses.getReceiverType(expectedType);
                }
                else {
                    effectiveReceiverType = null;
                }
            }
            else {
                effectiveReceiverType = receiverType;
            }
            functionDescriptor.initialize(effectiveReceiverType, Collections.<TypeParameterDescriptor>emptyList(), valueParameterDescriptors, null, Modality.FINAL, Visibility.LOCAL);
            context.trace.record(BindingContext.FUNCTION, expression, functionDescriptor);

            JetType returnType = NO_EXPECTED_TYPE;
            JetScope functionInnerScope = FunctionDescriptorUtil.getFunctionInnerScope(context.scope, functionDescriptor, context.trace);
            JetTypeReference returnTypeRef = functionLiteral.getReturnTypeRef();
            if (returnTypeRef != null) {
                returnType = context.typeResolver.resolveType(context.scope, returnTypeRef);
                context.services.checkFunctionReturnType(functionInnerScope, expression, returnType, context.dataFlowInfo);
            }
            else {
                if (functionTypeExpected) {
                    returnType = JetStandardClasses.getReturnType(expectedType);
                }
                returnType = context.services.getBlockReturnedType(functionInnerScope, functionLiteral.getBodyExpression(), CoercionStrategy.COERCION_TO_UNIT, context.replaceExpectedType(returnType));
            }
            JetType safeReturnType = returnType == null ? ErrorUtils.createErrorType("<return type>") : returnType;
            functionDescriptor.setReturnType(safeReturnType);

            if (functionTypeExpected) {
                JetType expectedReturnType = JetStandardClasses.getReturnType(expectedType);
                if (JetStandardClasses.isUnit(expectedReturnType)) {
                    return context.services.checkType(JetStandardClasses.getFunctionType(Collections.<AnnotationDescriptor>emptyList(), effectiveReceiverType, parameterTypes, expectedReturnType), expression, context);
                }

            }
            return context.services.checkType(JetStandardClasses.getFunctionType(Collections.<AnnotationDescriptor>emptyList(), effectiveReceiverType, parameterTypes, safeReturnType), expression, context);
        }
=======
@Override
        public JetType visitFunctionLiteralExpression(JetFunctionLiteralExpression expression, TypeInferenceContext context) {
            JetFunctionLiteral functionLiteral = expression.getFunctionLiteral();

            JetTypeReference receiverTypeRef = functionLiteral.getReceiverTypeRef();
            final JetType receiverType;
            if (receiverTypeRef != null) {
                receiverType = context.typeResolver.resolveType(context.scope, receiverTypeRef);
            } else {
                ReceiverDescriptor implicitReceiver = context.scope.getImplicitReceiver();
                receiverType = implicitReceiver.exists() ? implicitReceiver.getType() : null;
            }

            FunctionDescriptorImpl functionDescriptor = new FunctionDescriptorImpl(
                    context.scope.getContainingDeclaration(), Collections.<AnnotationDescriptor>emptyList(), "<anonymous>");

            List<JetType> parameterTypes = new ArrayList<JetType>();
            List<ValueParameterDescriptor> valueParameterDescriptors = Lists.newArrayList();
            List<JetParameter> declaredValueParameters = functionLiteral.getValueParameters();
            JetType expectedType = context.expectedType;

            boolean functionTypeExpected = expectedType != NO_EXPECTED_TYPE && JetStandardClasses.isFunctionType(expectedType);
            List<ValueParameterDescriptor> expectedValueParameters =  (functionTypeExpected)
                                                              ? JetStandardClasses.getValueParameters(functionDescriptor, expectedType)
                                                              : null;

            if (functionTypeExpected && declaredValueParameters.isEmpty() && expectedValueParameters.size() == 1) {
                ValueParameterDescriptor valueParameterDescriptor = expectedValueParameters.get(0);
                ValueParameterDescriptor it = new ValueParameterDescriptorImpl(
                        functionDescriptor, 0, Collections.<AnnotationDescriptor>emptyList(), "it", valueParameterDescriptor.getInType(), valueParameterDescriptor.getOutType(), valueParameterDescriptor.hasDefaultValue(), valueParameterDescriptor.isVararg()
                );
                valueParameterDescriptors.add(it);
                parameterTypes.add(it.getOutType());
                context.trace.record(AUTO_CREATED_IT, it);
            }
            else {
                for (int i = 0; i < declaredValueParameters.size(); i++) {
                    JetParameter declaredParameter = declaredValueParameters.get(i);
                    JetTypeReference typeReference = declaredParameter.getTypeReference();

                    JetType type;
                    if (typeReference != null) {
                        type = context.typeResolver.resolveType(context.scope, typeReference);
                    }
                    else {
                        if (expectedValueParameters != null && i < expectedValueParameters.size()) {
                            type = expectedValueParameters.get(i).getOutType();
                        }
                        else {
    //                        context.trace.getErrorHandler().genericError(declaredParameter.getNode(), "Cannot infer a type for this declaredParameter. To specify it explicitly use the {(p : Type) => ...} notation");
                            context.trace.report(CANNOT_INFER_PARAMETER_TYPE.on(declaredParameter));
                            type = ErrorUtils.createErrorType("Cannot be inferred");
                        }
                    }
                    ValueParameterDescriptor valueParameterDescriptor = context.classDescriptorResolver.resolveValueParameterDescriptor(functionDescriptor, declaredParameter, i, type);
                    parameterTypes.add(valueParameterDescriptor.getOutType());
                    valueParameterDescriptors.add(valueParameterDescriptor);
                }
            }

            JetType effectiveReceiverType;
            if (receiverTypeRef == null) {
                if (functionTypeExpected) {
                    effectiveReceiverType = JetStandardClasses.getReceiverType(expectedType);
                }
                else {
                    effectiveReceiverType = null;
                }
            }
            else {
                effectiveReceiverType = receiverType;
            }
            functionDescriptor.initialize(effectiveReceiverType, NO_RECEIVER, Collections.<TypeParameterDescriptor>emptyList(), valueParameterDescriptors, null, Modality.FINAL, Visibility.LOCAL);
            context.trace.record(BindingContext.FUNCTION, expression, functionDescriptor);

            JetType returnType = NO_EXPECTED_TYPE;
            JetScope functionInnerScope = FunctionDescriptorUtil.getFunctionInnerScope(context.scope, functionDescriptor, context.trace);
            JetTypeReference returnTypeRef = functionLiteral.getReturnTypeRef();
            if (returnTypeRef != null) {
                returnType = context.typeResolver.resolveType(context.scope, returnTypeRef);
                context.services.checkFunctionReturnType(functionInnerScope, expression, returnType, context.dataFlowInfo);
            }
            else {
                if (functionTypeExpected) {
                    returnType = JetStandardClasses.getReturnType(expectedType);
                }
                returnType = context.services.getBlockReturnedType(functionInnerScope, functionLiteral.getBodyExpression(), CoercionStrategy.COERCION_TO_UNIT, context.replaceExpectedType(returnType));
            }
            JetType safeReturnType = returnType == null ? ErrorUtils.createErrorType("<return type>") : returnType;
            functionDescriptor.setReturnType(safeReturnType);

            if (functionTypeExpected) {
                JetType expectedReturnType = JetStandardClasses.getReturnType(expectedType);
                if (JetStandardClasses.isUnit(expectedReturnType)) {
                    return context.services.checkType(JetStandardClasses.getFunctionType(Collections.<AnnotationDescriptor>emptyList(), effectiveReceiverType, parameterTypes, expectedReturnType), expression, context);
                }

            }
            return context.services.checkType(JetStandardClasses.getFunctionType(Collections.<AnnotationDescriptor>emptyList(), effectiveReceiverType, parameterTypes, safeReturnType), expression, context);
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222126/fstmerge_var2_7111516696805122460

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e3240_97756/rev_e3240-97756/compiler/frontend/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222200/fstmerge_var1_1696240999229813954
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222200/fstmerge_base_6213773286131137562
@Override
        public JetType visitThisExpression(JetThisExpression expression, TypeInferenceContext context) {
            JetType result = null;
            ReceiverDescriptor thisReceiver = null;
            String labelName = expression.getLabelName();
            if (labelName != null) {
                Collection<DeclarationDescriptor> declarationsByLabel = context.scope.getDeclarationsByLabel(labelName);
                int size = declarationsByLabel.size();
                final JetSimpleNameExpression targetLabel = expression.getTargetLabel();
                assert targetLabel != null;
                if (size == 1) {
                    DeclarationDescriptor declarationDescriptor = declarationsByLabel.iterator().next();
                    if (declarationDescriptor instanceof ClassDescriptor) {
                        ClassDescriptor classDescriptor = (ClassDescriptor) declarationDescriptor;
                        thisReceiver = classDescriptor.getImplicitReceiver();
                    }
                    else if (declarationDescriptor instanceof FunctionDescriptor) {
                        FunctionDescriptor functionDescriptor = (FunctionDescriptor) declarationDescriptor;
                        thisReceiver = functionDescriptor.getReceiver();
                    }
                    else {
                        throw new UnsupportedOperationException(); // TODO
                    }
                    context.trace.record(REFERENCE_TARGET, targetLabel, declarationDescriptor);
                    context.trace.record(REFERENCE_TARGET, expression.getThisReference(), declarationDescriptor);
                }
                else if (size == 0) {
                    // This uses the info written by the control flow processor
                    PsiElement psiElement = BindingContextUtils.resolveToDeclarationPsiElement(context.trace.getBindingContext(), targetLabel);
                    if (psiElement instanceof JetFunctionLiteralExpression) {
                        DeclarationDescriptor declarationDescriptor = context.trace.getBindingContext().get(BindingContext.DECLARATION_TO_DESCRIPTOR, psiElement);
                        if (declarationDescriptor instanceof FunctionDescriptor) {
                            thisReceiver = ((FunctionDescriptor) declarationDescriptor).getReceiver();
                            if (thisReceiver.exists()) {
                                context.trace.record(REFERENCE_TARGET, targetLabel, declarationDescriptor);
                                context.trace.record(REFERENCE_TARGET, expression.getThisReference(), declarationDescriptor);
                            }
                        }
                        else {
                            context.trace.report(UNRESOLVED_REFERENCE.on(targetLabel));
                        }
                    }
                    else {
                        context.trace.report(UNRESOLVED_REFERENCE.on(targetLabel));
                    }
                }
                else {
//                    context.trace.getErrorHandler().genericError(targetLabel.getNode(), "Ambiguous label");
                    context.trace.report(AMBIGUOUS_LABEL.on(targetLabel));
                }
            }
            else {
                thisReceiver = context.scope.getImplicitReceiver();

                DeclarationDescriptor declarationDescriptorForUnqualifiedThis = context.scope.getDeclarationDescriptorForUnqualifiedThis();
                if (declarationDescriptorForUnqualifiedThis != null) {
                    context.trace.record(REFERENCE_TARGET, expression.getThisReference(), declarationDescriptorForUnqualifiedThis);
                }
            }

            if (thisReceiver != null) {
                if (!thisReceiver.exists()) {
//                    context.trace.getErrorHandler().genericError(expression.getNode(), "'this' is not defined in this context");
                    context.trace.report(NO_THIS.on(expression));
                }
                else {
                    JetTypeReference superTypeQualifier = expression.getSuperTypeQualifier();
                    if (superTypeQualifier != null) {
                        JetTypeElement superTypeElement = superTypeQualifier.getTypeElement();
                        // Errors are reported by the parser
                        if (superTypeElement instanceof JetUserType) {
                            JetUserType typeElement = (JetUserType) superTypeElement;

                            ClassifierDescriptor classifierCandidate = context.typeResolver.resolveClass(context.scope, typeElement);
                            if (classifierCandidate instanceof ClassDescriptor) {
                                ClassDescriptor superclass = (ClassDescriptor) classifierCandidate;

                                JetType thisType = thisReceiver.getType();
                                Collection<? extends JetType> supertypes = thisType.getConstructor().getSupertypes();
                                TypeSubstitutor substitutor = TypeSubstitutor.create(thisType);
                                for (JetType declaredSupertype : supertypes) {
                                    if (declaredSupertype.getConstructor().equals(superclass.getTypeConstructor())) {
                                        result = substitutor.safeSubstitute(declaredSupertype, Variance.INVARIANT);
                                        break;
                                    }
                                }
                                if (result == null) {
//                                    context.trace.getErrorHandler().genericError(superTypeElement.getNode(), "Not a superclass");
                                    context.trace.report(NOT_A_SUPERTYPE.on(superTypeElement));
                                }
                            }
                        }
                    }
                    else {
                        result = thisReceiver.getType();
                    }
                    if (result != null) {
                        context.trace.record(BindingContext.EXPRESSION_TYPE, expression.getThisReference(), result);
                    }
                }
            }
            return context.services.checkType(result, expression, context);
        }
=======
@Override
        public JetType visitThisExpression(JetThisExpression expression, TypeInferenceContext context) {
            JetType result = null;
            ReceiverDescriptor thisReceiver = null;
            String labelName = expression.getLabelName();
            if (labelName != null) {
                Collection<DeclarationDescriptor> declarationsByLabel = context.scope.getDeclarationsByLabel(labelName);
                int size = declarationsByLabel.size();
                final JetSimpleNameExpression targetLabel = expression.getTargetLabel();
                assert targetLabel != null;
                if (size == 1) {
                    DeclarationDescriptor declarationDescriptor = declarationsByLabel.iterator().next();
                    if (declarationDescriptor instanceof ClassDescriptor) {
                        ClassDescriptor classDescriptor = (ClassDescriptor) declarationDescriptor;
                        thisReceiver = classDescriptor.getImplicitReceiver();
                    }
                    else if (declarationDescriptor instanceof FunctionDescriptor) {
                        FunctionDescriptor functionDescriptor = (FunctionDescriptor) declarationDescriptor;
                        thisReceiver = functionDescriptor.getReceiverParameter();
                    }
                    else {
                        throw new UnsupportedOperationException(); // TODO
                    }
                    context.trace.record(REFERENCE_TARGET, targetLabel, declarationDescriptor);
                    context.trace.record(REFERENCE_TARGET, expression.getThisReference(), declarationDescriptor);
                }
                else if (size == 0) {
                    // This uses the info written by the control flow processor
                    PsiElement psiElement = BindingContextUtils.resolveToDeclarationPsiElement(context.trace.getBindingContext(), targetLabel);
                    if (psiElement instanceof JetFunctionLiteralExpression) {
                        DeclarationDescriptor declarationDescriptor = context.trace.getBindingContext().get(BindingContext.DECLARATION_TO_DESCRIPTOR, psiElement);
                        if (declarationDescriptor instanceof FunctionDescriptor) {
                            thisReceiver = ((FunctionDescriptor) declarationDescriptor).getReceiverParameter();
                            if (thisReceiver.exists()) {
                                context.trace.record(REFERENCE_TARGET, targetLabel, declarationDescriptor);
                                context.trace.record(REFERENCE_TARGET, expression.getThisReference(), declarationDescriptor);
                            }
                        }
                        else {
                            context.trace.report(UNRESOLVED_REFERENCE.on(targetLabel));
                        }
                    }
                    else {
                        context.trace.report(UNRESOLVED_REFERENCE.on(targetLabel));
                    }
                }
                else {
//                    context.trace.getErrorHandler().genericError(targetLabel.getNode(), "Ambiguous label");
                    context.trace.report(AMBIGUOUS_LABEL.on(targetLabel));
                }
            }
            else {
                thisReceiver = context.scope.getImplicitReceiver();

                DeclarationDescriptor declarationDescriptorForUnqualifiedThis = context.scope.getDeclarationDescriptorForUnqualifiedThis();
                if (declarationDescriptorForUnqualifiedThis != null) {
                    context.trace.record(REFERENCE_TARGET, expression.getThisReference(), declarationDescriptorForUnqualifiedThis);
                }
            }

            if (thisReceiver != null) {
                if (!thisReceiver.exists()) {
//                    context.trace.getErrorHandler().genericError(expression.getNode(), "'this' is not defined in this context");
                    context.trace.report(NO_THIS.on(expression));
                }
                else {
                    JetTypeReference superTypeQualifier = expression.getSuperTypeQualifier();
                    if (superTypeQualifier != null) {
                        JetTypeElement superTypeElement = superTypeQualifier.getTypeElement();
                        // Errors are reported by the parser
                        if (superTypeElement instanceof JetUserType) {
                            JetUserType typeElement = (JetUserType) superTypeElement;

                            ClassifierDescriptor classifierCandidate = context.typeResolver.resolveClass(context.scope, typeElement);
                            if (classifierCandidate instanceof ClassDescriptor) {
                                ClassDescriptor superclass = (ClassDescriptor) classifierCandidate;

                                JetType thisType = thisReceiver.getType();
                                Collection<? extends JetType> supertypes = thisType.getConstructor().getSupertypes();
                                TypeSubstitutor substitutor = TypeSubstitutor.create(thisType);
                                for (JetType declaredSupertype : supertypes) {
                                    if (declaredSupertype.getConstructor().equals(superclass.getTypeConstructor())) {
                                        result = substitutor.safeSubstitute(declaredSupertype, Variance.INVARIANT);
                                        break;
                                    }
                                }
                                if (result == null) {
//                                    context.trace.getErrorHandler().genericError(superTypeElement.getNode(), "Not a superclass");
                                    context.trace.report(NOT_A_SUPERTYPE.on(superTypeElement));
                                }
                            }
                        }
                    }
                    else {
                        result = thisReceiver.getType();
                    }
                    if (result != null) {
                        context.trace.record(BindingContext.EXPRESSION_TYPE, expression.getThisReference(), result);
                    }
                }
            }
            return context.services.checkType(result, expression, context);
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222200/fstmerge_var2_1569954901483791455

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e3240_97756/rev_e3240-97756/compiler/frontend/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222219/fstmerge_var1_330464838494687618
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222219/fstmerge_base_6324860461119409070
private DataFlowInfo checkWhenCondition(@Nullable final JetExpression subjectExpression, final JetType subjectType, JetWhenCondition condition, final WritableScope scopeToExtend, final TypeInferenceContext context, final VariableDescriptor... subjectVariables) {
            final DataFlowInfo[] newDataFlowInfo = new DataFlowInfo[]{context.dataFlowInfo};
            condition.accept(new JetVisitorVoid() {

                @Override
                public void visitWhenConditionCall(JetWhenConditionCall condition) {
                    JetExpression callSuffixExpression = condition.getCallSuffixExpression();
//                    JetScope compositeScope = new ScopeWithReceiver(context.scope, subjectType, semanticServices.getTypeChecker());
                    if (callSuffixExpression != null) {
//                        JetType selectorReturnType = getType(compositeScope, callSuffixExpression, false, context);
                        assert subjectExpression != null;
                        JetType selectorReturnType = getSelectorReturnType(new ExpressionReceiver(subjectExpression, subjectType), callSuffixExpression, context);//getType(compositeScope, callSuffixExpression, false, context);
                        ensureBooleanResultWithCustomSubject(callSuffixExpression, selectorReturnType, "This expression", context);
                        context.services.checkNullSafety(subjectType, condition.getOperationTokenNode(), getCalleeFunctionDescriptor(callSuffixExpression, context), condition);
                    }
                }

                @Override
                public void visitWhenConditionInRange(JetWhenConditionInRange condition) {
                    JetExpression rangeExpression = condition.getRangeExpression();
                    if (rangeExpression != null) {
                        assert subjectExpression != null;
                        checkInExpression(condition.getOperationReference(), subjectExpression, rangeExpression, context);
                    }
                }

                @Override
                public void visitWhenConditionIsPattern(JetWhenConditionIsPattern condition) {
                    JetPattern pattern = condition.getPattern();
                    if (pattern != null) {
                        newDataFlowInfo[0] = checkPatternType(pattern, subjectType, scopeToExtend, context, subjectVariables);
                    }
                }

                @Override
                public void visitJetElement(JetElement element) {
//                    context.trace.getErrorHandler().genericError(element.getNode(), "Unsupported [JetTypeInferrer] : " + element);
                    context.trace.report(UNSUPPORTED.on(element, getClass().getCanonicalName()));
                }
            });
            return newDataFlowInfo[0];
        }
=======
private DataFlowInfo checkWhenCondition(@Nullable final JetExpression subjectExpression, final JetType subjectType, JetWhenCondition condition, final WritableScope scopeToExtend, final TypeInferenceContext context, final VariableDescriptor... subjectVariables) {
            final DataFlowInfo[] newDataFlowInfo = new DataFlowInfo[]{context.dataFlowInfo};
            condition.accept(new JetVisitorVoid() {

                @Override
                public void visitWhenConditionCall(JetWhenConditionCall condition) {
                    JetExpression callSuffixExpression = condition.getCallSuffixExpression();
//                    JetScope compositeScope = new ScopeWithReceiver(context.scope, subjectType, semanticServices.getTypeChecker());
                    if (callSuffixExpression != null) {
//                        JetType selectorReturnType = getType(compositeScope, callSuffixExpression, false, context);
                        assert subjectExpression != null;
                        JetType selectorReturnType = getSelectorReturnType(new ExpressionReceiver(subjectExpression, subjectType), condition.getOperationTokenNode(), callSuffixExpression, context);//getType(compositeScope, callSuffixExpression, false, context);
                        ensureBooleanResultWithCustomSubject(callSuffixExpression, selectorReturnType, "This expression", context);
//                        context.services.checkNullSafety(subjectType, condition.getOperationTokenNode(), getCalleeFunctionDescriptor(callSuffixExpression, context), condition);
                    }
                }

                @Override
                public void visitWhenConditionInRange(JetWhenConditionInRange condition) {
                    JetExpression rangeExpression = condition.getRangeExpression();
                    if (rangeExpression != null) {
                        assert subjectExpression != null;
                        checkInExpression(condition, condition.getOperationReference(), subjectExpression, rangeExpression, context);
                    }
                }

                @Override
                public void visitWhenConditionIsPattern(JetWhenConditionIsPattern condition) {
                    JetPattern pattern = condition.getPattern();
                    if (pattern != null) {
                        newDataFlowInfo[0] = checkPatternType(pattern, subjectType, scopeToExtend, context, subjectVariables);
                    }
                }

                @Override
                public void visitJetElement(JetElement element) {
//                    context.trace.getErrorHandler().genericError(element.getNode(), "Unsupported [JetTypeInferrer] : " + element);
                    context.trace.report(UNSUPPORTED.on(element, getClass().getCanonicalName()));
                }
            });
            return newDataFlowInfo[0];
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222219/fstmerge_var2_519482135827788388

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e3240_97756/rev_e3240-97756/compiler/frontend/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222225/fstmerge_var1_1484076335365723419
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222225/fstmerge_base_2940331604917299028
private DataFlowInfo checkPatternType(@NotNull JetPattern pattern, @NotNull final JetType subjectType, @NotNull final WritableScope scopeToExtend, final TypeInferenceContext context, @NotNull final VariableDescriptor... subjectVariables) {
            final DataFlowInfo[] result = new DataFlowInfo[] {context.dataFlowInfo};
            pattern.accept(new JetVisitorVoid() {
                @Override
                public void visitTypePattern(JetTypePattern typePattern) {
                    JetTypeReference typeReference = typePattern.getTypeReference();
                    if (typeReference != null) {
                        JetType type = context.typeResolver.resolveType(context.scope, typeReference);
                        checkTypeCompatibility(type, subjectType, typePattern);
                        result[0] = context.dataFlowInfo.isInstanceOf(subjectVariables, type);
                    }
                }

                @Override
                public void visitTuplePattern(JetTuplePattern pattern) {
                    List<JetTuplePatternEntry> entries = pattern.getEntries();
                    TypeConstructor typeConstructor = subjectType.getConstructor();
                    if (!JetStandardClasses.getTuple(entries.size()).getTypeConstructor().equals(typeConstructor)
                        || typeConstructor.getParameters().size() != entries.size()) {
//                        context.trace.getErrorHandler().genericError(pattern.getNode(), "Type mismatch: subject is of type " + subjectType + " but the pattern is of type Tuple" + entries.size());
                        context.trace.report(TYPE_MISMATCH_IN_TUPLE_PATTERN.on(pattern, subjectType, entries.size()));
                    }
                    else {
                        for (int i = 0, entriesSize = entries.size(); i < entriesSize; i++) {
                            JetTuplePatternEntry entry = entries.get(i);
                            JetType type = subjectType.getArguments().get(i).getType();

                            // TODO : is a name always allowed, ie for tuple patterns, not decomposer arg lists?
                            ASTNode nameLabelNode = entry.getNameLabelNode();
                            if (nameLabelNode != null) {
//                                context.trace.getErrorHandler().genericError(nameLabelNode, "Unsupported [JetTypeInferrer]");
                                context.trace.report(UNSUPPORTED.on(nameLabelNode, getClass().getCanonicalName()));
                            }

                            JetPattern entryPattern = entry.getPattern();
                            if (entryPattern != null) {
                                result[0] = result[0].and(checkPatternType(entryPattern, type, scopeToExtend, context));
                            }
                        }
                    }
                }

                @Override
                public void visitDecomposerPattern(JetDecomposerPattern pattern) {
                    JetExpression decomposerExpression = pattern.getDecomposerExpression();
                    if (decomposerExpression != null) {
                        ReceiverDescriptor receiver = new TransientReceiver(subjectType);
                        JetType selectorReturnType = getSelectorReturnType(receiver, decomposerExpression, context);

                        result[0] = checkPatternType(pattern.getArgumentList(), selectorReturnType == null ? ErrorUtils.createErrorType("No type") : selectorReturnType, scopeToExtend, context);
                    }
                }

                @Override
                public void visitWildcardPattern(JetWildcardPattern pattern) {
                    // Nothing
                }

                @Override
                public void visitExpressionPattern(JetExpressionPattern pattern) {
                    JetExpression expression = pattern.getExpression();
                    if (expression != null) {
                        JetType type = getType(expression, context.replaceScope(scopeToExtend));
                        checkTypeCompatibility(type, subjectType, pattern);
                    }
                }

                @Override
                public void visitBindingPattern(JetBindingPattern pattern) {
                    JetProperty variableDeclaration = pattern.getVariableDeclaration();
                    JetTypeReference propertyTypeRef = variableDeclaration.getPropertyTypeRef();
                    JetType type = propertyTypeRef == null ? subjectType : context.typeResolver.resolveType(context.scope, propertyTypeRef);
                    VariableDescriptor variableDescriptor = context.classDescriptorResolver.resolveLocalVariableDescriptorWithType(context.scope.getContainingDeclaration(), variableDeclaration, type);
                    scopeToExtend.addVariableDescriptor(variableDescriptor);
                    if (propertyTypeRef != null) {
                        if (!semanticServices.getTypeChecker().isSubtypeOf(subjectType, type)) {
//                            context.trace.getErrorHandler().genericError(propertyTypeRef.getNode(), type + " must be a supertype of " + subjectType + ". Use 'is' to match against " + type);
                            context.trace.report(TYPE_MISMATCH_IN_BINDING_PATTERN.on(propertyTypeRef, type, subjectType));
                        }
                    }

                    JetWhenCondition condition = pattern.getCondition();
                    if (condition != null) {
                        int oldLength = subjectVariables.length;
                        VariableDescriptor[] newSubjectVariables = new VariableDescriptor[oldLength + 1];
                        System.arraycopy(subjectVariables, 0, newSubjectVariables, 0, oldLength);
                        newSubjectVariables[oldLength] = variableDescriptor;
                        result[0] = checkWhenCondition(null, subjectType, condition, scopeToExtend, context, newSubjectVariables);
                    }
                }

                private void checkTypeCompatibility(@Nullable JetType type, @NotNull JetType subjectType, @NotNull JetElement reportErrorOn) {
                    // TODO : Take auto casts into account?
                    if (type == null) {
                        return;
                    }
                    if (TypeUtils.intersect(semanticServices.getTypeChecker(), Sets.newHashSet(type, subjectType)) == null) {
//                        context.trace.getErrorHandler().genericError(reportErrorOn.getNode(), "Incompatible types: " + type + " and " + subjectType);
                        context.trace.report(INCOMPATIBLE_TYPES.on(reportErrorOn, type, subjectType));
                    }
                }

                @Override
                public void visitJetElement(JetElement element) {
//                    context.trace.getErrorHandler().genericError(element.getNode(), "Unsupported [JetTypeInferrer]");
                    context.trace.report(UNSUPPORTED.on(element, getClass().getCanonicalName()));
                }
            });
            return result[0];
        }
=======
private DataFlowInfo checkPatternType(@NotNull JetPattern pattern, @NotNull final JetType subjectType, @NotNull final WritableScope scopeToExtend, final TypeInferenceContext context, @NotNull final VariableDescriptor... subjectVariables) {
            final DataFlowInfo[] result = new DataFlowInfo[] {context.dataFlowInfo};
            pattern.accept(new JetVisitorVoid() {
                @Override
                public void visitTypePattern(JetTypePattern typePattern) {
                    JetTypeReference typeReference = typePattern.getTypeReference();
                    if (typeReference != null) {
                        JetType type = context.typeResolver.resolveType(context.scope, typeReference);
                        checkTypeCompatibility(type, subjectType, typePattern);
                        result[0] = context.dataFlowInfo.isInstanceOf(subjectVariables, type);
                    }
                }

                @Override
                public void visitTuplePattern(JetTuplePattern pattern) {
                    List<JetTuplePatternEntry> entries = pattern.getEntries();
                    TypeConstructor typeConstructor = subjectType.getConstructor();
                    if (!JetStandardClasses.getTuple(entries.size()).getTypeConstructor().equals(typeConstructor)
                        || typeConstructor.getParameters().size() != entries.size()) {
//                        context.trace.getErrorHandler().genericError(pattern.getNode(), "Type mismatch: subject is of type " + subjectType + " but the pattern is of type Tuple" + entries.size());
                        context.trace.report(TYPE_MISMATCH_IN_TUPLE_PATTERN.on(pattern, subjectType, entries.size()));
                    }
                    else {
                        for (int i = 0, entriesSize = entries.size(); i < entriesSize; i++) {
                            JetTuplePatternEntry entry = entries.get(i);
                            JetType type = subjectType.getArguments().get(i).getType();

                            // TODO : is a name always allowed, ie for tuple patterns, not decomposer arg lists?
                            ASTNode nameLabelNode = entry.getNameLabelNode();
                            if (nameLabelNode != null) {
//                                context.trace.getErrorHandler().genericError(nameLabelNode, "Unsupported [JetTypeInferrer]");
                                context.trace.report(UNSUPPORTED.on(nameLabelNode, getClass().getCanonicalName()));
                            }

                            JetPattern entryPattern = entry.getPattern();
                            if (entryPattern != null) {
                                result[0] = result[0].and(checkPatternType(entryPattern, type, scopeToExtend, context));
                            }
                        }
                    }
                }

                @Override
                public void visitDecomposerPattern(JetDecomposerPattern pattern) {
                    JetExpression decomposerExpression = pattern.getDecomposerExpression();
                    if (decomposerExpression != null) {
                        ReceiverDescriptor receiver = new TransientReceiver(subjectType);
                        JetType selectorReturnType = getSelectorReturnType(receiver, null, decomposerExpression, context);

                        result[0] = checkPatternType(pattern.getArgumentList(), selectorReturnType == null ? ErrorUtils.createErrorType("No type") : selectorReturnType, scopeToExtend, context);
                    }
                }

                @Override
                public void visitWildcardPattern(JetWildcardPattern pattern) {
                    // Nothing
                }

                @Override
                public void visitExpressionPattern(JetExpressionPattern pattern) {
                    JetExpression expression = pattern.getExpression();
                    if (expression != null) {
                        JetType type = getType(expression, context.replaceScope(scopeToExtend));
                        checkTypeCompatibility(type, subjectType, pattern);
                    }
                }

                @Override
                public void visitBindingPattern(JetBindingPattern pattern) {
                    JetProperty variableDeclaration = pattern.getVariableDeclaration();
                    JetTypeReference propertyTypeRef = variableDeclaration.getPropertyTypeRef();
                    JetType type = propertyTypeRef == null ? subjectType : context.typeResolver.resolveType(context.scope, propertyTypeRef);
                    VariableDescriptor variableDescriptor = context.classDescriptorResolver.resolveLocalVariableDescriptorWithType(context.scope.getContainingDeclaration(), variableDeclaration, type);
                    scopeToExtend.addVariableDescriptor(variableDescriptor);
                    if (propertyTypeRef != null) {
                        if (!semanticServices.getTypeChecker().isSubtypeOf(subjectType, type)) {
//                            context.trace.getErrorHandler().genericError(propertyTypeRef.getNode(), type + " must be a supertype of " + subjectType + ". Use 'is' to match against " + type);
                            context.trace.report(TYPE_MISMATCH_IN_BINDING_PATTERN.on(propertyTypeRef, type, subjectType));
                        }
                    }

                    JetWhenCondition condition = pattern.getCondition();
                    if (condition != null) {
                        int oldLength = subjectVariables.length;
                        VariableDescriptor[] newSubjectVariables = new VariableDescriptor[oldLength + 1];
                        System.arraycopy(subjectVariables, 0, newSubjectVariables, 0, oldLength);
                        newSubjectVariables[oldLength] = variableDescriptor;
                        result[0] = checkWhenCondition(null, subjectType, condition, scopeToExtend, context, newSubjectVariables);
                    }
                }

                private void checkTypeCompatibility(@Nullable JetType type, @NotNull JetType subjectType, @NotNull JetElement reportErrorOn) {
                    // TODO : Take auto casts into account?
                    if (type == null) {
                        return;
                    }
                    if (TypeUtils.intersect(semanticServices.getTypeChecker(), Sets.newHashSet(type, subjectType)) == null) {
//                        context.trace.getErrorHandler().genericError(reportErrorOn.getNode(), "Incompatible types: " + type + " and " + subjectType);
                        context.trace.report(INCOMPATIBLE_TYPES.on(reportErrorOn, type, subjectType));
                    }
                }

                @Override
                public void visitJetElement(JetElement element) {
//                    context.trace.getErrorHandler().genericError(element.getNode(), "Unsupported [JetTypeInferrer]");
                    context.trace.report(UNSUPPORTED.on(element, getClass().getCanonicalName()));
                }
            });
            return result[0];
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222225/fstmerge_var2_8423426563551313089

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e3240_97756/rev_e3240-97756/compiler/frontend/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222290/fstmerge_var1_6076205233858548316
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222290/fstmerge_base_5621626768648235644
@Override
        public JetType visitQualifiedExpression(JetQualifiedExpression expression, TypeInferenceContext contextWithExpectedType) {
            TypeInferenceContext context = contextWithExpectedType.replaceExpectedType(NO_EXPECTED_TYPE);
            // TODO : functions as values
            JetExpression selectorExpression = expression.getSelectorExpression();
            JetExpression receiverExpression = expression.getReceiverExpression();
            JetType receiverType = context.services.typeInferrerVisitorWithNamespaces.getType(receiverExpression, context.replaceExpectedTypes(NO_EXPECTED_TYPE, NO_EXPECTED_TYPE));
            if (selectorExpression == null) return null;
            if (receiverType == null) receiverType = ErrorUtils.createErrorType("Type for " + expression.getText());

            if (selectorExpression instanceof JetSimpleNameExpression) {
                propagateConstantValues(expression, context, (JetSimpleNameExpression) selectorExpression);
            }

            // Clean resolution: no autocasts
            TemporaryBindingTrace cleanResolutionTrace = TemporaryBindingTrace.create(context.trace);
            TypeInferenceContext cleanResolutionContext = context.replaceBindingTrace(cleanResolutionTrace);
            JetType selectorReturnType = getSelectorReturnType(new ExpressionReceiver(receiverExpression, receiverType), selectorExpression, cleanResolutionContext);

            //TODO move further
            if (expression.getOperationSign() == JetTokens.SAFE_ACCESS) {
                if (selectorReturnType != null && !selectorReturnType.isNullable() && !JetStandardClasses.isUnit(selectorReturnType)) {
                    selectorReturnType = TypeUtils.makeNullable(selectorReturnType);
                }
            }
            if (selectorReturnType != null) {
                cleanResolutionTrace.addAllMyDataTo(context.trace);
            }
            else {
                VariableDescriptor variableDescriptor = cleanResolutionContext.services.getVariableDescriptorFromSimpleName(receiverExpression, context);
                boolean somethingFound = false;
                if (variableDescriptor != null) {
                    List<JetType> possibleTypes = Lists.newArrayList(context.dataFlowInfo.getPossibleTypesForVariable(variableDescriptor));
                    Collections.reverse(possibleTypes);

                    TemporaryBindingTrace autocastResolutionTrace = TemporaryBindingTrace.create(context.trace);
                    TypeInferenceContext autocastResolutionContext = context.replaceBindingTrace(autocastResolutionTrace);
                    for (JetType possibleType : possibleTypes) {
                        selectorReturnType = getSelectorReturnType(new ExpressionReceiver(receiverExpression, possibleType), selectorExpression, autocastResolutionContext);
                        if (selectorReturnType != null) {
                            context.services.checkAutoCast(receiverExpression, possibleType, variableDescriptor, autocastResolutionTrace);
                            autocastResolutionTrace.commit();
                            somethingFound = true;
                            break;
                        }
                        else {
                            autocastResolutionTrace = TemporaryBindingTrace.create(context.trace);
                            autocastResolutionContext = context.replaceBindingTrace(autocastResolutionTrace);
                        }
                    }
                }
                if (!somethingFound) {
                    cleanResolutionTrace.commit();
                }
            }

            JetType result;
            if (expression.getOperationSign() == JetTokens.QUEST) {
                if (selectorReturnType != null && !isBoolean(selectorReturnType) && selectorExpression != null) {
                    // TODO : more comprehensible error message
//                    context.trace.getErrorHandler().typeMismatch(selectorExpression, semanticServices.getStandardLibrary().getBooleanType(), selectorReturnType);
                    context.trace.report(TYPE_MISMATCH.on(selectorExpression, semanticServices.getStandardLibrary().getBooleanType(), selectorReturnType));
                }
                result = TypeUtils.makeNullable(receiverType);
            }
            else {
                result = selectorReturnType;
            }
            if (selectorExpression != null && result != null) {
                context.trace.record(BindingContext.EXPRESSION_TYPE, selectorExpression, result);
            }
            if (selectorReturnType != null) {
                // TODO : extensions to 'Any?'
                if (selectorExpression != null) {
                    receiverType = context.services.enrichOutType(receiverExpression, receiverType, context);

                    context.services.checkNullSafety(receiverType, expression.getOperationTokenNode(), getCalleeFunctionDescriptor(selectorExpression, context), expression);
                }
            }
            return context.services.checkType(result, expression, contextWithExpectedType);
        }
=======
@Override
        public JetType visitQualifiedExpression(JetQualifiedExpression expression, TypeInferenceContext contextWithExpectedType) {
            TypeInferenceContext context = contextWithExpectedType.replaceExpectedType(NO_EXPECTED_TYPE);
            // TODO : functions as values
            JetExpression selectorExpression = expression.getSelectorExpression();
            JetExpression receiverExpression = expression.getReceiverExpression();
            JetType receiverType = context.services.typeInferrerVisitorWithNamespaces.getType(receiverExpression, context.replaceExpectedTypes(NO_EXPECTED_TYPE, NO_EXPECTED_TYPE));
            if (selectorExpression == null) return null;
            if (receiverType == null) receiverType = ErrorUtils.createErrorType("Type for " + expression.getText());

            if (selectorExpression instanceof JetSimpleNameExpression) {
                propagateConstantValues(expression, context, (JetSimpleNameExpression) selectorExpression);
            }

            // Clean resolution: no autocasts
//            TemporaryBindingTrace cleanResolutionTrace = TemporaryBindingTrace.create(context.trace);
//            TypeInferenceContext cleanResolutionContext = context.replaceBindingTrace(cleanResolutionTrace);
            JetType selectorReturnType = getSelectorReturnType(new ExpressionReceiver(receiverExpression, receiverType), expression.getOperationTokenNode(), selectorExpression, context);

            //TODO move further
            if (expression.getOperationSign() == JetTokens.SAFE_ACCESS) {
                if (selectorReturnType != null && !selectorReturnType.isNullable() && !JetStandardClasses.isUnit(selectorReturnType)) {
                    selectorReturnType = TypeUtils.makeNullable(selectorReturnType);
                }
            }
//            if (selectorReturnType != null) {
//                cleanResolutionTrace.addAllMyDataTo(context.trace);
//            }
//            else {
//                VariableDescriptor variableDescriptor = cleanResolutionContext.services.getVariableDescriptorFromSimpleName(receiverExpression, context);
//                boolean somethingFound = false;
//                if (variableDescriptor != null) {
//                    List<JetType> possibleTypes = Lists.newArrayList(context.dataFlowInfo.getPossibleTypesForVariable(variableDescriptor));
//                    Collections.reverse(possibleTypes);
//
//                    TemporaryBindingTrace autocastResolutionTrace = TemporaryBindingTrace.create(context.trace);
//                    TypeInferenceContext autocastResolutionContext = context.replaceBindingTrace(autocastResolutionTrace);
//                    for (JetType possibleType : possibleTypes) {
//                        selectorReturnType = getSelectorReturnType(new ExpressionReceiver(receiverExpression, possibleType), selectorExpression, autocastResolutionContext);
//                        if (selectorReturnType != null) {
//                            context.services.checkAutoCast(receiverExpression, possibleType, variableDescriptor, autocastResolutionTrace);
//                            autocastResolutionTrace.commit();
//                            somethingFound = true;
//                            break;
//                        }
//                        else {
//                            autocastResolutionTrace = TemporaryBindingTrace.create(context.trace);
//                            autocastResolutionContext = context.replaceBindingTrace(autocastResolutionTrace);
//                        }
//                    }
//                }
//                if (!somethingFound) {
//                    cleanResolutionTrace.commit();
//                }
//            }

            JetType result;
            if (expression.getOperationSign() == JetTokens.QUEST) {
                if (selectorReturnType != null && !isBoolean(selectorReturnType)) {
                    // TODO : more comprehensible error message
//                    context.trace.getErrorHandler().typeMismatch(selectorExpression, semanticServices.getStandardLibrary().getBooleanType(), selectorReturnType);
                    context.trace.report(TYPE_MISMATCH.on(selectorExpression, semanticServices.getStandardLibrary().getBooleanType(), selectorReturnType));
                }
                result = TypeUtils.makeNullable(receiverType);
            }
            else {
                result = selectorReturnType;
            }
            // TODO : this is suspicious: remove this code?
            if (result != null) {
                context.trace.record(BindingContext.EXPRESSION_TYPE, selectorExpression, result);
            }
            if (selectorReturnType != null) {
//                // TODO : extensions to 'Any?'
//                receiverType = context.services.enrichOutType(receiverExpression, receiverType, context);
//
//                context.services.checkNullSafety(receiverType, expression.getOperationTokenNode(), getCalleeFunctionDescriptor(selectorExpression, context), expression);
            }
            return context.services.checkType(result, expression, contextWithExpectedType);
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222290/fstmerge_var2_2177890670422915848

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e3240_97756/rev_e3240-97756/compiler/frontend/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222301/fstmerge_var1_5608065845725520495
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222301/fstmerge_base_938175531457940352
@Override
        public JetType visitCallExpression(JetCallExpression expression, TypeInferenceContext context) {
            JetType expressionType = context.resolveCall(ReceiverDescriptor.NO_RECEIVER, expression);
            return context.services.checkType(expressionType, expression, context);
        }
=======
@Override
        public JetType visitCallExpression(JetCallExpression expression, TypeInferenceContext context) {
            JetType expressionType = context.resolveCall(NO_RECEIVER, null, expression);
            return context.services.checkType(expressionType, expression, context);
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222301/fstmerge_var2_8479968347389008294

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e3240_97756/rev_e3240-97756/compiler/frontend/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222311/fstmerge_var1_9030997866672317708
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222311/fstmerge_base_3406817846329707262
@Override
        public JetType visitUnaryExpression(JetUnaryExpression expression, TypeInferenceContext context) {
            JetExpression baseExpression = expression.getBaseExpression();
            if (baseExpression == null) return null;
            JetSimpleNameExpression operationSign = expression.getOperationSign();
            if (JetTokens.LABELS.contains(operationSign.getReferencedNameElementType())) {
                // TODO : Some processing for the label?
                return context.services.checkType(getType(baseExpression, context.replaceExpectedReturnType(context.expectedType)), expression, context);
            }
            IElementType operationType = operationSign.getReferencedNameElementType();
            String name = unaryOperationNames.get(operationType);
            if (name == null) {
//                context.trace.getErrorHandler().genericError(operationSign.getNode(), "Unknown unary operation");
                context.trace.report(UNSUPPORTED.on(operationSign, "visitUnaryExpression"));
                return null;
            }
            ExpressionReceiver receiver = getExpressionReceiver(baseExpression, context.replaceExpectedType(NO_EXPECTED_TYPE).replaceScope(context.scope));
            if (receiver == null) return null;

            FunctionDescriptor functionDescriptor = context.resolveCallWithGivenName(
                    CallMaker.makeCall(expression),
                    expression.getOperationSign(),
                    name,
                    receiver);

            if (functionDescriptor == null) return null;
            JetType returnType = functionDescriptor.getReturnType();
            JetType result;
            if (operationType == JetTokens.PLUSPLUS || operationType == JetTokens.MINUSMINUS) {
                if (semanticServices.getTypeChecker().isSubtypeOf(returnType, JetStandardClasses.getUnitType())) {
                    result = JetStandardClasses.getUnitType();
                }
                else {
                    JetType receiverType = receiver.getType();
                    if (!semanticServices.getTypeChecker().isSubtypeOf(returnType, receiverType)) {
//                        context.trace.getErrorHandler().genericError(operationSign.getNode(), name + " must return " + receiverType + " but returns " + returnType);
                        context.trace.report(RESULT_TYPE_MISMATCH.on(operationSign, name, receiverType, returnType));
                    }
                    else {
                        context.trace.record(BindingContext.VARIABLE_REASSIGNMENT, expression);
                    }
                    // TODO : Maybe returnType?
                    result = receiverType;
                }
            }
            else {
                result = returnType;
            }
            return context.services.checkType(result, expression, context);
        }
=======
@Override
        public JetType visitUnaryExpression(JetUnaryExpression expression, TypeInferenceContext context) {
            JetExpression baseExpression = expression.getBaseExpression();
            if (baseExpression == null) return null;
            JetSimpleNameExpression operationSign = expression.getOperationSign();
            if (JetTokens.LABELS.contains(operationSign.getReferencedNameElementType())) {
                // TODO : Some processing for the label?
                return context.services.checkType(getType(baseExpression, context.replaceExpectedReturnType(context.expectedType)), expression, context);
            }
            IElementType operationType = operationSign.getReferencedNameElementType();
            String name = unaryOperationNames.get(operationType);
            if (name == null) {
//                context.trace.getErrorHandler().genericError(operationSign.getNode(), "Unknown unary operation");
                context.trace.report(UNSUPPORTED.on(operationSign, "visitUnaryExpression"));
                return null;
            }
            ExpressionReceiver receiver = getExpressionReceiver(baseExpression, context.replaceExpectedType(NO_EXPECTED_TYPE).replaceScope(context.scope));
            if (receiver == null) return null;

            FunctionDescriptor functionDescriptor = context.resolveCallWithGivenName(
                    CallMaker.makeCall(receiver, expression),
                    expression.getOperationSign(),
                    name,
                    receiver);

            if (functionDescriptor == null) return null;
            JetType returnType = functionDescriptor.getReturnType();
            JetType result;
            if (operationType == JetTokens.PLUSPLUS || operationType == JetTokens.MINUSMINUS) {
                if (semanticServices.getTypeChecker().isSubtypeOf(returnType, JetStandardClasses.getUnitType())) {
                    result = JetStandardClasses.getUnitType();
                }
                else {
                    JetType receiverType = receiver.getType();
                    if (!semanticServices.getTypeChecker().isSubtypeOf(returnType, receiverType)) {
//                        context.trace.getErrorHandler().genericError(operationSign.getNode(), name + " must return " + receiverType + " but returns " + returnType);
                        context.trace.report(RESULT_TYPE_MISMATCH.on(operationSign, name, receiverType, returnType));
                    }
                    else {
                        context.trace.record(BindingContext.VARIABLE_REASSIGNMENT, expression);
                    }
                    // TODO : Maybe returnType?
                    result = receiverType;
                }
            }
            else {
                result = returnType;
            }
            return context.services.checkType(result, expression, context);
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222311/fstmerge_var2_6365248075237730533

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e3240_97756/rev_e3240-97756/compiler/frontend/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222316/fstmerge_var1_6688941711778056478
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222316/fstmerge_base_5734525320674921003
@Override
        public JetType visitBinaryExpression(JetBinaryExpression expression, TypeInferenceContext contextWithExpectedType) {
            TypeInferenceContext context = contextWithExpectedType.replaceExpectedType(NO_EXPECTED_TYPE);
            JetSimpleNameExpression operationSign = expression.getOperationReference();

            JetExpression left = expression.getLeft();
            JetExpression right = expression.getRight();

            JetType result = null;
            IElementType operationType = operationSign.getReferencedNameElementType();
            if (operationType == JetTokens.IDENTIFIER) {
                String referencedName = operationSign.getReferencedName();
                if (referencedName != null) {
                    result = getTypeForBinaryCall(context.scope, referencedName, context, expression);
                }
            }
            else if (binaryOperationNames.containsKey(operationType)) {
                result = getTypeForBinaryCall(context.scope, binaryOperationNames.get(operationType), context, expression);
            }
            else if (operationType == JetTokens.EQ) {
                result = visitAssignment(expression, context);
            }
            else if (assignmentOperationNames.containsKey(operationType)) {
                result = visitAssignmentOperation(expression, context);
            }
            else if (comparisonOperations.contains(operationType)) {
                JetType compareToReturnType = getTypeForBinaryCall(context.scope, "compareTo", context, expression);
                if (compareToReturnType != null) {
                    TypeConstructor constructor = compareToReturnType.getConstructor();
                    JetStandardLibrary standardLibrary = semanticServices.getStandardLibrary();
                    TypeConstructor intTypeConstructor = standardLibrary.getInt().getTypeConstructor();
                    if (constructor.equals(intTypeConstructor)) {
                        result = standardLibrary.getBooleanType();
                    } else {
//                        context.trace.getErrorHandler().genericError(operationSign.getNode(), "compareTo() must return Int, but returns " + compareToReturnType);
                        context.trace.report(COMPARE_TO_TYPE_MISMATCH.on(operationSign, compareToReturnType));
                    }
                }
            }
            else if (equalsOperations.contains(operationType)) {
                String name = "equals";
                if (right != null) {
                    ExpressionReceiver receiver = safeGetExpressionReceiver(left, context.replaceScope(context.scope));
                    OverloadResolutionResults<FunctionDescriptor> resolutionResults = context.resolveExactSignature(
                            receiver, "equals",
                            Collections.singletonList(JetStandardClasses.getNullableAnyType()));
                    if (resolutionResults.isSuccess()) {
                        FunctionDescriptor equals = resolutionResults.getResult().getResultingDescriptor();
                        context.trace.record(REFERENCE_TARGET, operationSign, equals);
                        if (ensureBooleanResult(operationSign, name, equals.getReturnType(), context)) {
                            ensureNonemptyIntersectionOfOperandTypes(expression, context);
                        }
                    }
                    else {
                        if (resolutionResults.isAmbiguity()) {
//                            StringBuilder stringBuilder = new StringBuilder();
//                            for (FunctionDescriptor functionDescriptor : resolutionResults.getResults()) {
//                                stringBuilder.append(DescriptorRenderer.TEXT.render(functionDescriptor)).append(" ");
//                            }
//                            context.trace.getErrorHandler().genericError(operationSign.getNode(), "Ambiguous function: " + stringBuilder);
                            context.trace.report(OVERLOAD_RESOLUTION_AMBIGUITY.on(operationSign, resolutionResults.getResults()));
                        }
                        else {
//                            context.trace.getErrorHandler().genericError(operationSign.getNode(), "No method 'equals(Any?) : Boolean' available");
                            context.trace.report(EQUALS_MISSING.on(operationSign));
                        }
                    }
                }
                result = semanticServices.getStandardLibrary().getBooleanType();
            }
            else if (operationType == JetTokens.EQEQEQ || operationType == JetTokens.EXCLEQEQEQ) {
                ensureNonemptyIntersectionOfOperandTypes(expression, context);

                // TODO : Check comparison pointlessness
                result = semanticServices.getStandardLibrary().getBooleanType();
            }
            else if (inOperations.contains(operationType)) {
                if (right == null) {
                    result = ErrorUtils.createErrorType("No right argument"); // TODO
                    return null;
                }
                checkInExpression(operationSign, left, right, context);
                result = semanticServices.getStandardLibrary().getBooleanType();
            }
            else if (operationType == JetTokens.ANDAND || operationType == JetTokens.OROR) {
                JetType leftType = getType(left, context.replaceScope(context.scope));
                WritableScopeImpl leftScope = newWritableScopeImpl(context.scope, context.trace).setDebugName("Left scope of && or ||");
                DataFlowInfo flowInfoLeft = extractDataFlowInfoFromCondition(left, operationType == JetTokens.ANDAND, leftScope, context);  // TODO: This gets computed twice: here and in extractDataFlowInfoFromCondition() for the whole condition
                WritableScopeImpl rightScope = operationType == JetTokens.ANDAND ? leftScope : newWritableScopeImpl(context.scope, context.trace).setDebugName("Right scope of && or ||");
                JetType rightType = right == null ? null : getType(right, context.replaceDataFlowInfo(flowInfoLeft).replaceScope(rightScope));
                if (leftType != null && !isBoolean(leftType)) {
//                    context.trace.getErrorHandler().typeMismatch(left, semanticServices.getStandardLibrary().getBooleanType(), leftType);
                    context.trace.report(TYPE_MISMATCH.on(left, semanticServices.getStandardLibrary().getBooleanType(), leftType));
                }
                if (rightType != null && !isBoolean(rightType)) {
//                    context.trace.getErrorHandler().typeMismatch(right, semanticServices.getStandardLibrary().getBooleanType(), rightType);
                    context.trace.report(TYPE_MISMATCH.on(right, semanticServices.getStandardLibrary().getBooleanType(), rightType));
                }
                result = semanticServices.getStandardLibrary().getBooleanType();
            }
            else if (operationType == JetTokens.ELVIS) {
                JetType leftType = getType(left, context.replaceScope(context.scope));
                JetType rightType = right == null ? null : getType(right, contextWithExpectedType.replaceScope(context.scope));
                if (leftType != null) {
                    if (!leftType.isNullable()) {
//                        context.trace.getErrorHandler().genericWarning(left.getNode(), "Elvis operator (?:) always returns the left operand of non-nullable type " + leftType);
                        context.trace.report(USELESS_ELVIS.on(expression, left, leftType));
                    }
                    if (rightType != null) {
                        context.services.checkType(TypeUtils.makeNullableAsSpecified(leftType, rightType.isNullable()), left, contextWithExpectedType);
                        return TypeUtils.makeNullableAsSpecified(semanticServices.getTypeChecker().commonSupertype(leftType, rightType), rightType.isNullable());
                    }
                }
            }
            else {
//                context.trace.getErrorHandler().genericError(operationSign.getNode(), "Unknown operation");
                context.trace.report(UNSUPPORTED.on(operationSign, "Unknown operation"));
            }
            return context.services.checkType(result, expression, contextWithExpectedType);
        }
=======
@Override
        public JetType visitBinaryExpression(JetBinaryExpression expression, TypeInferenceContext contextWithExpectedType) {
            TypeInferenceContext context = contextWithExpectedType.replaceExpectedType(NO_EXPECTED_TYPE);
            JetSimpleNameExpression operationSign = expression.getOperationReference();

            JetExpression left = expression.getLeft();
            JetExpression right = expression.getRight();

            JetType result = null;
            IElementType operationType = operationSign.getReferencedNameElementType();
            if (operationType == JetTokens.IDENTIFIER) {
                String referencedName = operationSign.getReferencedName();
                if (referencedName != null) {
                    result = getTypeForBinaryCall(context.scope, referencedName, context, expression);
                }
            }
            else if (binaryOperationNames.containsKey(operationType)) {
                result = getTypeForBinaryCall(context.scope, binaryOperationNames.get(operationType), context, expression);
            }
            else if (operationType == JetTokens.EQ) {
                result = visitAssignment(expression, context);
            }
            else if (assignmentOperationNames.containsKey(operationType)) {
                result = visitAssignmentOperation(expression, context);
            }
            else if (comparisonOperations.contains(operationType)) {
                JetType compareToReturnType = getTypeForBinaryCall(context.scope, "compareTo", context, expression);
                if (compareToReturnType != null) {
                    TypeConstructor constructor = compareToReturnType.getConstructor();
                    JetStandardLibrary standardLibrary = semanticServices.getStandardLibrary();
                    TypeConstructor intTypeConstructor = standardLibrary.getInt().getTypeConstructor();
                    if (constructor.equals(intTypeConstructor)) {
                        result = standardLibrary.getBooleanType();
                    } else {
//                        context.trace.getErrorHandler().genericError(operationSign.getNode(), "compareTo() must return Int, but returns " + compareToReturnType);
                        context.trace.report(COMPARE_TO_TYPE_MISMATCH.on(operationSign, compareToReturnType));
                    }
                }
            }
            else if (equalsOperations.contains(operationType)) {
                String name = "equals";
                if (right != null) {
                    ExpressionReceiver receiver = safeGetExpressionReceiver(left, context.replaceScope(context.scope));
                    OverloadResolutionResults<FunctionDescriptor> resolutionResults = context.resolveExactSignature(
                            receiver, "equals",
                            Collections.singletonList(JetStandardClasses.getNullableAnyType()));
                    if (resolutionResults.isSuccess()) {
                        FunctionDescriptor equals = resolutionResults.getResult().getResultingDescriptor();
                        context.trace.record(REFERENCE_TARGET, operationSign, equals);
                        if (ensureBooleanResult(operationSign, name, equals.getReturnType(), context)) {
                            ensureNonemptyIntersectionOfOperandTypes(expression, context);
                        }
                    }
                    else {
                        if (resolutionResults.isAmbiguity()) {
//                            StringBuilder stringBuilder = new StringBuilder();
//                            for (FunctionDescriptor functionDescriptor : resolutionResults.getResults()) {
//                                stringBuilder.append(DescriptorRenderer.TEXT.render(functionDescriptor)).append(" ");
//                            }
//                            context.trace.getErrorHandler().genericError(operationSign.getNode(), "Ambiguous function: " + stringBuilder);
                            context.trace.report(OVERLOAD_RESOLUTION_AMBIGUITY.on(operationSign, resolutionResults.getResults()));
                        }
                        else {
//                            context.trace.getErrorHandler().genericError(operationSign.getNode(), "No method 'equals(Any?) : Boolean' available");
                            context.trace.report(EQUALS_MISSING.on(operationSign));
                        }
                    }
                }
                result = semanticServices.getStandardLibrary().getBooleanType();
            }
            else if (operationType == JetTokens.EQEQEQ || operationType == JetTokens.EXCLEQEQEQ) {
                ensureNonemptyIntersectionOfOperandTypes(expression, context);

                // TODO : Check comparison pointlessness
                result = semanticServices.getStandardLibrary().getBooleanType();
            }
            else if (inOperations.contains(operationType)) {
                if (right == null) {
                    result = ErrorUtils.createErrorType("No right argument"); // TODO
                    return null;
                }
                checkInExpression(expression, expression.getOperationReference(), expression.getLeft(), expression.getRight(), context);
                result = semanticServices.getStandardLibrary().getBooleanType();
            }
            else if (operationType == JetTokens.ANDAND || operationType == JetTokens.OROR) {
                JetType leftType = getType(left, context.replaceScope(context.scope));
                WritableScopeImpl leftScope = newWritableScopeImpl(context.scope, context.trace).setDebugName("Left scope of && or ||");
                DataFlowInfo flowInfoLeft = extractDataFlowInfoFromCondition(left, operationType == JetTokens.ANDAND, leftScope, context);  // TODO: This gets computed twice: here and in extractDataFlowInfoFromCondition() for the whole condition
                WritableScopeImpl rightScope = operationType == JetTokens.ANDAND ? leftScope : newWritableScopeImpl(context.scope, context.trace).setDebugName("Right scope of && or ||");
                JetType rightType = right == null ? null : getType(right, context.replaceDataFlowInfo(flowInfoLeft).replaceScope(rightScope));
                if (leftType != null && !isBoolean(leftType)) {
//                    context.trace.getErrorHandler().typeMismatch(left, semanticServices.getStandardLibrary().getBooleanType(), leftType);
                    context.trace.report(TYPE_MISMATCH.on(left, semanticServices.getStandardLibrary().getBooleanType(), leftType));
                }
                if (rightType != null && !isBoolean(rightType)) {
//                    context.trace.getErrorHandler().typeMismatch(right, semanticServices.getStandardLibrary().getBooleanType(), rightType);
                    context.trace.report(TYPE_MISMATCH.on(right, semanticServices.getStandardLibrary().getBooleanType(), rightType));
                }
                result = semanticServices.getStandardLibrary().getBooleanType();
            }
            else if (operationType == JetTokens.ELVIS) {
                JetType leftType = getType(left, context.replaceScope(context.scope));
                JetType rightType = right == null ? null : getType(right, contextWithExpectedType.replaceScope(context.scope));
                if (leftType != null) {
                    if (!leftType.isNullable()) {
//                        context.trace.getErrorHandler().genericWarning(left.getNode(), "Elvis operator (?:) always returns the left operand of non-nullable type " + leftType);
                        context.trace.report(USELESS_ELVIS.on(expression, left, leftType));
                    }
                    if (rightType != null) {
                        context.services.checkType(TypeUtils.makeNullableAsSpecified(leftType, rightType.isNullable()), left, contextWithExpectedType);
                        return TypeUtils.makeNullableAsSpecified(semanticServices.getTypeChecker().commonSupertype(leftType, rightType), rightType.isNullable());
                    }
                }
            }
            else {
//                context.trace.getErrorHandler().genericError(operationSign.getNode(), "Unknown operation");
                context.trace.report(UNSUPPORTED.on(operationSign, "Unknown operation"));
            }
            return context.services.checkType(result, expression, contextWithExpectedType);
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222316/fstmerge_var2_4827742969946687934

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e3240_97756/rev_e3240-97756/compiler/frontend/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222355/fstmerge_var1_3155741833741137606
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222355/fstmerge_base_391492409616397517
@Override
        public JetType visitArrayAccessExpression(JetArrayAccessExpression expression, TypeInferenceContext contextWithExpectedType) {
            TypeInferenceContext context = contextWithExpectedType.replaceExpectedType(NO_EXPECTED_TYPE);
            JetExpression arrayExpression = expression.getArrayExpression();
            ExpressionReceiver receiver = getExpressionReceiver(arrayExpression, context.replaceScope(context.scope));

            if (receiver != null) {
                FunctionDescriptor functionDescriptor = context.resolveCallWithGivenName(
                        CallMaker.makeCall(expression, expression.getIndexExpressions()),
                        expression,
                        "get",
                        receiver);
                if (functionDescriptor != null) {
                    return context.services.checkType(functionDescriptor.getReturnType(), expression, contextWithExpectedType);
                }
            }
            return null;
        }
=======
@Override
        public JetType visitArrayAccessExpression(JetArrayAccessExpression expression, TypeInferenceContext contextWithExpectedType) {
            TypeInferenceContext context = contextWithExpectedType.replaceExpectedType(NO_EXPECTED_TYPE);
            JetExpression arrayExpression = expression.getArrayExpression();
            ExpressionReceiver receiver = getExpressionReceiver(arrayExpression, context.replaceScope(context.scope));

            if (receiver != null) {
                FunctionDescriptor functionDescriptor = context.resolveCallWithGivenName(
                        CallMaker.makeCallWithExpressions(expression, receiver, null, expression, expression.getIndexExpressions()),
                        expression,
                        "get",
                        receiver);
                if (functionDescriptor != null) {
                    return context.services.checkType(functionDescriptor.getReturnType(), expression, contextWithExpectedType);
                }
            }
            return null;
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222355/fstmerge_var2_2398622270109912230

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e3240_97756/rev_e3240-97756/compiler/frontend/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222359/fstmerge_var1_3270149415662615747
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222359/fstmerge_base_5038486523223044639
@Nullable
        protected JetType getTypeForBinaryCall(JetScope scope, String name, TypeInferenceContext context, JetBinaryExpression binaryExpression) {
            ExpressionReceiver receiver = safeGetExpressionReceiver(binaryExpression.getLeft(), context.replaceScope(scope));
            FunctionDescriptor functionDescriptor = context.replaceScope(scope).resolveCallWithGivenName(
                    CallMaker.makeCall(binaryExpression),
                    binaryExpression.getOperationReference(),
                    name,
                    receiver);
            if (functionDescriptor != null) {
                if (receiver.getType().isNullable()) {
                    // TODO : better error message for '1 + nullableVar' case
                    JetExpression right = binaryExpression.getRight();
                    String rightText = right == null ? "" : right.getText();
                    String leftText = binaryExpression.getLeft().getText();
//                    context.trace.getErrorHandler().genericError(binaryExpression.getOperationReference().getNode(),
//                                                                 "Infix call corresponds to a dot-qualified call '" +
//                                                                 leftText + "." + name + "(" + rightText + ")'" +
//                                                                 " which is not allowed on a nullable receiver '" + leftText + "'." +
//                                                                 " Use '?.'-qualified call instead");
                    context.trace.report(UNSAFE_INFIX_CALL.on(binaryExpression.getOperationReference(), leftText, name, rightText));
                }
                

                return functionDescriptor.getReturnType();
            }
            return null;
        }
=======
@Nullable
        protected JetType getTypeForBinaryCall(JetScope scope, String name, TypeInferenceContext context, JetBinaryExpression binaryExpression) {
            ExpressionReceiver receiver = safeGetExpressionReceiver(binaryExpression.getLeft(), context.replaceScope(scope));
            FunctionDescriptor functionDescriptor = context.replaceScope(scope).resolveCallWithGivenName(
                    CallMaker.makeCall(receiver, binaryExpression),
                    binaryExpression.getOperationReference(),
                    name,
                    receiver);
            if (functionDescriptor != null) {
//                if (receiver.getType().isNullable()) {
//                    // TODO : better error message for '1 + nullableVar' case
//                    JetExpression right = binaryExpression.getRight();
//                    String rightText = right == null ? "" : right.getText();
//                    String leftText = binaryExpression.getLeft().getText();
////                    context.trace.getErrorHandler().genericError(binaryExpression.getOperationReference().getNode(),
////                                                                 "Infix call corresponds to a dot-qualified call '" +
////                                                                 leftText + "." + name + "(" + rightText + ")'" +
////                                                                 " which is not allowed on a nullable receiver '" + leftText + "'." +
////                                                                 " Use '?.'-qualified call instead");
//                    context.trace.report(UNSAFE_INFIX_CALL.on(binaryExpression.getOperationReference(), leftText, name, rightText));
//                }
                

                return functionDescriptor.getReturnType();
            }
            return null;
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222359/fstmerge_var2_2370289761967881232

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e3240_97756/rev_e3240-97756/compiler/frontend/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222425/fstmerge_var1_3647224738017780822
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222425/fstmerge_base_3024671571372988093
private JetType resolveArrayAccessToLValue(JetArrayAccessExpression arrayAccessExpression, JetExpression rightHandSide, JetSimpleNameExpression operationSign, TypeInferenceContext context) {
            ExpressionReceiver receiver = getExpressionReceiver(arrayAccessExpression.getArrayExpression(), context.replaceScope(scope));
            if (receiver == null) return null;
//
            Call call = CallMaker.makeCall(arrayAccessExpression, rightHandSide);
//            // TODO : nasty hack: effort is duplicated
//            callResolver.resolveCallWithGivenName(
//                    scope,
//                    call,
//                    arrayAccessExpression,
//                    "set", arrayAccessExpression.getArrayExpression(), NO_EXPECTED_TYPE);
            FunctionDescriptor functionDescriptor = context.replaceScope(scope).replaceExpectedType(NO_EXPECTED_TYPE).resolveCallWithGivenName(
                    call,
                    arrayAccessExpression,
                    "set", receiver);
            if (functionDescriptor == null) return null;
            context.trace.record(REFERENCE_TARGET, operationSign, functionDescriptor);
            return context.services.checkType(functionDescriptor.getReturnType(), arrayAccessExpression, context);
        }
=======
private JetType resolveArrayAccessToLValue(JetArrayAccessExpression arrayAccessExpression, JetExpression rightHandSide, JetSimpleNameExpression operationSign, TypeInferenceContext context) {
            ExpressionReceiver receiver = getExpressionReceiver(arrayAccessExpression.getArrayExpression(), context.replaceScope(scope));
            if (receiver == null) return null;
//
            Call call = CallMaker.makeCall(receiver, arrayAccessExpression, rightHandSide);
//            // TODO : nasty hack: effort is duplicated
//            callResolver.resolveCallWithGivenName(
//                    scope,
//                    call,
//                    arrayAccessExpression,
//                    "set", arrayAccessExpression.getArrayExpression(), NO_EXPECTED_TYPE);
            FunctionDescriptor functionDescriptor = context.replaceScope(scope).replaceExpectedType(NO_EXPECTED_TYPE).resolveCallWithGivenName(
                    call,
                    arrayAccessExpression,
                    "set", receiver);
            if (functionDescriptor == null) return null;
            context.trace.record(REFERENCE_TARGET, operationSign, functionDescriptor);
            return context.services.checkType(functionDescriptor.getReturnType(), arrayAccessExpression, context);
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027222425/fstmerge_var2_8790422394857519703

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e3240_97756/rev_e3240-97756/compiler/frontend/src/org/jetbrains/jet/lang/types/JetTypeInferrer.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3894e_b3783/rev_3894e-b3783.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3083f_2bb8d/rev_3083f-2bb8d.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@NotNull
    private FunctionDescriptor standardFunction(ClassDescriptor classDescriptor, List<TypeProjection> typeArguments, String name, JetType... parameterType) {
        List<JetType> parameterTypeList = Arrays.asList(parameterType);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027484211/fstmerge_var1_1460412642980277349
        JetTypeInferrer.Services typeInferrerServices = JetSemanticServices.createSemanticServices(getProject()).getTypeInferrerServices(new BindingTraceContext());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027484211/fstmerge_base_8280597526810629240
        JetTypeInferrerServices typeInferrerServices = JetSemanticServices.createSemanticServices(getProject()).getTypeInferrerServices(new BindingTraceContext());
=======
//        ExpressionTypingServices typeInferrerServices = JetSemanticServices.createSemanticServices(getProject()).getTypeInferrerServices(new BindingTraceContext());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419027484211/fstmerge_var2_6253333801190194238

        CallResolver callResolver = new CallResolver(JetSemanticServices.createSemanticServices(getProject()), DataFlowInfo.getEmpty());
        OverloadResolutionResults<FunctionDescriptor> functions = callResolver.resolveExactSignature(
                classDescriptor.getMemberScope(typeArguments), ReceiverDescriptor.NO_RECEIVER, name, parameterTypeList);
        for (ResolvedCall<FunctionDescriptor> resolvedCall : functions.getResults()) {
            List<ValueParameterDescriptor> unsubstitutedValueParameters = resolvedCall.getResultingDescriptor().getValueParameters();
            for (int i = 0, unsubstitutedValueParametersSize = unsubstitutedValueParameters.size(); i < unsubstitutedValueParametersSize; i++) {
                ValueParameterDescriptor unsubstitutedValueParameter = unsubstitutedValueParameters.get(i);
                if (unsubstitutedValueParameter.getOutType().equals(parameterType[i])) {
                    return resolvedCall.getResultingDescriptor();
                }
            }
        }
        throw new IllegalArgumentException("Not found: std::" + classDescriptor.getName() + "." + name + "(" + parameterTypeList + ")");
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3083f_2bb8d/rev_3083f-2bb8d/idea/tests/org/jetbrains/jet/resolve/JetResolveTest.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c0861_7e142/rev_c0861-7e142.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_abe04_a7db6/rev_abe04-a7db6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_a9ab3_101b8/rev_a9ab3-101b8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_417bb_79ee5/rev_417bb-79ee5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d445a_2df7f/rev_d445a-2df7f.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419028139575/fstmerge_var1_6089226657194911258
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419028139575/fstmerge_base_2602898031160227338
private void processCFData(String name, Map<JetElement, Pseudocode> data) throws IOException {
        Collection<Pseudocode> pseudocodes = data.values();

        StringBuilder instructionDump = new StringBuilder();
        int i = 0;
        for (Pseudocode pseudocode : pseudocodes) {
            JetElement correspondingElement = pseudocode.getCorrespondingElement();
            String label;
            if (correspondingElement instanceof JetNamedDeclaration) {
                JetNamedDeclaration namedDeclaration = (JetNamedDeclaration) correspondingElement;
                label = namedDeclaration.getName();
            }
            else {
                label = "anonymous_" + i++;
            }

            instructionDump.append("== ").append(label).append(" ==\n");

            instructionDump.append(correspondingElement.getText());
            instructionDump.append("\n---------------------\n");
            pseudocode.dumpInstructions(instructionDump);
            instructionDump.append("=====================\n");
        }

        String expectedInstructionsFileName = getTestDataPath() + "/" + getTestFilePath().replace(".jet", ".instructions");
        File expectedInstructionsFile = new File(expectedInstructionsFileName);
        if (!expectedInstructionsFile.exists()) {
            FileUtil.writeToFile(expectedInstructionsFile, instructionDump.toString());
            fail("No expected instructions for " + name + " generated result is written into " + expectedInstructionsFileName);
        }
        String expectedInstructions = StringUtil.convertLineSeparators(FileUtil.loadFile(expectedInstructionsFile));

        assertEquals(expectedInstructions, instructionDump.toString());

//                        StringBuilder graphDump = new StringBuilder();
//                        for (Pseudocode pseudocode : pseudocodes) {
//                            topOrderDump(pseudocode.)
//                        }
    }
=======
private void processCFData(String name, Map<JetElement, Pseudocode> data) throws IOException {
        Collection<Pseudocode> pseudocodes = data.values();

        StringBuilder instructionDump = new StringBuilder();
        int i = 0;
        for (Pseudocode pseudocode : pseudocodes) {
            JetElement correspondingElement = pseudocode.getCorrespondingElement();
            String label;
            assert correspondingElement instanceof JetNamedDeclaration;
            if (correspondingElement instanceof JetFunctionLiteral) {
                label = "anonymous_" + i++;
            }
            else {
                JetNamedDeclaration namedDeclaration = (JetNamedDeclaration) correspondingElement;
                label = namedDeclaration.getName();
            }

            instructionDump.append("== ").append(label).append(" ==\n");

            instructionDump.append(correspondingElement.getText());
            instructionDump.append("\n---------------------\n");
            dumpInstructions(pseudocode, instructionDump);
            instructionDump.append("=====================\n");
            
            //check edges directions
            Collection<Instruction> instructions = pseudocode.getInstructions();
            for (Instruction instruction : instructions) {
                for (Instruction nextInstruction : instruction.getNextInstructions()) {
                    assertTrue("instruction: " + instruction + " next: " + nextInstruction, nextInstruction.getPreviousInstructions().contains(instruction));
                }
                for (Instruction prevInstruction : instruction.getPreviousInstructions()) {
                    assertTrue("instruction: " + instruction + " prev: " + prevInstruction, prevInstruction.getNextInstructions().contains(instruction));
                }
            }
        }

        String expectedInstructionsFileName = getTestDataPath() + "/" + getTestFilePath().replace(".jet", ".instructions");
        File expectedInstructionsFile = new File(expectedInstructionsFileName);
        if (!expectedInstructionsFile.exists()) {
            FileUtil.writeToFile(expectedInstructionsFile, instructionDump.toString());
            fail("No expected instructions for " + name + " generated result is written into " + expectedInstructionsFileName);
        }
        String expectedInstructions = StringUtil.convertLineSeparators(FileUtil.loadFile(expectedInstructionsFile));

        assertEquals(expectedInstructions, instructionDump.toString());

//                        StringBuilder graphDump = new StringBuilder();
//                        for (Pseudocode pseudocode : pseudocodes) {
//                            topOrderDump(pseudocode.)
//                        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419028139575/fstmerge_var2_2078031615135485436

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d445a_2df7f/rev_d445a-2df7f/idea/tests/org/jetbrains/jet/cfg/JetControlFlowTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419028139579/fstmerge_var1_3701558203222433373
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419028139579/fstmerge_base_2911109609083609867
private void dumpDot(String name, Collection<Pseudocode> pseudocodes) throws FileNotFoundException {
        String graphFileName = getTestDataPath() + "/" + getTestFilePath().replace(".jet", ".dot");
        File target = new File(graphFileName);

        PrintStream out = new PrintStream(target);

        out.println("digraph " + name + " {");
        int[] count = new int[1];
        Map<Instruction, String> nodeToName = new HashMap<Instruction, String>();
        for (Pseudocode pseudocode : pseudocodes) {
            pseudocode.dumpNodes(out, count, nodeToName);
        }
        int i = 0;
        for (Pseudocode pseudocode : pseudocodes) {
            String label;
            JetElement correspondingElement = pseudocode.getCorrespondingElement();
            if (correspondingElement instanceof JetNamedDeclaration) {
                JetNamedDeclaration namedDeclaration = (JetNamedDeclaration) correspondingElement;
                label = namedDeclaration.getName();
            }
            else {
                label = "anonymous_" + i;
            }
            out.println("subgraph cluster_" + i + " {\n" +
                        "label=\"" + label + "\";\n" +
                        "color=blue;\n");
            pseudocode.dumpEdges(out, count, nodeToName);
            out.println("}");
            i++;
        }
        out.println("}");
        out.close();
    }
=======
private void dumpDot(String name, Collection<Pseudocode> pseudocodes) throws FileNotFoundException {
        String graphFileName = getTestDataPath() + "/" + getTestFilePath().replace(".jet", ".dot");
        File target = new File(graphFileName);

        PrintStream out = new PrintStream(target);

        out.println("digraph " + name + " {");
        int[] count = new int[1];
        Map<Instruction, String> nodeToName = new HashMap<Instruction, String>();
        for (Pseudocode pseudocode : pseudocodes) {
            dumpNodes(pseudocode.getInstructions(), out, count, nodeToName);
        }
        int i = 0;
        for (Pseudocode pseudocode : pseudocodes) {
            String label;
            JetElement correspondingElement = pseudocode.getCorrespondingElement();
            if (correspondingElement instanceof JetNamedDeclaration) {
                JetNamedDeclaration namedDeclaration = (JetNamedDeclaration) correspondingElement;
                label = namedDeclaration.getName();
            }
            else {
                label = "anonymous_" + i;
            }
            out.println("subgraph cluster_" + i + " {\n" +
                        "label=\"" + label + "\";\n" +
                        "color=blue;\n");
            dumpEdges(pseudocode.getInstructions(), out, count, nodeToName);
            out.println("}");
            i++;
        }
        out.println("}");
        out.close();
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419028139579/fstmerge_var2_4954972732946202802

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d445a_2df7f/rev_d445a-2df7f/idea/tests/org/jetbrains/jet/cfg/JetControlFlowTest.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_fe869_a67b7/rev_fe869-a67b7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b837a_9122b/rev_b837a-9122b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_00008_87f5a/rev_00008-87f5a.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public static void main(String[] args) {
        System.setProperty("java.awt.headless", "true");
        Arguments arguments = new Arguments();
        try {
            Args.parse(arguments, args);
        }
        catch (Throwable t) {
            System.out.println("Usage: KotlinCompiler -output <outputDir> -src <filename or dirname>");
            t.printStackTrace();
            return;
        }

        Disposable root = new Disposable() {
            @Override
            public void dispose() {
            }
        };
        JetCoreEnvironment environment = new JetCoreEnvironment(root);

        File rtJar = initJdk();
        if (rtJar == null) return;

        environment.addToClasspath(rtJar);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419028535331/fstmerge_var1_3653400273434491645
        environment.registerFileType(JetFileType.INSTANCE, "kt");
        environment.registerParserDefinition(new JetParserDefinition());

        VirtualFile vFile = environment.getLocalFileSystem().findFileByPath(arguments.src);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419028535331/fstmerge_base_6106235634916315445
        environment.registerFileType(JetFileType.INSTANCE, "kt");
        environment.registerFileType(JetFileType.INSTANCE, "jet");
        environment.registerParserDefinition(new JetParserDefinition());
        VirtualFile vFile = environment.getLocalFileSystem().findFileByPath(args [0]);
=======
        VirtualFile vFile = environment.getLocalFileSystem().findFileByPath(args [0]);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419028535331/fstmerge_var2_1131571437634932768
        if (vFile == null) {
            System.out.print("File/directory not found: " + arguments.src);
            return;
        }

        Project project = environment.getProject();
        GenerationState generationState = new GenerationState(project, false);
        List<JetNamespace> namespaces = Lists.newArrayList();
        if(vFile.isDirectory())  {
            File dir = new File(vFile.getPath());
            addFiles(environment, project, namespaces, dir);
        }
        else {
            PsiFile psiFile = PsiManager.getInstance(project).findFile(vFile);
            if (psiFile instanceof JetFile) {
                namespaces.add(((JetFile) psiFile).getRootNamespace());
            }
            else {
                System.out.print("Not a Kotlin file: " + vFile.getPath());
                return;
            }
        }

        BindingContext bindingContext = AnalyzingUtils.getInstance(JavaDefaultImports.JAVA_DEFAULT_IMPORTS).analyzeNamespaces(project, namespaces, JetControlFlowDataTraceFactory.EMPTY);

        ErrorCollector errorCollector = new ErrorCollector(bindingContext);
        errorCollector.report();

        if (!errorCollector.hasErrors) {
            generationState.compileCorrectNamespaces(bindingContext, namespaces);

            final ClassFileFactory factory = generationState.getFactory();
            if(arguments.outputDir == null) {
                System.out.println("Output directory is not specified - no files will be saved to the disk");
            }
            else {
                List<String> files = factory.files();
                for (String file : files) {
                    File target = new File(arguments.outputDir, file);
                    try {
                        FileUtil.writeToFile(target, factory.asBytes(file));
                        System.out.println("Generated classfile: " + target);
                    } catch (IOException e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        }

    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_00008_87f5a/rev_00008-87f5a/compiler/cli/src/org/jetbrains/jet/cli/KotlinCompiler.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_00008_828ea/rev_00008-828ea.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_a81fb_62af2/rev_a81fb-62af2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_1de76_cc2d2/rev_1de76-cc2d2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3c8d8_4fb29/rev_3c8d8-4fb29.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3c8d8_92108/rev_3c8d8-92108.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_22afa_37c9e/rev_22afa-37c9e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_f1237_c7bb6/rev_f1237-c7bb6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ecdce_b467d/rev_ecdce-b467d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_5a9c5_2bf5a/rev_5a9c5-2bf5a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d0731_73941/rev_d0731-73941.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_5e5b7_03e1e/rev_5e5b7-03e1e.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419030000500/fstmerge_var1_4610525003011450887
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419030000500/fstmerge_base_2222218717712044098
private static void process(
            @NotNull JetSemanticServices semanticServices,
            @NotNull BindingTrace trace,
            @NotNull JetScope outerScope,
            NamespaceLike owner,
            @NotNull List<? extends JetDeclaration> declarations,
            @NotNull JetControlFlowDataTraceFactory flowDataTraceFactory,
            boolean declaredLocally) {
        TopDownAnalysisContext context = new TopDownAnalysisContext(semanticServices, trace);
        new TypeHierarchyResolver(context).process(outerScope, owner, declarations);
        new DeclarationResolver(context).process();
        new DelegationResolver(context).process();
        new OverrideResolver(context).process();
        new BodyResolver(context).resolveBehaviorDeclarationBodies();
        new DeclarationsChecker(context).process();
        new ControlFlowAnalyzer(context, flowDataTraceFactory, declaredLocally).process();
    }
=======
private static void process(
            @NotNull JetSemanticServices semanticServices,
            @NotNull BindingTrace trace,
            @NotNull JetScope outerScope,
            NamespaceLike owner,
            @NotNull List<? extends JetDeclaration> declarations,
            @NotNull JetControlFlowDataTraceFactory flowDataTraceFactory,
            boolean declaredLocally) {
        TopDownAnalysisContext context = new TopDownAnalysisContext(semanticServices, trace);
        new TypeHierarchyResolver(context).process(outerScope, owner, declarations);
        new DeclarationResolver(context).process();
        new DelegationResolver(context).process();
        new OverrideResolver(context).process();
        new BodyResolver(context).resolveBehaviorDeclarationBodies();
        new ControlFlowAnalyzer(context, flowDataTraceFactory, declaredLocally).process();
        new DeclarationsChecker(context).process();
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419030000500/fstmerge_var2_3659938460112240998

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_5e5b7_03e1e/rev_5e5b7-03e1e/compiler/frontend/src/org/jetbrains/jet/lang/resolve/TopDownAnalyzer.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_93d5a_8debe/rev_93d5a-8debe.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b4929_95a2a/rev_b4929-95a2a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_84b21_6a16c/rev_84b21-6a16c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_019cc_1862c/rev_019cc-1862c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_431ae_25841/rev_431ae-25841.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_49879_05f1d/rev_49879-05f1d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d7aa7_2feba/rev_d7aa7-2feba.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_f6dee_ec3f6/rev_f6dee-ec3f6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_2c43b_c71d9/rev_2c43b-c71d9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0b6df_d292b/rev_0b6df-d292b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_dfb17_f62b3/rev_dfb17-f62b3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_cfc41_2d633/rev_cfc41-2d633.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_abec6_1b8e5/rev_abec6-1b8e5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_7ef0d_2c2c6/rev_7ef0d-2c2c6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_a4b62_839d9/rev_a4b62-839d9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e001c_25d26/rev_e001c-25d26.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3bfd7_421d2/rev_3bfd7-421d2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_7975a_7f500/rev_7975a-7f500.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_2070c_39637/rev_2070c-39637.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_9ec55_77e0c/rev_9ec55-77e0c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_16d39_5ae69/rev_16d39-5ae69.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3c245_ca561/rev_3c245-ca561.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_91cb7_f38fe/rev_91cb7-f38fe.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_9edd8_cb37f/rev_9edd8-cb37f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_242da_01025/rev_242da-01025.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ebf29_dca53/rev_ebf29-dca53.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e96c9_63964/rev_e96c9-63964.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_5d2df_9cb0c/rev_5d2df-9cb0c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_894a0_b75a6/rev_894a0-b75a6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_aa007_c8030/rev_aa007-c8030.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_2fcc1_fd9ea/rev_2fcc1-fd9ea.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_2fcc1_1e63c/rev_2fcc1-1e63c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0ff63_25af9/rev_0ff63-25af9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0b689_c0cc9/rev_0b689-c0cc9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_f3f25_2ceb5/rev_f3f25-2ceb5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_a7048_0c758/rev_a7048-0c758.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_194bd_08e55/rev_194bd-08e55.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_a52d9_a7ead/rev_a52d9-a7ead.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_554aa_ecb3d/rev_554aa-ecb3d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_27293_09de9/rev_27293-09de9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_690ef_a9c40/rev_690ef-a9c40.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_a9a07_859c9/rev_a9a07-859c9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ec7c0_fc943/rev_ec7c0-fc943.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public JetType visitForExpression(JetForExpression expression, ExpressionTypingContext contextWithExpectedType) {
        ExpressionTypingContext context = contextWithExpectedType.replaceExpectedType(TypeUtils.NO_EXPECTED_TYPE);
        JetParameter loopParameter = expression.getLoopParameter();
        JetExpression loopRange = expression.getLoopRange();
        JetType expectedParameterType = null;
        if (loopRange != null) {
            ExpressionReceiver loopRangeReceiver = getExpressionReceiver(facade, loopRange, context.replaceScope(context.scope));
            if (loopRangeReceiver != null) {
                expectedParameterType = checkIterableConvention(loopRangeReceiver, context);
            }
        }

        WritableScope loopScope = newWritableScopeImpl(context).setDebugName("Scope with for-loop index");

        if (loopParameter != null) {
            JetTypeReference typeReference = loopParameter.getTypeReference();
            VariableDescriptor variableDescriptor;
            if (typeReference != null) {
                variableDescriptor = context.getDescriptorResolver().resolveLocalVariableDescriptor(context.scope.getContainingDeclaration(), context.scope, loopParameter);
                JetType actualParameterType = variableDescriptor.getOutType();
                if (expectedParameterType != null &&
                        actualParameterType != null &&
                        !context.semanticServices.getTypeChecker().isSubtypeOf(expectedParameterType, actualParameterType)) {
                    context.trace.report(TYPE_MISMATCH_IN_FOR_LOOP.on(typeReference, expectedParameterType, actualParameterType));
                }
            }
            else {
                if (expectedParameterType == null) {
                    expectedParameterType = ErrorUtils.createErrorType("Error");
                }
                variableDescriptor = context.getDescriptorResolver().resolveLocalVariableDescriptor(context.scope.getContainingDeclaration(), loopParameter, expectedParameterType);
            }

            {
                // http://youtrack.jetbrains.net/issue/KT-527

                VariableDescriptor olderVariable = context.scope.getVariable(variableDescriptor.getName());
                if (olderVariable != null && DescriptorUtils.isLocal(context.scope.getContainingDeclaration(), olderVariable)) {
                    context.trace.report(Errors.NAME_SHADOWING.on(variableDescriptor, context.trace.getBindingContext()));
                }
            }

            loopScope.addVariableDescriptor(variableDescriptor);
        }

        JetExpression body = expression.getBody();
        if (body != null) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419035843840/fstmerge_var1_7920965005856735105
            ExpressionTypingInternals blockLevelVisitor = ExpressionTypingVisitorDispatcher.createForBlock(loopScope);
            blockLevelVisitor.getType(body, context.replaceScope(loopScope));
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419035843840/fstmerge_base_2305586999228697899
            facade.getType(body, context.replaceScope(loopScope));
=======
            context.getServices().getBlockReturnedTypeWithWritableScope(loopScope, Collections.singletonList(body), CoercionStrategy.NO_COERCION, context);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419035843840/fstmerge_var2_6362476135515574060
        }

        return DataFlowUtils.checkType(JetStandardClasses.getUnitType(), expression, contextWithExpectedType);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ec7c0_fc943/rev_ec7c0-fc943/compiler/frontend/src/org/jetbrains/jet/lang/types/expressions/ControlStructureTypingVisitor.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_f5667_11e95/rev_f5667-11e95.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ce171_ba49f/rev_ce171-ba49f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_5075e_90c4b/rev_5075e-90c4b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_49c29_1e3c4/rev_49c29-1e3c4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_957b2_ffc5d/rev_957b2-ffc5d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_8d439_74fe2/rev_8d439-74fe2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_7155b_eee0c/rev_7155b-eee0c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_7155b_69547/rev_7155b-69547.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_66821_eab98/rev_66821-eab98.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6115d_e8b76/rev_6115d-e8b76.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6825f_13a17/rev_6825f-13a17.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e2d22_39ac2/rev_e2d22-39ac2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6f314_844c9/rev_6f314-844c9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_f7fb3_52ead/rev_f7fb3-52ead.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b9f1d_deb8d/rev_b9f1d-deb8d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_f68aa_8e5c3/rev_f68aa-8e5c3.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419038386985/fstmerge_var1_6170130829066806377
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419038386985/fstmerge_base_8029912176933526343
@NotNull
    public static TestSuite suite() {
        TestSuite suite = new TestSuite();

        JetTestCaseBuilder.appendTestsInDirectory(
                PluginTestCaseBase.getTestDataPathBase(), "/completion/basic/", false,
                JetTestCaseBuilder.emptyFilter, new JetTestCaseBuilder.NamedTestFactory() {

            @NotNull
            @Override
            public junit.framework.Test createTest(@NotNull String dataPath, @NotNull String name) {
                return new JetBasicCompletion(dataPath, name);
            }
        }, suite);

        return suite;
    }
=======
@NotNull
    public static TestSuite suite() {
        TestSuite suite = new TestSuite();

        JetTestCaseBuilder.appendTestsInDirectory(
                PluginTestCaseBase.getTestDataPathBase(), "/completion/basic/", false,
                JetTestCaseBuilder.emptyFilter, new JetTestCaseBuilder.NamedTestFactory() {

            @NotNull
            @Override
            public Test createTest(@NotNull String dataPath, @NotNull String name, @NotNull File file) {
                return new JetBasicCompletion(dataPath, name);
            }
        }, suite);

        return suite;
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419038386985/fstmerge_var2_4420977852886457565

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_f68aa_8e5c3/rev_f68aa-8e5c3/idea/tests/org/jetbrains/jet/completion/JetBasicCompletion.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6f21d_ec55d/rev_6f21d-ec55d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e5c39_d2729/rev_e5c39-d2729.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_2d942_8bdfa/rev_2d942-8bdfa.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_40937_41111/rev_40937-41111.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_2270a_ab770/rev_2270a-ab770.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_11641_242c5/rev_11641-242c5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b8995_e05de/rev_b8995-e05de.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0b4d0_42a00/rev_0b4d0-42a00.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_4bfdb_d9381/rev_4bfdb-d9381.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_4bfdb_22e14/rev_4bfdb-22e14.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_9d622_faf6b/rev_9d622-faf6b.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@NotNull
    public PropertyDescriptor resolvePrimaryConstructorParameterToAProperty(
            @NotNull ClassDescriptor classDescriptor,
            @NotNull JetScope scope,
            @NotNull JetParameter parameter) {
        JetType type = resolveParameterType(scope, parameter);
        String name = parameter.getName();
        boolean isMutable = parameter.isMutable();
        JetModifierList modifierList = parameter.getModifierList();

        if (modifierList != null) {
            ASTNode abstractNode = modifierList.getModifierNode(JetTokens.ABSTRACT_KEYWORD);
            if (abstractNode != null) {
//                trace.getErrorHandler().genericError(abstractNode, "This property cannot be declared abstract");
                trace.report(ABSTRACT_PROPERTY_IN_PRIMARY_CONSTRUCTOR_PARAMETERS.on(parameter, abstractNode));
            }
        }

        PropertyDescriptor propertyDescriptor = new PropertyDescriptor(
                classDescriptor,
                annotationResolver.resolveAnnotations(scope, modifierList),
                resolveModalityFromModifiers(parameter.getModifierList(), Modality.FINAL),
                resolveVisibilityFromModifiers(parameter.getModifierList()),
                isMutable,
                name == null ? "<no name>" : name
        );
        JetType inType = isMutable ? type : null;
        propertyDescriptor.setType(inType, type, Collections.<TypeParameterDescriptor>emptyList(), ReceiverDescriptor.NO_RECEIVER);

        PropertyGetterDescriptor getter = createDefaultGetter(propertyDescriptor);
        PropertySetterDescriptor setter = createDefaultSetter(propertyDescriptor);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419040217673/fstmerge_var1_1852689091289263852
        JetType inType = isMutable ? type : null;
        propertyDescriptor.setType(inType, type, Collections.<TypeParameterDescriptor>emptyList(), DescriptorUtils.getExpectedThisObjectIfNeeded(classDescriptor), ReceiverDescriptor.NO_RECEIVER);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419040217673/fstmerge_base_8922680564366038781
        JetType inType = isMutable ? type : null;
        propertyDescriptor.setType(inType, type, Collections.<TypeParameterDescriptor>emptyList(), ReceiverDescriptor.NO_RECEIVER);
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419040217673/fstmerge_var2_4127469571340936058
        propertyDescriptor.initialize(getter, setter);
        getter.initialize(propertyDescriptor.getOutType());

        trace.record(BindingContext.PRIMARY_CONSTRUCTOR_PARAMETER, parameter, propertyDescriptor);
        return propertyDescriptor;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_9d622_faf6b/rev_9d622-faf6b/compiler/frontend/src/org/jetbrains/jet/lang/resolve/DescriptorResolver.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_81fec_74425/rev_81fec-74425.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_88bda_a7e99/rev_88bda-a7e99.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_fcf14_63d74/rev_fcf14-63d74.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_9ae40_6889a/rev_9ae40-6889a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_8f461_8e105/rev_8f461-8e105.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3d918_c45d0/rev_3d918-c45d0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_9f87e_cab2e/rev_9f87e-cab2e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ac29a_3419d/rev_ac29a-3419d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0dcd4_a41d3/rev_0dcd4-a41d3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3cf7a_5e083/rev_3cf7a-5e083.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b58a9_7d3d5/rev_b58a9-7d3d5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e153d_3551b/rev_e153d-3551b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_337d8_12a89/rev_337d8-12a89.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_07676_a984b/rev_07676-a984b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6039b_d1229/rev_6039b-d1229.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_63cb2_4d4a4/rev_63cb2-4d4a4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_02111_ad9a8/rev_02111-ad9a8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6d197_c9215/rev_6d197-c9215.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_68d52_49f80/rev_68d52-49f80.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0dc31_de4b0/rev_0dc31-de4b0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_a279d_a3880/rev_a279d-a3880.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_529bc_232d1/rev_529bc-232d1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ec239_04696/rev_ec239-04696.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e0d93_894c8/rev_e0d93-894c8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e15ec_b0b14/rev_e15ec-b0b14.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_42349_991a3/rev_42349-991a3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b64e8_07254/rev_b64e8-07254.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_5653d_36f50/rev_5653d-36f50.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_90e5c_fa5be/rev_90e5c-fa5be.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_79d32_8cad0/rev_79d32-8cad0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_44e55_f45c6/rev_44e55-f45c6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_44e55_7060f/rev_44e55-7060f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_08447_b4538/rev_08447-b4538.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_588a7_2d78c/rev_588a7-2d78c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_25f7c_979df/rev_25f7c-979df.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_4579c_6aafa/rev_4579c-6aafa.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_939f9_6f584/rev_939f9-6f584.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419046804534/fstmerge_var1_2504106438595240528
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419046804534/fstmerge_base_1051714136164520191
public static void writeToOutputDirectory(ClassFileFactory factory, final String outputDir) {
        List<String> files = factory.files();
        for (String file : files) {
            if(!skipFile(file)) {
                File target = new File(outputDir, file);
                try {
                    FileUtil.writeToFile(target, factory.asBytes(file));
                } catch (IOException e) {
                    throw new CompileEnvironmentException(e);
                }
            }
        }
    }
=======
public static void writeToOutputDirectory(ClassFileFactory factory, final String outputDir) {
        List<String> files = factory.files();
        for (String file : files) {
//            if(!skipFile(file)) {
                File target = new File(outputDir, file);
                try {
                    FileUtil.writeToFile(target, factory.asBytes(file));
                } catch (IOException e) {
                    throw new CompileEnvironmentException(e);
                }
//            }
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419046804534/fstmerge_var2_5305559910491117335

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_939f9_6f584/rev_939f9-6f584/compiler/backend/src/org/jetbrains/jet/compiler/AbstractCompileEnvironment.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_f259b_a3878/rev_f259b-a3878.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_28c44_f660d/rev_28c44-f660d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c6caf_12ba5/rev_c6caf-12ba5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_02b2c_f632f/rev_02b2c-f632f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_fb075_01e6d/rev_fb075-01e6d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_87748_f2ff8/rev_87748-f2ff8.revisions
Conflict type: LineBasedMCFd
Conflict body: 
public static void writeToOutputDirectory(ClassFileFactory factory, final String outputDir) {
        List<String> files = factory.files();
        for (String file : files) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419047908087/fstmerge_var1_2042604230966145434
            File target = new File(outputDir, file);
            try {
                FileUtil.writeToFile(target, factory.asBytes(file));
            } catch (IOException e) {
                throw new CompileEnvironmentException(e);
            }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419047908087/fstmerge_base_5802331370630070037
            if(!skipFile(file)) {
                File target = new File(outputDir, file);
                try {
                    FileUtil.writeToFile(target, factory.asBytes(file));
                } catch (IOException e) {
                    throw new CompileEnvironmentException(e);
                }
            }
=======
//            if(!skipFile(file)) {
                File target = new File(outputDir, file);
                try {
                    FileUtil.writeToFile(target, factory.asBytes(file));
                } catch (IOException e) {
                    throw new CompileEnvironmentException(e);
                }
//            }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419047908087/fstmerge_var2_8562999299019208604
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_87748_f2ff8/rev_87748-f2ff8/compiler/backend/src/org/jetbrains/jet/compiler/CompileEnvironment.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_9fd76_14c0e/rev_9fd76-14c0e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_5897e_f2b1a/rev_5897e-f2b1a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_18d73_d140c/rev_18d73-d140c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c2dc1_c8798/rev_c2dc1-c8798.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6446e_42c9b/rev_6446e-42c9b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_db7e2_169e8/rev_db7e2-169e8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_1cfdb_3059a/rev_1cfdb-3059a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_94ef4_35fef/rev_94ef4-35fef.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_2bc5e_15fde/rev_2bc5e-15fde.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_629cd_30225/rev_629cd-30225.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_8cfc9_3fd82/rev_8cfc9-3fd82.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d0b1f_8c40a/rev_d0b1f-8c40a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_7ebf1_ab47b/rev_7ebf1-ab47b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_2feaa_b8fdf/rev_2feaa-b8fdf.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_023b3_85ff4/rev_023b3-85ff4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_fb577_ba6c9/rev_fb577-ba6c9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_a22b7_c3181/rev_a22b7-c3181.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0573e_3e8e8/rev_0573e-3e8e8.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419051320015/fstmerge_var1_4108090876382359057
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419051320015/fstmerge_base_3453452325340453050
@NotNull
        private Collection<DeclarationDescriptor> lookupDescriptorsForQualifiedExpression(@NotNull JetQualifiedExpression importedReference, @NotNull JetScope outerScope) {
            JetExpression receiverExpression = importedReference.getReceiverExpression();
            Collection<DeclarationDescriptor> declarationDescriptors;
            if (receiverExpression instanceof JetQualifiedExpression) {
                declarationDescriptors = lookupDescriptorsForQualifiedExpression((JetQualifiedExpression) receiverExpression, outerScope);
            }
            else {
                assert receiverExpression instanceof JetSimpleNameExpression;
                declarationDescriptors = lookupDescriptorsForSimpleNameReference((JetSimpleNameExpression) receiverExpression, outerScope);
            }
            JetExpression selectorExpression = importedReference.getSelectorExpression();
            assert selectorExpression instanceof JetSimpleNameExpression;
            JetSimpleNameExpression selector = (JetSimpleNameExpression) selectorExpression;
            JetSimpleNameExpression lastReference = getLastReference(receiverExpression);
            if (lastReference == null || !canImportMembersFrom(declarationDescriptors, lastReference)) {
                return Collections.emptyList();
            }
            for (DeclarationDescriptor declarationDescriptor : declarationDescriptors) {
                if (declarationDescriptor instanceof NamespaceDescriptor) {
                    return lookupDescriptorsForSimpleNameReference(selector, ((NamespaceDescriptor) declarationDescriptor).getMemberScope());
                }
                if (declarationDescriptor instanceof ClassDescriptor) {
                    return lookupObjectMembers(selector, (ClassDescriptor) declarationDescriptor);
                }
                if (declarationDescriptor instanceof VariableDescriptor) {
                    return lookupVariableMembers(selector, (VariableDescriptor) declarationDescriptor);
                }
            }

            return Collections.emptyList();
        }
=======
@NotNull
        private Collection<DeclarationDescriptor> lookupDescriptorsForQualifiedExpression(@NotNull JetQualifiedExpression importedReference, @NotNull JetScope outerScope) {
            JetExpression receiverExpression = importedReference.getReceiverExpression();
            Collection<DeclarationDescriptor> declarationDescriptors;
            if (receiverExpression instanceof JetQualifiedExpression) {
                declarationDescriptors = lookupDescriptorsForQualifiedExpression((JetQualifiedExpression) receiverExpression, outerScope);
            }
            else {
                assert receiverExpression instanceof JetSimpleNameExpression;
                declarationDescriptors = lookupDescriptorsForSimpleNameReference((JetSimpleNameExpression) receiverExpression, outerScope);
            }
            JetExpression selectorExpression = importedReference.getSelectorExpression();
            assert selectorExpression instanceof JetSimpleNameExpression;
            JetSimpleNameExpression selector = (JetSimpleNameExpression) selectorExpression;
            JetSimpleNameExpression lastReference = getLastReference(receiverExpression);
            if (lastReference == null || !canImportMembersFrom(declarationDescriptors, lastReference)) {
                return Collections.emptyList();
            }
            Collection<DeclarationDescriptor> result;
            for (DeclarationDescriptor declarationDescriptor : declarationDescriptors) {
                if (declarationDescriptor instanceof NamespaceDescriptor) {
                    result = lookupDescriptorsForSimpleNameReference(selector, ((NamespaceDescriptor) declarationDescriptor).getMemberScope());
                    if (!result.isEmpty()) return result;
                }
                if (declarationDescriptor instanceof ClassDescriptor) {
                    result = lookupObjectMembers(selector, (ClassDescriptor) declarationDescriptor);
                    if (!result.isEmpty()) return result;
                }
                if (declarationDescriptor instanceof VariableDescriptor) {
                    result = lookupVariableMembers(selector, (VariableDescriptor) declarationDescriptor);
                    if (!result.isEmpty()) return result;
                }
            }

            return Collections.emptyList();
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419051320015/fstmerge_var2_5937701231037028089

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0573e_3e8e8/rev_0573e-3e8e8/compiler/frontend/src/org/jetbrains/jet/lang/resolve/ImportsResolver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419051320031/fstmerge_var1_5278161264391145025
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419051320031/fstmerge_base_6791561672892641625
@NotNull
        private Collection<DeclarationDescriptor> lookupDescriptorsForSimpleNameReference(@NotNull JetSimpleNameExpression referenceExpression, @NotNull JetScope outerScope) {

            List<DeclarationDescriptor> descriptors = Lists.newArrayList();
            String referencedName = referenceExpression.getReferencedName();
            if (referencedName != null) {
                NamespaceDescriptor namespaceDescriptor = outerScope.getNamespace(referencedName);
                if (namespaceDescriptor != null) descriptors.add(namespaceDescriptor);

                ClassifierDescriptor classifierDescriptor = outerScope.getClassifier(referencedName);
                if (classifierDescriptor != null) descriptors.add(classifierDescriptor);

                descriptors.addAll(outerScope.getFunctions(referencedName));

                descriptors.addAll(outerScope.getProperties(referencedName));
            }
            if (!firstPhase) {
                if (descriptors.size() == 1) {
                    trace.record(BindingContext.REFERENCE_TARGET, referenceExpression, descriptors.get(0));
                }
                else if (descriptors.size() > 1) {
                    trace.record(BindingContext.AMBIGUOUS_REFERENCE_TARGET, referenceExpression, descriptors);
                }
                else {
                    trace.report(UNRESOLVED_REFERENCE.on(referenceExpression));
                }

                // If it's not an ambiguous case - store resolution scope
                if (descriptors.size() <= 1 && outerScope != JetScope.EMPTY) {
                    trace.record(BindingContext.RESOLUTION_SCOPE, referenceExpression, outerScope);
                }
            }
            return descriptors;
        }
=======
@NotNull
        private Collection<DeclarationDescriptor> lookupDescriptorsForSimpleNameReference(@NotNull JetSimpleNameExpression referenceExpression, @NotNull JetScope outerScope) {

            List<DeclarationDescriptor> descriptors = Lists.newArrayList();
            String referencedName = referenceExpression.getReferencedName();
            if (referencedName != null) {
                NamespaceDescriptor namespaceDescriptor = outerScope.getNamespace(referencedName);
                if (namespaceDescriptor != null) descriptors.add(namespaceDescriptor);

                ClassifierDescriptor classifierDescriptor = outerScope.getClassifier(referencedName);
                if (classifierDescriptor != null) descriptors.add(classifierDescriptor);

                ClassDescriptor objectDescriptor = outerScope.getObjectDescriptor(referencedName);
                if (objectDescriptor != null) descriptors.add(objectDescriptor);

                descriptors.addAll(outerScope.getFunctions(referencedName));

                descriptors.addAll(outerScope.getProperties(referencedName));
            }
            recordReference(descriptors, referenceExpression, outerScope);
            return descriptors;
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419051320031/fstmerge_var2_8373116145146332300

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0573e_3e8e8/rev_0573e-3e8e8/compiler/frontend/src/org/jetbrains/jet/lang/resolve/ImportsResolver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419051320035/fstmerge_var1_8306278811721378583
@NotNull
        public static Collection<DeclarationDescriptor> addBoundToReceiver(@NotNull Collection<DeclarationDescriptor> descriptors,
                                                                           @NotNull final DeclarationDescriptor receiver) {
            return Collections2.transform(descriptors, DescriptorUtils.getAddBoundToReceiverFunction(receiver));
        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419051320035/fstmerge_base_2120402679029316432
@NotNull
        public static Collection<DeclarationDescriptor> addBoundToReceiver(@NotNull Collection<DeclarationDescriptor> descriptors, @NotNull final DeclarationDescriptor receiver) {
            return Collections2.transform(descriptors, DescriptorUtils.getAddBoundToReceiverFunction(receiver));
        }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419051320035/fstmerge_var2_1675475524337568858

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0573e_3e8e8/rev_0573e-3e8e8/compiler/frontend/src/org/jetbrains/jet/lang/resolve/ImportsResolver.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_f457b_11978/rev_f457b-11978.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d51c0_2522c/rev_d51c0-2522c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_62de2_e6a2b/rev_62de2-e6a2b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_94e3c_edb32/rev_94e3c-edb32.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_29236_0f9a2/rev_29236-0f9a2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e7daa_c5ef3/rev_e7daa-c5ef3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_2a3d1_becd7/rev_2a3d1-becd7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3b789_04b1a/rev_3b789-04b1a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_dd1fd_cc3a7/rev_dd1fd-cc3a7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_16ceb_a529a/rev_16ceb-a529a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c0980_aa2ba/rev_c0980-aa2ba.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_53f7c_35a12/rev_53f7c-35a12.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_fa610_81764/rev_fa610-81764.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ffc6f_cedec/rev_ffc6f-cedec.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e7904_a6c62/rev_e7904-a6c62.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e5f43_4633e/rev_e5f43-4633e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_20920_40775/rev_20920-40775.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_91337_57f99/rev_91337-57f99.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e1743_51e4f/rev_e1743-51e4f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ca1ab_bb0ae/rev_ca1ab-bb0ae.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_11ad2_f6a5a/rev_11ad2-f6a5a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_43e9f_73c26/rev_43e9f-73c26.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c83d7_6bde4/rev_c83d7-6bde4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b3279_64f36/rev_b3279-64f36.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c62bb_68e4f/rev_c62bb-68e4f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_12338_6822d/rev_12338-6822d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_01e71_659fc/rev_01e71-659fc.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e3fdc_d32cc/rev_e3fdc-d32cc.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_356ad_73324/rev_356ad-73324.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_18c48_3dacc/rev_18c48-3dacc.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_80a40_094d5/rev_80a40-094d5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b35d3_a9180/rev_b35d3-a9180.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_2e228_8b622/rev_2e228-8b622.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_21b3b_1262f/rev_21b3b-1262f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_1921e_5b146/rev_1921e-5b146.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d22f4_00a08/rev_d22f4-00a08.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_4c70d_3fc7e/rev_4c70d-3fc7e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_84327_c21ea/rev_84327-c21ea.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_4ea99_949b2/rev_4ea99-949b2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_200b6_0698d/rev_200b6-0698d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_35ea5_821a1/rev_35ea5-821a1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_de1c4_20ca1/rev_de1c4-20ca1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_28ff4_d2ec5/rev_28ff4-d2ec5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6e1bf_28ff4/rev_6e1bf-28ff4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_25c30_173c7/rev_25c30-173c7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_9dfd5_5dcd3/rev_9dfd5-5dcd3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_96d72_2e13f/rev_96d72-2e13f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3fc89_b6ec1/rev_3fc89-b6ec1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_51361_c4793/rev_51361-c4793.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b6161_bb593/rev_b6161-bb593.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d9d12_77150/rev_d9d12-77150.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_8b17c_1ff5a/rev_8b17c-1ff5a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_87370_44654/rev_87370-44654.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c9d6b_ae031/rev_c9d6b-ae031.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_fe626_0ceac/rev_fe626-0ceac.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0a0cf_c68c2/rev_0a0cf-c68c2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_dba86_680e1/rev_dba86-680e1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b8dda_c2000/rev_b8dda-c2000.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_97ec5_4ff9a/rev_97ec5-4ff9a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3b856_5bb7c/rev_3b856-5bb7c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6a8df_fe26a/rev_6a8df-fe26a.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@NotNull
    @Override
    public Collection<DeclarationDescriptor> getAllDescriptors() {
        if (allDescriptors == null) {
            allDescriptors = Sets.newLinkedHashSet();

            if (psiClass != null) {
                allDescriptors.addAll(semanticServices.getDescriptorResolver().resolveMethods(psiClass, descriptor));

                allDescriptors.addAll(semanticServices.getDescriptorResolver().resolveFieldGroup(descriptor, psiClass, staticMembers()));
            }

            final PsiPackage javaPackage = semanticServices.getDescriptorResolver().findPackage(packageFQN);

            if (javaPackage != null) {
                boolean isKotlinNamespace = semanticServices.getKotlinNamespaceDescriptor(new FqName(javaPackage.getQualifiedName())) != null;
                final JavaDescriptorResolver descriptorResolver = semanticServices.getDescriptorResolver();

                for (PsiPackage psiSubPackage : javaPackage.getSubPackages()) {
                    if (semanticServices.getKotlinNamespaceDescriptor(new FqName(psiSubPackage.getQualifiedName())) == null) {
                        allDescriptors.add(descriptorResolver.resolveNamespace(new FqName(psiSubPackage.getQualifiedName())));
                    }
                }

                for (PsiClass psiClass : javaPackage.getClasses()) {
                    if (isKotlinNamespace && JvmAbi.PACKAGE_CLASS.equals(psiClass.getName())) {
                        continue;
                    }

                    // If this is a Kotlin class, we have already taken it through a containing namespace descriptor
                    ClassDescriptor kotlinClassDescriptor = semanticServices.getKotlinClassDescriptor(new FqName(psiClass.getQualifiedName()));
                    if (kotlinClassDescriptor != null) {
                        continue;
                    }

                    // TODO: Temp hack for collection function descriptors from java
                    if (JvmAbi.PACKAGE_CLASS.equals(psiClass.getName())) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419096856941/fstmerge_var1_6414778577628871159
                        LinkedHashSet<String> methodNames = new LinkedHashSet<String>();
                        for (PsiMethod psiMethod : psiClass.getMethods()) {
                            methodNames.add(psiMethod.getName());
                        }

                        for (String methodName : methodNames) {
                            try {
                                allDescriptors.addAll(getFunctions(methodName));
                            } catch (ProcessCanceledException cancelException) {
                                throw cancelException;
                            } catch (RuntimeException ex) {
                                LOG.error(ex);
                            }
                        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419096856941/fstmerge_base_2448611004262287104
                        HashSet<String> methodNames = new HashSet<String>();
                        for (PsiMethod psiMethod : psiClass.getMethods()) {
                            methodNames.add(psiMethod.getName());
                        }

                        for (String methodName : methodNames) {
                            try {
                                allDescriptors.addAll(getFunctions(methodName));
                            } catch (ProcessCanceledException cancelException) {
                                throw cancelException;
                            } catch (RuntimeException ex) {
                                LOG.error(ex);
                            }
                        }
=======
                        continue;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419096856941/fstmerge_var2_8538774319724117034
                    }

                    if (psiClass.hasModifierProperty(PsiModifier.PUBLIC)) {
                        ClassDescriptor classDescriptor = descriptorResolver.resolveClass(psiClass);
                        if (classDescriptor != null) {
                            allDescriptors.add(classDescriptor);
                        }
                    }
                }
            }
        }

        return allDescriptors;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6a8df_fe26a/rev_6a8df-fe26a/compiler/frontend.java/src/org/jetbrains/jet/lang/resolve/java/JavaPackageScope.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419096860411/fstmerge_var1_5115227203478994030
public static String getFQName(DeclarationDescriptor descriptor) {
        DeclarationDescriptor container = descriptor.getContainingDeclaration();
        if (container != null && !(container instanceof ModuleDescriptor)
                                 && !("<java_root>".equals(container.getName()))) {
            // TODO JavaNamespaceDescriptors should be refactored
            String baseName = getFQName(container);
            if (!baseName.isEmpty()) return baseName + "." + descriptor.getName();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419096860411/fstmerge_base_404211031528005010
public static String getFQName(DeclarationDescriptor descriptor) {
        DeclarationDescriptor container = descriptor.getContainingDeclaration();
        if (container != null && !(container instanceof ModuleDescriptor)) {
            String baseName = getFQName(container);
            if (!baseName.isEmpty()) return baseName + "." + descriptor.getName();
=======
public static FqName getFQName(@NotNull DeclarationDescriptor descriptor) {
        if (descriptor instanceof ModuleDescriptor) {
            return FqName.ROOT;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419096860411/fstmerge_var2_7427449964326298696
        }

        if (descriptor.getContainingDeclaration() == null) {
            if (descriptor instanceof NamespaceDescriptor) {
                // TODO: namespace must always have parent
                if (descriptor.getName().equals("jet")) {
                    return FqName.topLevel("jet");
                }
                if (descriptor.getName().equals("<java_root>")) {
                    return FqName.ROOT;
                }
            }
            throw new IllegalStateException("descriptor is not module descriptor and has null containingDeclaration: " + descriptor.getContainingDeclaration());
        }

        return getFQName(descriptor.getContainingDeclaration()).child(descriptor.getName());
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6a8df_fe26a/rev_6a8df-fe26a/compiler/frontend/src/org/jetbrains/jet/lang/resolve/DescriptorUtils.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419096877755/fstmerge_var1_4156136196730669303
public static String getJVMClassName(String fqName, boolean namespace) {
        if (fqName.length() == 0) {
            return JvmAbi.PACKAGE_CLASS;
        }

        String name = fqName.replace('.', '/');
        if (name.startsWith(JavaDescriptorResolver.JAVA_ROOT)) {
            name = name.substring(JavaDescriptorResolver.JAVA_ROOT.length() + 1, name.length());
        }
        if (namespace) {
            name += "/" + JvmAbi.PACKAGE_CLASS;
        }
        return name;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419096877755/fstmerge_base_6111815716401716381
public static String getJVMClassName(String fqName, boolean namespace) {
        if (fqName.length() == 0) {
            return JvmAbi.PACKAGE_CLASS;
        }

        String name = fqName.replace('.', '/');
        if(name.startsWith("<java_root>")) {
            name = name.substring("<java_root>".length() + 1, name.length());
        }
        if (namespace) {
            name += "/" + JvmAbi.PACKAGE_CLASS;
        }
        return name;
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419096877755/fstmerge_var2_9002118606852975512

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6a8df_fe26a/rev_6a8df-fe26a/compiler/backend/src/org/jetbrains/jet/codegen/NamespaceCodegen.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_5af46_e2d85/rev_5af46-e2d85.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ec8cc_56eab/rev_ec8cc-56eab.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_4f286_165a1/rev_4f286-165a1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ccf27_54af5/rev_ccf27-54af5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e740c_ef89a/rev_e740c-ef89a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_32d44_55141/rev_32d44-55141.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_4311b_23e56/rev_4311b-23e56.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6fdaa_5ece4/rev_6fdaa-5ece4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ca4f5_77652/rev_ca4f5-77652.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_834c6_32024/rev_834c6-32024.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_99c7b_153b6/rev_99c7b-153b6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_63889_5155b/rev_63889-5155b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c104a_63889/rev_c104a-63889.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_31b67_e56b8/rev_31b67-e56b8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_5d926_4b894/rev_5d926-4b894.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419117400553/fstmerge_var1_8638378836291603347
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419117400553/fstmerge_base_7516179873587196627
@Override
    public void annotate(@NotNull PsiElement element, @NotNull final AnnotationHolder holder) {
        if (!debugInfoEnabled || !JetPsiChecker.isErrorReportingEnabled()) {
            return;
        }
        
        if (element instanceof JetFile) {
            JetFile file = (JetFile) element;
            try {
                final BindingContext bindingContext = WholeProjectAnalyzerFacade.analyzeProjectWithCacheOnAFile(file);

                final Set<JetReferenceExpression> unresolvedReferences = Sets.newHashSet();
                for (Diagnostic diagnostic : bindingContext.getDiagnostics()) {
                    if (diagnostic instanceof UnresolvedReferenceDiagnostic) {
                        unresolvedReferences.add(((UnresolvedReferenceDiagnostic) diagnostic).getPsiElement());
                    }
                }

                file.acceptChildren(new JetVisitorVoid() {

                    @Override
                    public void visitReferenceExpression(JetReferenceExpression expression) {
                        if (expression instanceof JetSimpleNameExpression) {
                            JetSimpleNameExpression nameExpression = (JetSimpleNameExpression) expression;
                            IElementType elementType = expression.getNode().getElementType();
                            if (elementType == JetNodeTypes.OPERATION_REFERENCE) {
                                IElementType referencedNameElementType = nameExpression.getReferencedNameElementType();
                                if (EXCLUDED.contains(referencedNameElementType)) {
                                    return;
                                }
                                if (JetTokens.LABELS.contains(referencedNameElementType)) return;
                            }
                            else if (nameExpression.getReferencedNameElementType() == JetTokens.THIS_KEYWORD) {
                                return;
                            }
                        }

                        String target = null;
                        DeclarationDescriptor declarationDescriptor = bindingContext.get(REFERENCE_TARGET, expression);
                        if (declarationDescriptor != null) {
                            target = declarationDescriptor.toString();
                        }
                        else {
                            PsiElement labelTarget = bindingContext.get(LABEL_TARGET, expression);
                            if (labelTarget != null) {
                                target = labelTarget.getText();
                            }
                            else {
                                Collection<? extends DeclarationDescriptor> declarationDescriptors = bindingContext.get(AMBIGUOUS_REFERENCE_TARGET, expression);
                                if (declarationDescriptors != null) {
                                    target = "[" + declarationDescriptors.size() + " descriptors]";
                                }
                            }
                        }
                        boolean resolved = target != null;
                        boolean unresolved = unresolvedReferences.contains(expression);
                        JetType expressionType = bindingContext.get(EXPRESSION_TYPE, expression);
                        if (declarationDescriptor != null && !ApplicationManager.getApplication().isUnitTestMode() && (ErrorUtils.isError(declarationDescriptor) || ErrorUtils.containsErrorType(expressionType))) {
                            holder.createErrorAnnotation(expression, "[DEBUG] Resolved to error element").setTextAttributes(JetHighlighter.JET_RESOLVED_TO_ERROR);
                        }
                        if (resolved && unresolved) {
                            holder.createErrorAnnotation(expression, "[DEBUG] Reference marked as unresolved is actually resolved to " + target).setTextAttributes(JetHighlighter.JET_DEBUG_INFO);
                        }
                        else if (!resolved && !unresolved) {
                            holder.createErrorAnnotation(expression, "[DEBUG] Reference is not resolved to anything, but is not marked unresolved").setTextAttributes(JetHighlighter.JET_DEBUG_INFO);
                        }
                    }

                    @Override
                    public void visitJetElement(JetElement element) {
                        element.acceptChildren(this);
                    }
                });
            }
            catch (ProcessCanceledException e) {
                throw e;
            }
            catch (Throwable e) {
                // TODO
                holder.createErrorAnnotation(element, e.getClass().getCanonicalName() + ": " + e.getMessage());
                e.printStackTrace();
            }
        }
    }
=======
@Override
    public void annotate(@NotNull PsiElement element, @NotNull final AnnotationHolder holder) {
        if (!debugInfoEnabled || !JetPsiChecker.isErrorReportingEnabled()) {
            return;
        }
        
        if (element instanceof JetFile) {
            JetFile file = (JetFile) element;
            try {
                final BindingContext bindingContext = WholeProjectAnalyzerFacade.analyzeProjectWithCacheOnAFile(file)
                        .getBindingContext();

                final Set<JetReferenceExpression> unresolvedReferences = Sets.newHashSet();
                for (Diagnostic diagnostic : bindingContext.getDiagnostics()) {
                    if (diagnostic instanceof UnresolvedReferenceDiagnostic) {
                        unresolvedReferences.add(((UnresolvedReferenceDiagnostic) diagnostic).getPsiElement());
                    }
                }

                file.acceptChildren(new JetVisitorVoid() {

                    @Override
                    public void visitReferenceExpression(JetReferenceExpression expression) {
                        if (expression instanceof JetSimpleNameExpression) {
                            JetSimpleNameExpression nameExpression = (JetSimpleNameExpression) expression;
                            IElementType elementType = expression.getNode().getElementType();
                            if (elementType == JetNodeTypes.OPERATION_REFERENCE) {
                                IElementType referencedNameElementType = nameExpression.getReferencedNameElementType();
                                if (EXCLUDED.contains(referencedNameElementType)) {
                                    return;
                                }
                                if (JetTokens.LABELS.contains(referencedNameElementType)) return;
                            }
                            else if (nameExpression.getReferencedNameElementType() == JetTokens.THIS_KEYWORD) {
                                return;
                            }
                        }

                        String target = null;
                        DeclarationDescriptor declarationDescriptor = bindingContext.get(REFERENCE_TARGET, expression);
                        if (declarationDescriptor != null) {
                            target = declarationDescriptor.toString();
                        }
                        else {
                            PsiElement labelTarget = bindingContext.get(LABEL_TARGET, expression);
                            if (labelTarget != null) {
                                target = labelTarget.getText();
                            }
                            else {
                                Collection<? extends DeclarationDescriptor> declarationDescriptors = bindingContext.get(AMBIGUOUS_REFERENCE_TARGET, expression);
                                if (declarationDescriptors != null) {
                                    target = "[" + declarationDescriptors.size() + " descriptors]";
                                }
                            }
                        }
                        boolean resolved = target != null;
                        boolean unresolved = unresolvedReferences.contains(expression);
                        JetType expressionType = bindingContext.get(EXPRESSION_TYPE, expression);
                        if (declarationDescriptor != null && !ApplicationManager.getApplication().isUnitTestMode() && (ErrorUtils.isError(declarationDescriptor) || ErrorUtils.containsErrorType(expressionType))) {
                            holder.createErrorAnnotation(expression, "[DEBUG] Resolved to error element").setTextAttributes(JetHighlighter.JET_RESOLVED_TO_ERROR);
                        }
                        if (resolved && unresolved) {
                            holder.createErrorAnnotation(expression, "[DEBUG] Reference marked as unresolved is actually resolved to " + target).setTextAttributes(JetHighlighter.JET_DEBUG_INFO);
                        }
                        else if (!resolved && !unresolved) {
                            holder.createErrorAnnotation(expression, "[DEBUG] Reference is not resolved to anything, but is not marked unresolved").setTextAttributes(JetHighlighter.JET_DEBUG_INFO);
                        }
                    }

                    @Override
                    public void visitJetElement(JetElement element) {
                        element.acceptChildren(this);
                    }
                });
            }
            catch (ProcessCanceledException e) {
                throw e;
            }
            catch (Throwable e) {
                // TODO
                holder.createErrorAnnotation(element, e.getClass().getCanonicalName() + ": " + e.getMessage());
                e.printStackTrace();
            }
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419117400553/fstmerge_var2_9015425483985253430

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_5d926_4b894/rev_5d926-4b894/idea/src/org/jetbrains/jet/plugin/annotations/DebugInfoAnnotator.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419117400569/fstmerge_var1_7194001008155025793
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419117400569/fstmerge_base_738546677766411201
@Override
    public void annotate(@NotNull PsiElement element, @NotNull final AnnotationHolder holder) {
        if (element instanceof JetFile) {
            JetFile file = (JetFile) element;

            try {
                final BindingContext bindingContext = WholeProjectAnalyzerFacade.analyzeProjectWithCacheOnAFile(file);

                if (errorReportingEnabled) {
                    Collection<Diagnostic> diagnostics = Sets.newLinkedHashSet(bindingContext.getDiagnostics());
                    Set<PsiElement> redeclarations = Sets.newHashSet();
                    for (Diagnostic diagnostic : diagnostics) {

                        // This is needed because we have the same context for all files
                        if (diagnostic.getPsiFile() != file) continue;

                        registerDiagnosticAnnotations(diagnostic, redeclarations, holder);
                    }
                }

                highlightBackingFields(holder, file, bindingContext);

                file.acceptChildren(new JetVisitorVoid() {
                    @Override
                    public void visitSimpleNameExpression(@NotNull JetSimpleNameExpression expression) {
                        DeclarationDescriptor target = bindingContext.get(REFERENCE_TARGET, expression);
                        if (target instanceof ValueParameterDescriptor) {
                            ValueParameterDescriptor parameterDescriptor = (ValueParameterDescriptor) target;
                            if (bindingContext.get(AUTO_CREATED_IT, parameterDescriptor)) {
                                holder.createInfoAnnotation(expression, "Automatically declared based on the expected type").setTextAttributes(JetHighlighter.JET_AUTOCREATED_IT);
                            }
                        }

                        markVariableAsWrappedIfNeeded(expression.getNode(), target);
                        super.visitSimpleNameExpression(expression);
                    }

                    private void markVariableAsWrappedIfNeeded(@NotNull ASTNode node, DeclarationDescriptor target) {
                        if (target instanceof VariableDescriptor) {
                            VariableDescriptor variableDescriptor = (VariableDescriptor) target;
                            if (bindingContext.get(MUST_BE_WRAPPED_IN_A_REF, variableDescriptor)) {
                                holder.createInfoAnnotation(node, "Wrapped into a ref-object to be modifier when captured in a closure").setTextAttributes(JetHighlighter.JET_WRAPPED_INTO_REF);
                            }

                        }
                    }

                    @Override
                    public void visitProperty(@NotNull JetProperty property) {
                        DeclarationDescriptor declarationDescriptor = bindingContext.get(DECLARATION_TO_DESCRIPTOR, property);
                        PsiElement nameIdentifier = property.getNameIdentifier();
                        if (nameIdentifier != null) {
                            markVariableAsWrappedIfNeeded(nameIdentifier.getNode(), declarationDescriptor);
                        }
                        super.visitProperty(property);
                    }

                    @Override
                    public void visitExpression(@NotNull JetExpression expression) {
                        JetType autoCast = bindingContext.get(AUTOCAST, expression);
                        if (autoCast != null) {
                            holder.createInfoAnnotation(expression, "Automatically cast to " + autoCast).setTextAttributes(JetHighlighter.JET_AUTO_CAST_EXPRESSION);
                        }
                        expression.acceptChildren(this);
                    }

                    @Override
                    public void visitJetElement(@NotNull JetElement element) {
                        element.acceptChildren(this);
                    }
                });
            }
            catch (ProcessCanceledException e) {
                throw e;
            }
            catch (AssertionError e) {
                // For failing tests and to notify about idea internal error in -ea mode
                holder.createErrorAnnotation(element, e.getClass().getCanonicalName() + ": " + e.getMessage());
                throw e;
            }
            catch (Throwable e) {
                // TODO
                holder.createErrorAnnotation(element, e.getClass().getCanonicalName() + ": " + e.getMessage());
                e.printStackTrace();
            }
        }
    }
=======
@Override
    public void annotate(@NotNull PsiElement element, @NotNull final AnnotationHolder holder) {
        if (element instanceof JetFile) {
            JetFile file = (JetFile) element;

            try {
                final BindingContext bindingContext = WholeProjectAnalyzerFacade.analyzeProjectWithCacheOnAFile(file)
                        .getBindingContext();

                if (errorReportingEnabled) {
                    Collection<Diagnostic> diagnostics = Sets.newLinkedHashSet(bindingContext.getDiagnostics());
                    Set<PsiElement> redeclarations = Sets.newHashSet();
                    for (Diagnostic diagnostic : diagnostics) {

                        // This is needed because we have the same context for all files
                        if (diagnostic.getPsiFile() != file) continue;

                        registerDiagnosticAnnotations(diagnostic, redeclarations, holder);
                    }
                }

                highlightBackingFields(holder, file, bindingContext);

                file.acceptChildren(new JetVisitorVoid() {
                    @Override
                    public void visitSimpleNameExpression(@NotNull JetSimpleNameExpression expression) {
                        DeclarationDescriptor target = bindingContext.get(REFERENCE_TARGET, expression);
                        if (target instanceof ValueParameterDescriptor) {
                            ValueParameterDescriptor parameterDescriptor = (ValueParameterDescriptor) target;
                            if (bindingContext.get(AUTO_CREATED_IT, parameterDescriptor)) {
                                holder.createInfoAnnotation(expression, "Automatically declared based on the expected type").setTextAttributes(JetHighlighter.JET_AUTOCREATED_IT);
                            }
                        }

                        markVariableAsWrappedIfNeeded(expression.getNode(), target);
                        super.visitSimpleNameExpression(expression);
                    }

                    private void markVariableAsWrappedIfNeeded(@NotNull ASTNode node, DeclarationDescriptor target) {
                        if (target instanceof VariableDescriptor) {
                            VariableDescriptor variableDescriptor = (VariableDescriptor) target;
                            if (bindingContext.get(MUST_BE_WRAPPED_IN_A_REF, variableDescriptor)) {
                                holder.createInfoAnnotation(node, "Wrapped into a ref-object to be modifier when captured in a closure").setTextAttributes(JetHighlighter.JET_WRAPPED_INTO_REF);
                            }

                        }
                    }

                    @Override
                    public void visitProperty(@NotNull JetProperty property) {
                        DeclarationDescriptor declarationDescriptor = bindingContext.get(DECLARATION_TO_DESCRIPTOR, property);
                        PsiElement nameIdentifier = property.getNameIdentifier();
                        if (nameIdentifier != null) {
                            markVariableAsWrappedIfNeeded(nameIdentifier.getNode(), declarationDescriptor);
                        }
                        super.visitProperty(property);
                    }

                    @Override
                    public void visitExpression(@NotNull JetExpression expression) {
                        JetType autoCast = bindingContext.get(AUTOCAST, expression);
                        if (autoCast != null) {
                            holder.createInfoAnnotation(expression, "Automatically cast to " + autoCast).setTextAttributes(JetHighlighter.JET_AUTO_CAST_EXPRESSION);
                        }
                        expression.acceptChildren(this);
                    }

                    @Override
                    public void visitJetElement(@NotNull JetElement element) {
                        element.acceptChildren(this);
                    }
                });
            }
            catch (ProcessCanceledException e) {
                throw e;
            }
            catch (AssertionError e) {
                // For failing tests and to notify about idea internal error in -ea mode
                holder.createErrorAnnotation(element, e.getClass().getCanonicalName() + ": " + e.getMessage());
                throw e;
            }
            catch (Throwable e) {
                // TODO
                holder.createErrorAnnotation(element, e.getClass().getCanonicalName() + ": " + e.getMessage());
                e.printStackTrace();
            }
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419117400569/fstmerge_var2_2973606202320411498

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_5d926_4b894/rev_5d926-4b894/idea/src/org/jetbrains/jet/plugin/annotations/JetPsiChecker.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419117400575/fstmerge_var1_8808261409677607353
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419117400575/fstmerge_base_8172178920151034535
private void registerDiagnosticAnnotations(
            @NotNull Diagnostic diagnostic,
            @NotNull Set<PsiElement> redeclarations,
            @NotNull final AnnotationHolder holder
    ) {
        List<TextRange> textRanges = diagnostic.getTextRanges();
        if (diagnostic.getSeverity() == Severity.ERROR) {
            if (diagnostic.getFactory() == Errors.UNRESOLVED_IDE_TEMPLATE) {
                return;
            }
            if (diagnostic instanceof UnresolvedReferenceDiagnostic) {
                UnresolvedReferenceDiagnostic unresolvedReferenceDiagnostic = (UnresolvedReferenceDiagnostic) diagnostic;
                JetReferenceExpression referenceExpression = unresolvedReferenceDiagnostic.getPsiElement();
                PsiReference reference = referenceExpression.getReference();
                if (reference instanceof MultiRangeReference) {
                    MultiRangeReference mrr = (MultiRangeReference) reference;
                    for (TextRange range : mrr.getRanges()) {
                        Annotation annotation = holder.createErrorAnnotation(
                                range.shiftRight(referenceExpression.getTextOffset()),
                                diagnostic.getMessage());

                        registerQuickFix(annotation, diagnostic);

                        annotation.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);
                    }
                }
                else {
                    for (TextRange textRange : textRanges) {
                        Annotation annotation = holder.createErrorAnnotation(textRange, diagnostic.getMessage());
                        registerQuickFix(annotation, diagnostic);
                        annotation.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);
                    }
                }

                return;
            }

            if (diagnostic instanceof RedeclarationDiagnostic) {
                RedeclarationDiagnostic redeclarationDiagnostic = (RedeclarationDiagnostic) diagnostic;
                registerQuickFix(markRedeclaration(redeclarations, redeclarationDiagnostic, holder), diagnostic);
                return;
            }

            // Generic annotation
            for (TextRange textRange : textRanges) {
                Annotation errorAnnotation = holder.createErrorAnnotation(textRange, getMessage(diagnostic));
                registerQuickFix(errorAnnotation, diagnostic);
            }
        }
        else if (diagnostic.getSeverity() == Severity.WARNING) {
            for (TextRange textRange : textRanges) {
                Annotation annotation = holder.createWarningAnnotation(textRange, getMessage(diagnostic));
                registerQuickFix(annotation, diagnostic);

                if (diagnostic.getFactory() instanceof UnusedElementDiagnosticFactory) {
                    annotation.setHighlightType(ProblemHighlightType.LIKE_UNUSED_SYMBOL);
                }
            }
        }
    }
=======
private void registerDiagnosticAnnotations(
            @NotNull Diagnostic diagnostic,
            @NotNull Set<PsiElement> redeclarations,
            @NotNull final AnnotationHolder holder
    ) {
        List<TextRange> textRanges = diagnostic.getTextRanges();
        if (diagnostic.getSeverity() == Severity.ERROR) {
            if (diagnostic.getFactory() == Errors.UNRESOLVED_IDE_TEMPLATE) {
                return;
            }
            if (diagnostic instanceof UnresolvedReferenceDiagnostic) {
                UnresolvedReferenceDiagnostic unresolvedReferenceDiagnostic = (UnresolvedReferenceDiagnostic) diagnostic;
                JetReferenceExpression referenceExpression = unresolvedReferenceDiagnostic.getPsiElement();
                PsiReference reference = referenceExpression.getReference();
                if (reference instanceof MultiRangeReference) {
                    MultiRangeReference mrr = (MultiRangeReference) reference;
                    for (TextRange range : mrr.getRanges()) {
                        Annotation annotation = holder.createErrorAnnotation(
                                range.shiftRight(referenceExpression.getTextOffset()),
                                diagnostic.getMessage());

                        registerQuickFix(annotation, diagnostic);

                        annotation.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);
                    }
                }
                else {
                    for (TextRange textRange : textRanges) {
                        Annotation annotation = holder.createErrorAnnotation(textRange, diagnostic.getMessage());
                        registerQuickFix(annotation, diagnostic);
                        annotation.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);
                    }
                }

                return;
            }

            if (diagnostic instanceof RedeclarationDiagnostic) {
                RedeclarationDiagnostic redeclarationDiagnostic = (RedeclarationDiagnostic) diagnostic;
                registerQuickFix(markRedeclaration(redeclarations, redeclarationDiagnostic, holder), diagnostic);
                return;
            }

            // Generic annotation
            for (TextRange textRange : textRanges) {
                Annotation errorAnnotation = holder.createErrorAnnotation(textRange, getMessage(diagnostic));
                registerQuickFix(errorAnnotation, diagnostic);
                if (diagnostic.getFactory() == Errors.INVISIBLE_MEMBER) {
                    errorAnnotation.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);
                }
            }
        }
        else if (diagnostic.getSeverity() == Severity.WARNING) {
            for (TextRange textRange : textRanges) {
                Annotation annotation = holder.createWarningAnnotation(textRange, getMessage(diagnostic));
                registerQuickFix(annotation, diagnostic);

                if (diagnostic.getFactory() instanceof UnusedElementDiagnosticFactory) {
                    annotation.setHighlightType(ProblemHighlightType.LIKE_UNUSED_SYMBOL);
                }
            }
        }
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419117400575/fstmerge_var2_4482259180152689000

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_5d926_4b894/rev_5d926-4b894/idea/src/org/jetbrains/jet/plugin/annotations/JetPsiChecker.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419117400603/fstmerge_var1_6266856227412783039
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419117400603/fstmerge_base_7076098180967886756
@Override
    public LineMarkerInfo getLineMarkerInfo(PsiElement element) {
        JetFile file = (JetFile) element.getContainingFile();
        if (file == null) return null;

        final BindingContext bindingContext = WholeProjectAnalyzerFacade.analyzeProjectWithCacheOnAFile(file);

        if (element instanceof JetClass) {
            JetClass jetClass = (JetClass) element;
            ClassDescriptor classDescriptor = bindingContext.get(BindingContext.CLASS, jetClass);
            String text = classDescriptor == null ? "<i>Unresolved</i>" : DescriptorRenderer.HTML.render(classDescriptor);
            return createLineMarkerInfo(jetClass, text);
        }

        if (element instanceof JetProperty) {
            JetProperty jetProperty = (JetProperty) element;
            final VariableDescriptor variableDescriptor = bindingContext.get(BindingContext.VARIABLE, jetProperty);
            if (variableDescriptor instanceof PropertyDescriptor) {
                return createLineMarkerInfo(element, DescriptorRenderer.HTML.render(variableDescriptor));
            }
        }

        if (element instanceof JetNamedFunction) {
            JetNamedFunction jetFunction = (JetNamedFunction) element;

            final SimpleFunctionDescriptor functionDescriptor = bindingContext.get(BindingContext.FUNCTION, jetFunction);
            if (functionDescriptor == null) return null;
            final Set<? extends FunctionDescriptor> overriddenFunctions = functionDescriptor.getOverriddenDescriptors();
            Icon icon = isMember(functionDescriptor) ? (overriddenFunctions.isEmpty() ? PlatformIcons.METHOD_ICON : OVERRIDING_FUNCTION) : PlatformIcons.FUNCTION_ICON;
            return new LineMarkerInfo<JetNamedFunction>(
                    jetFunction, jetFunction.getTextOffset(), icon, Pass.UPDATE_ALL,
                    new Function<JetNamedFunction, String>() {
                        @Override
                        public String fun(JetNamedFunction jetFunction) {
                            StringBuilder builder = new StringBuilder();
                            builder.append(DescriptorRenderer.HTML.render(functionDescriptor));
                            int overrideCount = overriddenFunctions.size();
                            if (overrideCount >= 1) {
                                builder.append(" overrides ").append(DescriptorRenderer.HTML.render(overriddenFunctions.iterator().next()));
                            }
                            if (overrideCount > 1) {
                                int count = overrideCount - 1;
                                builder.append(" and ").append(count).append(" other function");
                                if (count > 1) {
                                    builder.append("s");
                                }
                            }

                            return builder.toString();
                        }
                    },
                    new GutterIconNavigationHandler<JetNamedFunction>() {
                        @Override
                        public void navigate(MouseEvent event, JetNamedFunction elt) {
                            if (overriddenFunctions.isEmpty()) return;
                            final List<PsiElement> list = Lists.newArrayList();
                            for (FunctionDescriptor overriddenFunction : overriddenFunctions) {
                                PsiElement declarationPsiElement = bindingContext.get(BindingContext.DESCRIPTOR_TO_DECLARATION, overriddenFunction);
                                list.add(declarationPsiElement);
                            }
                            if (list.isEmpty()) {
                                String myEmptyText = "empty text";
                                final JComponent renderer = HintUtil.createErrorLabel(myEmptyText);
                                final JBPopup popup = JBPopupFactory.getInstance().createComponentPopupBuilder(renderer, renderer).createPopup();
                                if (event != null) {
                                    popup.show(new RelativePoint(event));
                                }
                                return;
                            }
                            if (list.size() == 1) {
                                PsiNavigateUtil.navigate(list.iterator().next());
                            }
                            else {
                                final JBPopup popup = NavigationUtil.getPsiElementPopup(PsiUtilBase.toPsiElementArray(list), new DefaultPsiElementCellRenderer() {
                                            @Override
                                            public String getElementText(PsiElement element) {
                                                if (element instanceof JetNamedFunction) {
                                                    JetNamedFunction function = (JetNamedFunction) element;
                                                    return DescriptorRenderer.HTML.render(bindingContext.get(BindingContext.FUNCTION, function));
                                                }
                                                return super.getElementText(element);
                                            }
                                        }, DescriptorRenderer.HTML.render(functionDescriptor));
                                if (event != null) {
                                    popup.show(new RelativePoint(event));
                                }
                            }
                        }
                    }
            );
        }

        if (element instanceof JetNamespaceHeader) {
            JetNamespaceHeader header = (JetNamespaceHeader) element;
            if (header.getNameIdentifier() != null) {
                return createLineMarkerInfo(header,
                        DescriptorRenderer.HTML.render(bindingContext.get(BindingContext.NAMESPACE, file)));
            }
        }

        if (element instanceof JetObjectDeclaration && !(element.getParent() instanceof JetExpression)) {
            JetObjectDeclaration jetObjectDeclaration = (JetObjectDeclaration) element;

            return new LineMarkerInfo<JetObjectDeclaration>(
                    jetObjectDeclaration, jetObjectDeclaration.getTextOffset(), PlatformIcons.ANONYMOUS_CLASS_ICON, Pass.UPDATE_ALL,
                    new Function<JetObjectDeclaration, String>() {
                        @Override
                        public String fun(JetObjectDeclaration jetObjectDeclaration) {
                            ClassDescriptor classDescriptor = bindingContext.get(BindingContext.CLASS, jetObjectDeclaration);
                            if (classDescriptor != null) {
                                return DescriptorRenderer.HTML.renderAsObject(classDescriptor);
                            }
                            return "&lt;none>";
                        }
                    },
                    new GutterIconNavigationHandler<JetObjectDeclaration>() {
                        @Override
                        public void navigate(MouseEvent e, JetObjectDeclaration elt) {
                        }
                    }
            );
        }

        return null;
    }
=======
@Override
    public LineMarkerInfo getLineMarkerInfo(PsiElement element) {
        JetFile file = (JetFile) element.getContainingFile();
        if (file == null) return null;

        final BindingContext bindingContext = WholeProjectAnalyzerFacade.analyzeProjectWithCacheOnAFile(file)
                .getBindingContext();

        if (element instanceof JetClass) {
            JetClass jetClass = (JetClass) element;
            ClassDescriptor classDescriptor = bindingContext.get(BindingContext.CLASS, jetClass);
            String text = classDescriptor == null ? "<i>Unresolved</i>" : DescriptorRenderer.HTML.render(classDescriptor);
            return createLineMarkerInfo(jetClass, text);
        }

        if (element instanceof JetProperty) {
            JetProperty jetProperty = (JetProperty) element;
            final VariableDescriptor variableDescriptor = bindingContext.get(BindingContext.VARIABLE, jetProperty);
            if (variableDescriptor instanceof PropertyDescriptor) {
                return createLineMarkerInfo(element, DescriptorRenderer.HTML.render(variableDescriptor));
            }
        }

        if (element instanceof JetNamedFunction) {
            JetNamedFunction jetFunction = (JetNamedFunction) element;

            final SimpleFunctionDescriptor functionDescriptor = bindingContext.get(BindingContext.FUNCTION, jetFunction);
            if (functionDescriptor == null) return null;
            final Set<? extends FunctionDescriptor> overriddenFunctions = functionDescriptor.getOverriddenDescriptors();
            Icon icon = isMember(functionDescriptor) ? (overriddenFunctions.isEmpty() ? PlatformIcons.METHOD_ICON : OVERRIDING_FUNCTION) : PlatformIcons.FUNCTION_ICON;
            return new LineMarkerInfo<JetNamedFunction>(
                    jetFunction, jetFunction.getTextOffset(), icon, Pass.UPDATE_ALL,
                    new Function<JetNamedFunction, String>() {
                        @Override
                        public String fun(JetNamedFunction jetFunction) {
                            StringBuilder builder = new StringBuilder();
                            builder.append(DescriptorRenderer.HTML.render(functionDescriptor));
                            int overrideCount = overriddenFunctions.size();
                            if (overrideCount >= 1) {
                                builder.append(" overrides ").append(DescriptorRenderer.HTML.render(overriddenFunctions.iterator().next()));
                            }
                            if (overrideCount > 1) {
                                int count = overrideCount - 1;
                                builder.append(" and ").append(count).append(" other function");
                                if (count > 1) {
                                    builder.append("s");
                                }
                            }

                            return builder.toString();
                        }
                    },
                    new GutterIconNavigationHandler<JetNamedFunction>() {
                        @Override
                        public void navigate(MouseEvent event, JetNamedFunction elt) {
                            if (overriddenFunctions.isEmpty()) return;
                            final List<PsiElement> list = Lists.newArrayList();
                            for (FunctionDescriptor overriddenFunction : overriddenFunctions) {
                                PsiElement declarationPsiElement = bindingContext.get(BindingContext.DESCRIPTOR_TO_DECLARATION, overriddenFunction);
                                list.add(declarationPsiElement);
                            }
                            if (list.isEmpty()) {
                                String myEmptyText = "empty text";
                                final JComponent renderer = HintUtil.createErrorLabel(myEmptyText);
                                final JBPopup popup = JBPopupFactory.getInstance().createComponentPopupBuilder(renderer, renderer).createPopup();
                                if (event != null) {
                                    popup.show(new RelativePoint(event));
                                }
                                return;
                            }
                            if (list.size() == 1) {
                                PsiNavigateUtil.navigate(list.iterator().next());
                            }
                            else {
                                final JBPopup popup = NavigationUtil.getPsiElementPopup(PsiUtilBase.toPsiElementArray(list), new DefaultPsiElementCellRenderer() {
                                            @Override
                                            public String getElementText(PsiElement element) {
                                                if (element instanceof JetNamedFunction) {
                                                    JetNamedFunction function = (JetNamedFunction) element;
                                                    return DescriptorRenderer.HTML.render(bindingContext.get(BindingContext.FUNCTION, function));
                                                }
                                                return super.getElementText(element);
                                            }
                                        }, DescriptorRenderer.HTML.render(functionDescriptor));
                                if (event != null) {
                                    popup.show(new RelativePoint(event));
                                }
                            }
                        }
                    }
            );
        }

        if (element instanceof JetNamespaceHeader) {
            JetNamespaceHeader header = (JetNamespaceHeader) element;
            if (header.getNameIdentifier() != null) {
                return createLineMarkerInfo(header,
                        DescriptorRenderer.HTML.render(bindingContext.get(BindingContext.NAMESPACE, file)));
            }
        }

        if (element instanceof JetObjectDeclaration && !(element.getParent() instanceof JetExpression)) {
            JetObjectDeclaration jetObjectDeclaration = (JetObjectDeclaration) element;

            return new LineMarkerInfo<JetObjectDeclaration>(
                    jetObjectDeclaration, jetObjectDeclaration.getTextOffset(), PlatformIcons.ANONYMOUS_CLASS_ICON, Pass.UPDATE_ALL,
                    new Function<JetObjectDeclaration, String>() {
                        @Override
                        public String fun(JetObjectDeclaration jetObjectDeclaration) {
                            ClassDescriptor classDescriptor = bindingContext.get(BindingContext.CLASS, jetObjectDeclaration);
                            if (classDescriptor != null) {
                                return DescriptorRenderer.HTML.renderAsObject(classDescriptor);
                            }
                            return "&lt;none>";
                        }
                    },
                    new GutterIconNavigationHandler<JetObjectDeclaration>() {
                        @Override
                        public void navigate(MouseEvent e, JetObjectDeclaration elt) {
                        }
                    }
            );
        }

        return null;
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419117400603/fstmerge_var2_2770870301669793621

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_5d926_4b894/rev_5d926-4b894/idea/src/org/jetbrains/jet/plugin/annotations/JetLineMarkerProvider.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_23e36_a0d8a/rev_23e36-a0d8a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d4cce_16c69/rev_d4cce-16c69.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_652be_ff1cd/rev_652be-ff1cd.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@NotNull
    public static AnalyzeExhaust analyzeProjectWithCacheOnAFile(@NotNull JetFile file) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122202778/fstmerge_var1_7822848510629810057
        return analyzeFileWithCache(file, JetFilesProvider.getInstance(file.getProject()).sampleToAllFilesInModule());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122202778/fstmerge_base_6411153400009834242
        return AnalyzerFacadeForJVM.analyzeFileWithCache(file, JetFilesProvider.getInstance(file.getProject()).sampleToAllFilesInModule());
=======
        return AnalyzerFacadeForJVM.analyzeFileWithCache(file, JetFilesProvider.getInstance(file.getProject()).sampleToAllFilesInModule(),
                CompilerSpecialMode.REGULAR, CompilerDependencies.compilerDependenciesForProduction(CompilerSpecialMode.REGULAR));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122202778/fstmerge_var2_1463697248895830500
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_652be_ff1cd/rev_652be-ff1cd/idea/src/org/jetbrains/jet/plugin/project/WholeProjectAnalyzerFacade.java
Conflict type: LineBasedMCFd
Conflict body: 
@NotNull
    public static AnalyzeExhaust analyzeProjectWithCache(@NotNull Project project, @NotNull GlobalSearchScope scope) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122202783/fstmerge_var1_5050825310319887475
        return AnalyzerFacadeWithCache.analyzeProjectWithCache(project, JetFilesProvider.getInstance(project).allInScope(scope));
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122202783/fstmerge_base_1551150031793048116
        return AnalyzerFacadeForJVM.analyzeProjectWithCache(project, JetFilesProvider.getInstance(project).allInScope(scope));
=======
        return AnalyzerFacadeForJVM.analyzeProjectWithCache(project, JetFilesProvider.getInstance(project).allInScope(scope),
                CompilerSpecialMode.REGULAR, CompilerDependencies.compilerDependenciesForProduction(CompilerSpecialMode.REGULAR));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122202783/fstmerge_var2_7273154815765760345
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_652be_ff1cd/rev_652be-ff1cd/idea/src/org/jetbrains/jet/plugin/project/WholeProjectAnalyzerFacade.java
Conflict type: LineBasedMCFd
Conflict body: 
public static String[] suggestNames(JetExpression expression, JetNameValidator validator) {
        ArrayList<String> result = new ArrayList<String>();

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122202837/fstmerge_var1_2709486192480233152
        BindingContext bindingContext = AnalyzeSingleFileUtil.getContextForSingleFile((JetFile)expression.getContainingFile());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122202837/fstmerge_base_2975663842195325105
        BindingContext bindingContext = AnalyzerFacadeForJVM.analyzeFileWithCache((JetFile) expression.getContainingFile(),
                AnalyzerFacadeForJVM.SINGLE_DECLARATION_PROVIDER)
                    .getBindingContext();
=======
        BindingContext bindingContext = AnalyzerFacadeForJVM.analyzeFileWithCache((JetFile) expression.getContainingFile(),
                AnalyzerFacadeForJVM.SINGLE_DECLARATION_PROVIDER,
                CompilerSpecialMode.REGULAR, CompilerDependencies.compilerDependenciesForProduction(CompilerSpecialMode.REGULAR))
                    .getBindingContext();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122202837/fstmerge_var2_9055317396543470255
        JetType jetType = bindingContext.get(BindingContext.EXPRESSION_TYPE, expression);
        if (jetType != null) {
            addNamesForType(result, jetType, validator);
        }
        addNamesForExpression(result, expression, validator);

        if (result.isEmpty()) addName(result, "value", validator);
        return ArrayUtil.toStringArray(result);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_652be_ff1cd/rev_652be-ff1cd/idea/src/org/jetbrains/jet/plugin/refactoring/JetNameSuggester.java
Conflict type: LineBasedMCFd
Conflict body: 
private static void addCamelNames(ArrayList<String> result, String name, JetNameValidator validator) {
        if (name == "") return;
        String s = deleteNonLetterFromString(name);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122202850/fstmerge_var1_8940291807696334085
        if (s.startsWith("get") || s.startsWith("set")) {
            s = s.substring(0, 3);
        }
        else if (s.startsWith("is")) s = s.substring(0, 2);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122202850/fstmerge_base_7226144784884986270
        if (s.startsWith("get") || s.startsWith("set")) s = s.substring(0, 3);
        else if (s.startsWith("is")) s = s.substring(0, 2);
=======
        if (s.startsWith("get") || s.startsWith("set")) s = s.substring(3);
        else if (s.startsWith("is")) s = s.substring(2);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122202850/fstmerge_var2_7796913437478673575
        for (int i = 0; i < s.length(); ++i) {
            if (i == 0) {
                addName(result, StringUtil.decapitalize(s), validator);
            }
            else if (s.charAt(i) >= 'A' && s.charAt(i) <= 'Z') {
                addName(result, StringUtil.decapitalize(s.substring(i)), validator);
            }
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_652be_ff1cd/rev_652be-ff1cd/idea/src/org/jetbrains/jet/plugin/refactoring/JetNameSuggester.java
Conflict type: LineBasedMCFd
Conflict body: 
private static void addNamesForExpression(ArrayList<String> result, JetExpression expression, JetNameValidator validator) {
        if (expression instanceof JetQualifiedExpression) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122202858/fstmerge_var1_5138884234366078906
            JetQualifiedExpression qualifiedExpression = (JetQualifiedExpression)expression;
            addNamesForExpression(result, qualifiedExpression.getSelectorExpression(), validator);
        }
        else if (expression instanceof JetSimpleNameExpression) {
            JetSimpleNameExpression reference = (JetSimpleNameExpression)expression;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122202858/fstmerge_base_1969571245959724124
            JetQualifiedExpression qualifiedExpression = (JetQualifiedExpression) expression;
            addNamesForExpression(result, qualifiedExpression.getSelectorExpression(), validator);
        } else if (expression instanceof JetSimpleNameExpression) {
            JetSimpleNameExpression reference = (JetSimpleNameExpression) expression;
=======
            JetQualifiedExpression qualifiedExpression = (JetQualifiedExpression) expression;
            JetExpression selectorExpression = qualifiedExpression.getSelectorExpression();
            addNamesForExpression(result, selectorExpression, validator);
            if (selectorExpression != null && selectorExpression instanceof JetCallExpression) {
                JetExpression calleeExpression = ((JetCallExpression)selectorExpression).getCalleeExpression();
                if (calleeExpression != null && calleeExpression instanceof JetSimpleNameExpression) {
                    String name = ((JetSimpleNameExpression)calleeExpression).getReferencedName();
                    if (name != null && name.equals("sure")) {
                        addNamesForExpression(result, qualifiedExpression.getReceiverExpression(), validator);
                    }
                }
            }
        } else if (expression instanceof JetSimpleNameExpression) {
            JetSimpleNameExpression reference = (JetSimpleNameExpression) expression;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122202858/fstmerge_var2_5823497649775355341
            String referenceName = reference.getReferencedName();
            if (referenceName == null) return;
            if (referenceName.equals(referenceName.toUpperCase())) {
                addName(result, referenceName, validator);
            }
            else {
                addCamelNames(result, referenceName, validator);
            }
        }
        else if (expression instanceof JetCallExpression) {
            JetCallExpression call = (JetCallExpression)expression;
            addNamesForExpression(result, call.getCalleeExpression(), validator);
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_652be_ff1cd/rev_652be-ff1cd/idea/src/org/jetbrains/jet/plugin/refactoring/JetNameSuggester.java
Conflict type: LineBasedMCFd
Conflict body: 
private static void smartSelectExpression(@NotNull Editor editor, @NotNull PsiFile file, int offset,
                                              @NotNull final SelectExpressionCallback callback)
        throws IntroduceRefactoringException {
        if (offset < 0) throw new IntroduceRefactoringException(JetRefactoringBundle.message("cannot.refactor.not.expression"));
        PsiElement element = file.findElementAt(offset);
        if (element == null) throw new IntroduceRefactoringException(JetRefactoringBundle.message("cannot.refactor.not.expression"));
        if (element instanceof PsiWhiteSpace) {
            smartSelectExpression(editor, file, offset - 1, callback);
            return;
        }
        ArrayList<JetExpression> expressions = new ArrayList<JetExpression>();
        while (element != null && !(element instanceof JetBlockExpression) && !(element instanceof JetNamedFunction)
               && !(element instanceof JetClassBody) && !(element instanceof JetSecondaryConstructor)) {
            if (element instanceof JetExpression && !(element instanceof JetStatementExpression)) {
                boolean addExpression = true;
                if (element.getParent() instanceof JetQualifiedExpression) {
                    JetQualifiedExpression qualifiedExpression = (JetQualifiedExpression)element.getParent();
                    if (qualifiedExpression.getReceiverExpression() != element) {
                        addExpression = false;
                    }
                }
                else if (element.getParent() instanceof JetCallElement) {
                    addExpression = false;
                }
                else if (element.getParent() instanceof JetOperationExpression) {
                    JetOperationExpression operationExpression = (JetOperationExpression)element.getParent();
                    if (operationExpression.getOperationReference() == element) {
                        addExpression = false;
                    }
                }
                if (addExpression) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122202880/fstmerge_var1_8533222762264152865
                    JetExpression expression = (JetExpression)element;
                    BindingContext bindingContext = getContextForSingleFile((JetFile)expression.getContainingFile());
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122202880/fstmerge_base_8694443630138881628
                    JetExpression expression = (JetExpression) element;
                    BindingContext bindingContext = AnalyzerFacadeForJVM.analyzeFileWithCache((JetFile) expression.getContainingFile(),
                            AnalyzerFacadeForJVM.SINGLE_DECLARATION_PROVIDER)
                                .getBindingContext();
=======
                    JetExpression expression = (JetExpression) element;
                    BindingContext bindingContext = AnalyzerFacadeForJVM.analyzeFileWithCache((JetFile) expression.getContainingFile(),
                            AnalyzerFacadeForJVM.SINGLE_DECLARATION_PROVIDER, CompilerSpecialMode.REGULAR,
                            CompilerDependencies.compilerDependenciesForProduction(CompilerSpecialMode.REGULAR))
                                .getBindingContext();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122202880/fstmerge_var2_4760988652054957957
                    JetType expressionType = bindingContext.get(BindingContext.EXPRESSION_TYPE, expression);
                    if (expressionType == null || !(expressionType instanceof NamespaceType) &&
                                                  !JetTypeChecker.INSTANCE.equalTypes(JetStandardLibrary.
                                                      getInstance().getTuple0Type(), expressionType)) {
                        expressions.add(expression);
                    }
                }
            }
            element = element.getParent();
        }
        if (expressions.size() == 0) {
            throw new IntroduceRefactoringException(JetRefactoringBundle.message("cannot.refactor.not.expression"));
        }

        final DefaultListModel model = new DefaultListModel();
        for (JetExpression expression : expressions) {
            model.addElement(expression);
        }

        final ScopeHighlighter highlighter = new ScopeHighlighter(editor);

        final JList list = new JBList(model);

        list.setCellRenderer(new DefaultListCellRenderer() {
            @Override
            public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
                Component rendererComponent = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
                StringBuilder buffer = new StringBuilder();
                JetExpression element = (JetExpression)value;
                if (element.isValid()) {
                    setText(getExpressionShortText(element));
                }
                return rendererComponent;
            }
        });

        list.addListSelectionListener(new ListSelectionListener() {
            @Override
            public void valueChanged(ListSelectionEvent e) {
                highlighter.dropHighlight();
                int selectedIndex = list.getSelectedIndex();
                if (selectedIndex < 0) return;
                JetExpression expression = (JetExpression)model.get(selectedIndex);
                ArrayList<PsiElement> toExtract = new ArrayList<PsiElement>();
                toExtract.add(expression);
                highlighter.highlight(expression, toExtract);
            }
        });

        JBPopupFactory.getInstance().createListPopupBuilder(list).
            setTitle(JetRefactoringBundle.message("expressions.title")).setMovable(false).setResizable(false).
            setRequestFocus(true).setItemChoosenCallback(new Runnable() {
            @Override
            public void run() {
                callback.run((JetExpression)list.getSelectedValue());
            }
        }).addListener(new JBPopupAdapter() {
            @Override
            public void onClosed(LightweightWindowEvent event) {
                highlighter.dropHighlight();
            }
        }).createPopup().showInBestPositionFor(editor);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_652be_ff1cd/rev_652be-ff1cd/idea/src/org/jetbrains/jet/plugin/refactoring/JetRefactoringUtil.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public void updateUI(Object descriptor, ParameterInfoUIContext context) {
        //todo: when we will have ability to pass Array as vararg, implement such feature here too?
        if (context == null || context.getParameterOwner() == null || !context.getParameterOwner().isValid()) {
            return;
        }
        PsiElement parameterOwner = context.getParameterOwner();
        if (parameterOwner instanceof JetValueArgumentList) {
            JetValueArgumentList argumentList = (JetValueArgumentList)parameterOwner;
            if (descriptor instanceof FunctionDescriptor) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122203057/fstmerge_var1_6631719375292236233
                JetFile file = (JetFile)argumentList.getContainingFile();
                BindingContext bindingContext = AnalyzeSingleFileUtil.getContextForSingleFile(file);
                FunctionDescriptor functionDescriptor = (FunctionDescriptor)descriptor;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122203057/fstmerge_base_7421711026692386996
                JetFile file = (JetFile) argumentList.getContainingFile();
                BindingContext bindingContext =
                        AnalyzerFacadeForJVM.analyzeFileWithCache(file, AnalyzerFacadeForJVM.SINGLE_DECLARATION_PROVIDER)
                            .getBindingContext();
                FunctionDescriptor functionDescriptor = (FunctionDescriptor) descriptor;
=======
                JetFile file = (JetFile) argumentList.getContainingFile();
                BindingContext bindingContext =
                        AnalyzerFacadeForJVM.analyzeFileWithCache(file, AnalyzerFacadeForJVM.SINGLE_DECLARATION_PROVIDER,
                                CompilerSpecialMode.REGULAR, CompilerDependencies.compilerDependenciesForProduction(CompilerSpecialMode.REGULAR))
                            .getBindingContext();
                FunctionDescriptor functionDescriptor = (FunctionDescriptor) descriptor;
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122203057/fstmerge_var2_7357895022295478208
                StringBuilder builder = new StringBuilder();
                List<ValueParameterDescriptor> valueParameters = functionDescriptor.getValueParameters();
                List<JetValueArgument> valueArguments = argumentList.getArguments();
                int currentParameterIndex = context.getCurrentParameterIndex();
                int boldStartOffset = -1;
                int boldEndOffset = -1;
                boolean isGrey = false;
                boolean isDeprecated = false; //todo: add deprecation check
                Color color = context.getDefaultParameterColor();
                PsiElement parent = argumentList.getParent();
                if (parent instanceof JetCallElement) {
                    JetCallElement callExpression = (JetCallElement)parent;
                    JetExpression calleeExpression = callExpression.getCalleeExpression();
                    JetSimpleNameExpression refExpression = null;
                    if (calleeExpression instanceof JetSimpleNameExpression) {
                        refExpression = (JetSimpleNameExpression)calleeExpression;
                    }
                    else if (calleeExpression instanceof JetConstructorCalleeExpression) {
                        JetConstructorCalleeExpression constructorCalleeExpression = (JetConstructorCalleeExpression)calleeExpression;
                        if (constructorCalleeExpression.getConstructorReferenceExpression() instanceof JetSimpleNameExpression) {
                            refExpression = (JetSimpleNameExpression)constructorCalleeExpression.getConstructorReferenceExpression();
                        }
                    }
                    if (refExpression != null) {
                        DeclarationDescriptor declarationDescriptor = bindingContext.get(BindingContext.REFERENCE_TARGET, refExpression);
                        if (declarationDescriptor != null) {
                            if (declarationDescriptor == functionDescriptor) {
                                color = GREEN_BACKGROUND;
                            }
                        }
                    }
                }

                boolean[] usedIndexes = new boolean[valueParameters.size()];
                boolean namedMode = false;
                Arrays.fill(usedIndexes, false);
                if ((currentParameterIndex >= valueParameters.size() && (valueParameters.size() > 0 ||
                                                                         currentParameterIndex > 0)) &&
                    (valueParameters.size() == 0 || valueParameters.get(valueParameters.size() - 1).getVarargElementType() == null)) {
                    isGrey = true;
                }
                if (valueParameters.size() == 0) builder.append(CodeInsightBundle.message("parameter.info.no.parameters"));
                for (int i = 0; i < valueParameters.size(); ++i) {
                    if (i != 0) builder.append(", ");
                    boolean highlightParameter =
                        i == currentParameterIndex || (!namedMode && i < currentParameterIndex &&
                                                       valueParameters.get(valueParameters.size() - 1).
                                                           getVarargElementType() != null);
                    if (highlightParameter) boldStartOffset = builder.length();
                    if (!namedMode) {
                        if (valueArguments.size() > i) {
                            JetValueArgument argument = valueArguments.get(i);
                            if (argument.isNamed()) {
                                namedMode = true;
                            }
                            else {
                                ValueParameterDescriptor param = valueParameters.get(i);
                                builder.append(renderParameter(param, false, bindingContext));
                                if (i < currentParameterIndex) {
                                    if (argument.getArgumentExpression() != null) {
                                        //check type
                                        JetType paramType = getActualParameterType(param);
                                        JetType exprType =
                                            bindingContext.get(BindingContext.EXPRESSION_TYPE, argument.getArgumentExpression());
                                        if (exprType != null && !JetTypeChecker.INSTANCE.isSubtypeOf(exprType, paramType)) isGrey = true;
                                    }
                                    else {
                                        isGrey = true;
                                    }
                                }
                                usedIndexes[i] = true;
                            }
                        }
                        else {
                            ValueParameterDescriptor param = valueParameters.get(i);
                            builder.append(renderParameter(param, false, bindingContext));
                        }
                    }
                    if (namedMode) {
                        boolean takeAnyArgument = true;
                        if (valueArguments.size() > i) {
                            JetValueArgument argument = valueArguments.get(i);
                            if (argument.isNamed()) {
                                for (int j = 0; j < valueParameters.size(); ++j) {
                                    JetSimpleNameExpression referenceExpression = argument.getArgumentName().getReferenceExpression();
                                    ValueParameterDescriptor param = valueParameters.get(j);
                                    if (referenceExpression != null && !usedIndexes[j] &&
                                        param.getName().equals(referenceExpression.getReferencedName())) {
                                        takeAnyArgument = false;
                                        usedIndexes[j] = true;
                                        builder.append(renderParameter(param, true, bindingContext));
                                        if (i < currentParameterIndex) {
                                            if (argument.getArgumentExpression() != null) {
                                                //check type
                                                JetType paramType = getActualParameterType(param);
                                                JetType exprType =
                                                    bindingContext.get(BindingContext.EXPRESSION_TYPE, argument.getArgumentExpression());
                                                if (exprType != null && !JetTypeChecker.INSTANCE.isSubtypeOf(exprType, paramType)) {
                                                    isGrey = true;
                                                }
                                            }
                                            else {
                                                isGrey = true;
                                            }
                                        }
                                        break;
                                    }
                                }
                            }
                        }

                        if (takeAnyArgument) {
                            if (i < currentParameterIndex) isGrey = true;

                            for (int j = 0; j < valueParameters.size(); ++j) {
                                ValueParameterDescriptor param = valueParameters.get(j);
                                if (!usedIndexes[j]) {
                                    usedIndexes[j] = true;
                                    builder.append(renderParameter(param, true, bindingContext));
                                    break;
                                }
                            }
                        }
                    }
                    if (highlightParameter) boldEndOffset = builder.length();
                }
                if (builder.toString().isEmpty()) {
                    context.setUIComponentEnabled(false);
                }
                else {
                    context.setupUIComponentPresentation(builder.toString(), boldStartOffset, boldEndOffset, isGrey,
                                                         isDeprecated, false, color);
                }
            }
            else {
                context.setUIComponentEnabled(false);
            }
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_652be_ff1cd/rev_652be-ff1cd/idea/src/org/jetbrains/jet/plugin/parameterInfo/JetFunctionParameterInfoHandler.java
Conflict type: LineBasedMCFd
Conflict body: 
private static JetValueArgumentList findCall(CreateParameterInfoContext context) {
        //todo: calls to this constructors, when we will have auxiliary constructors
        PsiFile file = context.getFile();
        if (!(file instanceof JetFile)) return null;
        PsiElement element = file.findElementAt(context.getOffset());
        while (element != null && !(element instanceof JetValueArgumentList)) {
            element = element.getParent();
        }
        if (element == null) return null;
        JetValueArgumentList argumentList = (JetValueArgumentList)element;
        JetCallElement callExpression;
        if (element.getParent() instanceof JetCallElement) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122203064/fstmerge_var1_520652913688978609
            callExpression = (JetCallElement)element.getParent();
        }
        else {
            return null;
        }
        BindingContext bindingContext = AnalyzeSingleFileUtil.getContextForSingleFile((JetFile)file);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122203064/fstmerge_base_7226740935111996674
            callExpression = (JetCallElement) element.getParent();
        } else return null;
        BindingContext bindingContext = AnalyzerFacadeForJVM.analyzeFileWithCache(
                (JetFile) file,
                AnalyzerFacadeForJVM.SINGLE_DECLARATION_PROVIDER)
                    .getBindingContext();
=======
            callExpression = (JetCallElement) element.getParent();
        } else return null;
        BindingContext bindingContext = AnalyzerFacadeForJVM.analyzeFileWithCache(
                (JetFile) file,
                AnalyzerFacadeForJVM.SINGLE_DECLARATION_PROVIDER, CompilerSpecialMode.REGULAR, CompilerDependencies.compilerDependenciesForProduction(CompilerSpecialMode.REGULAR))
                    .getBindingContext();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122203064/fstmerge_var2_2680852743003661501
        JetExpression calleeExpression = callExpression.getCalleeExpression();
        if (calleeExpression == null) return null;
        JetSimpleNameExpression refExpression = null;
        if (calleeExpression instanceof JetSimpleNameExpression) {
            refExpression = (JetSimpleNameExpression)calleeExpression;
        }
        else if (calleeExpression instanceof JetConstructorCalleeExpression) {
            JetConstructorCalleeExpression constructorCalleeExpression = (JetConstructorCalleeExpression)calleeExpression;
            if (constructorCalleeExpression.getConstructorReferenceExpression() instanceof JetSimpleNameExpression) {
                refExpression = (JetSimpleNameExpression)constructorCalleeExpression.getConstructorReferenceExpression();
            }
        }
        if (refExpression != null) {
            JetScope scope = bindingContext.get(BindingContext.RESOLUTION_SCOPE, refExpression);
            DeclarationDescriptor placeDescriptor = null;
            if (scope != null) {
                placeDescriptor = scope.getContainingDeclaration();
            }
            Collection<DeclarationDescriptor> variants = TipsManager.getReferenceVariants(refExpression, bindingContext);
            String refName = refExpression.getReferencedName();
            PsiReference[] references = refExpression.getReferences();
            if (references.length == 0) return null;
            ArrayList<DeclarationDescriptor> itemsToShow = new ArrayList<DeclarationDescriptor>();
            for (DeclarationDescriptor variant : variants) {
                if (variant instanceof FunctionDescriptor) {
                    FunctionDescriptor functionDescriptor = (FunctionDescriptor)variant;
                    if (functionDescriptor.getName().equals(refName)) {
                        //todo: renamed functions?
                        if (placeDescriptor != null && !JetVisibilityChecker.isVisible(placeDescriptor, functionDescriptor)) continue;
                        itemsToShow.add(functionDescriptor);
                    }
                }
                else if (variant instanceof ClassDescriptor) {
                    ClassDescriptor classDescriptor = (ClassDescriptor)variant;
                    if (classDescriptor.getName().equals(refName)) {
                        //todo: renamed classes?
                        for (ConstructorDescriptor constructorDescriptor : classDescriptor.getConstructors()) {
                            if (placeDescriptor != null && !JetVisibilityChecker.isVisible(placeDescriptor, constructorDescriptor)) {
                                continue;
                            }
                            itemsToShow.add(constructorDescriptor);
                        }
                    }
                }
            }
            context.setItemsToShow(ArrayUtil.toObjectArray(itemsToShow));
            return argumentList;
        }
        return null;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_652be_ff1cd/rev_652be-ff1cd/idea/src/org/jetbrains/jet/plugin/parameterInfo/JetFunctionParameterInfoHandler.java
Conflict type: LineBasedMCFd
Conflict body: 
public static void addImportDirectiveIfNeeded(@NotNull JetType type, @NotNull JetFile file) {
        if (JetPluginUtil.checkTypeIsStandard(type, file.getProject()) || ErrorUtils.isErrorType(type)) {
            return;
        }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122204638/fstmerge_var1_3009609478630957558
        BindingContext bindingContext = getContextForSingleFile(file);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122204638/fstmerge_base_7937900732920883488
        BindingContext bindingContext = AnalyzerFacadeForJVM.analyzeFileWithCache(file, AnalyzerFacadeForJVM.SINGLE_DECLARATION_PROVIDER)
                .getBindingContext();
=======
        BindingContext bindingContext = AnalyzerFacadeForJVM.analyzeFileWithCache(
                file, AnalyzerFacadeForJVM.SINGLE_DECLARATION_PROVIDER,
                CompilerSpecialMode.REGULAR, CompilerDependencies.compilerDependenciesForProduction(CompilerSpecialMode.REGULAR))
                .getBindingContext();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122204638/fstmerge_var2_7796314974177892076
        PsiElement element = bindingContext.get(BindingContext.DESCRIPTOR_TO_DECLARATION, type.getMemberScope().getContainingDeclaration());
        if (element != null && element.getContainingFile() == file) { //declaration is in the same file, so no import is needed
            return;
        }
        addImportDirective(JetPluginUtil.computeTypeFullName(type), file);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_652be_ff1cd/rev_652be-ff1cd/idea/src/org/jetbrains/jet/plugin/quickfix/ImportInsertHelper.java
Conflict type: LineBasedMCFd
Conflict body: 
private static JetProperty getCorrespondingProperty(Editor editor, JetFile file) {
        final PsiElement elementAtCaret = file.findElementAt(editor.getCaretModel().getOffset());
        JetProperty property = PsiTreeUtil.getParentOfType(elementAtCaret, JetProperty.class);
        if (property != null) return property;
        JetSimpleNameExpression simpleNameExpression = PsiTreeUtil.getParentOfType(elementAtCaret, JetSimpleNameExpression.class);
        if (simpleNameExpression != null) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122205023/fstmerge_var1_3006403497370829163
            BindingContext bindingContext = getContextForSingleFile(file);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122205023/fstmerge_base_6830062122381841892
            BindingContext bindingContext = AnalyzerFacadeForJVM.analyzeFileWithCache(file, AnalyzerFacadeForJVM.SINGLE_DECLARATION_PROVIDER)
                    .getBindingContext();
=======
            BindingContext bindingContext = AnalyzerFacadeForJVM.analyzeFileWithCache(
                    file, AnalyzerFacadeForJVM.SINGLE_DECLARATION_PROVIDER,
                    CompilerSpecialMode.REGULAR, CompilerDependencies.compilerDependenciesForProduction(CompilerSpecialMode.REGULAR))
                    .getBindingContext();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122205023/fstmerge_var2_873619501072778070
            VariableDescriptor descriptor = BindingContextUtils.extractVariableDescriptorIfAny(bindingContext, simpleNameExpression, true);
            if (descriptor != null) {
                PsiElement declaration = bindingContext.get(BindingContext.DESCRIPTOR_TO_DECLARATION, descriptor);
                if (declaration instanceof JetProperty) {
                    return (JetProperty)declaration;
                }
            }
        }
        return null;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_652be_ff1cd/rev_652be-ff1cd/idea/src/org/jetbrains/jet/plugin/quickfix/ChangeVariableMutabilityFix.java
Conflict type: LineBasedMCFd
Conflict body: 
@Nullable
    public static JetType getDeclarationReturnType(JetNamedDeclaration declaration) {
        PsiFile file = declaration.getContainingFile();
        if (!(file instanceof JetFile)) return null;
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122205113/fstmerge_var1_8690156132246994606
        BindingContext bindingContext = getContextForSingleFile((JetFile)file);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122205113/fstmerge_base_131669320977019461
        BindingContext bindingContext = AnalyzerFacadeForJVM.analyzeFileWithCache((JetFile) file, AnalyzerFacadeForJVM.SINGLE_DECLARATION_PROVIDER)
                .getBindingContext();
=======
        BindingContext bindingContext = AnalyzerFacadeForJVM.analyzeFileWithCache(
                (JetFile) file, AnalyzerFacadeForJVM.SINGLE_DECLARATION_PROVIDER,
                CompilerSpecialMode.REGULAR, CompilerDependencies.compilerDependenciesForProduction(CompilerSpecialMode.REGULAR))
                .getBindingContext();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122205113/fstmerge_var2_642312784279170803
        DeclarationDescriptor descriptor = bindingContext.get(BindingContext.DECLARATION_TO_DESCRIPTOR, declaration);
        if (!(descriptor instanceof CallableDescriptor)) return null;
        JetType type = ((CallableDescriptor)descriptor).getReturnType();
        if (type instanceof DeferredType) {
            type = ((DeferredType)type).getActualType();
        }
        return type;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_652be_ff1cd/rev_652be-ff1cd/idea/src/org/jetbrains/jet/plugin/quickfix/QuickFixUtil.java
Conflict type: LineBasedMCFd
Conflict body: 
private void analyzeAndReportSemanticErrors() {
        Predicate<PsiFile> filesToAnalyzeCompletely =
            stubs ? Predicates.<PsiFile>alwaysFalse() : Predicates.<PsiFile>alwaysTrue();
        bindingContext = AnalyzerFacadeForJVM.analyzeFilesWithJavaIntegration(
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122215762/fstmerge_var1_2669806431679055764
            environment.getProject(), sourceFiles, filesToAnalyzeCompletely, JetControlFlowDataTraceFactory.EMPTY, compilerSpecialMode);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122215762/fstmerge_base_7727162482181873256
                environment.getProject(), sourceFiles, filesToAnalyzeCompletely, JetControlFlowDataTraceFactory.EMPTY, compilerSpecialMode);
=======
                environment.getProject(), sourceFiles, filesToAnalyzeCompletely, JetControlFlowDataTraceFactory.EMPTY,
                compilerDependencies);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122215762/fstmerge_var2_1467990008045517347

        for (Diagnostic diagnostic : bindingContext.getBindingContext().getDiagnostics()) {
            reportDiagnostic(messageCollector, diagnostic);
        }

        reportIncompleteHierarchies(messageCollector);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_652be_ff1cd/rev_652be-ff1cd/compiler/cli/src/org/jetbrains/jet/compiler/CompileSession.java
Conflict type: LineBasedMCFd
Conflict body: 
@NotNull
    public GenerationState generate(boolean module) {
        Project project = environment.getProject();
        GenerationState generationState = new GenerationState(project, ClassBuilderFactories.binaries(stubs),
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122215780/fstmerge_var1_5270116702173752246
                                                              isVerbose ? new BackendProgress() : Progress.DEAF, bindingContext,
                                                              sourceFiles);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122215780/fstmerge_base_927083312393375549
                isVerbose ? new BackendProgress() : Progress.DEAF, bindingContext, sourceFiles);
=======
                isVerbose ? new BackendProgress() : Progress.DEAF, bindingContext, sourceFiles, compilerDependencies.getCompilerSpecialMode());
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122215780/fstmerge_var2_3402275858250161490
        generationState.compileCorrectFiles(CompilationErrorHandler.THROW_EXCEPTION);

        List<CompilerPlugin> plugins = environment.getCompilerPlugins();
        if (!module) {
            if (plugins != null) {
                CompilerPluginContext context = new CompilerPluginContext(project, bindingContext.getBindingContext(), getSourceFiles());
                for (CompilerPlugin plugin : plugins) {
                    plugin.processFiles(context);
                }
            }
        }
        return generationState;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_652be_ff1cd/rev_652be-ff1cd/compiler/cli/src/org/jetbrains/jet/compiler/CompileSession.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122215790/fstmerge_var1_5924119384553296018
public CompileSession(JetCoreEnvironment environment,
                          MessageRenderer messageRenderer,
                          PrintStream errorStream,
                          boolean verbose,
                          CompilerSpecialMode mode) {
        this.environment = environment;
        this.messageRenderer = messageRenderer;
        this.errorStream = errorStream;
        isVerbose = verbose;
        this.compilerSpecialMode = mode;
        messageCollector = new MessageCollector(this.messageRenderer);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122215790/fstmerge_base_852738223369835971
public CompileSession(JetCoreEnvironment environment, MessageRenderer messageRenderer, PrintStream errorStream, boolean verbose, CompilerSpecialMode mode) {
        this.environment = environment;
        this.messageRenderer = messageRenderer;
        this.errorStream = errorStream;
        isVerbose = verbose;
        this.compilerSpecialMode = mode;
        messageCollector = new MessageCollector(this.messageRenderer);
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122215790/fstmerge_var2_1281442642829678527

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_652be_ff1cd/rev_652be-ff1cd/compiler/cli/src/org/jetbrains/jet/compiler/CompileSession.java
Conflict type: LineBasedMCFd
Conflict body: 
private JetScope createScope(JetScope libraryScope) {
            JetFile file = JetPsiFactory.createFile(getProject(), "abstract class C { abstract fun foo(); abstract val a: Int }");
            List<JetDeclaration> declarations = file.getDeclarations();
            JetDeclaration aClass = declarations.get(0);
            assert aClass instanceof JetClass;
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122235400/fstmerge_var1_3825326753413405144
            AnalyzeExhaust bindingContext = AnalyzerFacadeForJVM.analyzeOneFileWithJavaIntegration(file, JetControlFlowDataTraceFactory.EMPTY);
            DeclarationDescriptor classDescriptor =
                bindingContext.getBindingContext().get(BindingContext.DECLARATION_TO_DESCRIPTOR, aClass);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122235400/fstmerge_base_3171655136660641828
            AnalyzeExhaust bindingContext = AnalyzerFacadeForJVM.analyzeFileWithCache(file, AnalyzerFacadeForJVM.SINGLE_DECLARATION_PROVIDER);
            DeclarationDescriptor classDescriptor = bindingContext.getBindingContext().get(BindingContext.DECLARATION_TO_DESCRIPTOR, aClass);
=======
            AnalyzeExhaust bindingContext = AnalyzerFacadeForJVM.analyzeFileWithCache(
                    file, AnalyzerFacadeForJVM.SINGLE_DECLARATION_PROVIDER,
                    CompilerSpecialMode.REGULAR, CompileCompilerDependenciesTest.compilerDependenciesForTests(CompilerSpecialMode.REGULAR));
            DeclarationDescriptor classDescriptor = bindingContext.getBindingContext().get(BindingContext.DECLARATION_TO_DESCRIPTOR, aClass);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122235400/fstmerge_var2_8653123950702846673
            WritableScopeImpl scope = new WritableScopeImpl(libraryScope, root, RedeclarationHandler.DO_NOTHING);
            assert classDescriptor instanceof ClassifierDescriptor;
            scope.addClassifierDescriptor((ClassifierDescriptor)classDescriptor);
            scope.changeLockLevel(WritableScope.LockLevel.READING);
            return scope;
        }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_652be_ff1cd/rev_652be-ff1cd/compiler/tests/org/jetbrains/jet/types/JetDefaultModalityModifiersTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122238974/fstmerge_var1_2095651686470176478
public static GenerationState compileFileGetGenerationState(JetFile psiFile) {
        final AnalyzeExhaust analyzeExhaust = AnalyzerFacadeForJVM.analyzeOneFileWithJavaIntegrationAndCheckForErrors(psiFile, JetControlFlowDataTraceFactory.EMPTY);
        GenerationState state = new GenerationState(psiFile.getProject(), ClassBuilderFactories.binaries(false),
                                                    analyzeExhaust, Collections.singletonList(psiFile));
        state.compileCorrectFiles(CompilationErrorHandler.THROW_EXCEPTION);
        return state;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122238974/fstmerge_base_4527307039235214914
public static GenerationState compileFileGetGenerationState(JetFile psiFile) {
        final AnalyzeExhaust analyzeExhaust = AnalyzerFacadeForJVM.analyzeOneFileWithJavaIntegrationAndCheckForErrors(psiFile, JetControlFlowDataTraceFactory.EMPTY);
        GenerationState state = new GenerationState(psiFile.getProject(), ClassBuilderFactories.binaries(false), analyzeExhaust, Collections.singletonList(psiFile));
        state.compileCorrectFiles(CompilationErrorHandler.THROW_EXCEPTION);
        return state;
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419122238974/fstmerge_var2_1196490728197660762

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_652be_ff1cd/rev_652be-ff1cd/compiler/backend/src/org/jetbrains/jet/codegen/GenerationUtils.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ec155_dafcd/rev_ec155-dafcd.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_1752b_8c74b/rev_1752b-8c74b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ff853_3813e/rev_ff853-3813e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_954dc_823c8/rev_954dc-823c8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_9df8f_ea466/rev_9df8f-ea466.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_77dad_2460c/rev_77dad-2460c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_4953b_a5ae8/rev_4953b-a5ae8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3d860_216cb/rev_3d860-216cb.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public String execute(Map map, String code, RenderContext renderContext) throws MacroException {
        try {
            VelocityContext context = new VelocityContext(MacroUtils.defaultVelocityContext());
            String renderedTemplate = VelocityUtils.getRenderedTemplate("template.velocity", context);
            StringBuilder result = new StringBuilder(renderedTemplate);

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419136536394/fstmerge_var1_8916904391065190112
            generateHtmlFromCode(code, result);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419136536394/fstmerge_base_2056536133210164004
                IElementType token = jetLexer.advance();
                if (token == null) break;
//                CharSequence yytext = jetLexer.yytext();
                String yytext = jetLexer.yytext().toString().replaceAll("\n", "\r\n");
                String style = null;
                if (token instanceof JetKeywordToken) {
                    style = "keyword";
                } else if (token == JetTokens.IDENTIFIER) {
                    for (IElementType softKeyword : JetTokens.SOFT_KEYWORDS.asSet()) {
                        if (((JetKeywordToken) softKeyword).getValue().equals(yytext.toString())) {
                            style = "softkeyword";
                            break;
                        }
                    }
                    style = style == null ? "plain" : style;
                } else if (styleMap.containsKey(token)) {
                    style = styleMap.get(token);
                } else {
                    style = "plain";
                }
                result.append("<code class=\"jet ").append(style).append("\">");
                escapeHTML(result, yytext);
                result.append("</code>");
            }
=======
                IElementType token = jetLexer.advance();
                if (token == null) break;
//                CharSequence yytext = jetLexer.yytext();
                String yytext = jetLexer.yytext().toString().replaceAll("\n", "\r\n");
                String style = null;
                if (token instanceof JetKeywordToken) {
                    style = "keyword";
                }
                else if (token == JetTokens.IDENTIFIER) {
                    for (IElementType softKeyword : JetTokens.SOFT_KEYWORDS.asSet()) {
                        if (((JetKeywordToken) softKeyword).getValue().equals(yytext.toString())) {
                            style = "softkeyword";
                            break;
                        }
                    }
                    style = style == null ? "plain" : style;
                }
                else if (styleMap.containsKey(token)) {
                    style = styleMap.get(token);
                }
                else {
                    style = "plain";
                }
                result.append("<code class=\"jet ").append(style).append("\">");
                escapeHTML(result, yytext);
                result.append("</code>");
            }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419136536394/fstmerge_var2_43462211708929026

            return result.toString();
        } catch (Throwable e) {
            return ConfluenceUtils.getErrorInHtml(e, code);
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3d860_216cb/rev_3d860-216cb/confluence/src/main/java/org/jetbrains/jet/lexer/JetMacro.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_a31ed_34ad2/rev_a31ed-34ad2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_a947d_ebf26/rev_a947d-ebf26.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e4eb4_3b0c9/rev_e4eb4-3b0c9.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419142481797/fstmerge_var1_6070104228418245171
private void reportSyntaxErrors() {
        for (JetFile file : environment.getSourceFiles()) {
            file.accept(new PsiRecursiveElementWalkingVisitor() {
                @Override
                public void visitErrorElement(PsiErrorElement element) {
                    String description = element.getErrorDescription();
                    String message = StringUtil.isEmpty(description) ? "Syntax error" : description;
                    Diagnostic diagnostic = new SyntaxErrorDiagnostic(element, Severity.ERROR, message);
                    reportDiagnostic(messageCollector, diagnostic);
                }
            });
        }
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419142481797/fstmerge_base_5314301655918338211
private void reportSyntaxErrors() {
        for (JetFile file : environment.getSourceFiles()) {
            file.accept(new PsiRecursiveElementWalkingVisitor() {
                @Override
                public void visitErrorElement(PsiErrorElement element) {
                    String description = element.getErrorDescription();
                    String message = StringUtil.isEmpty(description) ? "Syntax error" : description;
                    Diagnostic diagnostic = DiagnosticFactory.create(Severity.ERROR, message).on(element);
                    reportDiagnostic(messageCollector, diagnostic);
                }
            });
        }
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419142481797/fstmerge_var2_7973173643004051261

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e4eb4_3b0c9/rev_e4eb4-3b0c9/compiler/cli/src/org/jetbrains/jet/compiler/CompileSession.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419142481802/fstmerge_var1_2858435251638718057
private static void reportDiagnostic(MessageCollector collector, Diagnostic diagnostic) {
        DiagnosticUtils.LineAndColumn lineAndColumn = DiagnosticUtils.getLineAndColumn(diagnostic);
        VirtualFile virtualFile = diagnostic.getPsiFile().getVirtualFile();
        String path = virtualFile == null ? null : virtualFile.getPath();
        String render;
        if (diagnostic.getFactory() == SYNTAX_ERROR_FACTORY) {
            render = ((SyntaxErrorDiagnostic)diagnostic).message;
        }
        else {
            render = DefaultErrorMessages.RENDERER.render(diagnostic);
        }
        collector.report(diagnostic.getSeverity(), render, path, lineAndColumn.getLine(), lineAndColumn.getColumn());
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419142481802/fstmerge_base_5786370447428263632
private static void reportDiagnostic(MessageCollector collector, Diagnostic diagnostic) {
        DiagnosticUtils.LineAndColumn lineAndColumn = DiagnosticUtils.getLineAndColumn(diagnostic);
        VirtualFile virtualFile = diagnostic.getPsiFile().getVirtualFile();
        String path = virtualFile == null ? null : virtualFile.getPath();
        collector.report(diagnostic.getSeverity(), diagnostic.getMessage(), path, lineAndColumn.getLine(), lineAndColumn.getColumn());
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419142481802/fstmerge_var2_8979536270353555969

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e4eb4_3b0c9/rev_e4eb4-3b0c9/compiler/cli/src/org/jetbrains/jet/compiler/CompileSession.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ DiagnosticFactory1<JetModifierListOwner, CallableMemberDescriptor> NOTHING_TO_OVERRIDE =
            DiagnosticFactory1.create(ERROR, PositioningStrategies.positionModifier(JetTokens.OVERRIDE_KEYWORD)); ##FSTMerge## DiagnosticFactory1<JetModifierListOwner, CallableMemberDescriptor> NOTHING_TO_OVERRIDE = DiagnosticFactory1.create(ERROR, "{0} overrides nothing", PositioningStrategies.positionModifier(JetTokens.OVERRIDE_KEYWORD), DescriptorRenderer.TEXT); ##FSTMerge## DiagnosticFactory1<JetModifierListOwner, CallableMemberDescriptor> NOTHING_TO_OVERRIDE = DiagnosticFactory1.create(ERROR, "{0} overrides nothing", PositioningStrategies.POSITION_OVERRIDE_MODIFIER, DescriptorRenderer.TEXT);
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e4eb4_3b0c9/rev_e4eb4-3b0c9/compiler/frontend/src/org/jetbrains/jet/lang/diagnostics/Errors.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ DiagnosticFactory3<PsiNameIdentifierOwner, CallableMemberDescriptor, CallableMemberDescriptor, DeclarationDescriptor>
            VIRTUAL_MEMBER_HIDDEN = DiagnosticFactory3.create(ERROR, PositioningStrategies.POSITION_NAME_IDENTIFIER); ##FSTMerge## DiagnosticFactory3<PsiNameIdentifierOwner, CallableMemberDescriptor, CallableMemberDescriptor, DeclarationDescriptor> VIRTUAL_MEMBER_HIDDEN = DiagnosticFactory3.create(ERROR, "''{0}'' hides ''{1}'' in class {2} and needs 'override' modifier", PositioningStrategies.POSITION_NAME_IDENTIFIER, DescriptorRenderer.TEXT, DescriptorRenderer.TEXT, DescriptorRenderer.TEXT); ##FSTMerge## DiagnosticFactory3<PsiNameIdentifierOwner, CallableMemberDescriptor, CallableMemberDescriptor, DeclarationDescriptor> VIRTUAL_MEMBER_HIDDEN =
            DiagnosticFactory3.create(ERROR, "''{0}'' hides ''{1}'' in class {2} and needs 'override' modifier", PositioningStrategies.POSITION_NAME_IDENTIFIER, DescriptorRenderer.TEXT, DescriptorRenderer.TEXT, DescriptorRenderer.TEXT);
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e4eb4_3b0c9/rev_e4eb4-3b0c9/compiler/frontend/src/org/jetbrains/jet/lang/diagnostics/Errors.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_71ef1_d0bd5/rev_71ef1-d0bd5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_4aae7_7f272/rev_4aae7-7f272.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_62e3f_4502f/rev_62e3f-4502f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_272ba_47c38/rev_272ba-47c38.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_eeafd_3e862/rev_eeafd-3e862.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419153470700/fstmerge_var1_6801383542342898550
public ExitCode exec(final PrintStream errStream, K2JVMCompilerArguments arguments) {
        if (arguments.help) {
            usage(errStream);
            return OK;
        }
        System.setProperty("java.awt.headless", "true");

        final MessageRenderer messageRenderer = arguments.tags ? MessageRenderer.TAGS : MessageRenderer.PLAIN;

        errStream.print(messageRenderer.renderPreamble());

        try {
            if (arguments.version) {
                errStream.println(messageRenderer.render(CompilerMessageSeverity.INFO, "Kotlin Compiler version " + K2JVMCompilerVersion.VERSION, CompilerMessageLocation.NO_LOCATION));
            }

            CompilerSpecialMode mode = parseCompilerSpecialMode(arguments);

            File jdkHeadersJar;
            if (mode.includeJdkHeaders()) {
                if (arguments.jdkHeaders != null) {
                    jdkHeadersJar = new File(arguments.jdkHeaders);
                }
                else {
                    jdkHeadersJar = PathUtil.getAltHeadersPath();
                }
            }
            else {
                jdkHeadersJar = null;
            }
            File runtimeJar;

            if (mode.includeKotlinRuntime()) {
                if (arguments.stdlib != null) {
                    runtimeJar = new File(arguments.stdlib);
                }
                else {
                    runtimeJar = PathUtil.getDefaultRuntimePath();
                }
            }
            else {
                runtimeJar = null;
            }

            CompilerDependencies dependencies = new CompilerDependencies(mode, CompilerDependencies.findRtJar(), jdkHeadersJar, runtimeJar);
            PrintingMessageCollector messageCollector = new PrintingMessageCollector(errStream, messageRenderer, arguments.verbose);
            Disposable rootDisposable = CompileEnvironmentUtil.createMockDisposable();

            JetCoreEnvironment environment = new JetCoreEnvironment(rootDisposable, dependencies);
            CompileEnvironmentConfiguration configuration = new CompileEnvironmentConfiguration(environment, messageCollector);

            messageCollector.report(CompilerMessageSeverity.LOGGING, "Configuring the compilation environment",
                                    CompilerMessageLocation.NO_LOCATION);
            try {
                configureEnvironment(configuration, arguments);

                boolean noErrors;
                if (arguments.module != null) {
                    List<Module> modules = CompileEnvironmentUtil.loadModuleScript(arguments.module, new PrintingMessageCollector(errStream, messageRenderer, false));
                    File directory = new File(arguments.module).getParentFile();
                    noErrors = KotlinToJVMBytecodeCompiler.compileModules(configuration, modules,
                                                                          directory, arguments.jar, arguments.outputDir,
                                                                          arguments.includeRuntime);
                }
                else {
                    // TODO ideally we'd unify to just having a single field that supports multiple files/dirs
                    if (arguments.getSourceDirs() != null) {
                        noErrors = KotlinToJVMBytecodeCompiler.compileBunchOfSourceDirectories(configuration,
                                                                                               arguments.getSourceDirs(), arguments.jar, arguments.outputDir, arguments.includeRuntime);
                    }
                    else {
                        noErrors = KotlinToJVMBytecodeCompiler.compileBunchOfSources(configuration,
                                                                     arguments.src, arguments.jar, arguments.outputDir, arguments.includeRuntime);
                    }
                }
                return noErrors ? OK : COMPILATION_ERROR;
            }
            catch (CompilationException e) {
                messageCollector.report(CompilerMessageSeverity.EXCEPTION, MessageRenderer.PLAIN.renderException(e),
                                        MessageUtil.psiElementToMessageLocation(e.getElement()));
                return INTERNAL_ERROR;
            }
            catch (Throwable t) {
                messageCollector.report(CompilerMessageSeverity.EXCEPTION, MessageRenderer.PLAIN.renderException(t), CompilerMessageLocation.NO_LOCATION);
                return INTERNAL_ERROR;
            }
            finally {
                Disposer.dispose(rootDisposable);
                messageCollector.printToErrStream();
            }
        }
        finally {
             errStream.print(messageRenderer.renderConclusion());
        }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419153470700/fstmerge_base_4191083983314393752
public ExitCode exec(final PrintStream errStream, K2JVMCompilerArguments arguments) {
        if (arguments.help) {
            usage(errStream);
            return OK;
        }
        System.setProperty("java.awt.headless", "true");

        final MessageRenderer messageRenderer = arguments.tags ? MessageRenderer.TAGS : MessageRenderer.PLAIN;

        errStream.print(messageRenderer.renderPreamble());

        try {
            if (arguments.version) {
                errStream.println(messageRenderer.render(CompilerMessageSeverity.INFO, "Kotlin Compiler version " + K2JVMCompilerVersion.VERSION, CompilerMessageLocation.NO_LOCATION));
            }

            CompilerSpecialMode mode = parseCompilerSpecialMode(arguments);

            File jdkHeadersJar;
            if (mode.includeJdkHeaders()) {
                if (arguments.jdkHeaders != null) {
                    jdkHeadersJar = new File(arguments.jdkHeaders);
                }
                else {
                    jdkHeadersJar = PathUtil.getAltHeadersPath();
                }
            }
            else {
                jdkHeadersJar = null;
            }
            File runtimeJar;

            if (mode.includeKotlinRuntime()) {
                if (arguments.stdlib != null) {
                    runtimeJar = new File(arguments.stdlib);
                }
                else {
                    runtimeJar = PathUtil.getDefaultRuntimePath();
                }
            }
            else {
                runtimeJar = null;
            }

            CompilerDependencies dependencies = new CompilerDependencies(mode, CompilerDependencies.findRtJar(), jdkHeadersJar, runtimeJar);
            PrintingMessageCollector messageCollector = new PrintingMessageCollector(errStream, messageRenderer, arguments.verbose);
            Disposable rootDisposable = CompileEnvironmentUtil.createMockDisposable();

            JetCoreEnvironment environment = new JetCoreEnvironment(rootDisposable, dependencies);
            CompileEnvironmentConfiguration configuration = new CompileEnvironmentConfiguration(environment, dependencies, messageCollector);

            messageCollector.report(CompilerMessageSeverity.LOGGING, "Configuring the compilation environment",
                                    CompilerMessageLocation.NO_LOCATION);
            try {
                configureEnvironment(configuration, arguments);

                boolean noErrors;
                if (arguments.module != null) {
                    List<Module> modules = CompileEnvironmentUtil.loadModuleScript(arguments.module, new PrintingMessageCollector(errStream, messageRenderer, false));
                    File directory = new File(arguments.module).getParentFile();
                    noErrors = KotlinToJVMBytecodeCompiler.compileModules(configuration, modules,
                                                                          directory, arguments.jar, arguments.outputDir,
                                                                          arguments.includeRuntime);
                }
                else {
                    // TODO ideally we'd unify to just having a single field that supports multiple files/dirs
                    if (arguments.getSourceDirs() != null) {
                        noErrors = KotlinToJVMBytecodeCompiler.compileBunchOfSourceDirectories(configuration,
                                                                                               arguments.getSourceDirs(), arguments.jar, arguments.outputDir, arguments.includeRuntime);
                    }
                    else {
                        noErrors = KotlinToJVMBytecodeCompiler.compileBunchOfSources(configuration,
                                                                     arguments.src, arguments.jar, arguments.outputDir, arguments.includeRuntime);
                    }
                }
                return noErrors ? OK : COMPILATION_ERROR;
            }
            catch (CompilationException e) {
                messageCollector.report(CompilerMessageSeverity.EXCEPTION, MessageRenderer.PLAIN.renderException(e),
                                        MessageUtil.psiElementToMessageLocation(e.getElement()));
                return INTERNAL_ERROR;
            }
            catch (Throwable t) {
                messageCollector.report(CompilerMessageSeverity.EXCEPTION, MessageRenderer.PLAIN.renderException(t), CompilerMessageLocation.NO_LOCATION);
                return INTERNAL_ERROR;
            }
            finally {
                Disposer.dispose(rootDisposable);
                messageCollector.printToErrStream();
            }
        }
        finally {
             errStream.print(messageRenderer.renderConclusion());
        }
=======
@NotNull
    @Override
    public ExitCode exec(PrintStream errStream, K2JVMCompilerArguments arguments) {
        return super.exec(errStream, arguments);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419153470700/fstmerge_var2_8096388660050396965
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_eeafd_3e862/rev_eeafd-3e862/compiler/cli/src/org/jetbrains/jet/cli/jvm/K2JVMCompiler.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419153470998/fstmerge_var1_4401356168624821687
public JetCoreEnvironment(Disposable parentDisposable, @NotNull CompilerDependencies compilerDependencies) {
        super(parentDisposable);

        this.compilerDependencies = compilerDependencies;

        registerFileType(JetFileType.INSTANCE, "kt");
        registerFileType(JetFileType.INSTANCE, "kts");
        registerFileType(JetFileType.INSTANCE, "ktm");
        registerFileType(JetFileType.INSTANCE, "jet");
        registerParserDefinition(new JavaParserDefinition());
        registerParserDefinition(new JetParserDefinition());


        myProject.registerService(JetFilesProvider.class, new CliJetFilesProvider(this));
        Extensions.getArea(myProject)
                .getExtensionPoint(PsiElementFinder.EP_NAME)
                .registerExtension(new JavaElementFinder(myProject));

        CompilerSpecialMode compilerSpecialMode = compilerDependencies.getCompilerSpecialMode();

        addToClasspath(compilerDependencies.getJdkJar());

        if (compilerSpecialMode.includeJdkHeaders()) {
            for (VirtualFile root : compilerDependencies.getJdkHeaderRoots()) {
                addLibraryRoot(root);
            }
        }
        if (compilerSpecialMode.includeKotlinRuntime()) {
            addToClasspath(compilerDependencies.getRuntimeJar());
        }

        JetStandardLibrary.initialize(getProject());
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419153470998/fstmerge_base_8922482730221616302
public JetCoreEnvironment(Disposable parentDisposable, @NotNull CompilerDependencies compilerDependencies) {
        super(parentDisposable);
        registerFileType(JetFileType.INSTANCE, "kt");
        registerFileType(JetFileType.INSTANCE, "kts");
        registerFileType(JetFileType.INSTANCE, "ktm");
        registerFileType(JetFileType.INSTANCE, "jet");
        registerParserDefinition(new JavaParserDefinition());
        registerParserDefinition(new JetParserDefinition());


        myProject.registerService(JetFilesProvider.class, new CliJetFilesProvider(this));
        Extensions.getArea(myProject)
                .getExtensionPoint(PsiElementFinder.EP_NAME)
                .registerExtension(new JavaElementFinder(myProject));

        CompilerSpecialMode compilerSpecialMode = compilerDependencies.getCompilerSpecialMode();

        addToClasspath(compilerDependencies.getJdkJar());

        if (compilerSpecialMode.includeJdkHeaders()) {
            for (VirtualFile root : compilerDependencies.getJdkHeaderRoots()) {
                addLibraryRoot(root);
            }
        }
        if (compilerSpecialMode.includeKotlinRuntime()) {
            for (VirtualFile root : compilerDependencies.getRuntimeRoots()) {
                addLibraryRoot(root);
            }
        }

        JetStandardLibrary.initialize(getProject());
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419153470998/fstmerge_var2_6799193167185275010

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_eeafd_3e862/rev_eeafd-3e862/compiler/cli/src/org/jetbrains/jet/cli/jvm/compiler/JetCoreEnvironment.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419153471003/fstmerge_var1_5938368877393984498
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419153471003/fstmerge_base_552177065980852904
public CompileEnvironmentConfiguration(@NotNull JetCoreEnvironment environment,
            @NotNull CompilerDependencies compilerDependencies, @NotNull MessageCollector messageCollector) {
        this.messageCollector = messageCollector;
        this.compilerDependencies = compilerDependencies;
        this.environment = environment;
    }
=======
public CompileEnvironmentConfiguration(@NotNull JetCoreEnvironment environment,
            @NotNull CompilerDependencies compilerDependencies,
            @NotNull MessageCollector messageCollector) {
        super(messageCollector);
        this.compilerDependencies = compilerDependencies;
        this.environment = environment;
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419153471003/fstmerge_var2_2548778536968854789

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_eeafd_3e862/rev_eeafd-3e862/compiler/cli/src/org/jetbrains/jet/cli/jvm/compiler/CompileEnvironmentConfiguration.java
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ @NotNull
    private final MessageCollector messageCollector; ##FSTMerge## private final MessageCollector messageCollector; ##FSTMerge##
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_eeafd_3e862/rev_eeafd-3e862/compiler/cli/src/org/jetbrains/jet/cli/jvm/compiler/CompileEnvironmentConfiguration.java
Conflict type: LineBasedMCFd
Conflict body: 
public static JetCoreEnvironment createEnvironmentWithMockJdk(Disposable disposable, @NotNull CompilerSpecialMode compilerSpecialMode) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419153488033/fstmerge_var1_8478580256899355795
        JetCoreEnvironment environment =
                new JetCoreEnvironment(disposable, CompileCompilerDependenciesTest.compilerDependenciesForTests(compilerSpecialMode, true));
        environment.addToClasspath(getAnnotationsJar());
        return environment;
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419153488033/fstmerge_base_9083605026214066672
        return new JetCoreEnvironment(disposable, CompileCompilerDependenciesTest.compilerDependenciesForTests(compilerSpecialMode, true));
=======
        return JetCoreEnvironment.getCoreEnvironmentForJVM(disposable, CompileCompilerDependenciesTest
                .compilerDependenciesForTests(compilerSpecialMode, true));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419153488033/fstmerge_var2_8804111022963099866
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_eeafd_3e862/rev_eeafd-3e862/compiler/tests/org/jetbrains/jet/JetTestUtils.java
Conflict type: LineBasedMCFd
Conflict body: 
public void testMe() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        createEnvironmentWithMockJdk();
        String text = "import org.jetbrains.jet.codegen.CompileTextTest; fun x() = CompileTextTest()";
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419153490560/fstmerge_var1_3658069169055240654
        CompileEnvironmentConfiguration configuration = new CompileEnvironmentConfiguration(
                myEnvironment, MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419153490560/fstmerge_base_20263864952994116
        CompilerDependencies dependencies = CompileCompilerDependenciesTest.compilerDependenciesForTests(CompilerSpecialMode.REGULAR, false);
        JetCoreEnvironment environment = new JetCoreEnvironment(CompileEnvironmentUtil.createMockDisposable(), dependencies);
        CompileEnvironmentConfiguration configuration = new CompileEnvironmentConfiguration(environment, dependencies, MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR);
=======
        CompilerDependencies dependencies = CompileCompilerDependenciesTest.compilerDependenciesForTests(CompilerSpecialMode.REGULAR, false);
        JetCoreEnvironment environment = JetCoreEnvironment.getCoreEnvironmentForJVM(CompileEnvironmentUtil.createMockDisposable(), dependencies);
        CompileEnvironmentConfiguration configuration = new CompileEnvironmentConfiguration(environment, dependencies, MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419153490560/fstmerge_var2_5857856296016849638
        configuration.getEnvironment().addToClasspathFromClassLoader(getClass().getClassLoader());
        ClassLoader classLoader = KotlinToJVMBytecodeCompiler.compileText(configuration, text);
        Class<?> namespace = classLoader.loadClass("namespace");
        Method x = namespace.getDeclaredMethod("x");
        Object invoke = x.invoke(null);
        assertTrue(invoke instanceof CompileTextTest);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_eeafd_3e862/rev_eeafd-3e862/compiler/tests/org/jetbrains/jet/codegen/CompileTextTest.java
Conflict type: LineBasedMCFd
Conflict body: 
private CompileEnvironmentConfiguration env( String stdlib, String[] classpath ) {
        CompilerDependencies dependencies = CompilerDependencies.compilerDependenciesForProduction(CompilerSpecialMode.REGULAR);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419153513231/fstmerge_var1_2961260838911983428
        JetCoreEnvironment environment = new JetCoreEnvironment(CompileEnvironmentUtil.createMockDisposable(), dependencies);
        CompileEnvironmentConfiguration env = new CompileEnvironmentConfiguration(environment, MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419153513231/fstmerge_base_8974926840470745698
        JetCoreEnvironment environment = new JetCoreEnvironment(CompileEnvironmentUtil.createMockDisposable(), dependencies);
        CompileEnvironmentConfiguration env = new CompileEnvironmentConfiguration(environment, dependencies, MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR);
=======
        JetCoreEnvironment environment = JetCoreEnvironment.getCoreEnvironmentForJVM(CompileEnvironmentUtil.createMockDisposable(), dependencies);
        CompileEnvironmentConfiguration env = new CompileEnvironmentConfiguration(environment, dependencies, MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419153513231/fstmerge_var2_8323112062027698005

        if (( stdlib != null ) && ( stdlib.trim().length() > 0 )) {
            File file = new File(stdlib);
            CompileEnvironmentUtil.addToClasspath(env.getEnvironment(), file);
        }

        if (( classpath != null ) && ( classpath.length > 0 )) {
            CompileEnvironmentUtil.addToClasspath(env.getEnvironment(), classpath);
        }

        // lets register any compiler plugins
        env.getCompilerPlugins().addAll(getCompilerPlugins());

        return env;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_eeafd_3e862/rev_eeafd-3e862/build-tools/core/src/org/jetbrains/jet/buildtools/core/BytecodeCompiler.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_34829_3d975/rev_34829-3d975.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_442d0_85bc9/rev_442d0-85bc9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_bc204_218b7/rev_bc204-218b7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_422fc_1c557/rev_422fc-1c557.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_8297d_ad4cb/rev_8297d-ad4cb.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ded82_e796f/rev_ded82-e796f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_162cc_ded82/rev_162cc-ded82.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_070a3_b5687/rev_070a3-b5687.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ee1d4_b0c01/rev_ee1d4-b0c01.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_43d64_a8951/rev_43d64-a8951.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_9c914_b55ca/rev_9c914-b55ca.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_93b8a_cf662/rev_93b8a-cf662.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_8793d_f9515/rev_8793d-f9515.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e4007_ec1a7/rev_e4007-ec1a7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_94022_cb4ce/rev_94022-cb4ce.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_5bb48_69e74/rev_5bb48-69e74.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0490c_9f0fc/rev_0490c-9f0fc.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_88ecb_843eb/rev_88ecb-843eb.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_a1a3d_9c8da/rev_a1a3d-9c8da.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6c0a3_1d0ef/rev_6c0a3-1d0ef.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ae00b_ef194/rev_ae00b-ef194.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_88e05_20a20/rev_88e05-20a20.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_9a7f3_3872e/rev_9a7f3-3872e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3660d_3c1fb/rev_3660d-3c1fb.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3e3b1_ee689/rev_3e3b1-ee689.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c1103_2e531/rev_c1103-2e531.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6b13f_895b4/rev_6b13f-895b4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d94f9_11f2a/rev_d94f9-11f2a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_1c599_071e2/rev_1c599-071e2.revisions

=========================================================
=========================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c613b_9e727/rev_c613b-9e727.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d67e2_aed16/rev_d67e2-aed16.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d54e1_744fa/rev_d54e1-744fa.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_28b15_e4e69/rev_28b15-e4e69.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ce5b5_cf639/rev_ce5b5-cf639.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_8b191_8d2bd/rev_8b191-8d2bd.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_95f61_34f48/rev_95f61-34f48.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_4478f_a4ffb/rev_4478f-a4ffb.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e2400_0da54/rev_e2400-0da54.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_77320_9b2e2/rev_77320-9b2e2.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419294260348/fstmerge_var1_1628583446581908371
public TestConfig(@NotNull Project project, @NotNull EcmaVersion version) {
        super(project, "main", version);
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419294260348/fstmerge_base_6997985310392428937
public TestConfig(@NotNull Project project, @NotNull EcmaVersion version) {
        super(project, version);
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419294260348/fstmerge_var2_2364154792009993952

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_77320_9b2e2/rev_77320-9b2e2/js/js.tests/test/org/jetbrains/k2js/test/config/TestConfig.java
Conflict type: LineBasedMCFd
Conflict body: 
private static void runFileWithRhino(@NotNull String inputFile,
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419294260378/fstmerge_var1_1671677218962504149
                                         @NotNull Context context,
                                         @NotNull Scriptable scope) throws Exception {
        context.evaluateString(scope, fileToString(inputFile), inputFile, 1, null);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419294260378/fstmerge_base_7641501649733929818
                                         @NotNull Context context,
                                         @NotNull Scriptable scope) throws Exception {
        FileReader reader = new FileReader(inputFile);
        try {
            context.evaluateReader(scope, reader, inputFile, 1, null);
        } finally {
            reader.close();
        }
=======
            @NotNull Context context,
            @NotNull Scriptable scope) throws Exception {
        FileReader reader = new FileReader(inputFile);
        try {
            context.evaluateReader(scope, reader, inputFile, 1, null);
        }
        finally {
            reader.close();
        }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419294260378/fstmerge_var2_6247267662052339915
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_77320_9b2e2/rev_77320-9b2e2/js/js.tests/test/org/jetbrains/k2js/test/rhino/RhinoUtils.java
Conflict type: LineBasedMCFd
Conflict body: 
public static void runRhinoTest(@NotNull List<String> fileNames,
            @NotNull RhinoResultChecker checker,
            @Nullable Map<String, Object> variables,
            @NotNull EcmaVersion ecmaVersion) throws Exception {
        Context context = createContext(ecmaVersion);
        try {
            Scriptable scope = getScope(ecmaVersion, context);
            putGlobalVariablesIntoScope(scope, variables);
            for (String filename : fileNames) {
                runFileWithRhino(filename, context, scope);
            }
            checker.runChecks(context, scope);
        }
        finally {
            Context.exit();
        }
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419294260385/fstmerge_var1_2417255775603605472
        checker.runChecks(context, scope);

        lintIt(context, fileNames.get(fileNames.size() - 1));

        Context.exit();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419294260385/fstmerge_base_4819739640197004594
        checker.runChecks(context, scope);
        Context.exit();
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419294260385/fstmerge_var2_7787663435672692175
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_77320_9b2e2/rev_77320-9b2e2/js/js.tests/test/org/jetbrains/k2js/test/rhino/RhinoUtils.java
Conflict type: LineBasedMCFd
Conflict body: 
@Override
    public void runChecks(Context context, Scriptable scope) throws Exception {
        Object result = evaluateFunction(context, scope);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419294260397/fstmerge_var1_6683293236674413328
        assertResultValid(result, context);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419294260397/fstmerge_base_8886210703512943223
        assertResultValid(result);
=======
        flushSystemOut(context, scope);
        assertResultValid(result);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419294260397/fstmerge_var2_3925823048504952798
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_77320_9b2e2/rev_77320-9b2e2/js/js.tests/test/org/jetbrains/k2js/test/rhino/RhinoFunctionResultChecker.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b2def_bb8dc/rev_b2def-bb8dc.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_1c7b3_cbf83/rev_1c7b3-cbf83.revisions
Conflict type: LineBasedMCFd
Conflict body: 
~~FSTMerge~~ @NotNull
    public static final List<String> LIB_FILE_NAMES_DEPENDENT_ON_STDLIB = Arrays.asList(
            "/stdlib/dom.kt",
            "/stdlib/jutil.kt",
            "/stdlib/JUMaps.kt",
            "/stdlib/test.kt",
            "/core/stringDefs.kt",
            "/core/strings.kt"
    ); ##FSTMerge## @NotNull
    public static final List<String> LIB_FILE_NAMES_DEPENDENT_ON_STDLIB = Arrays.asList(
            "/stdlib/jutil.kt",
            "/stdlib/JUMaps.kt",
            "/stdlib/test.kt",
            "/core/stringDefs.kt",
            "/core/strings.kt"
    ); ##FSTMerge## @NotNull
    public static final List<String> LIB_FILE_NAMES_DEPENDENT_ON_STDLIB = Arrays.asList(
            "/stdlib/jutil.kt",
            //"/stdlib/JUMaps.kt",
            "/stdlib/test.kt",
            "/core/stringDefs.kt",
            "/core/strings.kt"
    );
File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_1c7b3_cbf83/rev_1c7b3-cbf83/js/js.translator/src/org/jetbrains/k2js/config/Config.java
Conflict type: LineBasedMCFd
Conflict body: 
public void testGenerateTestCase() throws Exception {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419294840886/fstmerge_var1_4213399515445368672
        generateJavaScriptFiles(EcmaVersion.all(),
                                "libraries/stdlib/test",
                                "dom/DomTest.kt",
                                "js/MapTest.kt",
                                "js/JsDomTest.kt",
                                "iterators/FunctionIteratorTest.kt",
                                "iterators/IteratorsTest.kt",
                                "GetOrElseTest.kt",
                                "ListTest.kt",
                                "SetTest.kt",
                                "StringTest.kt");
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419294840886/fstmerge_base_2107718754418458548
        generateJavaScriptFiles(EcmaVersion.all(),
                                "libraries/stdlib/test",
                                //"dom/DomTest.kt",
                                "js/MapTest.kt",
                                "ListTest.kt",
                                "StringTest.kt");
=======
        performStdLibTest(EcmaVersion.all(),
                          "libraries/stdlib/test",
                          //"dom/DomTest.kt",
                          //"js/MapTest.kt",
                          "ListTest.kt",
                          "StringTest.kt");
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419294840886/fstmerge_var2_2750827469428089714
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_1c7b3_cbf83/rev_1c7b3-cbf83/js/js.tests/test/org/jetbrains/k2js/test/semantics/StdLibTestToJSTest.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_1c5e5_92231/rev_1c5e5-92231.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_39a8a_b989c/rev_39a8a-b989c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_06f2c_4b062/rev_06f2c-4b062.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_a0795_112cd/rev_a0795-112cd.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_5cc04_80127/rev_5cc04-80127.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_2d6b8_1de2e/rev_2d6b8-1de2e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ac434_78a9a/rev_ac434-78a9a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_eeacf_675fd/rev_eeacf-675fd.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_db008_98efc/rev_db008-98efc.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_2ac70_fa7ad/rev_2ac70-fa7ad.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0c023_1cc54/rev_0c023-1cc54.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6eb4c_f9b02/rev_6eb4c-f9b02.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_9eab2_97abf/rev_9eab2-97abf.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_7e38c_b216b/rev_7e38c-b216b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_4712d_0b616/rev_4712d-0b616.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e8dba_ab30a/rev_e8dba-ab30a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_fe1e6_e291c/rev_fe1e6-e291c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b55ef_c14a0/rev_b55ef-c14a0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_36e0d_a98cd/rev_36e0d-a98cd.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3cf1f_f53a4/rev_3cf1f-f53a4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_713a2_e8deb/rev_713a2-e8deb.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_98ed2_71adf/rev_98ed2-71adf.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419302018201/fstmerge_var1_1510944912324157841
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419302018201/fstmerge_base_4410064768996372694
private RangesFIF() {
        add(pattern("Int.upto"), new CallStandardMethodIntrinsic("Kotlin.intUpto", true, 1));
        add(pattern("Int.downto"), new CallStandardMethodIntrinsic("Kotlin.intDownto", true, 1));
    }
=======
private RangesFIF() {
        add(pattern("Int.upto"), new CallStandardMethodIntrinsic(new JsNameRef("intUpto", "Kotlin"), true, 1));
        add(pattern("Int.downto"), new CallStandardMethodIntrinsic(new JsNameRef("intDownto", "Kotlin"), true, 1));
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419302018201/fstmerge_var2_1025320143027316462

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_98ed2_71adf/rev_98ed2-71adf/js/js.translator/src/org/jetbrains/k2js/translate/intrinsic/functions/factories/RangesFIF.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0b054_06160/rev_0b054-06160.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_17a97_358d8/rev_17a97-358d8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_f9aea_8860b/rev_f9aea-8860b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d2d5f_5855c/rev_d2d5f-5855c.revisions
Conflict type: LineBasedMCFd
Conflict body: 
private void generatePrimaryConstructorProperties(PropertyCodegen propertyCodegen, JetClassOrObject origin) {
        boolean isAnnotation = origin instanceof JetClass && ((JetClass) origin).isAnnotation();
        for (JetParameter p : getPrimaryConstructorParameters()) {
            if (p.getValOrVarNode() != null) {
                PropertyDescriptor propertyDescriptor = state.getBindingContext().get(BindingContext.PRIMARY_CONSTRUCTOR_PARAMETER, p);
                if (propertyDescriptor != null) {
                    if (!isAnnotation) {
                        propertyCodegen.generateBackingField(p, propertyDescriptor);
                        propertyCodegen
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419303429696/fstmerge_var1_8356232527240069445
                                .generateDefaultGetter(propertyDescriptor, getAccessModifiers(propertyDescriptor, 0), p);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419303429696/fstmerge_base_7377335590025845431
                                .generateDefaultGetter(propertyDescriptor, JetTypeMapper.getAccessModifiers(propertyDescriptor, 0), p);
=======
                                .generateDefaultGetter(propertyDescriptor, getVisibilityAccessFlag(propertyDescriptor), p);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419303429696/fstmerge_var2_5518150056715689023
                        if (propertyDescriptor.isVar()) {
                            propertyCodegen
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419303429696/fstmerge_var1_8356232527240069445
                                    .generateDefaultSetter(propertyDescriptor, getAccessModifiers(propertyDescriptor, 0), p);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419303429696/fstmerge_base_7377335590025845431
                                    .generateDefaultSetter(propertyDescriptor, JetTypeMapper.getAccessModifiers(propertyDescriptor, 0), p);
=======
                                    .generateDefaultSetter(propertyDescriptor, getVisibilityAccessFlag(propertyDescriptor), p);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419303429696/fstmerge_var2_5518150056715689023
                        }
                    }
                    else {
                        Type type = state.getInjector().getJetTypeMapper().mapType(propertyDescriptor.getType(), MapTypeMode.VALUE);
                        v.newMethod(p, ACC_PUBLIC | ACC_ABSTRACT, p.getName(), "()" + type.getDescriptor(), null, null);
                    }
                }
            }
        }
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d2d5f_5855c/rev_d2d5f-5855c/compiler/backend/src/org/jetbrains/jet/codegen/ClassBodyCodegen.java
Conflict type: LineBasedMCFd
Conflict body: 
private void generateDefaultGetter(JetProperty p) {
        final PropertyDescriptor propertyDescriptor = (PropertyDescriptor) state.getBindingContext().get(BindingContext.VARIABLE, p);
        assert propertyDescriptor != null;
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419303429796/fstmerge_var1_7470517282667343409
        int flags = getAccessModifiers(propertyDescriptor, 0) |
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419303429796/fstmerge_base_7295025028963516355
        int flags = JetTypeMapper.getAccessModifiers(propertyDescriptor, 0) |
=======
        int flags = getVisibilityAccessFlag(propertyDescriptor) |
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419303429796/fstmerge_var2_824127086226461540
                    (propertyDescriptor.getModality() == Modality.ABSTRACT
                     ? ACC_ABSTRACT
                     : (propertyDescriptor.getModality() == Modality.FINAL ? ACC_FINAL : 0));
        generateDefaultGetter(propertyDescriptor, flags, p);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d2d5f_5855c/rev_d2d5f-5855c/compiler/backend/src/org/jetbrains/jet/codegen/PropertyCodegen.java
Conflict type: LineBasedMCFd
Conflict body: 
private void generateDefaultSetter(JetProperty p) {
        final PropertyDescriptor propertyDescriptor = (PropertyDescriptor) state.getBindingContext().get(BindingContext.VARIABLE, p);
        assert propertyDescriptor != null;

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419303429811/fstmerge_var1_7670792151414058417
        int modifiers = getAccessModifiers(propertyDescriptor, 0);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419303429811/fstmerge_base_7378308008014810662
        int modifiers = JetTypeMapper.getAccessModifiers(propertyDescriptor, 0);
=======
        int modifiers = getVisibilityAccessFlag(propertyDescriptor);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419303429811/fstmerge_var2_6290966903092593964
        PropertySetterDescriptor setter = propertyDescriptor.getSetter();
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419303429811/fstmerge_var1_7670792151414058417
        int flags = setter == null ? modifiers : getAccessModifiers(setter, modifiers);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419303429811/fstmerge_base_7378308008014810662
        int flags = setter == null ? modifiers : JetTypeMapper.getAccessModifiers(setter, modifiers);
=======
        int flags = setter == null ? modifiers : getVisibilityAccessFlag(setter);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419303429811/fstmerge_var2_6290966903092593964
        flags |= (propertyDescriptor.getModality() == Modality.ABSTRACT ? ACC_ABSTRACT : 0);
        generateDefaultSetter(propertyDescriptor, flags, p);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d2d5f_5855c/rev_d2d5f-5855c/compiler/backend/src/org/jetbrains/jet/codegen/PropertyCodegen.java
Conflict type: LineBasedMCFd
Conflict body: 
private void generatedMethod(
            JetExpression bodyExpressions,
            JvmMethodSignature jvmSignature,
            boolean needJetAnnotations, @Nullable String propertyTypeSignature,
            CodegenContext.MethodContext context,
            FunctionDescriptor functionDescriptor,
            JetDeclarationWithBody fun
    ) {
        if (functionDescriptor.getKind() == CallableMemberDescriptor.Kind.FAKE_OVERRIDE) {
            throw new IllegalStateException("must not generate code for fake overrides");
        }

        List<ValueParameterDescriptor> paramDescrs = functionDescriptor.getValueParameters();

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419303430408/fstmerge_var1_3460346944826877693
        int flags = getAccessModifiers(functionDescriptor, 0);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419303430408/fstmerge_base_5909633371699811354
        int flags = JetTypeMapper.getAccessModifiers(functionDescriptor, 0);
=======
        int flags = getVisibilityAccessFlag(functionDescriptor);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419303430408/fstmerge_var2_3160285608689801657

        if (!functionDescriptor.getValueParameters().isEmpty()
            && functionDescriptor.getValueParameters().get(functionDescriptor.getValueParameters().size() - 1)
                       .getVarargElementType() != null) {
            flags |= ACC_VARARGS;
        }

        Modality modality = functionDescriptor.getModality();
        if (modality == Modality.FINAL) {
            DeclarationDescriptor containingDeclaration = functionDescriptor.getContainingDeclaration();
            if (!(containingDeclaration instanceof ClassDescriptor) ||
                ((ClassDescriptor) containingDeclaration).getKind() != ClassKind.TRAIT) {
                flags |= ACC_FINAL;
            }
        }

        OwnerKind kind = context.getContextKind();

        if (kind == OwnerKind.TRAIT_IMPL) {
            needJetAnnotations = false;
        }

        ReceiverDescriptor expectedThisObject = functionDescriptor.getExpectedThisObject();
        ReceiverDescriptor receiverParameter = functionDescriptor.getReceiverParameter();

        if (kind != OwnerKind.TRAIT_IMPL || bodyExpressions != null) {
            boolean isStatic = kind == OwnerKind.NAMESPACE || kind instanceof OwnerKind.StaticDelegateKind;
            if (isStatic || kind == OwnerKind.TRAIT_IMPL) {
                flags |= ACC_STATIC;
            }

            boolean isAbstract = (
                                         modality == Modality.ABSTRACT
                                         || isInterface(functionDescriptor.getContainingDeclaration())
                                 ) && !isStatic && kind != OwnerKind.TRAIT_IMPL;
            if (isAbstract) flags |= ACC_ABSTRACT;

            final MethodVisitor mv =
                    v.newMethod(fun, flags, jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor(),
                                jvmSignature.getGenericsSignature(), null);
            AnnotationCodegen.forMethod(mv, state.getInjector().getJetTypeMapper()).genAnnotations(functionDescriptor);
            if (state.getClassBuilderMode() != ClassBuilderMode.SIGNATURES) {
                int start = 0;
                if (needJetAnnotations) {
                    if (functionDescriptor instanceof PropertyAccessorDescriptor) {
                        PropertyCodegen.generateJetPropertyAnnotation(mv, propertyTypeSignature, jvmSignature.getKotlinTypeParameter(),
                                                                      ((PropertyAccessorDescriptor) functionDescriptor)
                                                                              .getCorrespondingProperty(),
                                                                      functionDescriptor.getVisibility());
                    }
                    else if (functionDescriptor instanceof SimpleFunctionDescriptor) {
                        if (propertyTypeSignature != null) {
                            throw new IllegalStateException();
                        }
                        JetMethodAnnotationWriter aw = JetMethodAnnotationWriter.visitAnnotation(mv);
                        BitSet kotlinFlags = getFlagsForVisibility(functionDescriptor.getVisibility());
                        if (isInterface(functionDescriptor.getContainingDeclaration()) && modality != Modality.ABSTRACT) {
                            kotlinFlags.set(modality == Modality.FINAL
                                            ? JvmStdlibNames.FLAG_FORCE_FINAL_BIT
                                            : JvmStdlibNames.FLAG_FORCE_OPEN_BIT);
                        }
                        aw.writeFlags(kotlinFlags);
                        aw.writeNullableReturnType(functionDescriptor.getReturnType().isNullable());
                        aw.writeTypeParameters(jvmSignature.getKotlinTypeParameter());
                        aw.writeReturnType(jvmSignature.getKotlinReturnType());
                        aw.visitEnd();
                    }
                    else {
                        throw new IllegalStateException();
                    }

                    if (receiverParameter.exists()) {
                        JetValueParameterAnnotationWriter av = JetValueParameterAnnotationWriter.visitParameterAnnotation(mv, start++);
                        av.writeName("this$receiver");
                        av.writeNullable(receiverParameter.getType().isNullable());
                        av.writeReceiver();
                        if (jvmSignature.getKotlinParameterTypes() != null && jvmSignature.getKotlinParameterTypes().get(0) != null) {
                            av.writeType(jvmSignature.getKotlinParameterTypes().get(0).getKotlinSignature());
                        }
                        av.visitEnd();
                    }
                    for (int i = 0; i != paramDescrs.size(); ++i) {
                        ValueParameterDescriptor parameterDescriptor = paramDescrs.get(i);
                        AnnotationCodegen.forParameter(i, mv, state.getInjector().getJetTypeMapper()).genAnnotations(parameterDescriptor);
                        JetValueParameterAnnotationWriter av = JetValueParameterAnnotationWriter.visitParameterAnnotation(mv, i + start);
                        av.writeName(parameterDescriptor.getName().getName());
                        av.writeHasDefaultValue(parameterDescriptor.declaresDefaultValue());
                        av.writeNullable(parameterDescriptor.getType().isNullable());
                        if (jvmSignature.getKotlinParameterTypes() != null && jvmSignature.getKotlinParameterTypes().get(i) != null) {
                            av.writeType(jvmSignature.getKotlinParameterTypes().get(i + start).getKotlinSignature());
                        }
                        av.visitEnd();
                    }
                }
            }

            if (!isAbstract && state.getClassBuilderMode() == ClassBuilderMode.STUBS) {
                StubCodegen.generateStubCode(mv);
            }


            if (!isAbstract && state.getClassBuilderMode() == ClassBuilderMode.FULL) {
                mv.visitCode();

                Label methodBegin = new Label();
                mv.visitLabel(methodBegin);

                FrameMap frameMap = context.prepareFrame(state.getInjector().getJetTypeMapper());

                ExpressionCodegen codegen =
                        new ExpressionCodegen(mv, frameMap, jvmSignature.getAsmMethod().getReturnType(), context, state);

                Type[] argTypes = jvmSignature.getAsmMethod().getArgumentTypes();
                int add = 0;

                if (kind == OwnerKind.TRAIT_IMPL) {
                    add++;
                }

                if (receiverParameter.exists()) {
                    add++;
                }

                for (int i = 0; i < paramDescrs.size(); i++) {
                    ValueParameterDescriptor parameter = paramDescrs.get(i);
                    frameMap.enter(parameter, argTypes[i + add]);
                }

                if (!isStatic &&
                    (kind instanceof OwnerKind.DelegateKind) != (functionDescriptor.getKind() == FunctionDescriptor.Kind.DELEGATION)) {
                    throw new IllegalStateException("mismatching kind in " + functionDescriptor);
                }

                Map<Name, Label> mapLabelsToDivideLocalVarVisibilityForSharedVar = new HashMap<Name, Label>();

                if (kind instanceof OwnerKind.StaticDelegateKind) {
                    OwnerKind.StaticDelegateKind dk = (OwnerKind.StaticDelegateKind) kind;
                    InstructionAdapter iv = new InstructionAdapter(mv);
                    for (int i = 0, k = 0; i < argTypes.length; i++) {
                        Type argType = argTypes[i];
                        iv.load(k, argType);
                        //noinspection AssignmentToForLoopParameter
                        k += argType.getSize();
                    }
                    iv.invokestatic(dk.getOwnerClass(), jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor());
                    iv.areturn(jvmSignature.getAsmMethod().getReturnType());
                }
                else if (kind instanceof OwnerKind.DelegateKind) {
                    OwnerKind.DelegateKind dk = (OwnerKind.DelegateKind) kind;
                    InstructionAdapter iv = new InstructionAdapter(mv);
                    iv.load(0, OBJECT_TYPE);
                    dk.getDelegate().put(OBJECT_TYPE, iv);
                    for (int i = 0; i < argTypes.length; i++) {
                        Type argType = argTypes[i];
                        iv.load(i + 1, argType);
                    }
                    iv.invokeinterface(dk.getOwnerClass(), jvmSignature.getAsmMethod().getName(),
                                       jvmSignature.getAsmMethod().getDescriptor());
                    iv.areturn(jvmSignature.getAsmMethod().getReturnType());
                }
                else {
                    for (ValueParameterDescriptor parameter : paramDescrs) {
                        Type sharedVarType = state.getInjector().getJetTypeMapper().getSharedVarType(parameter);
                        if (sharedVarType != null) {
                            Type localVarType = state.getInjector().getJetTypeMapper().mapType(parameter.getType(), MapTypeMode.VALUE);
                            int index = frameMap.getIndex(parameter);
                            mv.visitTypeInsn(NEW, sharedVarType.getInternalName());
                            mv.visitInsn(DUP);
                            mv.visitInsn(DUP);
                            mv.visitMethodInsn(INVOKESPECIAL, sharedVarType.getInternalName(), "<init>", "()V");
                            mv.visitVarInsn(localVarType.getOpcode(ILOAD), index);
                            mv.visitFieldInsn(PUTFIELD, sharedVarType.getInternalName(), "ref",
                                              StackValue.refType(localVarType).getDescriptor());

                            Label labelToDivideLocalVarForSharedVarVisibility = new Label();
                            mv.visitLabel(labelToDivideLocalVarForSharedVarVisibility);
                            mapLabelsToDivideLocalVarVisibilityForSharedVar
                                    .put(parameter.getName(), labelToDivideLocalVarForSharedVarVisibility);

                            mv.visitVarInsn(sharedVarType.getOpcode(ISTORE), index);
                        }
                    }

                    codegen.returnExpression(bodyExpressions);
                }

                Label methodEnd = new Label();
                mv.visitLabel(methodEnd);

                Collection<String> localVariableNames = new HashSet<String>();
                localVariableNames.addAll(codegen.getLocalVariableNamesForExpression());
                for (ValueParameterDescriptor parameterDescriptor : paramDescrs) {
                    localVariableNames.add(parameterDescriptor.getName().getName());
                }

                int k = 0;

                if (expectedThisObject.exists()) {
                    Type type = state.getInjector().getJetTypeMapper().mapType(expectedThisObject.getType(), MapTypeMode.VALUE);
                    // TODO: specify signature
                    mv.visitLocalVariable("this", type.getDescriptor(), null, methodBegin, methodEnd, k++);
                }
                else if (fun instanceof JetFunctionLiteralExpression ||
                         isLocalFun(state.getBindingContext(), functionDescriptor)) {
                    Type type = state.getInjector().getJetTypeMapper().mapType(
                            context.getThisDescriptor().getDefaultType(), MapTypeMode.VALUE);
                    mv.visitLocalVariable("this", type.getDescriptor(), null, methodBegin, methodEnd, k++);
                }

                if (receiverParameter.exists()) {
                    Type type = state.getInjector().getJetTypeMapper().mapType(receiverParameter.getType(), MapTypeMode.VALUE);
                    // TODO: specify signature
                    mv.visitLocalVariable("this$receiver", type.getDescriptor(), null, methodBegin, methodEnd, k);
                    k += type.getSize();
                }

                for (ValueParameterDescriptor parameter : paramDescrs) {
                    Type type = state.getInjector().getJetTypeMapper().mapType(parameter.getType(), MapTypeMode.VALUE);
                    // TODO: specify signature

                    Label divideLabel = mapLabelsToDivideLocalVarVisibilityForSharedVar.get(parameter.getName());
                    String parameterName = parameter.getName().getName();
                    if (divideLabel != null) {
                        Type sharedVarType = state.getInjector().getJetTypeMapper().getSharedVarType(parameter);
                        mv.visitLocalVariable(parameterName, type.getDescriptor(), null, methodBegin, divideLabel, k);

                        String nameForSharedVar = generateTmpVariableName(localVariableNames);
                        localVariableNames.add(nameForSharedVar);

                        mv.visitLocalVariable(nameForSharedVar, sharedVarType.getDescriptor(), null, divideLabel, methodEnd, k);
                        k += Math.max(type.getSize(), sharedVarType.getSize());
                    }
                    else {
                        mv.visitLocalVariable(parameter.getName().getName(), type.getDescriptor(), null, methodBegin, methodEnd, k);
                        k += type.getSize();
                    }
                }

                endVisit(mv, null, fun);

                generateBridgeIfNeeded(owner, state, v, jvmSignature.getAsmMethod(), functionDescriptor, kind);
            }
        }

        generateDefaultIfNeeded(context, state, v, jvmSignature.getAsmMethod(), functionDescriptor, kind);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d2d5f_5855c/rev_d2d5f-5855c/compiler/backend/src/org/jetbrains/jet/codegen/FunctionCodegen.java
Conflict type: LineBasedMCFd
Conflict body: 
protected void generatePrimaryConstructor() {
        if (ignoreIfTraitOrAnnotation()) return;

        if (kind != OwnerKind.IMPLEMENTATION) {
            throw new IllegalStateException("incorrect kind for primary constructor: " + kind);
        }

        ConstructorDescriptor constructorDescriptor = bindingContext.get(BindingContext.CONSTRUCTOR, myClass);

        final CodegenContext.ConstructorContext constructorContext = context.intoConstructor(constructorDescriptor);

        lookupConstructorExpressionsInClosureIfPresent(constructorContext);

        MutableClosure closure = context.closure;
        boolean hasThis0 = closure != null && closure.getCaptureThis() != null;

        final CallableMethod callableMethod = typeMapper.mapToCallableMethod(constructorDescriptor, context.closure);
        final JvmMethodSignature constructorMethod = callableMethod.getSignature();

        assert constructorDescriptor != null;
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419303430548/fstmerge_var1_7840970519097391165
        int flags = getAccessModifiers(constructorDescriptor, 0);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419303430548/fstmerge_base_5929477398992924894
        int flags = JetTypeMapper.getAccessModifiers(constructorDescriptor, 0);
=======
        int flags = getVisibilityAccessFlag(constructorDescriptor);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419303430548/fstmerge_var2_6572031457254780998
        final MethodVisitor mv = v.newMethod(myClass, flags, constructorMethod.getName(), constructorMethod.getAsmMethod().getDescriptor(),
                                             constructorMethod.getGenericsSignature(), null);
        if (state.getClassBuilderMode() == ClassBuilderMode.SIGNATURES) return;

        AnnotationVisitor jetConstructorVisitor = mv.visitAnnotation(JvmStdlibNames.JET_CONSTRUCTOR.getDescriptor(), true);

        int flagsValue = BitSetUtils.toInt(getFlagsForVisibility(constructorDescriptor.getVisibility()));
        if (JvmStdlibNames.FLAGS_DEFAULT_VALUE != flagsValue) {
            jetConstructorVisitor.visit(JvmStdlibNames.JET_CLASS_FLAGS_FIELD, flagsValue);
        }

        jetConstructorVisitor.visitEnd();

        AnnotationCodegen.forMethod(mv, typeMapper).genAnnotations(constructorDescriptor);

        writeParameterAnnotations(constructorDescriptor, constructorMethod, hasThis0, mv);

        if (state.getClassBuilderMode() == ClassBuilderMode.STUBS) {
            StubCodegen.generateStubCode(mv);
            return;
        }

        generatePrimiryConstructorImpl(constructorDescriptor, constructorContext, constructorMethod, callableMethod, hasThis0, closure, mv);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d2d5f_5855c/rev_d2d5f-5855c/compiler/backend/src/org/jetbrains/jet/codegen/ImplementationBodyCodegen.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_8c1f4_b7b0d/rev_8c1f4-b7b0d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6e951_454ad/rev_6e951-454ad.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_a2458_58c1c/rev_a2458-58c1c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_645b7_56477/rev_645b7-56477.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_95489_475d5/rev_95489-475d5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_28160_81de3/rev_28160-81de3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_2dd47_aca74/rev_2dd47-aca74.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3a9ed_932d2/rev_3a9ed-932d2.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_29068_47f6a/rev_29068-47f6a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_52d25_e37cb/rev_52d25-e37cb.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d385c_07a25/rev_d385c-07a25.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_649cb_9f546/rev_649cb-9f546.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_a6468_1f4dd/rev_a6468-1f4dd.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_58a8c_3d4a5/rev_58a8c-3d4a5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_34c22_70795/rev_34c22-70795.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_23ce1_c53b8/rev_23ce1-c53b8.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e4a17_8ef06/rev_e4a17-8ef06.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_bc59e_89017/rev_bc59e-89017.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_31480_c93df/rev_31480-c93df.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b39d3_6f31f/rev_b39d3-6f31f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_cd566_e5327/rev_cd566-e5327.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3b6ad_79bf1/rev_3b6ad-79bf1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b9fc6_13d85/rev_b9fc6-13d85.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b93f7_16aa4/rev_b93f7-16aa4.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_a34a6_1dce3/rev_a34a6-1dce3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0543b_1d08b/rev_0543b-1d08b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b74ae_f2b3b/rev_b74ae-f2b3b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d396c_edbbc/rev_d396c-edbbc.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d44fd_a4c02/rev_d44fd-a4c02.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_9b11d_267bb/rev_9b11d-267bb.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_76ede_4c917/rev_76ede-4c917.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_7761d_1a5c9/rev_7761d-1a5c9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0514d_aa199/rev_0514d-aa199.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_4bf71_868bf/rev_4bf71-868bf.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_5429c_3b72b/rev_5429c-3b72b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_acbcc_fc3a4/rev_acbcc-fc3a4.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@NotNull
    public static JetMultiDeclarationEntry getMultiDeclarationEntryThatTypeMismatchComponentFunction(Diagnostic diagnostic) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419319637870/fstmerge_var1_3139144673850421
        @SuppressWarnings("unchecked")
        String componentName = ((DiagnosticWithParameters3<JetExpression, Name, JetType, JetType>) diagnostic).getA().asString();
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419319637870/fstmerge_base_3879362949550759197
        String componentName = ((DiagnosticWithParameters3<JetExpression, Name, JetType, JetType>) diagnostic).getA().getName();
=======
        String componentName = ((DiagnosticWithParameters3<JetExpression, Name, JetType, JetType>) diagnostic).getA().asString();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419319637870/fstmerge_var2_8153332011829599441
        int componentIndex = Integer.valueOf(componentName.substring(DescriptorResolver.COMPONENT_FUNCTION_NAME_PREFIX.length()));
        JetMultiDeclaration multiDeclaration = QuickFixUtil.getParentElementOfType(diagnostic, JetMultiDeclaration.class);
        assert multiDeclaration != null : "COMPONENT_FUNCTION_RETURN_TYPE_MISMATCH reported on expression that is not within any multi declaration";
        return multiDeclaration.getEntries().get(componentIndex - 1);
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_acbcc_fc3a4/rev_acbcc-fc3a4/idea/src/org/jetbrains/jet/plugin/quickfix/ChangeFunctionReturnTypeFix.java
Conflict type: SameSignatureCM
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419319638323/fstmerge_var1_8357437820566150807
public static JetIntentionActionsFactory createFactory() {
        return new JetSingleIntentionActionFactory() {
            @Nullable
            @Override
            public IntentionAction createAction(Diagnostic diagnostic) {
                JetNamedFunction function = QuickFixUtil.getParentElementOfType(diagnostic, JetNamedFunction.class);
                return function == null ? null : new AddFunctionToSupertypeFix(function);
            }
        };
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419319638323/fstmerge_base_7973864819095306629
=======
public static JetIntentionActionFactory createFactory() {
        return new JetIntentionActionFactory() {
            @Nullable
            @Override
            public IntentionAction createAction(Diagnostic diagnostic) {
                JetNamedFunction function = QuickFixUtil.getParentElementOfType(diagnostic, JetNamedFunction.class);
                return function == null ? null : new AddFunctionToSupertypeFix(function);
            }
        };
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419319638323/fstmerge_var2_7243619866610324017

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_acbcc_fc3a4/rev_acbcc-fc3a4/idea/src/org/jetbrains/jet/plugin/quickfix/AddFunctionToSupertypeFix.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_7e564_84291/rev_7e564-84291.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ef2af_2f554/rev_ef2af-2f554.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_26a6a_8f24d/rev_26a6a-8f24d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b2cca_9c29c/rev_b2cca-9c29c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_8df51_0ccb1/rev_8df51-0ccb1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_79e7c_cd6b6/rev_79e7c-cd6b6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d2b1b_1565a/rev_d2b1b-1565a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_33efb_a1309/rev_33efb-a1309.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_40546_2436e/rev_40546-2436e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6ce92_adcb3/rev_6ce92-adcb3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_f99f4_04e39/rev_f99f4-04e39.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_846de_5a383/rev_846de-5a383.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_dd42b_c35f7/rev_dd42b-c35f7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_32c34_9e7aa/rev_32c34-9e7aa.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_a3bfd_723d5/rev_a3bfd-723d5.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_cc47f_839df/rev_cc47f-839df.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_aaf31_24fde/rev_aaf31-24fde.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_30bf2_a4f29/rev_30bf2-a4f29.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d3eb2_2c93a/rev_d3eb2-2c93a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0c447_2888a/rev_0c447-2888a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_bf36e_ff400/rev_bf36e-ff400.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_afde1_bd407/rev_afde1-bd407.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_a2ba7_18f4a/rev_a2ba7-18f4a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_95446_453b0/rev_95446-453b0.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_cfca7_5fb81/rev_cfca7-5fb81.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b8d4d_2c61f/rev_b8d4d-2c61f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c6052_7cf58/rev_c6052-7cf58.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_44234_86767/rev_44234-86767.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_9f901_b9991/rev_9f901-b9991.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3e451_7c891/rev_3e451-7c891.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0be6e_6755a/rev_0be6e-6755a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_68da8_32286/rev_68da8-32286.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_84a89_7fb9d/rev_84a89-7fb9d.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_856e3_209f7/rev_856e3-209f7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b7002_f1d2c/rev_b7002-f1d2c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_877b9_0045e/rev_877b9-0045e.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0b694_a9d35/rev_0b694-a9d35.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_d1984_2a724/rev_d1984-2a724.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_371df_a6a1b/rev_371df-a6a1b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_82a25_0d61f/rev_82a25-0d61f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_eb3dd_8777a/rev_eb3dd-8777a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_216ea_c32bb/rev_216ea-c32bb.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0feb0_32651/rev_0feb0-32651.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_32860_cfc16/rev_32860-cfc16.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_86792_f6a4c/rev_86792-f6a4c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6de11_ed7a1/rev_6de11-ed7a1.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_b9e24_d28ca/rev_b9e24-d28ca.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6feee_feece/rev_6feee-feece.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_3713f_19aa3/rev_3713f-19aa3.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ab2ca_98532/rev_ab2ca-98532.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_65e67_fe9de/rev_65e67-fe9de.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_4bcfe_caeb9/rev_4bcfe-caeb9.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0032f_4678a/rev_0032f-4678a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_6df80_4463c/rev_6df80-4463c.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_20931_f6129/rev_20931-f6129.revisions
Conflict type: LineBasedMCFd
Conflict body: 
@Nullable
    public JetScope createKotlinPackageScope(@NotNull PackageFragmentDescriptor descriptor, @NotNull KotlinJvmBinaryClass kotlinClass) {
        String[] data = readData(kotlinClass, PACKAGE_FACADE);
        if (data != null) {
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370917318/fstmerge_var1_3154927448890713492
            return new DeserializedPackageMemberScope(descriptor, JavaProtoBufUtil.readPackageDataFrom(data), context);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370917318/fstmerge_base_4926562738392850810
            return new DeserializedPackageMemberScope(storageManager, descriptor, deserializers,
                                                      memberFilter, javaDescriptorFinder, JavaProtoBufUtil.readPackageDataFrom(data));
=======
            return new DeserializedPackageMemberScope(storageManager, descriptor, deserializers,
                                                      javaDescriptorFinder, JavaProtoBufUtil.readPackageDataFrom(data));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370917318/fstmerge_var2_5908236400101798092
        }
        return null;
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_20931_f6129/rev_20931-f6129/core/descriptor.loader.java/src/org/jetbrains/jet/lang/resolve/kotlin/DeserializedDescriptorResolver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370923376/fstmerge_var1_7509965627296822002
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370923376/fstmerge_base_7076344389787786330
protected DeserializedMemberScope(
            @NotNull StorageManager storageManager,
            @NotNull DeclarationDescriptor containingDeclaration,
            @NotNull DescriptorDeserializer deserializer,
            @NotNull Collection<ProtoBuf.Callable> membersList
    ) {
        this.containingDeclaration = containingDeclaration;
        this.deserializer = deserializer;

        this.membersProtos = groupByName(membersList);
        this.functions = storageManager.createMemoizedFunction(new Function1<Name, Collection<FunctionDescriptor>>() {
            @Override
            public Collection<FunctionDescriptor> invoke(Name name) {
                return computeFunctions(name);
            }
        });
        this.properties = storageManager.createMemoizedFunction(new Function1<Name, Collection<VariableDescriptor>>() {
            @Override
            public Collection<VariableDescriptor> invoke(Name name) {
                return computeProperties(name);
            }
        });
        this.allDescriptors = storageManager.createLazyValue(new Function0<Collection<DeclarationDescriptor>>() {
            @Override
            public Collection<DeclarationDescriptor> invoke() {
                return computeAllDescriptors();
            }
        });
    }
=======
protected DeserializedMemberScope(
            @NotNull StorageManager storageManager,
            @NotNull DeclarationDescriptor containingDeclaration,
            @NotNull DescriptorDeserializer deserializer,
            @NotNull final Collection<ProtoBuf.Callable> membersList
    ) {
        this.containingDeclaration = containingDeclaration;
        this.deserializer = deserializer;

        this.membersProtos = storageManager.createLazyValue(new Function0<Map<Name, List<ProtoBuf.Callable>>>() {
            @Override
            public Map<Name, List<ProtoBuf.Callable>> invoke() {
                return groupByName(filteredMemberProtos(membersList));
            }
        });
        this.functions = storageManager.createMemoizedFunction(new Function1<Name, Collection<FunctionDescriptor>>() {
            @Override
            public Collection<FunctionDescriptor> invoke(Name name) {
                return computeFunctions(name);
            }
        });
        this.properties = storageManager.createMemoizedFunction(new Function1<Name, Collection<VariableDescriptor>>() {
            @Override
            public Collection<VariableDescriptor> invoke(Name name) {
                return computeProperties(name);
            }
        });
        this.allDescriptors = storageManager.createLazyValue(new Function0<Collection<DeclarationDescriptor>>() {
            @Override
            public Collection<DeclarationDescriptor> invoke() {
                return computeAllDescriptors();
            }
        });
    }
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370923376/fstmerge_var2_8840442884587110377

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_20931_f6129/rev_20931-f6129/core/serialization/src/org/jetbrains/jet/descriptors/serialization/descriptors/DeserializedMemberScope.java
Conflict type: LineBasedMCFd
Conflict body: 
public BuiltinsPackageFragment(@NotNull StorageManager storageManager, @NotNull ModuleDescriptor module) {
        super(module, KotlinBuiltIns.BUILT_INS_PACKAGE_FQ_NAME);
        nameResolver = NameSerializationUtil.deserializeNameResolver(getStream(BuiltInsSerializationUtil.getNameTableFilePath(getFqName())));

        packageFragmentProvider = new BuiltinsPackageFragmentProvider();

<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370927338/fstmerge_var1_2259395755379446223
        DeserializationContext context = new DeserializationContext(
                storageManager, new BuiltInsDescriptorFinder(storageManager),
                // TODO: support annotations
                AnnotationLoader.UNSUPPORTED, ConstantLoader.UNSUPPORTED, packageFragmentProvider,
                MemberFilter.ALWAYS_TRUE, nameResolver
        );
        members = new DeserializedPackageMemberScope(this, loadPackage(), context);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370927338/fstmerge_base_8911230864692987923
        // TODO: support annotations
        members = new DeserializedPackageMemberScope(storageManager, this, Deserializers.UNSUPPORTED, MemberFilter.ALWAYS_TRUE,
                                                     new BuiltInsDescriptorFinder(storageManager), loadPackage(), nameResolver);
=======
        // TODO: support annotations
        members = new DeserializedPackageMemberScope(storageManager, this, Deserializers.UNSUPPORTED,
                                                     new BuiltInsDescriptorFinder(storageManager), new PackageData(nameResolver, loadPackage()));
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370927338/fstmerge_var2_3639749351096521887
    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_20931_f6129/rev_20931-f6129/core/descriptors/src/org/jetbrains/jet/lang/types/lang/BuiltinsPackageFragment.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370932842/fstmerge_var1_9039153412000571115
@Nullable
    public static File generateModuleDescription(
            CompileContext context,
            ModuleChunk chunk,
            List<File> sourceFiles // ignored for non-incremental compilation
    )
            throws IOException
    {
        KotlinModuleDescriptionBuilder builder = FACTORY.create();

        boolean noSources = true;

        Set<File> outputDirs = new HashSet<File>();
        for (ModuleBuildTarget target : chunk.getTargets()) {
            outputDirs.add(getOutputDir(target));
        }
        ProjectBuilderLogger logger = context.getLoggingManager().getProjectBuilderLogger();
        for (ModuleBuildTarget target : chunk.getTargets()) {
            File outputDir = getOutputDir(target);

            if (!IncrementalCompilation.ENABLED) {
                sourceFiles = new ArrayList<File>(KotlinSourceFileCollector.getAllKotlinSourceFiles(target));
            }

            if (sourceFiles.size() > 0) {
                noSources = false;

                if (logger.isEnabled()) {
                    logger.logCompiledFiles(sourceFiles, KotlinBuilder.KOTLIN_BUILDER_NAME, "Compiling files:");
                }
            }

            builder.addModule(
                    target.getId(),
                    outputDir.getAbsolutePath(),
                    getKotlinModuleDependencies(context, target),
                    sourceFiles,
                    target.isTests(),
                    // this excludes the output directories from the class path, to be removed for true incremental compilation
                    outputDirs
            );
        }

        if (noSources) return null;

        File scriptFile = File.createTempFile("kjps", StringUtil.sanitizeJavaIdentifier(chunk.getName()) + ".script.xml");

        writeScriptToFile(context, builder.asText(), scriptFile);

        return scriptFile;
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370932842/fstmerge_base_6347416897057242097
@Nullable
    public static File generateModuleDescription(
            CompileContext context,
            ModuleChunk chunk,
            List<File> sourceFiles // ignored for non-incremental compilation
    )
            throws IOException
    {
        KotlinModuleDescriptionBuilder builder = FACTORY.create();

        boolean noSources = true;

        Set<File> outputDirs = new HashSet<File>();
        for (ModuleBuildTarget target : chunk.getTargets()) {
            outputDirs.add(getOutputDir(target));
        }
        ProjectBuilderLogger logger = context.getLoggingManager().getProjectBuilderLogger();
        for (ModuleBuildTarget target : chunk.getTargets()) {
            File outputDir = getOutputDir(target);

            if (!IncrementalCompilation.ENABLED) {
                sourceFiles = new ArrayList<File>(KotlinSourceFileCollector.getAllKotlinSourceFiles(target));
            }

            if (sourceFiles.size() > 0) {
                noSources = false;

                if (logger.isEnabled()) {
                    logger.logCompiledFiles(sourceFiles, KotlinBuilder.KOTLIN_BUILDER_NAME, "Compiling files:");
                }
            }

            builder.addModule(
                    target.getId(),
                    outputDir.getAbsolutePath(),
                    getKotlinModuleDependencies(context, target),
                    sourceFiles,
                    target.isTests(),
                    // this excludes the output directories from the class path, to be removed for true incremental compilation
                    outputDirs
            );
        }

        if (noSources) return null;

        String scriptFilename = context.getProjectDescriptor().dataManager.getDataPaths().getDataStorageRoot().getName()
                   + "#" + StringUtil.sanitizeJavaIdentifier(chunk.getName());
        File scriptFile = new File(PathManager.getTempPath() + File.separator + scriptFilename + ".script." + FACTORY.getFileExtension());

        writeScriptToFile(context, builder.asText(), scriptFile);

        return scriptFile;
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370932842/fstmerge_var2_8689367937062427987

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_20931_f6129/rev_20931-f6129/jps-plugin/src/org/jetbrains/jet/jps/build/KotlinBuilderModuleScriptGenerator.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370938637/fstmerge_var1_3940858238944411150
public InjectorForTopDownAnalyzerForJvm(
        @NotNull Project project,
        @NotNull GlobalContext globalContext,
        @NotNull BindingTrace bindingTrace,
        @NotNull ModuleDescriptor moduleDescriptor,
        @NotNull MemberFilter memberFilter
    ) {
        this.project = project;
        this.globalContext = globalContext;
        this.storageManager = globalContext.getStorageManager();
        this.bindingTrace = bindingTrace;
        this.moduleDescriptor = moduleDescriptor;
        this.platformToKotlinClassMap = moduleDescriptor.getPlatformToKotlinClassMap();
        this.topDownAnalyzer = new TopDownAnalyzer();
        this.lazyTopDownAnalyzer = new LazyTopDownAnalyzer();
        this.mutablePackageFragmentProvider = new MutablePackageFragmentProvider(getModuleDescriptor());
        this.memberFilter = memberFilter;
        this.javaClassFinder = new JavaClassFinderImpl();
        this.virtualFileFinder = org.jetbrains.jet.lang.resolve.kotlin.VirtualFileFinder.SERVICE.getInstance(project);
        this.deserializedDescriptorResolver = new DeserializedDescriptorResolver();
        this.psiBasedExternalAnnotationResolver = new PsiBasedExternalAnnotationResolver();
        this.traceBasedExternalSignatureResolver = new TraceBasedExternalSignatureResolver();
        this.traceBasedErrorReporter = new TraceBasedErrorReporter();
        this.psiBasedMethodSignatureChecker = new PsiBasedMethodSignatureChecker();
        this.traceBasedJavaResolverCache = new TraceBasedJavaResolverCache();
        this.javaPropertyInitializerEvaluator = new JavaPropertyInitializerEvaluatorImpl();
        this.globalJavaResolverContext = new GlobalJavaResolverContext(storageManager, javaClassFinder, virtualFileFinder, deserializedDescriptorResolver, psiBasedExternalAnnotationResolver, traceBasedExternalSignatureResolver, traceBasedErrorReporter, psiBasedMethodSignatureChecker, traceBasedJavaResolverCache, javaPropertyInitializerEvaluator);
        this.lazyJavaPackageFragmentProvider = new LazyJavaPackageFragmentProvider(globalJavaResolverContext, getModuleDescriptor());
        this.javaDescriptorResolver = new JavaDescriptorResolver(lazyJavaPackageFragmentProvider, getModuleDescriptor());
        this.bodyResolver = new BodyResolver();
        this.annotationResolver = new AnnotationResolver();
        this.callResolver = new CallResolver();
        this.argumentTypeResolver = new ArgumentTypeResolver();
        this.expressionTypingComponents = new ExpressionTypingComponents();
        this.expressionTypingServices = new ExpressionTypingServices(expressionTypingComponents);
        this.controlStructureTypingUtils = new ControlStructureTypingUtils(expressionTypingServices);
        this.expressionTypingUtils = new ExpressionTypingUtils(expressionTypingServices, callResolver);
        this.forLoopConventionsChecker = new ForLoopConventionsChecker();
        this.reflectionTypes = new ReflectionTypes(getModuleDescriptor());
        this.callExpressionResolver = new CallExpressionResolver();
        this.descriptorResolver = new DescriptorResolver();
        this.delegatedPropertyResolver = new DelegatedPropertyResolver();
        this.typeResolver = new TypeResolver();
        this.qualifiedExpressionResolver = new QualifiedExpressionResolver();
        this.callResolverExtensionProvider = new CallResolverExtensionProvider();
        this.candidateResolver = new CandidateResolver();
        this.controlFlowAnalyzer = new ControlFlowAnalyzer();
        this.declarationsChecker = new DeclarationsChecker();
        this.functionAnalyzerExtension = new FunctionAnalyzerExtension();
        this.scriptBodyResolver = new ScriptBodyResolver();
        this.declarationResolver = new DeclarationResolver();
        this.importsResolver = new ImportsResolver();
        this.jetImportsFactory = new JetImportsFactory();
        this.overloadResolver = new OverloadResolver();
        this.overrideResolver = new OverrideResolver();
        this.typeHierarchyResolver = new TypeHierarchyResolver();
        this.scriptHeaderResolver = new ScriptHeaderResolver();
        this.javaDescriptorFinder = new JavaDescriptorFinder(getJavaDescriptorResolver(), lazyJavaPackageFragmentProvider);
        this.annotationDescriptorLoader = new AnnotationDescriptorLoader();
        this.constantDescriptorLoader = new ConstantDescriptorLoader();
        this.deserializationGlobalContextForJava = new DeserializationGlobalContextForJava(storageManager, javaDescriptorFinder, annotationDescriptorLoader, constantDescriptorLoader, lazyJavaPackageFragmentProvider, memberFilter);
        this.descriptorDeserializersStorage = new DescriptorDeserializersStorage(storageManager);

        this.topDownAnalyzer.setBodyResolver(bodyResolver);
        this.topDownAnalyzer.setDeclarationResolver(declarationResolver);
        this.topDownAnalyzer.setLazyTopDownAnalyzer(lazyTopDownAnalyzer);
        this.topDownAnalyzer.setModuleDescriptor(moduleDescriptor);
        this.topDownAnalyzer.setOverloadResolver(overloadResolver);
        this.topDownAnalyzer.setOverrideResolver(overrideResolver);
        this.topDownAnalyzer.setPackageFragmentProvider(mutablePackageFragmentProvider);
        this.topDownAnalyzer.setProject(project);
        this.topDownAnalyzer.setTrace(bindingTrace);
        this.topDownAnalyzer.setTypeHierarchyResolver(typeHierarchyResolver);

        this.lazyTopDownAnalyzer.setBodyResolver(bodyResolver);
        this.lazyTopDownAnalyzer.setDeclarationResolver(declarationResolver);
        this.lazyTopDownAnalyzer.setModuleDescriptor(moduleDescriptor);
        this.lazyTopDownAnalyzer.setOverloadResolver(overloadResolver);
        this.lazyTopDownAnalyzer.setOverrideResolver(overrideResolver);
        this.lazyTopDownAnalyzer.setTrace(bindingTrace);

        javaClassFinder.setProject(project);

        traceBasedExternalSignatureResolver.setExternalAnnotationResolver(psiBasedExternalAnnotationResolver);
        traceBasedExternalSignatureResolver.setProject(project);
        traceBasedExternalSignatureResolver.setTrace(bindingTrace);

        traceBasedJavaResolverCache.setTrace(bindingTrace);

        traceBasedErrorReporter.setTrace(bindingTrace);

        psiBasedMethodSignatureChecker.setExternalAnnotationResolver(psiBasedExternalAnnotationResolver);
        psiBasedMethodSignatureChecker.setExternalSignatureResolver(traceBasedExternalSignatureResolver);

        bodyResolver.setAnnotationResolver(annotationResolver);
        bodyResolver.setCallResolver(callResolver);
        bodyResolver.setControlFlowAnalyzer(controlFlowAnalyzer);
        bodyResolver.setDeclarationsChecker(declarationsChecker);
        bodyResolver.setDelegatedPropertyResolver(delegatedPropertyResolver);
        bodyResolver.setExpressionTypingServices(expressionTypingServices);
        bodyResolver.setFunctionAnalyzerExtension(functionAnalyzerExtension);
        bodyResolver.setScriptBodyResolverResolver(scriptBodyResolver);
        bodyResolver.setTrace(bindingTrace);

        annotationResolver.setCallResolver(callResolver);
        annotationResolver.setStorageManager(storageManager);
        annotationResolver.setTypeResolver(typeResolver);

        callResolver.setArgumentTypeResolver(argumentTypeResolver);
        callResolver.setCandidateResolver(candidateResolver);
        callResolver.setExpressionTypingServices(expressionTypingServices);
        callResolver.setTypeResolver(typeResolver);

        argumentTypeResolver.setExpressionTypingServices(expressionTypingServices);
        argumentTypeResolver.setTypeResolver(typeResolver);

        expressionTypingServices.setAnnotationResolver(annotationResolver);
        expressionTypingServices.setCallExpressionResolver(callExpressionResolver);
        expressionTypingServices.setCallResolver(callResolver);
        expressionTypingServices.setDescriptorResolver(descriptorResolver);
        expressionTypingServices.setExtensionProvider(callResolverExtensionProvider);
        expressionTypingServices.setProject(project);
        expressionTypingServices.setTypeResolver(typeResolver);

        expressionTypingComponents.setCallResolver(callResolver);
        expressionTypingComponents.setControlStructureTypingUtils(controlStructureTypingUtils);
        expressionTypingComponents.setExpressionTypingServices(expressionTypingServices);
        expressionTypingComponents.setExpressionTypingUtils(expressionTypingUtils);
        expressionTypingComponents.setForLoopConventionsChecker(forLoopConventionsChecker);
        expressionTypingComponents.setGlobalContext(globalContext);
        expressionTypingComponents.setPlatformToKotlinClassMap(platformToKotlinClassMap);
        expressionTypingComponents.setReflectionTypes(reflectionTypes);

        forLoopConventionsChecker.setExpressionTypingServices(expressionTypingServices);
        forLoopConventionsChecker.setExpressionTypingUtils(expressionTypingUtils);
        forLoopConventionsChecker.setProject(project);

        callExpressionResolver.setExpressionTypingServices(expressionTypingServices);

        descriptorResolver.setAnnotationResolver(annotationResolver);
        descriptorResolver.setDelegatedPropertyResolver(delegatedPropertyResolver);
        descriptorResolver.setExpressionTypingServices(expressionTypingServices);
        descriptorResolver.setStorageManager(storageManager);
        descriptorResolver.setTypeResolver(typeResolver);

        delegatedPropertyResolver.setCallResolver(callResolver);
        delegatedPropertyResolver.setExpressionTypingServices(expressionTypingServices);

        typeResolver.setAnnotationResolver(annotationResolver);
        typeResolver.setModuleDescriptor(moduleDescriptor);
        typeResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);

        candidateResolver.setArgumentTypeResolver(argumentTypeResolver);

        controlFlowAnalyzer.setTrace(bindingTrace);

        declarationsChecker.setDescriptorResolver(descriptorResolver);
        declarationsChecker.setTrace(bindingTrace);

        functionAnalyzerExtension.setTrace(bindingTrace);

        scriptBodyResolver.setExpressionTypingServices(expressionTypingServices);

        declarationResolver.setAnnotationResolver(annotationResolver);
        declarationResolver.setDescriptorResolver(descriptorResolver);
        declarationResolver.setImportsResolver(importsResolver);
        declarationResolver.setTrace(bindingTrace);

        importsResolver.setImportsFactory(jetImportsFactory);
        importsResolver.setModuleDescriptor(moduleDescriptor);
        importsResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);
        importsResolver.setTrace(bindingTrace);

        jetImportsFactory.setProject(project);

        overloadResolver.setTrace(bindingTrace);

        overrideResolver.setTrace(bindingTrace);

        typeHierarchyResolver.setDescriptorResolver(descriptorResolver);
        typeHierarchyResolver.setImportsResolver(importsResolver);
        typeHierarchyResolver.setPackageFragmentProvider(mutablePackageFragmentProvider);
        typeHierarchyResolver.setScriptHeaderResolver(scriptHeaderResolver);
        typeHierarchyResolver.setTrace(bindingTrace);

        scriptHeaderResolver.setPackageFragmentProvider(mutablePackageFragmentProvider);
        scriptHeaderResolver.setTrace(bindingTrace);

        deserializedDescriptorResolver.setContext(deserializationGlobalContextForJava);
        deserializedDescriptorResolver.setErrorReporter(traceBasedErrorReporter);

        annotationDescriptorLoader.setClassResolver(javaDescriptorResolver);
        annotationDescriptorLoader.setErrorReporter(traceBasedErrorReporter);
        annotationDescriptorLoader.setKotlinClassFinder(virtualFileFinder);
        annotationDescriptorLoader.setStorage(descriptorDeserializersStorage);

        descriptorDeserializersStorage.setClassResolver(javaDescriptorResolver);
        descriptorDeserializersStorage.setErrorReporter(traceBasedErrorReporter);

        constantDescriptorLoader.setClassResolver(javaDescriptorResolver);
        constantDescriptorLoader.setErrorReporter(traceBasedErrorReporter);
        constantDescriptorLoader.setKotlinClassFinder(virtualFileFinder);
        constantDescriptorLoader.setStorage(descriptorDeserializersStorage);

        javaClassFinder.initialize();

    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370938637/fstmerge_base_5188360899507842332
public InjectorForTopDownAnalyzerForJvm(
        @NotNull Project project,
        @NotNull GlobalContext globalContext,
        @NotNull BindingTrace bindingTrace,
        @NotNull ModuleDescriptor moduleDescriptor,
        @NotNull MemberFilter memberFilter
    ) {
        this.project = project;
        this.globalContext = globalContext;
        this.storageManager = globalContext.getStorageManager();
        this.bindingTrace = bindingTrace;
        this.moduleDescriptor = moduleDescriptor;
        this.platformToKotlinClassMap = moduleDescriptor.getPlatformToKotlinClassMap();
        this.topDownAnalyzer = new TopDownAnalyzer();
        this.lazyTopDownAnalyzer = new LazyTopDownAnalyzer();
        this.mutablePackageFragmentProvider = new MutablePackageFragmentProvider(getModuleDescriptor());
        this.memberFilter = memberFilter;
        this.javaClassFinder = new JavaClassFinderImpl();
        this.virtualFileFinder = org.jetbrains.jet.lang.resolve.kotlin.VirtualFileFinder.SERVICE.getInstance(project);
        this.deserializedDescriptorResolver = new DeserializedDescriptorResolver();
        this.psiBasedExternalAnnotationResolver = new PsiBasedExternalAnnotationResolver();
        this.traceBasedExternalSignatureResolver = new TraceBasedExternalSignatureResolver();
        this.traceBasedErrorReporter = new TraceBasedErrorReporter();
        this.psiBasedMethodSignatureChecker = new PsiBasedMethodSignatureChecker();
        this.traceBasedJavaResolverCache = new TraceBasedJavaResolverCache();
        this.javaPropertyInitializerEvaluator = new JavaPropertyInitializerEvaluatorImpl();
        this.globalJavaResolverContext = new GlobalJavaResolverContext(storageManager, javaClassFinder, virtualFileFinder, deserializedDescriptorResolver, psiBasedExternalAnnotationResolver, traceBasedExternalSignatureResolver, traceBasedErrorReporter, psiBasedMethodSignatureChecker, traceBasedJavaResolverCache, javaPropertyInitializerEvaluator);
        this.lazyJavaPackageFragmentProvider = new LazyJavaPackageFragmentProvider(globalJavaResolverContext, getModuleDescriptor());
        this.javaDescriptorResolver = new JavaDescriptorResolver(lazyJavaPackageFragmentProvider, getModuleDescriptor());
        this.bodyResolver = new BodyResolver();
        this.annotationResolver = new AnnotationResolver();
        this.callResolver = new CallResolver();
        this.argumentTypeResolver = new ArgumentTypeResolver();
        this.expressionTypingComponents = new ExpressionTypingComponents();
        this.expressionTypingServices = new ExpressionTypingServices(expressionTypingComponents);
        this.controlStructureTypingUtils = new ControlStructureTypingUtils(expressionTypingServices);
        this.expressionTypingUtils = new ExpressionTypingUtils(expressionTypingServices, callResolver);
        this.forLoopConventionsChecker = new ForLoopConventionsChecker();
        this.reflectionTypes = new ReflectionTypes(getModuleDescriptor());
        this.callExpressionResolver = new CallExpressionResolver();
        this.descriptorResolver = new DescriptorResolver();
        this.delegatedPropertyResolver = new DelegatedPropertyResolver();
        this.typeResolver = new TypeResolver();
        this.qualifiedExpressionResolver = new QualifiedExpressionResolver();
        this.callResolverExtensionProvider = new CallResolverExtensionProvider();
        this.candidateResolver = new CandidateResolver();
        this.controlFlowAnalyzer = new ControlFlowAnalyzer();
        this.declarationsChecker = new DeclarationsChecker();
        this.functionAnalyzerExtension = new FunctionAnalyzerExtension();
        this.scriptBodyResolver = new ScriptBodyResolver();
        this.declarationResolver = new DeclarationResolver();
        this.importsResolver = new ImportsResolver();
        this.jetImportsFactory = new JetImportsFactory();
        this.scriptHeaderResolver = new ScriptHeaderResolver();
        this.overloadResolver = new OverloadResolver();
        this.overrideResolver = new OverrideResolver();
        this.typeHierarchyResolver = new TypeHierarchyResolver();
        this.descriptorDeserializers = new DescriptorDeserializers();
        this.annotationDescriptorDeserializer = new AnnotationDescriptorDeserializer();
        this.descriptorDeserializersStorage = new DescriptorDeserializersStorage(storageManager);
        this.constantDescriptorDeserializer = new ConstantDescriptorDeserializer();

        this.topDownAnalyzer.setBodyResolver(bodyResolver);
        this.topDownAnalyzer.setDeclarationResolver(declarationResolver);
        this.topDownAnalyzer.setLazyTopDownAnalyzer(lazyTopDownAnalyzer);
        this.topDownAnalyzer.setModuleDescriptor(moduleDescriptor);
        this.topDownAnalyzer.setOverloadResolver(overloadResolver);
        this.topDownAnalyzer.setOverrideResolver(overrideResolver);
        this.topDownAnalyzer.setPackageFragmentProvider(mutablePackageFragmentProvider);
        this.topDownAnalyzer.setProject(project);
        this.topDownAnalyzer.setTrace(bindingTrace);
        this.topDownAnalyzer.setTypeHierarchyResolver(typeHierarchyResolver);

        this.lazyTopDownAnalyzer.setBodyResolver(bodyResolver);
        this.lazyTopDownAnalyzer.setDeclarationResolver(declarationResolver);
        this.lazyTopDownAnalyzer.setModuleDescriptor(moduleDescriptor);
        this.lazyTopDownAnalyzer.setOverloadResolver(overloadResolver);
        this.lazyTopDownAnalyzer.setOverrideResolver(overrideResolver);
        this.lazyTopDownAnalyzer.setTrace(bindingTrace);

        javaClassFinder.setProject(project);

        traceBasedExternalSignatureResolver.setExternalAnnotationResolver(psiBasedExternalAnnotationResolver);
        traceBasedExternalSignatureResolver.setProject(project);
        traceBasedExternalSignatureResolver.setTrace(bindingTrace);

        traceBasedJavaResolverCache.setTrace(bindingTrace);

        traceBasedErrorReporter.setTrace(bindingTrace);

        psiBasedMethodSignatureChecker.setExternalAnnotationResolver(psiBasedExternalAnnotationResolver);
        psiBasedMethodSignatureChecker.setExternalSignatureResolver(traceBasedExternalSignatureResolver);

        bodyResolver.setAnnotationResolver(annotationResolver);
        bodyResolver.setCallResolver(callResolver);
        bodyResolver.setControlFlowAnalyzer(controlFlowAnalyzer);
        bodyResolver.setDeclarationsChecker(declarationsChecker);
        bodyResolver.setDelegatedPropertyResolver(delegatedPropertyResolver);
        bodyResolver.setExpressionTypingServices(expressionTypingServices);
        bodyResolver.setFunctionAnalyzerExtension(functionAnalyzerExtension);
        bodyResolver.setScriptBodyResolverResolver(scriptBodyResolver);
        bodyResolver.setTrace(bindingTrace);

        annotationResolver.setCallResolver(callResolver);
        annotationResolver.setStorageManager(storageManager);
        annotationResolver.setTypeResolver(typeResolver);

        callResolver.setArgumentTypeResolver(argumentTypeResolver);
        callResolver.setCandidateResolver(candidateResolver);
        callResolver.setExpressionTypingServices(expressionTypingServices);
        callResolver.setTypeResolver(typeResolver);

        argumentTypeResolver.setExpressionTypingServices(expressionTypingServices);
        argumentTypeResolver.setTypeResolver(typeResolver);

        expressionTypingServices.setAnnotationResolver(annotationResolver);
        expressionTypingServices.setCallExpressionResolver(callExpressionResolver);
        expressionTypingServices.setCallResolver(callResolver);
        expressionTypingServices.setDescriptorResolver(descriptorResolver);
        expressionTypingServices.setExtensionProvider(callResolverExtensionProvider);
        expressionTypingServices.setProject(project);
        expressionTypingServices.setTypeResolver(typeResolver);

        expressionTypingComponents.setCallResolver(callResolver);
        expressionTypingComponents.setControlStructureTypingUtils(controlStructureTypingUtils);
        expressionTypingComponents.setExpressionTypingServices(expressionTypingServices);
        expressionTypingComponents.setExpressionTypingUtils(expressionTypingUtils);
        expressionTypingComponents.setForLoopConventionsChecker(forLoopConventionsChecker);
        expressionTypingComponents.setGlobalContext(globalContext);
        expressionTypingComponents.setPlatformToKotlinClassMap(platformToKotlinClassMap);
        expressionTypingComponents.setReflectionTypes(reflectionTypes);

        forLoopConventionsChecker.setExpressionTypingServices(expressionTypingServices);
        forLoopConventionsChecker.setExpressionTypingUtils(expressionTypingUtils);
        forLoopConventionsChecker.setProject(project);

        callExpressionResolver.setExpressionTypingServices(expressionTypingServices);

        descriptorResolver.setAnnotationResolver(annotationResolver);
        descriptorResolver.setDelegatedPropertyResolver(delegatedPropertyResolver);
        descriptorResolver.setExpressionTypingServices(expressionTypingServices);
        descriptorResolver.setStorageManager(storageManager);
        descriptorResolver.setTypeResolver(typeResolver);

        delegatedPropertyResolver.setCallResolver(callResolver);
        delegatedPropertyResolver.setExpressionTypingServices(expressionTypingServices);

        typeResolver.setAnnotationResolver(annotationResolver);
        typeResolver.setModuleDescriptor(moduleDescriptor);
        typeResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);

        candidateResolver.setArgumentTypeResolver(argumentTypeResolver);

        controlFlowAnalyzer.setTrace(bindingTrace);

        declarationsChecker.setDescriptorResolver(descriptorResolver);
        declarationsChecker.setTrace(bindingTrace);

        functionAnalyzerExtension.setTrace(bindingTrace);

        scriptBodyResolver.setExpressionTypingServices(expressionTypingServices);

        declarationResolver.setAnnotationResolver(annotationResolver);
        declarationResolver.setDescriptorResolver(descriptorResolver);
        declarationResolver.setImportsResolver(importsResolver);
        declarationResolver.setScriptHeaderResolver(scriptHeaderResolver);
        declarationResolver.setTrace(bindingTrace);

        importsResolver.setImportsFactory(jetImportsFactory);
        importsResolver.setModuleDescriptor(moduleDescriptor);
        importsResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);
        importsResolver.setTrace(bindingTrace);

        jetImportsFactory.setProject(project);

        scriptHeaderResolver.setPackageFragmentProvider(mutablePackageFragmentProvider);
        scriptHeaderResolver.setTrace(bindingTrace);

        overloadResolver.setTrace(bindingTrace);

        overrideResolver.setTrace(bindingTrace);

        typeHierarchyResolver.setDescriptorResolver(descriptorResolver);
        typeHierarchyResolver.setImportsResolver(importsResolver);
        typeHierarchyResolver.setPackageFragmentProvider(mutablePackageFragmentProvider);
        typeHierarchyResolver.setScriptHeaderResolver(scriptHeaderResolver);
        typeHierarchyResolver.setTrace(bindingTrace);

        deserializedDescriptorResolver.setDeserializers(descriptorDeserializers);
        deserializedDescriptorResolver.setErrorReporter(traceBasedErrorReporter);
        deserializedDescriptorResolver.setJavaDescriptorResolver(javaDescriptorResolver);
        deserializedDescriptorResolver.setJavaPackageFragmentProvider(lazyJavaPackageFragmentProvider);
        deserializedDescriptorResolver.setMemberFilter(memberFilter);
        deserializedDescriptorResolver.setStorageManager(storageManager);

        descriptorDeserializers.setAnnotationDescriptorDeserializer(annotationDescriptorDeserializer);
        descriptorDeserializers.setConstantDescriptorDeserializer(constantDescriptorDeserializer);

        annotationDescriptorDeserializer.setClassResolver(javaDescriptorResolver);
        annotationDescriptorDeserializer.setErrorReporter(traceBasedErrorReporter);
        annotationDescriptorDeserializer.setKotlinClassFinder(virtualFileFinder);
        annotationDescriptorDeserializer.setStorage(descriptorDeserializersStorage);

        descriptorDeserializersStorage.setClassResolver(javaDescriptorResolver);
        descriptorDeserializersStorage.setErrorReporter(traceBasedErrorReporter);

        constantDescriptorDeserializer.setClassResolver(javaDescriptorResolver);
        constantDescriptorDeserializer.setErrorReporter(traceBasedErrorReporter);
        constantDescriptorDeserializer.setKotlinClassFinder(virtualFileFinder);
        constantDescriptorDeserializer.setStorage(descriptorDeserializersStorage);

        javaClassFinder.initialize();

    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370938637/fstmerge_var2_7731128957337245218

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_20931_f6129/rev_20931-f6129/compiler/frontend.java/src/org/jetbrains/jet/di/InjectorForTopDownAnalyzerForJvm.java
Conflict type: LineBasedMCFd
Conflict body: 
public InjectorForLazyResolveWithJava(
        @NotNull Project project,
        @NotNull GlobalContextImpl globalContext,
        @NotNull DeclarationProviderFactory declarationProviderFactory,
        @NotNull BindingTrace bindingTrace
    ) {
        this.project = project;
        this.globalContext = globalContext;
        this.lockBasedStorageManager = globalContext.getStorageManager();
        this.declarationProviderFactory = declarationProviderFactory;
        this.bindingTrace = bindingTrace;
        this.module = org.jetbrains.jet.lang.resolve.java.AnalyzerFacadeForJVM.createJavaModule("<fake-jdr-module>");
        this.platformToKotlinClassMap = module.getPlatformToKotlinClassMap();
        this.resolveSession = new ResolveSession(project, globalContext, getModule(), declarationProviderFactory, bindingTrace);
        this.javaClassFinder = new JavaClassFinderImpl();
        this.virtualFileFinder = org.jetbrains.jet.lang.resolve.kotlin.VirtualFileFinder.SERVICE.getInstance(project);
        this.deserializedDescriptorResolver = new DeserializedDescriptorResolver();
        this.psiBasedExternalAnnotationResolver = new PsiBasedExternalAnnotationResolver();
        this.traceBasedExternalSignatureResolver = new TraceBasedExternalSignatureResolver();
        this.traceBasedErrorReporter = new TraceBasedErrorReporter();
        this.psiBasedMethodSignatureChecker = new PsiBasedMethodSignatureChecker();
        this.lazyResolveBasedCache = new LazyResolveBasedCache();
        this.javaPropertyInitializerEvaluator = new JavaPropertyInitializerEvaluatorImpl();
        this.globalJavaResolverContext = new GlobalJavaResolverContext(lockBasedStorageManager, javaClassFinder, virtualFileFinder, deserializedDescriptorResolver, psiBasedExternalAnnotationResolver, traceBasedExternalSignatureResolver, traceBasedErrorReporter, psiBasedMethodSignatureChecker, lazyResolveBasedCache, javaPropertyInitializerEvaluator);
        this.lazyJavaPackageFragmentProvider = new LazyJavaPackageFragmentProvider(globalJavaResolverContext, getModule());
        this.javaDescriptorResolver = new JavaDescriptorResolver(lazyJavaPackageFragmentProvider, getModule());
        this.annotationResolver = new AnnotationResolver();
        this.callResolver = new CallResolver();
        this.argumentTypeResolver = new ArgumentTypeResolver();
        this.expressionTypingComponents = new ExpressionTypingComponents();
        this.expressionTypingServices = new ExpressionTypingServices(expressionTypingComponents);
        this.controlStructureTypingUtils = new ControlStructureTypingUtils(expressionTypingServices);
        this.expressionTypingUtils = new ExpressionTypingUtils(expressionTypingServices, callResolver);
        this.forLoopConventionsChecker = new ForLoopConventionsChecker();
        this.reflectionTypes = new ReflectionTypes(getModule());
        this.callExpressionResolver = new CallExpressionResolver();
        this.descriptorResolver = new DescriptorResolver();
        this.delegatedPropertyResolver = new DelegatedPropertyResolver();
        this.typeResolver = new TypeResolver();
        this.qualifiedExpressionResolver = new QualifiedExpressionResolver();
        this.callResolverExtensionProvider = new CallResolverExtensionProvider();
        this.candidateResolver = new CandidateResolver();
        this.jetImportsFactory = new JetImportsFactory();
        this.scopeProvider = new ScopeProvider(getResolveSession());
        this.scriptBodyResolver = new ScriptBodyResolver();
        this.javaDescriptorFinder = new JavaDescriptorFinder(getJavaDescriptorResolver(), lazyJavaPackageFragmentProvider);
        this.annotationDescriptorLoader = new AnnotationDescriptorLoader();
        this.constantDescriptorLoader = new ConstantDescriptorLoader();
        this.deserializationGlobalContextForJava = new DeserializationGlobalContextForJava(lockBasedStorageManager, javaDescriptorFinder, annotationDescriptorLoader, constantDescriptorLoader, lazyJavaPackageFragmentProvider, memberFilter);
        this.descriptorDeserializersStorage = new DescriptorDeserializersStorage(lockBasedStorageManager);

        this.resolveSession.setAnnotationResolve(annotationResolver);
        this.resolveSession.setDescriptorResolver(descriptorResolver);
        this.resolveSession.setJetImportFactory(jetImportsFactory);
        this.resolveSession.setQualifiedExpressionResolver(qualifiedExpressionResolver);
        this.resolveSession.setScopeProvider(scopeProvider);
        this.resolveSession.setScriptBodyResolver(scriptBodyResolver);
        this.resolveSession.setTypeResolver(typeResolver);

        javaClassFinder.setProject(project);

        traceBasedExternalSignatureResolver.setExternalAnnotationResolver(psiBasedExternalAnnotationResolver);
        traceBasedExternalSignatureResolver.setProject(project);
        traceBasedExternalSignatureResolver.setTrace(bindingTrace);

        lazyResolveBasedCache.setSession(resolveSession);

        traceBasedErrorReporter.setTrace(bindingTrace);

        psiBasedMethodSignatureChecker.setExternalAnnotationResolver(psiBasedExternalAnnotationResolver);
        psiBasedMethodSignatureChecker.setExternalSignatureResolver(traceBasedExternalSignatureResolver);

        annotationResolver.setCallResolver(callResolver);
        annotationResolver.setStorageManager(lockBasedStorageManager);
        annotationResolver.setTypeResolver(typeResolver);

        callResolver.setArgumentTypeResolver(argumentTypeResolver);
        callResolver.setCandidateResolver(candidateResolver);
        callResolver.setExpressionTypingServices(expressionTypingServices);
        callResolver.setTypeResolver(typeResolver);

        argumentTypeResolver.setExpressionTypingServices(expressionTypingServices);
        argumentTypeResolver.setTypeResolver(typeResolver);

        expressionTypingServices.setAnnotationResolver(annotationResolver);
        expressionTypingServices.setCallExpressionResolver(callExpressionResolver);
        expressionTypingServices.setCallResolver(callResolver);
        expressionTypingServices.setDescriptorResolver(descriptorResolver);
        expressionTypingServices.setExtensionProvider(callResolverExtensionProvider);
        expressionTypingServices.setProject(project);
        expressionTypingServices.setTypeResolver(typeResolver);

        expressionTypingComponents.setCallResolver(callResolver);
        expressionTypingComponents.setControlStructureTypingUtils(controlStructureTypingUtils);
        expressionTypingComponents.setExpressionTypingServices(expressionTypingServices);
        expressionTypingComponents.setExpressionTypingUtils(expressionTypingUtils);
        expressionTypingComponents.setForLoopConventionsChecker(forLoopConventionsChecker);
        expressionTypingComponents.setGlobalContext(globalContext);
        expressionTypingComponents.setPlatformToKotlinClassMap(platformToKotlinClassMap);
        expressionTypingComponents.setReflectionTypes(reflectionTypes);

        forLoopConventionsChecker.setExpressionTypingServices(expressionTypingServices);
        forLoopConventionsChecker.setExpressionTypingUtils(expressionTypingUtils);
        forLoopConventionsChecker.setProject(project);

        callExpressionResolver.setExpressionTypingServices(expressionTypingServices);

        descriptorResolver.setAnnotationResolver(annotationResolver);
        descriptorResolver.setDelegatedPropertyResolver(delegatedPropertyResolver);
        descriptorResolver.setExpressionTypingServices(expressionTypingServices);
        descriptorResolver.setStorageManager(lockBasedStorageManager);
        descriptorResolver.setTypeResolver(typeResolver);

        delegatedPropertyResolver.setCallResolver(callResolver);
        delegatedPropertyResolver.setExpressionTypingServices(expressionTypingServices);

        typeResolver.setAnnotationResolver(annotationResolver);
        typeResolver.setModuleDescriptor(module);
        typeResolver.setQualifiedExpressionResolver(qualifiedExpressionResolver);

        candidateResolver.setArgumentTypeResolver(argumentTypeResolver);

        jetImportsFactory.setProject(project);

        scriptBodyResolver.setExpressionTypingServices(expressionTypingServices);

        deserializedDescriptorResolver.setContext(deserializationGlobalContextForJava);
        deserializedDescriptorResolver.setErrorReporter(traceBasedErrorReporter);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370938652/fstmerge_var1_4687477329968957700

        annotationDescriptorLoader.setClassResolver(javaDescriptorResolver);
        annotationDescriptorLoader.setErrorReporter(traceBasedErrorReporter);
        annotationDescriptorLoader.setKotlinClassFinder(virtualFileFinder);
        annotationDescriptorLoader.setStorage(descriptorDeserializersStorage);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370938652/fstmerge_base_1130184765076568694
        deserializedDescriptorResolver.setJavaDescriptorResolver(javaDescriptorResolver);
        deserializedDescriptorResolver.setJavaPackageFragmentProvider(lazyJavaPackageFragmentProvider);
        deserializedDescriptorResolver.setMemberFilter(memberFilter);
        deserializedDescriptorResolver.setStorageManager(lockBasedStorageManager);

        descriptorDeserializers.setAnnotationDescriptorDeserializer(annotationDescriptorDeserializer);
        descriptorDeserializers.setConstantDescriptorDeserializer(constantDescriptorDeserializer);

        annotationDescriptorDeserializer.setClassResolver(javaDescriptorResolver);
        annotationDescriptorDeserializer.setErrorReporter(traceBasedErrorReporter);
        annotationDescriptorDeserializer.setKotlinClassFinder(virtualFileFinder);
        annotationDescriptorDeserializer.setStorage(descriptorDeserializersStorage);
=======
        deserializedDescriptorResolver.setJavaDescriptorResolver(javaDescriptorResolver);
        deserializedDescriptorResolver.setJavaPackageFragmentProvider(lazyJavaPackageFragmentProvider);
        deserializedDescriptorResolver.setStorageManager(lockBasedStorageManager);

        descriptorDeserializers.setAnnotationDescriptorDeserializer(annotationDescriptorDeserializer);
        descriptorDeserializers.setConstantDescriptorDeserializer(constantDescriptorDeserializer);

        annotationDescriptorDeserializer.setClassResolver(javaDescriptorResolver);
        annotationDescriptorDeserializer.setErrorReporter(traceBasedErrorReporter);
        annotationDescriptorDeserializer.setKotlinClassFinder(virtualFileFinder);
        annotationDescriptorDeserializer.setStorage(descriptorDeserializersStorage);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370938652/fstmerge_var2_3132116413605977022

        descriptorDeserializersStorage.setClassResolver(javaDescriptorResolver);
        descriptorDeserializersStorage.setErrorReporter(traceBasedErrorReporter);

        constantDescriptorLoader.setClassResolver(javaDescriptorResolver);
        constantDescriptorLoader.setErrorReporter(traceBasedErrorReporter);
        constantDescriptorLoader.setKotlinClassFinder(virtualFileFinder);
        constantDescriptorLoader.setStorage(descriptorDeserializersStorage);

        javaClassFinder.initialize();

    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_20931_f6129/rev_20931-f6129/compiler/frontend.java/src/org/jetbrains/jet/di/InjectorForLazyResolveWithJava.java
Conflict type: LineBasedMCFd
Conflict body: 
public InjectorForJavaDescriptorResolver(
        @NotNull Project project,
        @NotNull BindingTrace bindingTrace
    ) {
        this.project = project;
        this.bindingTrace = bindingTrace;
        this.globalContext = org.jetbrains.jet.context.ContextPackage.GlobalContext();
        this.lockBasedStorageManager = globalContext.getStorageManager();
        this.module = org.jetbrains.jet.lang.resolve.java.AnalyzerFacadeForJVM.createJavaModule("<fake-jdr-module>");
        this.javaClassFinder = new JavaClassFinderImpl();
        this.virtualFileFinder = org.jetbrains.jet.lang.resolve.kotlin.VirtualFileFinder.SERVICE.getInstance(project);
        this.deserializedDescriptorResolver = new DeserializedDescriptorResolver();
        this.psiBasedExternalAnnotationResolver = new PsiBasedExternalAnnotationResolver();
        this.traceBasedExternalSignatureResolver = new TraceBasedExternalSignatureResolver();
        this.traceBasedErrorReporter = new TraceBasedErrorReporter();
        this.psiBasedMethodSignatureChecker = new PsiBasedMethodSignatureChecker();
        this.traceBasedJavaResolverCache = new TraceBasedJavaResolverCache();
        this.javaPropertyInitializerEvaluator = new JavaPropertyInitializerEvaluatorImpl();
        this.globalJavaResolverContext = new GlobalJavaResolverContext(lockBasedStorageManager, getJavaClassFinder(), virtualFileFinder, deserializedDescriptorResolver, psiBasedExternalAnnotationResolver, traceBasedExternalSignatureResolver, traceBasedErrorReporter, psiBasedMethodSignatureChecker, traceBasedJavaResolverCache, javaPropertyInitializerEvaluator);
        this.lazyJavaPackageFragmentProvider = new LazyJavaPackageFragmentProvider(globalJavaResolverContext, getModule());
        this.javaDescriptorResolver = new JavaDescriptorResolver(lazyJavaPackageFragmentProvider, getModule());
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370938684/fstmerge_var1_7098503760145580596
        this.memberFilter = org.jetbrains.jet.descriptors.serialization.descriptors.MemberFilter.ALWAYS_TRUE;
        this.javaDescriptorFinder = new JavaDescriptorFinder(getJavaDescriptorResolver(), lazyJavaPackageFragmentProvider);
        this.annotationDescriptorLoader = new AnnotationDescriptorLoader();
        this.constantDescriptorLoader = new ConstantDescriptorLoader();
        this.deserializationGlobalContextForJava = new DeserializationGlobalContextForJava(lockBasedStorageManager, javaDescriptorFinder, annotationDescriptorLoader, constantDescriptorLoader, lazyJavaPackageFragmentProvider, memberFilter);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370938684/fstmerge_base_7354881397781003326
        this.memberFilter = org.jetbrains.jet.descriptors.serialization.descriptors.MemberFilter.ALWAYS_TRUE;
        this.descriptorDeserializers = new DescriptorDeserializers();
        this.annotationDescriptorDeserializer = new AnnotationDescriptorDeserializer();
=======
        this.descriptorDeserializers = new DescriptorDeserializers();
        this.annotationDescriptorDeserializer = new AnnotationDescriptorDeserializer();
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370938684/fstmerge_var2_7699434039398674239
        this.descriptorDeserializersStorage = new DescriptorDeserializersStorage(lockBasedStorageManager);

        this.javaClassFinder.setProject(project);

        traceBasedExternalSignatureResolver.setExternalAnnotationResolver(psiBasedExternalAnnotationResolver);
        traceBasedExternalSignatureResolver.setProject(project);
        traceBasedExternalSignatureResolver.setTrace(bindingTrace);

        traceBasedJavaResolverCache.setTrace(bindingTrace);

        traceBasedErrorReporter.setTrace(bindingTrace);

        psiBasedMethodSignatureChecker.setExternalAnnotationResolver(psiBasedExternalAnnotationResolver);
        psiBasedMethodSignatureChecker.setExternalSignatureResolver(traceBasedExternalSignatureResolver);

        deserializedDescriptorResolver.setContext(deserializationGlobalContextForJava);
        deserializedDescriptorResolver.setErrorReporter(traceBasedErrorReporter);
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370938684/fstmerge_var1_7098503760145580596

        annotationDescriptorLoader.setClassResolver(javaDescriptorResolver);
        annotationDescriptorLoader.setErrorReporter(traceBasedErrorReporter);
        annotationDescriptorLoader.setKotlinClassFinder(virtualFileFinder);
        annotationDescriptorLoader.setStorage(descriptorDeserializersStorage);
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370938684/fstmerge_base_7354881397781003326
        deserializedDescriptorResolver.setJavaDescriptorResolver(javaDescriptorResolver);
        deserializedDescriptorResolver.setJavaPackageFragmentProvider(lazyJavaPackageFragmentProvider);
        deserializedDescriptorResolver.setMemberFilter(memberFilter);
        deserializedDescriptorResolver.setStorageManager(lockBasedStorageManager);

        descriptorDeserializers.setAnnotationDescriptorDeserializer(annotationDescriptorDeserializer);
        descriptorDeserializers.setConstantDescriptorDeserializer(constantDescriptorDeserializer);

        annotationDescriptorDeserializer.setClassResolver(javaDescriptorResolver);
        annotationDescriptorDeserializer.setErrorReporter(traceBasedErrorReporter);
        annotationDescriptorDeserializer.setKotlinClassFinder(virtualFileFinder);
        annotationDescriptorDeserializer.setStorage(descriptorDeserializersStorage);
=======
        deserializedDescriptorResolver.setJavaDescriptorResolver(javaDescriptorResolver);
        deserializedDescriptorResolver.setJavaPackageFragmentProvider(lazyJavaPackageFragmentProvider);
        deserializedDescriptorResolver.setStorageManager(lockBasedStorageManager);

        descriptorDeserializers.setAnnotationDescriptorDeserializer(annotationDescriptorDeserializer);
        descriptorDeserializers.setConstantDescriptorDeserializer(constantDescriptorDeserializer);

        annotationDescriptorDeserializer.setClassResolver(javaDescriptorResolver);
        annotationDescriptorDeserializer.setErrorReporter(traceBasedErrorReporter);
        annotationDescriptorDeserializer.setKotlinClassFinder(virtualFileFinder);
        annotationDescriptorDeserializer.setStorage(descriptorDeserializersStorage);
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419370938684/fstmerge_var2_7699434039398674239

        descriptorDeserializersStorage.setClassResolver(javaDescriptorResolver);
        descriptorDeserializersStorage.setErrorReporter(traceBasedErrorReporter);

        constantDescriptorLoader.setClassResolver(javaDescriptorResolver);
        constantDescriptorLoader.setErrorReporter(traceBasedErrorReporter);
        constantDescriptorLoader.setKotlinClassFinder(virtualFileFinder);
        constantDescriptorLoader.setStorage(descriptorDeserializersStorage);

        javaClassFinder.initialize();

    }

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_20931_f6129/rev_20931-f6129/compiler/frontend.java/src/org/jetbrains/jet/di/InjectorForJavaDescriptorResolver.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419371010472/fstmerge_var1_8740860284068883110
@NotNull
    public static String getPackagePartInternalName(@NotNull DeserializedCallableMemberDescriptor callable) {
        FqName packageFqName = ((PackageFragmentDescriptor) callable.getContainingDeclaration()).getFqName();
        FqName packagePartFqName = packageFqName.child(BaseDescriptorLoader.getPackagePartClassName(callable));
        return JvmClassName.byFqNameWithoutInnerClasses(packagePartFqName).getInternalName();
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419371010472/fstmerge_base_3585981425848815285
@NotNull
    public static String getPackagePartInternalName(@NotNull DeserializedCallableMemberDescriptor callable) {
        FqName packageFqName = ((PackageFragmentDescriptor) callable.getContainingDeclaration()).getFqName();
        FqName packagePartFqName = packageFqName.child(BaseDescriptorDeserializer.getPackagePartClassName(callable));
        return JvmClassName.byFqNameWithoutInnerClasses(packagePartFqName).getInternalName();
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419371010472/fstmerge_var2_8139085673320088164

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_20931_f6129/rev_20931-f6129/compiler/backend/src/org/jetbrains/jet/codegen/PackageCodegen.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_86588_9f864/rev_86588-9f864.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_fd4ae_3f2d6/rev_fd4ae-3f2d6.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e73ee_a2fdf/rev_e73ee-a2fdf.revisions
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419379198401/fstmerge_var1_882405687990018866
@Override
    protected void checkHeader(@NotNull MessageChecker checker) {
        checker.expect(Message.info().textStartsWith("Using kotlinHome="));
        checker.expect(Message.info().textStartsWith("Invoking K2JVMCompiler"));
        checker.expect(Message.info().textStartsWith("Kotlin Compiler version"));
        checker.expect(Message.stats().textStartsWith("Using Kotlin home directory"));
        checker.expect(Message.stats().text("Configuring the compilation environment"));
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419379198401/fstmerge_base_5185243111566359526
@Override
    protected void checkHeader(@NotNull MessageChecker checker) {
        checker.expect(Message.info().textStartsWith("Using kotlinHome="));
        checker.expect(Message.info().textStartsWith("Invoking compiler"));
        checker.expect(Message.info().textStartsWith("Kotlin Compiler version"));
        checker.expect(Message.stats().textStartsWith("Using Kotlin home directory"));
        checker.expect(Message.stats().text("Configuring the compilation environment"));
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419379198401/fstmerge_var2_7348828785457179455

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e73ee_a2fdf/rev_e73ee-a2fdf/idea/tests/org/jetbrains/jet/plugin/compilerMessages/JetCompilerMessagingTest.java
Conflict type: LineBasedMCFd
Conflict body: 
<<<<<<< /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419379198440/fstmerge_var1_7626156598269447524
@Override
    protected void checkHeader(@NotNull MessageChecker checker) {
        checker.expect(info().textStartsWith("Using kotlinHome="));
        checker.expect(info().textStartsWith("Invoking K2JSCompiler"));
        checker.expect(info().textStartsWith("Kotlin Compiler version"));
        checker.expect(stats().textMatchesRegexp("Compiling source files: .*/src/test.kt"));
    }
||||||| /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419379198440/fstmerge_base_6565405657424390854
@Override
    protected void checkHeader(@NotNull MessageChecker checker) {
        checker.expect(info().textStartsWith("Using kotlinHome="));
        checker.expect(info().textStartsWith("Invoking compiler"));
        checker.expect(info().textStartsWith("Kotlin Compiler version"));
        checker.expect(stats().textMatchesRegexp("Compiling source files: .*/src/test.kt"));
    }
=======
>>>>>>> /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/conflictsAnalyzer/fstmerge_tmp1419379198440/fstmerge_var2_332292196241789705

File path: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_e73ee_a2fdf/rev_e73ee-a2fdf/idea/tests/org/jetbrains/jet/plugin/compilerMessages/K2JSCompilerMessagingTest.java

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_46da0_6095f/rev_46da0-6095f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_47f4b_cab31/rev_47f4b-cab31.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_36f7c_b92df/rev_36f7c-b92df.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_39806_295ce/rev_39806-295ce.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_0b2b8_da3fc/rev_0b2b8-da3fc.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_31e21_4980a/rev_31e21-4980a.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_ee675_740fe/rev_ee675-740fe.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_94568_3f103/rev_94568-3f103.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c0151_90b06/rev_c0151-90b06.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_34bf3_51aa7/rev_34bf3-51aa7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_92e96_88a26/rev_92e96-88a26.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_c4bfa_c074b/rev_c4bfa-c074b.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_7de40_0dfc7/rev_7de40-0dfc7.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_1ab0e_7ed7f/rev_1ab0e-7ed7f.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_074ac_40add/rev_074ac-40add.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_274e5_15327/rev_274e5-15327.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_074e2_4e702/rev_074e2-4e702.revisions

==================================================================================================================
Revision: /media/ines/b9d638e1-93ee-435a-af41-80d544917e00/gitClones/conflictsStudy/downloads/kotlin/revisions/rev_a9d3c_73d62/rev_a9d3c-73d62.revisions

=========================================================